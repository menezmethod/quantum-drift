### DIRECTORY . FOLDER STRUCTURE ###
./
    index.html
    flatten.py
    index.js
    codebase.md
    ui/
        ShipSelectionUI.js
        GameRoom.js
        GameUI.js
        MiniMap.js
    scenes/
        TeamDemo.js
    core/
        Game.js
        TeamManager.js
        Scene.js
        GameEngine.js
        Engine.js
        NetworkManager.js
        InfiniteMap.js
    config/
        ShipConfig.js
        Controls.js
        GameConfig.js
    constants/
    utils/
    styles/
        main.css
        controls.css
    effects/
    assets/
        ModelLoader.js
        SoundManager.js
        .DS_Store
        AssetLoader.js
        textures/
        images/
        models/
            .DS_Store
            textures/
                tex.png
                Colors3.png
            ships/
                ALTSPACE2.glb
                ALTSPACE1.glb
            flora/
                Grass_01.glb
                .DS_Store
                SmalRoots_01.glb
                BigPlant_06.glb
                SP_Plant08.glb
                SP_Plant07.glb
                Mushrooms.glb
                SP_Tree04.glb
                SP_Tree02.glb
                SP_Tree03.glb
                SP_Tree01.glb
                Tenticles_01.glb
            objects/
                .DS_Store
                SP_Stone01.glb
                SP_Mountain03.glb
                SP_Mountain02.glb
                SP_Mountain01.glb
                SP_Ground03.glb
                SP_Ground02.glb
                SP_Ground05.glb
                SP_Ground04.glb
            terrain/
                .DS_Store
                Water.glb
                Terrain.glb
            rocks/
                SP_Rock01.glb
                SP_Rock03.glb
                SP_Rock02.glb
                SP_Rock06.glb
                .DS_Store
                SP_Rock07.glb
                SP_Rock05.glb
                SP_Rock04.glb
                SP_Rock09.glb
                SP_Rock08.glb
        sounds/
            weapon-switch.mp3
            laser.mp3
            bounce.mp3
            weapon-charging.mp3
            grenade-laser.mp3
            laser-bounce.mp3
            weapon-armor-hit.mp3
    entities/
        Ship.js
        obstacles/
        weapons/
            RegularLaser.js
            WeaponSystem.js
            Laser.js
        enemies/
            EnemyManager.js
            Enemy.js
        player/
            Player.js
### DIRECTORY . FOLDER STRUCTURE ###

### DIRECTORY . FLATTENED CONTENT ###
### ./index.html BEGIN ###
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/main.css">
    <link rel="stylesheet" href="./styles/controls.css">
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="loader"></div>
            <p>Loading the quantum realm...</p>
        </div>
    </div>
    
    <div id="start-screen" class="hidden">
        <div class="start-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="player-input">
                <input type="text" id="player-name" maxlength="15" placeholder="Enter your pilot name" />
                <p class="input-info">Your name will be visible to other players</p>
            </div>
            <button id="start-button" class="glow-button">START GAME</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>
    
    <!-- Multiplayer Info -->
    <div id="multiplayer-info" class="hidden">
        <div class="connection-indicator">
            <span>Connection: </span>
            <span id="connection-status">Disconnected</span>
        </div>
        <div class="players-indicator">
            <span>Players: </span>
            <span id="players-count">0</span>
        </div>
    </div>
    
    <!-- Simple HUD for controls info -->
    <div class="controls-info hidden">
        <p>W/↑: Forward | S/↓: Backward</p>
        <p>A/← D/→: Rotate Ship</p>
        <p>Q/E: Strafe Left/Right</p>
        <p>Space: Fire Laser</p>
        <p>Avoid the colored obstacles!</p>
    </div>
</body>
<script type="module" src="./index.js"></script>
</html> 
### ./index.html END ###

### ./flatten.py BEGIN ###
import os
import argparse

def printFolderStructure(directory, output_file):
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n")
    for root, directories, files in os.walk(directory):
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write('{}{}/\n'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            output_file.write('{}{}\n'.format(subindent, f))
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n\n")

def walkFolderTree(folder):
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            yield os.path.join(dirpath, filename)

def main():
    parser = argparse.ArgumentParser(description='Flattens a codebase.')
    parser.add_argument('--folders', nargs='*', help='Base folders to process')
    parser.add_argument('--system_instructions', action='store_true', help='Print system instructions')

    system_instructions = """## System Instructions for Language Model Assistance in Code Debugging

### Role Definition:
- **Act as a software engineer** tasked with assisting in debugging code.
- Provide insights, explanations, and solutions based on the provided codebase information.

### Codebase Markdown File Structure:
- The codebase markdown file represents the actual codebase structure and content.
- It begins with a directory tree representation:
  ```
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  (file tree representation)
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  ```
- Following the directory tree, the contents of each file are displayed:
  ```
  ### path/to/file1 BEGIN ###
  (content of file1)
  ### path/to/file1 END ###
  
  ### path/to/file2 BEGIN ###
  (content of file2)
  ### path/to/file2 END ###
  ```

### Guidelines for Interaction:
- Respond to queries based on the explicit content provided within the markdown file.
- Avoid making assumptions about the code without clear evidence presented in the file content.
- When seeking specific implementation details, refer to the corresponding section in the markdown file, for example:
  ```
  ### folder1/folder2/myfile.ts BEGIN ###
  (specific implementation details)
  ### folder1/folder2/myfile.ts END ###
  ```

### Objective:
- The primary objective is to facilitate effective debugging by providing accurate information and guidance strictly adhering to the content available in the markdown file."""

    args = parser.parse_args()

    if args.system_instructions:
        print(system_instructions)

        if not args.folders:
            return

    if args.folders:
        base_folders = args.folders
        with open('codebase.md', 'w') as output_file:
            for base_folder in base_folders:
                printFolderStructure(base_folder, output_file)
                
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
                for filepath in walkFolderTree(base_folder):
                    content = f"### {filepath} BEGIN ###\n"
                    
                    try:
                        with open(filepath, "r") as f:
                            content += f.read()
                        content += f"\n### {filepath} END ###\n\n"
                    except:
                        continue
                    
                    output_file.write(content)
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
    else:
        print("usage: main.py [-h] --folders FOLDERS [FOLDERS ...] [--system_instructions]")
        print("Error: the following arguments are required: --folders")

if __name__ == "__main__":
    main()
### ./flatten.py END ###

### ./index.js BEGIN ###
import * as THREE from 'three';
import { OrbitControls } from '@three/examples/controls/OrbitControls';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import './styles/main.css';
import { GameUI } from './ui/GameUI';
import { MiniMap } from './ui/MiniMap';
import { CONTROL_SETTINGS, CONTROL_FEEDBACK, DEFAULT_CONTROL_STATE, ControlUtils } from './config/Controls';
import { ShipSelectionUI } from './ui/ShipSelectionUI';
import AssetLoader from './assets/AssetLoader';
import { InfiniteMap } from './core/InfiniteMap';
import { NetworkManager } from './core/NetworkManager';
import { CSS2DRenderer, CSS2DObject } from '@three/examples/renderers/CSS2DRenderer';
import { GAME_CONFIG } from './config/GameConfig';
import { Player } from './entities/player/Player';
import { SoundManager } from './assets/SoundManager';

// Basic Three.js game with a ship
class SimpleGame {
  constructor() {
    // Initialize all properties first
    // Player information
    this.playerName = 'Pilot';  // Default player name
    
    // Create the asset loader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => this.updateLoadingUI(message),
      (type, error) => this.handleLoadError(type, error)
    );
    
    // Initialize SoundManager
    this.soundManager = new SoundManager();
    
    // Asset loading state
    this.loadingState = {
      started: false,
      completed: false,
      errors: []
    };
    
    // Track assets loading
    this.assetsLoaded = false;
    this.shipModelLoaded = false;
    
    // Initialize control state
    this.keys = { ...DEFAULT_CONTROL_STATE };
    
    // Setup animation timing
    this.clock = new THREE.Clock();
    this.lastTime = Date.now();
    
    // Event handling - bind methods
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    
    // Debounce timers
    this.mouseMoveTimer = null;
    this.resizeTimer = null;
    this.weaponCooldowns = new Map();
    this.lastWeaponSwitch = 0;

    // Setup basic Three.js scene
    this.setupScene();
    
    // Create game UI
    this.ui = new GameUI();
    
    // Create player after scene setup (as specified in Task 8)
    this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
      type: 'PLAYER',
      shipModel: 'STANDARD',
      teamColor: 0x00ffff
    });
    this.scene.add(this.player.mesh);
    
    // For backward compatibility with existing code
    this.playerShip = this.player.mesh;
    
    // Game properties
    this.boundarySize = 100; // Size of the playable area
    
    // Initialize player state
    this.health = 100;
    this.maxHealth = 100;
    this.energy = 100;
    this.maxEnergy = 100;
    this.energyRechargeRate = 20; // Units per second
    this.currentWeapon = 'LASER';
    
    // Initialize available weapons
    this.availableWeapons = ['LASER', 'GRENADE', 'BOUNCE'];
    this.weaponIndex = 0; // Start with LASER
    
    // Load assets
    this.loadAssets();
    
    // Setup controls
    this.setupControls();
    
    // Initialize infinite map after scene setup
    this.infiniteMap = new InfiniteMap(this);
    
    // Create mini-map (after scene setup) but keep it hidden initially
    this.miniMap = new MiniMap(this);
    this.miniMap.hide(); // Make sure it starts hidden
    
    // Handle window resize
    window.addEventListener('resize', this.boundHandleResize);
    
    console.log('Simple game initialized!');

    // Add frame counter
    this.frameCount = 0;
    
    // Initialize NetworkManager
    this.networkManager = new NetworkManager();
    
    // Initialize remotePlayers map for multiplayer
    this.remotePlayers = new Map();
    
    this.networkManager.on('connected', () => {
      console.log('Connected to game server!');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from game server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      // Update player count
      this.updatePlayerCount();
    });
    
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      // Remove player mesh if it exists
      const player = this.remotePlayers.get(id);
      if (player) {
        this.scene.remove(player);
        this.remotePlayers.delete(id);
        console.log(`Removed remote player: ${id}`);
      }
      // Update player count
      this.updatePlayerCount();
    });
    
    // Add player update handling
    this.networkManager.on('player_update', (data) => {
      this.updateRemotePlayer(data.id, data.position, data.rotation);
    });
    
    // Add laser shot handling
    this.networkManager.on('laser_shot', (shotData) => {
      console.log('Received laser shot from network:', shotData);
      const position = new THREE.Vector3(shotData.origin.x, shotData.origin.y, shotData.origin.z);
      const direction = new THREE.Vector3(shotData.direction.x, shotData.direction.y, shotData.direction.z);

      if (shotData.type === 'bounce') {
        this.fireBouncingLaser(position, direction);
      } else {
        this.fireLaser(position, direction);
      }
    });
    
    // Add helper method to update player count
    this.updatePlayerCount = () => {
      const count = this.networkManager.getOtherPlayers().length + 1; // +1 for self
      document.getElementById('players-count').textContent = count;
    };
    
    this.multiplayerEnabled = false;
  }
  
  setupScene() {
    // Create Three.js Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a1f); // Dark blue background
    
    // Setup WebGL renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(this.renderer.domElement);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near
      1000 // Far
    );
    
    // Position camera
    this.camera.position.set(0, 7, 15); // Slightly above and behind player
    this.camera.lookAt(0, 0, 0);
    
    // Attach audio listener to camera
    if (this.soundManager) {
      this.camera.add(this.soundManager.getListener());
      console.log('Audio listener attached to camera');
    }
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);
    
    // Create a simple grid floor
    this.createFloor();
    
    // Create some obstacles
    this.createObstacles();
  }
  
  async loadAssets() {
    if (this.loadingState.started) {
        console.warn('🔍 Asset loading already in progress');
        return;
    }
    
    this.updateLoadingUI('Loading game assets...');
    
    try {
        // Create initial player with default ship
        if (!this.player) {
            this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
                type: 'PLAYER',
                shipModel: 'STANDARD',
                teamColor: 0x00ffff
            });
            this.playerShip = this.player.mesh; // For backward compatibility
        }
        
        // Load all assets through AssetLoader
        await this.assetLoader.loadAll();
        this.assetsLoaded = true;
        this.shipModelLoaded = true;
        
        console.log('✅ All assets loaded successfully');
        this.checkLoadingProgress();
    } catch (error) {
        console.error('🔍 Critical error loading assets:', error);
        this.handleLoadError('critical', error);
    }
  }
  
  handleLoadError(assetType, error) {
    console.error(`Error loading ${assetType}:`, error);
    this.loadingState.errors.push({ type: assetType, error: error.message });
    
    // Update UI with error
    this.updateLoadingUI(`Error loading ${assetType}. ${this.loadingState.errors.length} errors total.`);
    
    // If critical error, show error screen
    if (assetType === 'critical') {
      this.showErrorScreen('Failed to load game assets. Please refresh the page.');
    }
  }
  
  updateLoadingUI(message) {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const messageElement = loadingScreen.querySelector('.loading-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  }
  
  showErrorScreen(message) {
    // Create error screen if it doesn't exist
    let errorScreen = document.getElementById('error-screen');
    if (!errorScreen) {
      errorScreen = document.createElement('div');
      errorScreen.id = 'error-screen';
      errorScreen.className = 'error-screen';
      
      const errorMessage = document.createElement('div');
      errorMessage.className = 'error-message';
      errorScreen.appendChild(errorMessage);
      
      const retryButton = document.createElement('button');
      retryButton.textContent = 'Retry';
      retryButton.onclick = () => {
        errorScreen.remove();
        this.loadingState = {
          started: false,
          completed: false,
          errors: []
        };
        this.loadAssets();
      };
      errorScreen.appendChild(retryButton);
      
      document.body.appendChild(errorScreen);
    }
    
    // Update error message
    const messageElement = errorScreen.querySelector('.error-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
  }
  
  checkLoadingProgress() {
    console.log('🔍 Checking loading progress...');
    
    // Log loading state
    console.log('Loading state:', JSON.stringify(this.loadingState, null, 2));
    
    // Define what's required for a fully loaded game
    const requiredAssets = {
      shipModel: this.shipModelLoaded,
      assetsLoaded: this.assetLoader.loadingState.completed
    };
    
    // Check if all required assets are loaded
    const allAssetsLoaded = Object.entries(requiredAssets).every(([key, loaded]) => {
      console.log(`🔍 ${key}: ${loaded ? '✅' : '❌'}`);
      return loaded;
    });
    
    if (allAssetsLoaded) {
      console.log('✅ All required assets loaded!');
      this.loadingState.completed = true;
      this.showStartScreen();
    } else {
      // Log which assets are still pending
      const pendingAssets = Object.entries(requiredAssets)
        .filter(([_, loaded]) => !loaded)
        .map(([key]) => key);
      console.log('⏳ Still waiting for:', pendingAssets);
      
      // Update loading UI
      this.updateLoadingUI(`Loading... (${pendingAssets.join(', ')})`);
      
      // Check again after a delay
      setTimeout(() => this.checkLoadingProgress(), 1000);
    }
  }
  
  showStartScreen() {
    console.log('🔍 Attempting to show start screen');
    
    // Timeout to ensure UI has time to update
    setTimeout(() => {
      // Hide loading screen and show start screen
      const loadingScreen = document.getElementById('loading-screen');
      const startScreen = document.getElementById('start-screen');
      
      console.log('🔍 Loading screen element:', loadingScreen);
      console.log('🔍 Start screen element:', startScreen);
      
      if (loadingScreen) {
        console.log('🔍 Adding fade-out class to loading screen');
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          loadingScreen.classList.add('hidden');
          loadingScreen.classList.remove('fade-out');
          console.log('🔍 Loading screen hidden');
        }, 500);
      } else {
        console.error('🔍 Loading screen element not found!');
      }
      
      if (startScreen) {
        console.log('🔍 Showing start screen');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('fade-in');
      } else {
        console.error('🔍 Start screen element not found!');
      }
      
      console.log('🔍 Game ready to start!');
    }, 500);
  }
  
  addThrusterGlow() {
    // Check if player and player mesh exist
    if (!this.player || !this.player.mesh) {
      console.warn('Cannot add thruster glow: Player or player mesh is not initialized');
      return;
    }
    
    // Create a single, efficient thruster glow effect
    // Use instanced mesh for better performance if you have multiple thrusters
    
    // Create a glow for the thruster
    const thrusterGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 12);
    const thrusterMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending // Use additive blending for better glow effect
    });
    
    const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
    thruster.position.set(0, 0, -0.7); // Position at the back of the ship
    thruster.rotation.x = Math.PI / 2;
    thruster.name = 'thruster'; // Name it for easier reference later
    
    // Add thruster to player mesh
    this.player.mesh.add(thruster);
    
    // Add point light for the thruster
    const thrusterLight = new THREE.PointLight(0x00ffff, 1, 3);
    thrusterLight.position.copy(thruster.position);
    thrusterLight.name = 'thrusterLight';
    
    // Store references for animation
    this.thruster = thruster;
    this.thrusterLight = thrusterLight;
    
    // Create a subtle, animated glow effect with proper initialization
    this.thrusterPulse = { 
      value: 0,
      phase: 0 
    };
    
    // Add to ship model
    if (this.shipModel) {
      this.shipModel.add(thruster);
      this.shipModel.add(thrusterLight);
    }
  }
  
  createFloor() {
    console.log('Creating floor with Terrain.glb model');
    
    // Create a placeholder floor initially - this will be visible until the model loads
    const tempFloorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);
    const tempFloorMaterial = new THREE.MeshBasicMaterial({
      color: 0x000022,
      transparent: true,
      opacity: 0.2,
    });
    
    this.floor = new THREE.Mesh(tempFloorGeometry, tempFloorMaterial);
    this.floor.rotation.x = -Math.PI / 2;
    this.floor.position.y = -0.01;
    this.scene.add(this.floor);
    
    // Also create an invisible raycasting plane that will always work for targeting
    // This ensures mouse input works consistently regardless of the visual floor model
    this.raycastFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        transparent: true, 
        opacity: 0.05, // Very slight visibility for debugging
        side: THREE.DoubleSide
      })
    );
    this.raycastFloor.rotation.x = -Math.PI / 2;
    this.raycastFloor.position.y = 0.1; // Position higher above terrain
    this.scene.add(this.raycastFloor);
    
    // Add debug logging
    console.log('Raycast floor created at height:', this.raycastFloor.position.y, 'and size:', 1000);
    
    // Load texture first
    const textureLoader = new THREE.TextureLoader();
    const texturePromise = new Promise((resolve, reject) => {
      textureLoader.load(
        'assets/models/textures/Colors3.png', 
        texture => {
          console.log('Terrain texture (Colors3.png) loaded successfully');
          // Configure texture 
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(8, 8); // Repeat the texture more times for better detail
          resolve(texture);
        },
        undefined,
        error => {
          console.error('Error loading Colors3.png texture:', error);
          // Try fallback texture
          textureLoader.load(
            'assets/models/textures/tex.png', 
            fallbackTexture => {
              console.log('Fallback texture loaded');
              fallbackTexture.wrapS = THREE.RepeatWrapping;
              fallbackTexture.wrapT = THREE.RepeatWrapping;
              fallbackTexture.repeat.set(5, 5);
              resolve(fallbackTexture);
            },
            undefined,
            fallbackError => {
              console.error('Error loading fallback texture:', fallbackError);
              resolve(null); // Resolve with null to continue without texture
            }
          );
        }
      );
    });
    
    // When texture is loaded (or failed), get the terrain model from AssetLoader
    texturePromise.then(texture => {
      // Get terrain model from AssetLoader
      const terrain = this.assetLoader.getModel('terrain/Terrain.glb');
      
      if (terrain) {
        console.log('Using terrain model from AssetLoader');
        
        // Remove the temporary floor
        if (this.floor) {
          this.scene.remove(this.floor);
          this.floor.geometry.dispose();
          this.floor.material.dispose();
        }
        
        // Clone the model to avoid modifying the original
        const terrainClone = terrain.clone();
        
        // Scale the terrain appropriately
        const terrainScale = 100; // Adjust this value to change the overall size
        terrainClone.scale.set(terrainScale, terrainScale * 0.5, terrainScale);
        
        // Position terrain at center and slightly below zero to avoid z-fighting
        terrainClone.position.set(0, -0.2, 0);
        
        // Apply texture if available
        if (texture) {
          terrainClone.traverse((node) => {
            if (node.isMesh) {
              node.material = node.material.clone(); // Clone material to avoid affecting other instances
              node.material.map = texture;
              node.material.needsUpdate = true;
              
              // Enable shadows
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
        }
        
        // Add to scene
        this.scene.add(terrainClone);
        this.terrain = terrainClone;
        
        console.log('Terrain model added to scene');
        
        // Add a circular highlight around the player's position
        this.createPlayerHighlight();
      } else {
        console.warn('Terrain model not found in AssetLoader, using fallback grid');
        
        // Create a grid as fallback
        const grid = new THREE.GridHelper(100, 100, 0x0000ff, 0x000044);
        grid.position.y = 0;
        this.scene.add(grid);
        this.terrain = grid;
        
        // Add player highlight anyway
        this.createPlayerHighlight();
      }
    });
  }

  // Separate method for player highlight to avoid code duplication
  createPlayerHighlight() {
    // Add a circular highlight around the player's position
    const highlightGeometry = new THREE.CircleGeometry(5, 32);
    const highlightMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
    });
    
    this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    this.playerHighlight.rotation.x = -Math.PI / 2;
    this.playerHighlight.position.y = 0.02; // Slightly above the floor
    this.scene.add(this.playerHighlight);
  }
  
  createBoundaryMarkers() {
    const boundarySize = 25; // Should match constrainToBounds boundary
    const markerSize = 1;
    const markerHeight = 1;
    const numMarkers = 10; // Number of markers per side
    
    const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
    const markerMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0x600000,
      transparent: true,
      opacity: 0.7
    });
    
    const markers = new THREE.Group();
    
    // Create boundary markers along the perimeter
    for (let i = 0; i < numMarkers; i++) {
      const t = (i / (numMarkers - 1)) * 2 - 1; // -1 to 1
      const position = boundarySize * t;
      
      // North edge
      const northMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      northMarker.position.set(position, markerHeight / 2, -boundarySize);
      markers.add(northMarker);
      
      // South edge
      const southMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      southMarker.position.set(position, markerHeight / 2, boundarySize);
      markers.add(southMarker);
      
      // East edge
      const eastMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      eastMarker.position.set(boundarySize, markerHeight / 2, position);
      markers.add(eastMarker);
      
      // West edge
      const westMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      westMarker.position.set(-boundarySize, markerHeight / 2, position);
      markers.add(westMarker);
    }
    
    this.scene.add(markers);
  }
  
  createObstacles() {
    // Create obstacle arrays
    this.obstacles = [];
    
    console.log('🚧 Creating immersive landscape with pathways and scattered crystals');
    
    // Define model categories and paths, with a focus on variety and character
    const obstacleCategories = {
      // Small to medium rocks
      rocks: [
        'SP_Rock01.glb', 
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      // Expanded flora selection
      flora: [
        'Grass_01.glb',
        'Mushrooms.glb',
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SmalRoots_01.glb',
        'Tenticles_01.glb',
        'BigPlant_06.glb'
      ],
      // Expanded ground features for creating pathways
      groundFeatures: [
        'objects/SP_Ground02.glb',
        'objects/SP_Ground03.glb',
        'objects/SP_Ground04.glb',
        'objects/SP_Ground05.glb'
      ],
      // Crystal clusters for interest points
      crystals: [
        'objects/SP_Crystal01.glb',
        'objects/SP_Stone01.glb'
      ],
      // Mountains for landscape borders and key landmarks
      mountains: [
        'objects/SP_Mountain01.glb',
        'objects/SP_Mountain02.glb',
        'objects/SP_Mountain03.glb'
      ]
    };
    
    // Enhanced distribution for a more detailed landscape
    const distribution = {
      rocks: 8,
      flora: 10,
      groundFeatures: 18,  // Increased from 12 to 18
      crystals: 9,
      mountains: 12  // Increased from 4 to 12
    };
    
    // Define some pre-made templates for object groupings
    const templates = [
      // Rock garden template
      {
        position: new THREE.Vector3(25, 0, 15),
        rotation: Math.PI / 6,
        elements: [
          { category: 'rocks', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 2.0, rotation: 0 },
          { category: 'rocks', modelIndex: 2, offset: new THREE.Vector3(3, 0, 1), scale: 1.3, rotation: Math.PI/3 },
          { category: 'rocks', modelIndex: 1, offset: new THREE.Vector3(-2, 0, 2), scale: 1.5, rotation: Math.PI/5 },
          { category: 'flora', modelIndex: 1, offset: new THREE.Vector3(2, 0, 3), scale: 1.2, rotation: 0 }
        ]
      },
      // Flora cluster template
      {
        position: new THREE.Vector3(-20, 0, -18),
        rotation: Math.PI / 4,
        elements: [
          { category: 'flora', modelIndex: 4, offset: new THREE.Vector3(0, 0, 0), scale: 1.8, rotation: 0 },
          { category: 'flora', modelIndex: 0, offset: new THREE.Vector3(2, 0, 2), scale: 1.4, rotation: Math.PI/2 },
          { category: 'flora', modelIndex: 3, offset: new THREE.Vector3(-1.5, 0, 1), scale: 1.2, rotation: Math.PI/6 },
          { category: 'rocks', modelIndex: 3, offset: new THREE.Vector3(1, 0, -2), scale: 1.0, rotation: 0 }
        ]
      },
      // Crystal formation template
      {
        position: new THREE.Vector3(-15, 0, 30),
        rotation: -Math.PI / 3,
        elements: [
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 1.5, rotation: 0 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(1.5, 0, 1), scale: 1.0, rotation: Math.PI/2 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(-1, 0, 1.5), scale: 0.8, rotation: Math.PI/4 },
          { category: 'groundFeatures', modelIndex: 2, offset: new THREE.Vector3(0, -0.2, 0), scale: 1.8, rotation: 0 }
        ]
      }
    ];
    
    // Create main pathways (4 paths coming from center, like a cross)
    const pathways = [
      { direction: new THREE.Vector3(1, 0, 0), width: 5 },   // East
      { direction: new THREE.Vector3(-1, 0, 0), width: 5 },  // West
      { direction: new THREE.Vector3(0, 0, 1), width: 5 },   // North
      { direction: new THREE.Vector3(0, 0, -1), width: 5 }   // South
    ];
    
    // Add some curved pathways to make it more interesting
    pathways.push(
      { 
        direction: new THREE.Vector3(0.7, 0, 0.7), 
        width: 4,
        curve: 0.8 // Will curve around
      },
      { 
        direction: new THREE.Vector3(-0.7, 0, -0.7), 
        width: 4,
        curve: -0.5 // Will curve the other way
      }
    );
    
    // Create some crystal gardens (clusters of crystals)
    const crystalGardens = [
      { x: 30, z: 30, radius: 8, count: 4 },
      { x: -25, z: 20, radius: 6, count: 3 },
      { x: 15, z: -35, radius: 10, count: 5 }
    ];
    
    // Function to check if a position is near a pathway
    const isNearPathway = (x, z, pathWidth) => {
      for (const path of pathways) {
        // Create a vector from center to this position
        const posVector = new THREE.Vector3(x, 0, z);
        const length = posVector.length();
        
        // Normalize the vector to compare direction
        if (length > 0) posVector.divideScalar(length);
        
        // Check if this aligns with any pathway
        const dot = posVector.dot(path.direction);
        
        // If aligned with path direction and not too close to center
        if (dot > 0.7 && length > 15 && length < 40) {
          // Calculate perpendicular distance to path
          const perpFactor = Math.sqrt(1 - dot * dot) * length;
          if (perpFactor < (path.width || pathWidth)) {
            return true;
          }
          
          // For curved paths
          if (path.curve) {
            // Check if in a curved region
            if (length > 20) {
              // Apply curvature - this is simplified but creates a nice effect
              const curveFactor = (length - 20) * path.curve * 0.1;
              const curvePerp = Math.abs(perpFactor - curveFactor);
              if (curvePerp < (path.width || pathWidth)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    
    // Function to check if position is in a crystal garden
    const isInCrystalGarden = (x, z) => {
      for (const garden of crystalGardens) {
        const dx = x - garden.x;
        const dz = z - garden.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance < garden.radius) {
          return garden;
        }
      }
      return null;
    };
    
    // Load and place models as obstacles
    for (const [category, models] of Object.entries(obstacleCategories)) {
      const count = distribution[category];
      
      for (let i = 0; i < count; i++) {
        // Select a random model from this category
        const modelPath = models[Math.floor(Math.random() * models.length)];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Create position based on category
        let x, z;
        let attempts = 0;
        let isValid = false;
        let inGarden = null;
        
        while (!isValid && attempts < 30) {
          attempts++;
          
          if (category === 'groundFeatures') {
            // Ground features go along pathways or in open areas
            if (Math.random() < 0.7) {
              // 70% along pathways
              const angle = Math.random() * Math.PI * 2;
              const distance = 15 + Math.random() * 25; // Between 15-40 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
              
              // If not near a pathway, try again
              if (!isNearPathway(x, z, 6)) continue;
            } else {
              // 30% randomly placed
              x = (Math.random() * 80) - 40;
              z = (Math.random() * 80) - 40;
            }
          } else if (category === 'crystals') {
            // Try to place in crystal gardens
            if (Math.random() < 0.7) {
              // 70% in crystal gardens
              const garden = crystalGardens[Math.floor(Math.random() * crystalGardens.length)];
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * garden.radius;
              x = garden.x + Math.cos(angle) * distance;
              z = garden.z + Math.sin(angle) * distance;
              inGarden = garden;
            } else {
              // 30% scattered elsewhere, avoiding pathways
              x = (Math.random() * 70) - 35;
              z = (Math.random() * 70) - 35;
              
              // If near a pathway, try again
              if (isNearPathway(x, z, 6)) continue;
            }
          } else if (category === 'mountains') {
            // Mountains go on the periphery with more diverse placement
            if (i < 4) {
              // Place 4 mountains at the far corners of the map
              const angle = (Math.PI/4) + (i * Math.PI/2); // Place at 45°, 135°, 225°, 315°
              const distance = 40 + Math.random() * 5; // Between 40-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else if (i < 8) {
              // Place 4 mountains at cardinal directions, but further out
              const angle = (i - 4) * Math.PI/2; // Place at 0°, 90°, 180°, 270°
              const distance = 42 + Math.random() * 8; // Between 42-50 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else {
              // Place remaining mountains randomly but still on periphery
              const angle = Math.random() * Math.PI * 2;
              const distance = 35 + Math.random() * 10; // Between 35-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            }
            
            // If near a pathway, try again (want mountains to border but not block paths)
            if (isNearPathway(x, z, 8)) continue;
          } else {
            // Rocks and flora go anywhere but not on paths
            x = (Math.random() * 80) - 40;
            z = (Math.random() * 80) - 40;
            
            // Avoid pathways for these obstacles
            if (isNearPathway(x, z, 5)) continue;
          }
          
          // Keep all objects away from center spawn
          if (Math.sqrt(x * x + z * z) < 15) continue;
          
          // Position is valid
          isValid = true;
        }
        
        if (!isValid) continue; // Skip if couldn't find valid position
        
        // Scale factors tailored by category and context
        let scale;
        if (category === 'rocks') {
          scale = 1.5 + Math.random() * 1.0; // Larger rocks (1.5-2.5)
        } else if (category === 'flora') {
          scale = 1.2 + Math.random() * 0.8; // Taller flora (1.2-2.0)
        } else if (category === 'groundFeatures') {
          if (isNearPathway(x, z, 6)) {
            // Ground features along pathways have more consistent size
            scale = 1.2 + Math.random() * 0.6; // Medium-sized ground (1.2-1.8)
          } else {
            // Ground features away from pathways can vary more
            scale = 0.8 + Math.random() * 1.4; // Variable ground features (0.8-2.2)
          }
        } else if (category === 'crystals') {
          if (inGarden) {
            // Varied crystal sizes in gardens
            scale = 0.5 + Math.random() * 1.4; // Variety of sizes (0.5-1.9)
          } else {
            // Scattered crystals are smaller
            scale = 0.7 + Math.random() * 0.6; // Smaller scattered (0.7-1.3)
          }
        } else if (category === 'mountains') {
          // More diverse mountain scales based on position
          if (i < 4) {
            // Corner mountains are largest
            scale = 2.2 + Math.random() * 1.3; // Largest mountains (2.2-3.5)
          } else if (i < 8) {
            // Cardinal direction mountains are medium-large
            scale = 1.8 + Math.random() * 1.0; // Medium-large mountains (1.8-2.8)
          } else {
            // Random mountains have varied sizes
            scale = 1.4 + Math.random() * 1.6; // Variable mountains (1.4-3.0)
          }
        }
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale and position
            model.scale.set(scale, scale, scale);
            model.position.set(x, 0, z); // Will adjust y based on model size
            
            // Add randomized rotation, except for ground features on pathways
            if (category === 'groundFeatures' && isNearPathway(x, z, 6)) {
              // Align with nearest pathway for ground features
              const alignAngle = Math.atan2(z, x);
              model.rotation.y = alignAngle + (Math.random() * 0.5 - 0.25); // Slight variation
            } else {
              model.rotation.y = Math.random() * Math.PI * 2;
            }
            
            // Enable shadows with optimization
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Optimize materials while keeping visual quality
                if (node.material) {
                  // Add category-specific visual enhancements
                  if (category === 'crystals' && modelPath.includes('Crystal')) {
                    // Make crystals glow with random colors
                    const crystalColors = [
                      new THREE.Color(0x00ffff), // cyan
                      new THREE.Color(0xff00ff), // magenta
                      new THREE.Color(0x88bbff), // light blue
                      new THREE.Color(0xffaa00)  // orange
                    ];
                    
                    // Random crystal color
                    const crystalColor = crystalColors[Math.floor(Math.random() * crystalColors.length)];
                    node.material.emissive = crystalColor;
                    node.material.emissiveIntensity = 0.3 + Math.random() * 0.3; // 0.3-0.6
                  } else if (category === 'mountains') {
                    // Give mountains a slight purple/blue tint
                    node.material.color = new THREE.Color(0x9090b0);
                  } else if (category === 'groundFeatures') {
                    // Give ground features varied earthy tones
                    const groundColors = [
                      new THREE.Color(0x908070), // tan
                      new THREE.Color(0x807060), // brown
                      new THREE.Color(0x708060), // olive
                      new THREE.Color(0x606070)  // slate
                    ];
                    node.material.color = groundColors[Math.floor(Math.random() * groundColors.length)];
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // IMPROVED COLLISION DETECTION: Use oriented bounding box for more accurate collisions
            // First, compute an accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use the improved ground placement calculation
            const groundY = this.calculateGroundOffset(model, category, scale);
            model.position.y = groundY;
            
            // Generate compound collision shapes for more accurate collision detection
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, scale);
            
            // Create better collision data with compound shapes
            const obstacleData = {
              mesh: model,
              type: category,
              // Advanced collision data
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              // Keep bounding box for broad-phase checks
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * scale / 2),
                  model.position.y - (size.y * scale / 2),
                  model.position.z - (size.z * scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * scale / 2),
                  model.position.y + (size.y * scale / 2),
                  model.position.z + (size.z * scale / 2)
                ),
                size: size.clone().multiplyScalar(scale),
                rotation: model.rotation.y
              },
              // Also keep a simple radius for quick distance checks
              size: Math.max(size.x, size.z) * scale * 0.5,
              position: model.position.clone()
            };
            
            this.obstacles.push(obstacleData);
            
            // Log first few obstacles for debugging
            if (this.obstacles.length <= 3) {
              console.log(`Created ${category} obstacle from ${modelPath}: width=${size.x * scale}, height=${size.y * scale}, depth=${size.z * scale} at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
            }
          },
          undefined, // Progress callback
          (error) => {
            console.error(`Error loading obstacle model ${fullPath}:`, error);
          }
        );
      }
    }
    
    // Create a special centerpiece crystal formation
    this.createCenterpiece();
    
    // Create template-based object groupings for more cohesive landscape
    this.createTemplateGroupings(templates, obstacleCategories);
    
    console.log(`Started loading ${Object.values(distribution).reduce((a, b) => a + b, 0)} obstacles with pathways and crystal gardens`);
  }
  
  /**
   * Create template-based object groupings
   */
  createTemplateGroupings(templates, categoryModels) {
    console.log('Creating template-based object groupings');
    
    templates.forEach((template, templateIndex) => {
      const templatePosition = template.position;
      const templateRotation = template.rotation;
      
      // Process each element in the template
      template.elements.forEach(element => {
        const category = element.category;
        
        // Get the model list for this category
        const models = categoryModels[category];
        if (!models || models.length === 0) return;
        
        // Select model by index or randomly if index is out of bounds
        const modelIndex = element.modelIndex < models.length ? element.modelIndex : Math.floor(Math.random() * models.length);
        const modelPath = models[modelIndex];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Calculate final position with rotation applied to offset
        const offset = element.offset.clone();
        
        // Apply template rotation to the offset
        if (templateRotation) {
          // Create rotation matrix
          const rotMatrix = new THREE.Matrix4().makeRotationY(templateRotation);
          offset.applyMatrix4(rotMatrix);
        }
        
        // Final position combines template position and rotated offset
        const finalPosition = new THREE.Vector3(
          templatePosition.x + offset.x,
          templatePosition.y + offset.y,
          templatePosition.z + offset.z
        );
        
        // Final rotation combines template rotation and element rotation
        const finalRotation = templateRotation + element.rotation;
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale
            model.scale.set(element.scale, element.scale, element.scale);
            
            // Set initial position 
            model.position.copy(finalPosition);
            
            // Apply rotation
            model.rotation.y = finalRotation;
            
            // Enable shadows with appropriate material enhancements
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Apply category-specific visual effects
                if (node.material) {
                  if (category === 'crystals') {
                    // Crystal glow effect
                    node.material.emissive = new THREE.Color(0x88bbff);
                    node.material.emissiveIntensity = 0.3;
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // Compute accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use improved ground placement
            const groundY = this.calculateGroundOffset(model, category, element.scale);
            model.position.y = groundY + element.offset.y; // Apply any intentional Y offset
            
            // Generate compound collision shapes
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, element.scale);
            
            // Add to obstacles array with collision data
            this.obstacles.push({
              mesh: model,
              type: category,
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * element.scale / 2),
                  model.position.y - (size.y * element.scale / 2),
                  model.position.z - (size.z * element.scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * element.scale / 2),
                  model.position.y + (size.y * element.scale / 2),
                  model.position.z + (size.z * element.scale / 2)
                ),
                size: size.clone().multiplyScalar(element.scale),
                rotation: model.rotation.y
              },
              size: Math.max(size.x, size.z) * element.scale * 0.5,
              position: model.position.clone()
            });
            
            console.log(`Template ${templateIndex+1}: Added ${category} model at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
          },
          undefined,
          (error) => {
            console.error(`Error loading template model ${fullPath}:`, error);
          }
        );
      });
    });
  }
  
  setupControls() {
    // Store active keys for visual feedback
    this.activeKeys = new Set();
    
    // Add visual indicators for controls
    this.createControlIndicators();
    
    // Detect if we're on a touch device
    this.isTouchDevice = 'ontouchstart' in window;
    
    // Keyboard controls
    document.addEventListener('keydown', this.boundHandleKeyDown);
    document.addEventListener('keyup', this.boundHandleKeyUp);
    
    // Mouse controls - attach to the canvas for better precision
    const canvas = this.renderer.domElement;
    canvas.addEventListener('click', this.boundHandleClick);
    canvas.addEventListener('mousemove', this.boundHandleMouseMove);
    
    // Setup touch controls for mobile devices
    if (this.isTouchDevice) {
      this.setupTouchControls();
    }
  }
  
  createControlIndicators() {
    console.log('Creating control indicators');
    // Create container if it doesn't exist
    if (!this.controlsContainer) {
        this.controlsContainer = document.createElement('div');
        this.controlsContainer.id = 'controls';
        this.controlsContainer.className = 'control-indicators';
        document.body.appendChild(this.controlsContainer);
        console.log('Control container created');
    }

    // Clear existing indicators
    this.controlsContainer.innerHTML = '';
    
    // Create the movement controls grid
    const movementControls = document.createElement('div');
    movementControls.className = 'movement-controls control-group';
    
    // Create the weapon controls section
    const weaponControls = document.createElement('div');
    weaponControls.className = 'weapon-controls control-group';
    
    // Define the key indicators for movement
    const movementKeys = [
        { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward', gridArea: 'forward' },
        { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward', gridArea: 'backward' },
        { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left', gridArea: 'left' },
        { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right', gridArea: 'right' },
        { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left', gridArea: 'strafeLeft' },
        { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right', gridArea: 'strafeRight' },
        { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon', gridArea: 'fire' }
    ];
    
    // Define the key indicators for weapons
    const weaponKeys = [
        { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser', className: 'weapon-key' },
        { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade', className: 'weapon-key' },
        { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser', className: 'weapon-key' },
        { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon', className: 'weapon-key' }
    ];
    
    // Create movement indicators
    movementKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        movementControls.appendChild(indicator);
    });
    
    // Create weapon indicators
    weaponKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        weaponControls.appendChild(indicator);
    });
    
    // Add a controls hint
    const hint = document.createElement('div');
    hint.className = 'controls-hint';
    hint.textContent = 'Press C to toggle controls visibility';
    
    // Add all elements to controls container
    this.controlsContainer.appendChild(movementControls);
    this.controlsContainer.appendChild(weaponControls);
    this.controlsContainer.appendChild(hint);
    
    console.log('Control indicators created with updated structure');
  }
  
  updateControlIndicators() {
    // Skip if control indicators aren't created yet
    if (!this.controlsContainer) return;
    
    // Update movement keys
    this.updateIndicatorState('forward', this.keys.forward);
    this.updateIndicatorState('backward', this.keys.backward);
    this.updateIndicatorState('left', this.keys.left);
    this.updateIndicatorState('right', this.keys.right);
    this.updateIndicatorState('strafeLeft', this.keys.strafeLeft);
    this.updateIndicatorState('strafeRight', this.keys.strafeRight);
    
    // Update fire state
    this.updateIndicatorState('fire', this.keys.fire);
    
    // Update weapon selection
    this.updateIndicatorState('selectLaser', this.currentWeapon === 'LASER');
    this.updateIndicatorState('selectGrenade', this.currentWeapon === 'GRENADE');
    this.updateIndicatorState('selectBounce', this.currentWeapon === 'BOUNCE');
  }
  
  updateIndicatorState(id, isActive) {
    const indicator = this.controlsContainer?.querySelector(`#indicator-${id}`);
    if (indicator) {
      if (isActive) {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }
  }
  
  handleResize(event) {
    // Debounce resize events
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    
    this.resizeTimer = setTimeout(() => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.resizeTimer = null;
    }, 100);
  }
  
  handleKeyDown(event) {
    // Handle escape key for in-game menu
    if (event.code === 'Escape') {
        this.showInGameMenu();
        return;
    }
    
    // Handle 'C' key to toggle controls visibility
    if (event.code === 'KeyC') {
        console.log('C key pressed - toggling controls');
        this.toggleControls();
        return;
    }
    
    // Handle 'M' key to toggle mini-map
    if (event.code === 'KeyM') {
        this.toggleMiniMap();
        return;
    }

    // Get control action from key mapping
    const action = ControlUtils.getActionForKey(event.code);
    
    // Skip if key isn't mapped or event is repeated
    if (!action || event.repeat) return;
    
    // Handle weapon selection
    if (action.category === 'WEAPONS') {
        if (action.action === 'SWITCH_WEAPON') {
            this.cycleWeapon();
            return;
        } else if (action.action === 'SELECT_LASER') {
            this.selectWeapon('LASER');
            return;
        } else if (action.action === 'SELECT_GRENADE') {
            this.selectWeapon('GRENADE');
            return;
        } else if (action.action === 'SELECT_BOUNCE') {
            this.selectWeapon('BOUNCE');
            return;
        }
    }
    
    // Handle UI controls
    if (action.category === 'UI') {
        if (action.action === 'TOGGLE_MAP') {
            this.toggleMiniMap();
            return;
        } else if (action.action === 'TOGGLE_CONTROLS') {
            this.toggleControls();
            return;
        }
    }
    
    // Set key state to active
    if (action.category === 'MOVEMENT') {
        this.keys[action.action.toLowerCase()] = true;
    }
    
    // Store active key for visual feedback
    this.activeKeys.add(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
    
    // Prevent default browser behavior for game controls
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'Tab', 'KeyM'].includes(event.code)) {
        event.preventDefault();
    }
}
  
  handleKeyUp(event) {
    const action = ControlUtils.getActionForKey(event.code);
    if (!action) return;
    
    // Skip weapon selection keys on keyup
    if (action.category === 'WEAPONS' && action.action.startsWith('SELECT_')) {
      return;
    }
    
    // Set key state to inactive
    if (action.category === 'MOVEMENT') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'WEAPONS') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'UI') {
      this.keys[action.action.toLowerCase()] = false;
    }
    
    // Remove from active keys
    this.activeKeys.delete(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
  }
  
  handleClick(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault) {
        event.preventDefault();
    }
    
    // Prevent rapid-fire clicking
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
        return;
    }
    
    // Get click coordinates relative to canvas
    const rect = this.renderer.domElement.getBoundingClientRect();
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid click coordinates');
        return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Convert to normalized device coordinates
    const mouse = new THREE.Vector2(
        (x / this.renderer.domElement.clientWidth) * 2 - 1,
        -(y / this.renderer.domElement.clientHeight) * 2 + 1
    );
    
    // Handle weapon-specific targeting
    if (this.currentWeapon === 'GRENADE') {
        this.handleGrenadeTargeting({ 
            clientX, 
            clientY,
            preventDefault: () => {} // Add dummy preventDefault for consistency
        });
    } else {
        this.handleDirectionalFiring({ clientX, clientY });
    }
  }
  
  handleMouseMove(event) {
    // Skip if we're moving too frequently (throttle)
    if (this.mouseMoveTimer) {
        return;
    }
    
    // Use requestAnimationFrame for smoother updates
    this.mouseMoveTimer = requestAnimationFrame(() => {
        // Get mouse coordinates relative to canvas
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update targeting indicators for any weapon type
        this.updateTargetingIndicator({
            clientX: event.clientX,
            clientY: event.clientY
        });
        
        // Additional targeting for grenade if that's the current weapon
        if (this.currentWeapon === 'GRENADE') {
            this.updateGrenadeTargetingIndicator({
                clientX: event.clientX,
                clientY: event.clientY
            });
        }
        
        this.mouseMoveTimer = null;
    });
}
  
  handleFireAction() {
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
      return;
    }
    
    // Set cooldown based on weapon type
    const cooldownTime = this.currentWeapon === 'GRENADE' ? 1000 :
                        this.currentWeapon === 'BOUNCE' ? 500 :
                        200;
    
    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);
    this.fireCurrentWeapon();
  }
  
  setupTouchControls() {
    // Create touch control container
    const touchControls = document.createElement('div');
    touchControls.className = 'touch-controls';
    document.body.appendChild(touchControls);
    
    // Create virtual joystick for movement
    const joystickContainer = document.createElement('div');
    joystickContainer.className = 'joystick-container';
    touchControls.appendChild(joystickContainer);
    
    const joystick = document.createElement('div');
    joystick.className = 'joystick';
    joystickContainer.appendChild(joystick);
    
    const joystickKnob = document.createElement('div');
    joystickKnob.className = 'joystick-knob';
    joystick.appendChild(joystickKnob);
    
    // Create fire button
    const fireButton = document.createElement('div');
    fireButton.className = 'touch-button fire-button';
    fireButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.ACTIONS.find(a => a.id === 'fire').label;
    touchControls.appendChild(fireButton);
    
    // Create weapon switch button
    const weaponButton = document.createElement('div');
    weaponButton.className = 'touch-button weapon-button';
    weaponButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.WEAPONS.find(w => w.id === 'switchWeapon').label;
    touchControls.appendChild(weaponButton);
    
    // Joystick handling
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickOrigin.x = rect.left + rect.width / 2;
      joystickOrigin.y = rect.top + rect.height / 2;
      handleJoystickMove(touch);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (joystickActive) {
        const touch = e.touches[0];
        handleJoystickMove(touch);
        e.preventDefault();
      }
    });
    
    document.addEventListener('touchend', (e) => {
      if (joystickActive) {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Reset movement keys using DEFAULT_CONTROL_STATE
        Object.keys(DEFAULT_CONTROL_STATE).forEach(key => {
          if (key.startsWith('forward') || key.startsWith('backward') || 
              key.startsWith('left') || key.startsWith('right') || 
              key.startsWith('strafe')) {
            this.keys[key] = DEFAULT_CONTROL_STATE[key];
          }
        });
        
        this.updateControlIndicators();
      }
    });
    
    const handleJoystickMove = (touch) => {
      const maxDistance = CONTROL_SETTINGS.TOUCH.JOYSTICK_MAX_DISTANCE;
      const deadZone = CONTROL_SETTINGS.TOUCH.JOYSTICK_DEAD_ZONE;
      
      // Calculate distance from center
      const dx = touch.clientX - joystickOrigin.x;
      const dy = touch.clientY - joystickOrigin.y;
      
      // Limit distance to maxDistance
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
      const angle = Math.atan2(dy, dx);
      
      // Move joystick knob
      const knobX = distance * Math.cos(angle);
      const knobY = distance * Math.sin(angle);
      joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
      
      // Convert joystick position to key presses using deadzone
      this.keys.forward = dy < -deadZone;
      this.keys.backward = dy > deadZone;
      this.keys.left = dx < -deadZone;
      this.keys.right = dx > deadZone;
      
      this.updateControlIndicators();
    };
    
    // Fire button handling with weapon cooldown
    let lastFireTime = 0;
    fireButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      const cooldown = CONTROL_SETTINGS.WEAPON_COOLDOWNS[this.currentWeapon];
      
      if (now - lastFireTime >= cooldown) {
        this.keys.fire = true;
        this.fireCurrentWeapon();
        lastFireTime = now;
      }
      
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    fireButton.addEventListener('touchend', (e) => {
      this.keys.fire = false;
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    // Weapon switch button handling with cooldown
    let lastWeaponSwitchTime = 0;
    weaponButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastWeaponSwitchTime >= 200) { // 200ms cooldown for weapon switching
        this.cycleWeapon();
        lastWeaponSwitchTime = now;
      }
      e.preventDefault();
    });
    
    // Enable directional fire on game area tap
    const gameArea = document.querySelector('canvas');
    if (gameArea) {
      let lastTapTime = 0;
      
      gameArea.addEventListener('touchstart', (e) => {
        // Ignore if touch is in control areas
        const touch = e.touches[0];
        const isInControlArea = 
          touchControls.contains(document.elementFromPoint(touch.clientX, touch.clientY));
          
        if (!isInControlArea && this.playerShip) {
          const now = Date.now();
          const doubleTapDelay = CONTROL_SETTINGS.TOUCH.DOUBLE_TAP_DELAY;
          
          // Check for double tap
          if (now - lastTapTime < doubleTapDelay) {
            // Handle double tap action (e.g., special weapon)
            this.cycleWeapon();
          } else {
            // Handle single tap (directional firing)
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // Handle directional firing similarly to mouse
            const touchPoint = new THREE.Vector2(
              (touchX / window.innerWidth) * 2 - 1,
              -(touchY / window.innerHeight) * 2 + 1
            );
            
            // Use raycasting to determine the point in 3D space
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touchPoint, this.camera);
            
            // Check for intersection with the floor
            const intersects = raycaster.intersectObject(this.floor);
            
            if (intersects.length > 0) {
              const targetPoint = intersects[0].point;
              
              // Calculate the direction from the player to the target point
              const shipPosition = this.playerShip.position.clone();
              const direction = targetPoint.clone().sub(shipPosition).normalize();
              
              // Only care about horizontal direction (ignore y component)
              direction.y = 0;
              direction.normalize();
              
              // Store the original rotation
              const originalRotation = this.playerShip.rotation.clone();
              
              // Temporarily rotate the ship to face the target
              this.playerShip.lookAt(shipPosition.clone().add(direction));
              
              // Fire the weapon in that direction
              if (this.currentWeapon === 'GRENADE') {
                // For grenades, we simulate a tap at the target location
                const targetEvent = {
                  clientX: touchX,
                  clientY: touchY,
                  preventDefault: () => {}
                };
                this.handleGrenadeTargeting(targetEvent);
              } else {
                // For lasers and bounce, fire in the direction
                this.fireCurrentWeapon(direction);
              }
              
              // Restore the original rotation
              this.playerShip.rotation.copy(originalRotation);
            }
          }
          
          lastTapTime = now;
          e.preventDefault();
        }
      });
    }
  }
  
  toggleControls() {
    // Clear any existing timeout
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
    
    // Also clear any auto-fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (!this.controlsContainer) {
      this.createControlIndicators();
    }
    
    if (this.controlsContainer.classList.contains('visible')) {
      this.fadeOutControls();
    } else {
      this.fadeInControls();
    }
  }
  
  fadeInControls() {
    console.log('Fading in controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // Remove any classes that might hide the controls
        this.controlsContainer.classList.remove('hidden', 'fading');
        // Add the visible class
        this.controlsContainer.classList.add('visible');
        console.log('Controls should now be visible with class: visible');
        
        // Set a timeout to automatically fade out the controls after 5 seconds
        // (but only if we're in the game and not in a menu)
        if (this.isRunning) {
            this.controlsFadeTimeout = setTimeout(() => {
              console.log('Auto-hiding controls after timeout');
              this.fadeOutControls();
            }, 5000);
        }
    } else {
        console.warn('Control container not found during fade in');
        // Try to create controls if they don't exist
        this.createControlIndicators();
        // And then try to show them
        if (this.controlsContainer) {
            this.controlsContainer.classList.add('visible');
            
            // Also set the auto-fade timeout for the newly created controls
            // (but only if we're in the game and not in a menu)
            if (this.isRunning) {
                this.controlsFadeTimeout = setTimeout(() => {
                  console.log('Auto-hiding newly created controls after timeout');
                  this.fadeOutControls();
                }, 5000);
            }
        }
    }
  }
  
  fadeOutControls() {
    console.log('Fading out controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // First add the fading class for the transition
        this.controlsContainer.classList.add('fading');
        this.controlsContainer.classList.remove('visible');
        
        // After the transition completes, add the hidden class
        setTimeout(() => {
            if (this.controlsContainer) {
                this.controlsContainer.classList.add('hidden');
            }
        }, 500); // Match the transition time from CSS
    } else {
        console.warn('Control container not found during fade out');
    }
  }
  
  updateWeaponUI() {
    // Update UI to reflect weapon change
    if (this.ui) {
        this.ui.updateWeapon(this.currentWeapon);
        
        // Update targeting indicator color if it exists
        if (this.targetingIndicator) {
            const colors = {
                'LASER': new THREE.Color(0x00ffff),
                'GRENADE': new THREE.Color(0xff4500),
                'BOUNCE': new THREE.Color(0x00ff99)
            };
            const color = colors[this.currentWeapon] || colors['LASER'];
            
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
        }
    }
    
    // Log weapon change
    console.log('Weapon updated:', this.currentWeapon);
}

selectWeapon(weaponType) {
    console.log('Selecting specific weapon:', weaponType);
    const index = this.availableWeapons.indexOf(weaponType);
    if (index !== -1) {
        this.weaponIndex = index;
        this.currentWeapon = weaponType;
        console.log('Weapon selection successful');
        
        // Update UI to reflect weapon change
        this.updateWeaponUI();
        
        // Play weapon switch sound if available
        this.playSound('weapon-switch');
    } else {
        console.warn('Attempted to select unavailable weapon:', weaponType);
    }
}
  
  cycleWeapon() {
    console.log('Cycling weapon from:', this.currentWeapon);
    this.weaponIndex = (this.weaponIndex + 1) % this.availableWeapons.length;
    this.currentWeapon = this.availableWeapons[this.weaponIndex];
    console.log('New weapon selected:', this.currentWeapon);
    
    // Update UI to reflect weapon change
    this.updateWeaponUI();
    
    // Play weapon switch sound
    this.playSound('weapon-switch');
}
  
  fireGrenade() {
    console.log("Grenade weapon selected - click to target");
  }
  
  animate() {
    // Call animationFrame with this instance as context
    requestAnimationFrame(this.animate.bind(this));
    
    try {
      // Calculate delta time
      const now = performance.now();
      const deltaTime = (now - this.lastTime) / 1000; // in seconds
      this.lastTime = now;
      
      // Update frame counter
      this.frameCount++;
      
      // Limit update rate
      if (this.frameCount % 2 === 0) { // Reduce update frequency
        // Only update gameplay if the player ship exists
        if (this.playerShip) {
          // Update player
          if (typeof this.updatePlayer === 'function') {
            this.updatePlayer(deltaTime);
          }
          
          // Update other elements - only if they exist
          if (typeof this.updateLasers === 'function') {
            this.updateLasers();
          }
          
          if (typeof this.updateEnergy === 'function') {
            this.updateEnergy(deltaTime);
          }
          
          if (typeof this.updateCamera === 'function') {
            this.updateCamera();
          }
          
          // Update collision detection
          if (typeof this.checkObstacleCollisions === 'function') {
            this.checkObstacleCollisions();
          }
          
          // Update thruster effects
          if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
          }
          
          // Check if boost is active and update energy consumption
          if (this.keys && this.keys.boost && this.energy > 0) {
            this.energy = Math.max(0, this.energy - 30 * deltaTime); // Boost drains energy
            if (this.ui) {
              this.ui.updateEnergy(this.energy, this.maxEnergy);
            }
          }
        }
        
        // Update bounceLasers if they exist
        if (this.bouncingLasers && this.bouncingLasers.length > 0 && 
            typeof this.updateBouncingLasers === 'function') {
          this.updateBouncingLasers();
        }
        
        // Update grenades if they exist
        if (this.grenades && this.grenades.length > 0 && 
            typeof this.updateGrenades === 'function') {
          this.updateGrenades();
        }
        
        // Update multiplayer
        if (this.multiplayerEnabled && this.networkManager) {
          // Send our position and rotation to server
          if (this.playerShip) {
            this.networkManager.sendPlayerUpdate({
              position: {
                x: this.playerShip.position.x,
                y: this.playerShip.position.y,
                z: this.playerShip.position.z
              },
              rotation: this.playerShip.rotation.y,
              name: this.playerName,
              shipType: this.currentShipType || 'default'
            });
          }
          
          // Update other players
          if (typeof this.updateOtherPlayers === 'function') {
            this.updateOtherPlayers();
          }
        }
      }
      
      // Render the scene
      if (this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        
        // Render CSS2D elements if renderer exists
        if (this.labelRenderer) {
          this.labelRenderer.render(this.scene, this.camera);
        }
      }
    } catch (error) {
      console.error("Error in animate loop:", error);
      // Don't rethrow, we want to keep the animation loop running
    }
  }
  
  updatePlayer(deltaTime) {
    if (!this.playerShip) return;
    
    // Save original position in case we need to revert due to collision
    const originalPosition = this.playerShip.position.clone();
    
    // ORIGINAL SHIP MOVEMENT PHYSICS
    const moveSpeed = 10; // Base movement speed
    const rotateSpeed = 2.5; // Base rotation speed
    
    let moved = false; // Track if the ship moved
    
    // Handle forward/backward movement
    if (this.keys.forward) {
        // Move forward
        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(forwardDir, moveSpeed * deltaTime);
        moved = true;
    }
    else if (this.keys.backward) {
        // Move backward
        const backwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(backwardDir, moveSpeed * deltaTime);
        moved = true;
    }

    // Handle left/right rotation
    if (this.keys.left) {
        // Rotate left
        this.playerShip.rotation.y += rotateSpeed * deltaTime;
        moved = true;
    }
    else if (this.keys.right) {
        // Rotate right
        this.playerShip.rotation.y -= rotateSpeed * deltaTime;
        moved = true;
    }
    
    // Update player highlight to follow the player ship
    if (this.playerHighlight) {
        this.playerHighlight.position.x = this.playerShip.position.x;
        this.playerHighlight.position.z = this.playerShip.position.z;
        
        // Add a subtle pulsing effect to the highlight
        const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
        this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
    }
    
    // Check for collisions after movement
    if (moved) {
        this.checkObstacleCollisions();
        
        // If no collisions, update thruster effects
        if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
        }
        
        // Send position update to server if multiplayer is enabled
        if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
            this.sendPlayerPositionUpdate();
        }
    }
  }
  
  updateLasers() {
    if (!this.lasers) return;
    
    for (let i = this.lasers.length - 1; i >= 0; i--) {
      const laser = this.lasers[i];
      
      // Move laser
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update trail effect
      laser.trailPoints.push(laser.mesh.position.clone());
      if (laser.trailPoints.length > 8) { // Reduced trail length for better performance
        laser.trailPoints.shift();
      }
      
      // Update trail geometry
      const positions = new Float32Array(laser.trailPoints.length * 3);
      for (let j = 0; j < laser.trailPoints.length; j++) {
        positions[j * 3] = laser.trailPoints[j].x;
        positions[j * 3 + 1] = laser.trailPoints[j].y;
        positions[j * 3 + 2] = laser.trailPoints[j].z;
      }
      laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Pulse effect
      laser.pulsePhase += 0.3;
      const pulse = Math.sin(laser.pulsePhase) * 0.2 + 0.8;
      laser.mesh.material.opacity = pulse;
      const light = laser.mesh.children[0];
      if (light) {
        light.intensity = pulse * 2;
      }
      
      // Increment lifetime
      laser.lifeTime++;
      
      // Remove old lasers
      if (laser.lifeTime > laser.maxLifeTime) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.lasers.splice(i, 1);
        continue;
      }
      
      // Check for collisions with obstacles
      for (let j = 0; j < this.obstacles.length; j++) {
        const obstacle = this.obstacles[j];
        
        // Simple distance check
        if (laser.mesh.position.distanceTo(obstacle.position) < 1.5) {
          // Create enhanced hit effect
          this.createEnhancedHitEffect(laser.mesh.position.clone(), laser.direction.clone());
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  createEnhancedHitEffect(position, direction) {
    // Create a burst of particles
    const particleCount = 15;
    const particles = [];
    
    // Create particle material
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity based on impact direction
      const spread = Math.PI / 2; // 90 degree spread
      const angle = Math.random() * spread - spread/2;
      const speed = 0.2 + Math.random() * 0.3;
      
      // Calculate velocity
      const velocity = direction.clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle)
        .multiplyScalar(speed);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0; // Full life
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.3, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(position.clone().add(direction));
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }
  
  checkObstacleCollisions() {
    if (!this.playerShip || !this.infiniteMap) {
      console.log('Skipping collision check - player ship or infinite map not available');
      return;
    }
    
    // Get player collision info
    const playerRadius = this.playerShip.userData.collisionRadius || 0.35;
    const playerPos = this.playerShip.position.clone();
    
    // Create player sphere for collision checks
    const playerSphere = {
      center: playerPos,
      radius: playerRadius
    };
    
    // Check collisions with infinite map objects first
    const mapCollision = this.infiniteMap.checkCollisions(playerPos, playerRadius);
    
    if (mapCollision.collided) {
      // Handle collision from infinite map
      this.handleObjectCollision(playerPos, mapCollision.object.position, mapCollision.object.type || 'terrain');
      return; // Stop checking after handling one collision
    }
    
    // Check local obstacles with more accurate collision detection
    for (const obstacle of this.obstacles) {
      if (!obstacle.mesh) continue;
      
      // First, do a quick broad-phase check with spheres for efficiency
      const obstaclePos = obstacle.position.clone();
      const distance = playerPos.distanceTo(obstaclePos);
      const quickCheckDistance = playerRadius + obstacle.size;
      
      // Skip detailed check if clearly not colliding
      if (distance > quickCheckDistance * 1.5) continue;
      
      // Determine if collision happened based on shape type
      let collision = false;
      
      if (obstacle.collisionShape === 'compound' && obstacle.compoundShapes) {
        // Use compound shape collision detection for complex objects
        collision = this.checkCompoundCollision(playerSphere, obstacle.compoundShapes);
      } else if (obstacle.collisionShape === 'complex' && obstacle.boundingBox) {
        // Fall back to oriented bounding box if compound shapes not available
        collision = this.checkBoxCollision(
          playerPos, playerRadius,
          obstacle.boundingBox, 
          obstacle.boundingBox.rotation
        );
      } else {
        // Simplest case: sphere-based collision for backward compatibility
        collision = distance < quickCheckDistance;
      }
      
      if (collision) {
        // Handle the collision
        this.handleObjectCollision(playerPos, obstaclePos, obstacle.type);
        break; // Only handle one collision at a time
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (compound shapes)
   */
  checkCompoundCollision(playerSphere, compoundShapes) {
    // Check collision against each shape in the compound
    for (const shape of compoundShapes) {
      let collision = false;
      
      if (shape.type === 'box') {
        // Box vs sphere collision
        collision = this.checkBoxSphereCollision(
          shape.center,
          shape.halfExtents,
          shape.worldRotation || 0,
          playerSphere
        );
      } else if (shape.type === 'sphere') {
        // Sphere vs sphere collision (simpler case)
        const distance = playerSphere.center.distanceTo(shape.center);
        collision = distance < (playerSphere.radius + shape.radius);
      }
      
      if (collision) {
        return true; // Collision with any part means collision with the compound
      }
    }
    
    return false; // No collision with any part
  }
  
  /**
   * Check collision between a rotated box and a sphere
   */
  checkBoxSphereCollision(boxCenter, boxHalfExtents, boxRotation, sphere) {
    // Transform sphere center to box space (accounting for rotation)
    const toSphere = new THREE.Vector3().subVectors(sphere.center, boxCenter);
    
    // Apply inverse rotation to get into box space
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(-boxRotation);
      toSphere.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on box to sphere in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-boxHalfExtents.x, Math.min(boxHalfExtents.x, toSphere.x)),
      Math.max(-boxHalfExtents.y, Math.min(boxHalfExtents.y, toSphere.y)),
      Math.max(-boxHalfExtents.z, Math.min(boxHalfExtents.z, toSphere.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(boxRotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to sphere center (for efficiency)
    const squaredDistance = sphere.center.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than sphere radius squared
    return squaredDistance < (sphere.radius * sphere.radius);
  }

  /**
   * Handle collision with any object
   */
  handleObjectCollision(playerPos, objectPos, objectType) {
    console.log(`COLLISION DETECTED with ${objectType}: Pushing ship back`);
    
    // Push player away from obstacle
    const pushDir = new THREE.Vector3()
      .subVectors(playerPos, objectPos)
      .normalize();
      
    // Adjust push force based on object type
    let pushForce = 0.7; // Default push force
    let damageAmount = 5; // Default damage
    
    // Customize collision response based on type
    switch(objectType) {
      case 'rocks':
        pushForce = 0.85; // Rocks push strongly
        damageAmount = 8;
        break;
      case 'specialObjects':
      case 'groundFeatures':
        pushForce = 0.75; // Ground features push medium
        damageAmount = 6;
        break;
      case 'mountains':
        pushForce = 1.0; // Mountains push very strongly
        damageAmount = 10;
        break;
      case 'crystals':
        pushForce = 0.7; // Crystals push medium but with special effect
        damageAmount = 7;
        
        // Add special crystal collision effect
        this.createCrystalCollisionEffect(objectPos);
        break;
      case 'centerpiece':
        pushForce = 0.9; // Centerpiece pushes strongly
        damageAmount = 9;
        
        // Add special centerpiece collision effect
        this.createCrystalCollisionEffect(objectPos, true);
        break;
      case 'flora':
        pushForce = 0.6; // Flora pushes gently
        damageAmount = 3;
        break;
      default:
        // Use default values
        break;
    }
    
    // Apply the push force
    this.playerShip.position.addScaledVector(pushDir, pushForce);
    
    // Flash collision warning
    this.flashCollisionWarning();
    
    // Apply damage if the function exists
    if (typeof this.applyDamage === 'function') {
      this.applyDamage(damageAmount);
    }
    
    // Play appropriate collision sound based on object type
    let soundToPlay = 'collision';
    
    if (objectType === 'specialObjects') {
      // Crystal-like sounds for special objects
      soundToPlay = 'crystalHit';
    } else if (objectType === 'mountains') {
      // Heavy impact for mountains
      soundToPlay = 'heavyImpact';
    }
    
    // Play the sound if it exists, otherwise fall back to default collision
    if (this.playSound) {
      try {
        this.playSound(soundToPlay);
      } catch (e) {
        // Fall back to default if sound doesn't exist
        try {
          this.playSound('collision');
        } catch (e2) {
          // No sound available
        }
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (oriented box)
   */
  checkBoxCollision(playerPos, playerRadius, box, rotation) {
    // Get box center
    const boxCenter = new THREE.Vector3(
      (box.min.x + box.max.x) / 2,
      (box.min.y + box.max.y) / 2,
      (box.min.z + box.max.z) / 2
    );
    
    // Calculate half extents of box
    const halfExtents = new THREE.Vector3(
      (box.max.x - box.min.x) / 2,
      (box.max.y - box.min.y) / 2,
      (box.max.z - box.min.z) / 2
    );
    
    // Vector from box center to player
    const toPlayer = new THREE.Vector3().subVectors(playerPos, boxCenter);
    
    // If we have rotation, apply inverse rotation to convert to box space
    if (rotation) {
      // Create rotation matrix for the box (negative rotation to invert)
      const rotMatrix = new THREE.Matrix4().makeRotationY(-rotation);
      toPlayer.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on the box to the player in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-halfExtents.x, Math.min(halfExtents.x, toPlayer.x)),
      Math.max(-halfExtents.y, Math.min(halfExtents.y, toPlayer.y)),
      Math.max(-halfExtents.z, Math.min(halfExtents.z, toPlayer.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (rotation) {
      // Create rotation matrix for the box
      const rotMatrix = new THREE.Matrix4().makeRotationY(rotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to player center
    const squaredDistance = playerPos.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than player radius squared
    return squaredDistance < (playerRadius * playerRadius);
  }
  
  updateCamera() {
    // Check if cameraTargetPosition is initialized
    if (!this.cameraTargetPosition) {
      this.cameraTargetPosition = new THREE.Vector3();
      this.cameraTargetLookAt = new THREE.Vector3();
      this.cameraSmoothingFactor = 0.05;
    }
    
    // If playerShip doesn't exist, early return
    if (!this.playerShip) return;
    
    // Define the camera offset from the player
    const offsetY = 18; // Height above the player
    const offsetZ = -16; // Distance behind the player (adjusted for larger ship)
    
    // Get the player's forward direction vector (simplified)
    const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
    
    // Calculate camera target position (directly above and slightly behind player)
    this.cameraTargetPosition.copy(this.playerShip.position);
    this.cameraTargetPosition.y += offsetY;
    
    // Move camera back based on player's orientation
    const backOffset = forwardDir.clone().multiplyScalar(offsetZ);
    this.cameraTargetPosition.add(backOffset);
    
    // Smoothly move camera toward target position
    this.camera.position.lerp(this.cameraTargetPosition, this.cameraSmoothingFactor);
    
    // Make camera look at the player
    this.cameraTargetLookAt.copy(this.playerShip.position);
    this.camera.lookAt(this.cameraTargetLookAt);
  }
  
  updateThrusterEffects() {
    // Skip if ship model isn't loaded
    if (!this.shipModel || !this.thruster || !this.thrusterLight) return;
    
    // Use stored references instead of finding children each time
    const { thruster, thrusterLight } = this;
    
    // Base thruster scale and opacity on movement
    const isMovingForward = this.keys.forward;
    const isMovingBackward = this.keys.backward;
    
    // Update thruster pulse for ambient animation
    this.thrusterPulse.value = (this.thrusterPulse.value + 0.1) % (Math.PI * 2);
    const pulseEffect = Math.sin(this.thrusterPulse.value) * 0.1;
    
    if (isMovingForward) {
      // Full thruster when moving forward
      const randomScale = 1 + Math.random() * 0.2 + pulseEffect;
      thruster.scale.set(1, 1, randomScale);
      thruster.material.opacity = 0.7 + Math.random() * 0.3;
      thrusterLight.intensity = 1.2 + Math.random() * 0.3 + pulseEffect;
      
      // Add color variation for a more dynamic effect
      const hue = (Date.now() % 1000) / 1000; // Cycle through colors over time
      thruster.material.color.setHSL(hue, 1, 0.5);
      thrusterLight.color.setHSL(hue, 1, 0.5);
    } else if (isMovingBackward) {
      // Reduced thruster when moving backward
      const randomScale = 0.3 + Math.random() * 0.1 + pulseEffect * 0.5;
      thruster.scale.set(0.5, 0.5, randomScale);
      thruster.material.opacity = 0.4 + Math.random() * 0.2;
      thrusterLight.intensity = 0.6 + Math.random() * 0.2 + pulseEffect * 0.5;
      
      // Cooler color for reverse thrust
      thruster.material.color.setHSL(0.6, 1, 0.5); // Blue-ish
      thrusterLight.color.setHSL(0.6, 1, 0.5);
    } else {
      // Idle state with subtle pulsing
      const idleScale = 0.3 + pulseEffect;
      thruster.scale.set(0.3, 0.3, idleScale);
      thruster.material.opacity = 0.3 + pulseEffect;
      thrusterLight.intensity = 0.4 + pulseEffect;
      
      // Neutral color for idle
      thruster.material.color.setHSL(0.5, 0.7, 0.5); // Cyan-ish
      thrusterLight.color.setHSL(0.5, 0.7, 0.5);
    }
    
    // Performance optimization: only update material if it's visible
    if (thruster.material.opacity < 0.01) {
      thruster.visible = false;
      thrusterLight.visible = false;
    } else {
      thruster.visible = true;
      thrusterLight.visible = true;
    }
  }
  
  flashCollisionWarning() {
    // Create a full-screen flash effect for collision
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'collision-flash';
    document.body.appendChild(flashOverlay);
    
    // Remove after animation completes
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, 150);
  }
  
  updateEnergy(deltaTime) {
    // Validate parameters
    if (typeof deltaTime !== 'number' || deltaTime < 0) {
        console.warn('Invalid deltaTime in updateEnergy:', deltaTime);
        return;
    }

    // Initialize energy values if undefined
    if (typeof this.energy !== 'number') this.energy = 0;
    if (typeof this.maxEnergy !== 'number') this.maxEnergy = 100;
    if (typeof this.energyRechargeRate !== 'number') this.energyRechargeRate = 20;

    // Store old energy for change detection
    const oldEnergy = this.energy;

    // Calculate recharge amount
    const rechargeAmount = this.energyRechargeRate * deltaTime;
    
    // Apply recharge with bounds checking
    this.energy = Math.min(this.maxEnergy, this.energy + rechargeAmount);

    // Update UI only if energy changed
    if (this.energy !== oldEnergy) {
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        }

        // Play charging sound when energy is low (under 10%)
        if (this.energy < (this.maxEnergy * 0.1)) {
            this.playSound('weapon-charging');
        }

        // Log significant energy changes (more than 1 unit) for debugging
        if (Math.abs(this.energy - oldEnergy) > 1) {
            console.log(`Energy updated: ${oldEnergy.toFixed(1)} -> ${this.energy.toFixed(1)} (Δ${deltaTime.toFixed(3)}s)`);
        }
    }
  }
  
  updateGrenades() {
    if (!this.grenades || this.grenades.length === 0) return;
    
    for (let i = this.grenades.length - 1; i >= 0; i--) {
      const grenade = this.grenades[i];
      
      // If the grenade has exploded, handle explosion effects
      if (grenade.exploded) {
        // Increase the explosion radius until maximum
        grenade.explosionMesh.scale.addScalar(0.2);
        grenade.explosionLight.intensity -= 0.1;
        
        // Remove explosion after it's done
        if (grenade.explosionLight.intensity <= 0) {
          this.scene.remove(grenade.explosionMesh);
          this.scene.remove(grenade.trail);
          this.grenades.splice(i, 1);
        }
        continue;
      }
      
      // Update the grenade position along the arc
      grenade.progress += 0.02;
      
      if (grenade.progress >= 1) {
        // Explode when reaching the target
        this.explodeGrenade(grenade, i);
      } else {
        // Move along a quadratic bezier curve for arcing trajectory
        const p0 = grenade.startPos;
        const p1 = grenade.midPos;
        const p2 = grenade.endPos;
        
        // Quadratic bezier formula: p = (1-t)^2 * p0 + 2(1-t)t * p1 + t^2 * p2
        const t = grenade.progress;
        const oneMinusT = 1 - t;
        
        grenade.mesh.position.x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
        grenade.mesh.position.y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
        grenade.mesh.position.z = oneMinusT * oneMinusT * p0.z + 2 * oneMinusT * t * p1.z + t * t * p2.z;
        
        // Add trail effect
        const point = grenade.mesh.position.clone();
        grenade.trailPoints.push(point);
        
        // Keep only the last 20 trail points
        if (grenade.trailPoints.length > 20) {
          grenade.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(grenade.trailPoints.length * 3);
        for (let j = 0; j < grenade.trailPoints.length; j++) {
          positions[j * 3] = grenade.trailPoints[j].x;
          positions[j * 3 + 1] = grenade.trailPoints[j].y;
          positions[j * 3 + 2] = grenade.trailPoints[j].z;
        }
        
        grenade.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        grenade.trail.geometry.attributes.position.needsUpdate = true;
      }
    }
  }
  
  explodeGrenade(grenade, index) {
    // Remove the grenade mesh
    this.scene.remove(grenade.mesh);
    
    // Create explosion geometry
    const explosionGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const explosionMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8
    });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(grenade.mesh.position);
    
    // Add to scene
    this.scene.add(explosionMesh);
    
    // Add explosion light
    const explosionLight = new THREE.PointLight(0xff6600, 3, 10);
    explosionMesh.add(explosionLight);
    
    // Mark as exploded
    grenade.exploded = true;
    grenade.explosionMesh = explosionMesh;
    grenade.explosionLight = explosionLight;
    
    // Calculate damage radius
    const explosionCenter = grenade.mesh.position.clone();
    const maxDamage = 50; // Maximum damage at center - 50% of health
    const damageRadius = grenade.explosionRadius || 4; // Default radius of 4 units
    
    // Check for obstacle hits in explosion radius
    for (const obstacle of this.obstacles) {
      const distance = obstacle.position.distanceTo(explosionCenter);
      if (distance < damageRadius) {
        // Calculate damage based on distance (linear falloff)
        const damagePercent = 1 - (distance / damageRadius);
        const hitPoint = obstacle.position.clone().add(
          explosionCenter.clone().sub(obstacle.position).normalize().multiplyScalar(distance * 0.8)
        );
        this.createHitEffect(hitPoint);
      }
    }
    
    // Check for player damage
    const playerPosition = this.playerShip.position.clone();
    playerPosition.y = 0; // Project to ground plane
    const grenadePosition = explosionCenter.clone();
    grenadePosition.y = 0; // Project to ground plane
    
    const playerDistance = playerPosition.distanceTo(grenadePosition);
    if (playerDistance < damageRadius) {
      // Calculate damage with distance falloff
      const damagePercent = 1 - (playerDistance / damageRadius);
      const damage = Math.floor(maxDamage * damagePercent);
      
      // Apply damage to player
      this.health = Math.max(0, this.health - damage);
      
      // Update UI
      if (this.ui) {
        this.ui.updateHealth(this.health, this.maxHealth);
      }
      
      // Visual feedback
      this.flashCollisionWarning();
      this.createHitEffect(playerPosition);
    }
  }
  
  updateBouncingLasers() {
    if (!this.bouncingLasers || this.bouncingLasers.length === 0) return;
    
    const playerPos = this.playerShip ? this.playerShip.position.clone() : null;
    
    // Update each laser
    for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
      const laser = this.bouncingLasers[i];
      
      // Skip invalid lasers
      if (!laser || !laser.mesh) continue;
      
      // Update laser position
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update the trail
      if (laser.trail) {
        // Add current position to trail points
        laser.trailPoints.push(laser.mesh.position.clone());
        
        // Limit the number of trail points
        if (laser.trailPoints.length > 20) {
          laser.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(laser.trailPoints.length * 3);
        for (let j = 0; j < laser.trailPoints.length; j++) {
          positions[j * 3] = laser.trailPoints[j].x;
          positions[j * 3 + 1] = laser.trailPoints[j].y;
          positions[j * 3 + 2] = laser.trailPoints[j].z;
        }
        
        // Update geometry
        laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        laser.trail.geometry.attributes.position.needsUpdate = true;
      }
      
      // Check for collisions with obstacles
      let collision = false;
      let closestPoint = null;
      let closestDistance = Infinity;
      let closestNormal = null;
      
      // Check for collision with each obstacle
      for (const obstacle of this.obstacles) {
        if (!obstacle.geometry) continue;
        
        let intersection = null;
        let normal = null;
        
        if (obstacle.geometry instanceof THREE.SphereGeometry) {
          const radius = obstacle.geometry.parameters.radius;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else if (obstacle.geometry instanceof THREE.CylinderGeometry) {
          const radius = obstacle.geometry.parameters.radiusTop;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else {
          // For boxes, use bounding sphere as approximation
          const boundingSphere = obstacle.geometry.boundingSphere;
          if (!boundingSphere) {
            obstacle.geometry.computeBoundingSphere();
          }
          const sphere = new THREE.Sphere(
            obstacle.position,
            obstacle.geometry.boundingSphere.radius
          );
          intersection = tempRay.intersectSphere(sphere, tempVector);
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        }
        
        if (intersection) {
          const dist = laser.mesh.position.distanceTo(intersection);
          if (dist < closestDist && dist < laser.speed * 1.2) {
            closestDist = dist;
            closestPoint = intersection;
            closestNormal = normal;
          }
        }
      }
      
      // Handle bounce if collision found
      if (closestPoint && closestNormal) {
        // Position at intersection point
        laser.mesh.position.copy(closestPoint);
        
        // Calculate reflection direction
        const dot = laser.direction.dot(closestNormal);
        const reflection = laser.direction.clone()
          .sub(closestNormal.multiplyScalar(2 * dot))
          .normalize();
        
        // Update direction with some randomness for more interesting bounces
        const randomAngle = (Math.random() - 0.5) * 0.2; // Small random angle
        reflection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
        laser.direction.copy(reflection);
        
        // Increment bounce count
        laser.bounces++;
        
        // Create bounce effect
        this.createBounceEffect(closestPoint.clone(), closestNormal.clone());
        
        // Play bounce sound
        this.playSound('bounce');
        
        // Enable player collision after first bounce
        laser.canHitPlayer = true;
        
        // Increase speed slightly with each bounce
        laser.speed *= 1.1;
        
        bounced = true;
      }
      
      // If no bounce, move normally
      if (!bounced) {
        laser.mesh.position.copy(nextPosition);
      }
      
      // Check for enemy collisions - new code
      if (this.enemyManager && this.enemyManager.enemies.length > 0) {
        for (let j = this.enemyManager.enemies.length - 1; j >= 0; j--) {
          const enemy = this.enemyManager.enemies[j];
          if (!enemy.isActive) continue;
          
          const enemyPos = enemy.mesh.position.clone();
          enemyPos.y = 0.5; // Adjust to match laser height
          
          // Check if the laser hit the enemy
          const hitDistance = 0.7; // Collision distance for enemy hits
          if (laser.mesh.position.distanceTo(enemyPos) < hitDistance) {
            // Enemy hit
            enemy.takeDamage(10); // Damage the enemy
            
            // Create hit effect
            this.createHitEffect(enemyPos);
            
            // Play hit sound
            this.playSound('weapon-armor-hit');
            
            // Remove laser
            this.scene.remove(laser.mesh);
            this.scene.remove(laser.trail);
            this.bouncingLasers.splice(i, 1);
            break; // Exit the enemy loop
          }
        }
      }
      
      // Check for player collision
      if (laser.canHitPlayer) {
        const playerPos = this.playerShip.position.clone();
        playerPos.y = 0.5;
        
        if (laser.mesh.position.distanceTo(playerPos) < 1) {
          // Player hit
          this.health -= 10;
          if (this.health < 0) this.health = 0;
          
          // Update UI
          this.ui.updateHealth(this.health, this.maxHealth);
          
          // Visual feedback
          this.flashCollisionWarning();
          this.createBounceEffect(playerPos, new THREE.Vector3(0, 1, 0));
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.bouncingLasers.splice(i, 1);
          continue;
        }
      }
      
      // Update lifetime
      laser.lifeTime++;
      
      // Remove if too old or too many bounces
      if (laser.lifeTime > laser.maxLifeTime || laser.bounces >= laser.maxBounces) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.bouncingLasers.splice(i, 1);
      }
    }
  }
  
  // Create a special effect for laser bounces
  createBounceEffect(position, normal) {
    // Create a particle burst effect at the bounce point
    const particleCount = 20;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    // Add a flash of light at bounce point
    const bounceLight = new THREE.PointLight(0x00ffcc, 3, 5);
    bounceLight.position.copy(position);
    this.scene.add(bounceLight);
    
    // Create a ring effect at bounce point
    const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(position);
    
    // Orient the ring according to the normal
    if (Math.abs(normal.y) > 0.99) { // If normal is pointing mainly up/down
      ring.rotation.x = Math.PI / 2; // Rotate to lie flat
    } else {
      // Point the ring along the normal
      const rotationAxis = new THREE.Vector3(0, 1, 0).cross(normal).normalize();
      const angle = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0)));
      ring.setRotationFromAxisAngle(rotationAxis, angle);
    }
    
    this.scene.add(ring);
    
    // Create particles around bounce point
    for (let i = 0; i < particleCount; i++) {
      // Random direction from bounce point
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(2)).normalize();
      
      // Starting at bounce point
      const startPoint = position.clone();
      particlePositions[i * 3] = startPoint.x;
      particlePositions[i * 3 + 1] = startPoint.y;
      particlePositions[i * 3 + 2] = startPoint.z;
      
      // Random sizes for particles
      particleSizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.1,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Store particle velocities
    const particleVelocities = [];
    for (let i = 0; i < particleCount; i++) {
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1, 
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(1.5)).normalize();
      
      // Random speed
      const speed = Math.random() * 0.1 + 0.05;
      particleVelocities.push(direction.multiplyScalar(speed));
    }
    
    // Animate particles and effects
    let frameCount = 0;
    const maxFrames = 30;
    
    const animate = () => {
      frameCount++;
      
      // Update particles
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x;
        positions[i * 3 + 1] += particleVelocities[i].y;
        positions[i * 3 + 2] += particleVelocities[i].z;
        
        // Slow down particles over time
        particleVelocities[i].multiplyScalar(0.95);
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Fade the light
      bounceLight.intensity *= 0.85;
      
      // Expand and fade the ring
      ring.scale.addScalar(0.15);
      ring.material.opacity *= 0.9;
      
      // Fade the particles
      particles.material.opacity *= 0.92;
      
      if (frameCount < maxFrames) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(bounceLight);
        this.scene.remove(ring);
        this.scene.remove(particles);
      }
    };
    
    // Start animation
    animate();
  }
  
  // Now add new methods to handle grenade targeting
  updateGrenadeTargetingIndicator(event) {
    // Create targeting indicator if it doesn't exist
    if (!this.grenadeTargetIndicator) {
      // Create targeting indicator
      const targetGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
      const targetMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, 
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      this.grenadeTargetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
      this.grenadeTargetIndicator.rotation.x = Math.PI / 2; // Make it horizontal
      
      // Add pulsing animation
      this.grenadeTargetIndicator.pulse = 0;
      
      // Add to scene
      this.scene.add(this.grenadeTargetIndicator);
    }
    
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // Update indicator color based on range
        if (distance > maxRange) {
          this.grenadeTargetIndicator.material.color.set(0xff0000); // Red for out of range
        } else {
          this.grenadeTargetIndicator.material.color.set(0x00ff00); // Green for valid
        }
        
        // Position the targeting indicator
        this.grenadeTargetIndicator.position.copy(targetPoint);
        this.grenadeTargetIndicator.position.y = 0.1; // Slightly above floor
        
        // Pulse animation
        this.grenadeTargetIndicator.pulse += 0.1;
        const scale = 1 + 0.2 * Math.sin(this.grenadeTargetIndicator.pulse);
        this.grenadeTargetIndicator.scale.set(scale, scale, scale);
        
        // Store target point for launching
        this.grenadeTargetPoint = targetPoint.clone();
    }
  }
  
  handleGrenadeTargeting(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Validate energy before proceeding
    if (!this.energy || !this.maxEnergy) {
        console.warn('Energy values invalid:', { energy: this.energy, maxEnergy: this.maxEnergy });
        return;
    }
    
    // Check if we have enough energy - now requires FULL energy
    if (this.energy < this.maxEnergy) {
        console.log("Not enough energy for grenade");
        return;
    }
    
    // Validate event coordinates
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid grenade target coordinates');
        return;
    }
    
    // Get the position where to throw the grenade
    const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // If beyond max range, limit to max range
        if (distance > maxRange) {
            toTarget.normalize().multiplyScalar(maxRange);
            targetPoint.copy(shipPosition).add(toTarget);
        }
        
        // Consume full energy
        this.energy = 0;
        
        // Update UI with energy change
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        } else {
            console.warn('UI energy update failed');
        }
        
        // Create and launch the grenade
        this.launchGrenade(targetPoint);
    }
  }
  
  launchGrenade(targetPoint) {
    // Create grenade mesh
    const grenadeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const grenadeMaterial = new THREE.MeshPhongMaterial({
      color: 0xff4500,
      emissive: 0xff2000,
      emissiveIntensity: 0.5
    });
    const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial);
    
    // Position at the ship
    grenade.position.copy(this.playerShip.position);
    grenade.position.y = 0.5; // Slightly above floor
    
    // Add to scene
    this.scene.add(grenade);
    
    // Add grenade trail effect
    const trail = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({
        color: 0xff4500,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      })
    );
    this.scene.add(trail);
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(0xff4500, 1, 3);
    grenade.add(light);
    
    // Store grenade data for animation
    if (!this.grenades) {
      this.grenades = [];
    }
    
    // Calculate the arc of the grenade
    const startPos = grenade.position.clone();
    const endPos = targetPoint.clone();
    const midPos = startPos.clone().add(endPos.clone().sub(startPos).multiplyScalar(0.5));
    midPos.y += 5; // Arc height
    
    this.grenades.push({
      mesh: grenade,
      trail: trail,
      startPos: startPos,
      midPos: midPos,
      endPos: endPos,
      progress: 0,
      exploded: false,
      explosionRadius: 4,
      trailPoints: []
    });

    // Play grenade launch sound
    this.playSound('grenade-laser');
  }
  
  // Add a method to show targeting indicator for all weapons
  updateTargetingIndicator(event) {
    // Skip if indicator was recently updated
    if (this.lastIndicatorUpdate && Date.now() - this.lastIndicatorUpdate < 16) {
        return;
    }
    this.lastIndicatorUpdate = Date.now();

    // Get the mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Log the normalized mouse position occasionally
    if (Math.random() < 0.01) {
      console.log('Mouse normalized position:', mouse);
    }
    
    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Check for intersection with the raycastFloor
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    // Log raycasting results occasionally for debugging
    if (Math.random() < 0.01) {
      console.log('Raycast results:', { 
        intersections: intersects.length, 
        raycastFloorExists: !!this.raycastFloor,
        raycastFloorPosition: this.raycastFloor ? this.raycastFloor.position.y : 'N/A'
      });
    }
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Create or update targeting indicator
        if (!this.targetingIndicator) {
            console.log('Creating new targeting indicator');
            // Create a more efficient indicator using a single geometry
            const geometry = new THREE.Group();
            
            // Outer ring with fewer segments - MAKE LARGER
            const outerRing = new THREE.RingGeometry(0.8, 1.0, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8, // Increased opacity
                side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerRing, material);
            
            // Inner ring with fewer segments - MAKE LARGER
            const innerRing = new THREE.RingGeometry(0.2, 0.4, 16);
            const inner = new THREE.Mesh(innerRing, material.clone());
            
            // Simplified crosshair - MAKE LARGER
            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = new Float32Array([
                -0.6, 0, 0,
                0.6, 0, 0,
                0, -0.6, 0,
                0, 0.6, 0
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));
            const lines = new THREE.LineSegments(lineGeometry, material.clone());
            
            geometry.add(outer);
            geometry.add(inner);
            geometry.add(lines);
            
            this.targetingIndicator = geometry;
            this.targetingIndicator.rotation.x = Math.PI / 2;
            this.scene.add(this.targetingIndicator);
        }
        
        // Update position - INCREASE HEIGHT
        this.targetingIndicator.position.copy(targetPoint);
        this.targetingIndicator.position.y = 0.5; // Much higher above the terrain
        
        // Update color based on weapon type
        const colors = {
            'LASER': new THREE.Color(0x00ffff),
            'GRENADE': new THREE.Color(0xff4500),
            'BOUNCE': new THREE.Color(0x00ff99)
        };
        const color = colors[this.currentWeapon] || colors['LASER'];
        
        // Only update colors if they've changed
        if (!this.lastWeaponColor || this.lastWeaponColor !== this.currentWeapon) {
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
            this.lastWeaponColor = this.currentWeapon;
        }
        
        // Simplified pulse animation
        if (!this.targetingIndicator.pulse) {
            this.targetingIndicator.pulse = 0;
        }
        this.targetingIndicator.pulse = (this.targetingIndicator.pulse + 0.1) % (Math.PI * 2);
        const pulseScale = 1.0 + 0.1 * Math.sin(this.targetingIndicator.pulse);
        this.targetingIndicator.scale.setScalar(pulseScale);
        
        // Show indicator
        this.targetingIndicator.visible = true;
        
        // Reset fade timeout
        if (this.targetingTimeout) {
            clearTimeout(this.targetingTimeout);
        }
        this.targetingTimeout = setTimeout(() => {
            if (this.targetingIndicator && this.targetingIndicator.visible) {
                this.targetingIndicator.visible = false;
            }
        }, 1000);
        
        // Extract target direction for firing
        const direction = new THREE.Vector3()
            .subVectors(targetPoint, this.playerShip.position)
            .normalize();
        
        // Store direction for firing
        this.targetDirection = direction;
    }
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggleMiniMap() {
    if (this.miniMap) {
      this.miniMap.toggle();
    }
  }
  
  // Add cleanup method
  cleanup() {
    // Stop and remove all sounds
    this.soundPools.forEach(pool => {
      pool.forEach(wrapper => {
        if (wrapper.sound.isPlaying) {
          wrapper.sound.stop();
        }
        wrapper.sound.buffer = null;
      });
    });
    
    // Clear sound pools and loaded sounds
    this.soundPools.clear();
    this.loadedSounds.clear();
    this.soundLoadPromises.clear();
    
    // Remove audio listener from camera
    if (this.audioListener) {
      this.camera.remove(this.audioListener);
      this.audioListener = null;
    }
    
    // Remove event listeners
    window.removeEventListener('resize', this.boundHandleResize);
    document.removeEventListener('keydown', this.boundHandleKeyDown);
    document.removeEventListener('keyup', this.boundHandleKeyUp);
    document.removeEventListener('click', this.boundHandleClick);
    document.removeEventListener('mousemove', this.boundHandleMouseMove);
    
    // Clear timers
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = null;
    }
    
    if (this.mouseMoveTimer) {
      clearTimeout(this.mouseMoveTimer);
      this.mouseMoveTimer = null;
    }
    
    // Clear weapon cooldowns
    this.weaponCooldowns.clear();
    
    // Clear key states
    Object.keys(this.keys).forEach(key => {
      this.keys[key] = false;
    });
    this.activeKeys.clear();
  }

  startGame() {
    console.log("Starting game...");
    
    // Get player name from input
    const playerNameInput = document.getElementById('player-name');
    this.playerName = playerNameInput.value.trim() || 'Pilot-' + Math.floor(Math.random() * 1000);
    
    // Hide start screen
    const startScreen = document.getElementById('start-screen');
    startScreen.classList.add('hidden');
    
    // Enable multiplayer mode by default
    this.multiplayerEnabled = true;
    
    // Connect to server
    if (this.networkManager) {
      this.networkManager.connect();
      
      // Show multiplayer info UI
      const multiplayerInfo = document.getElementById('multiplayer-info');
      if (multiplayerInfo) {
        multiplayerInfo.classList.remove('hidden');
      }
      
      // Update player info on server
      this.networkManager.updatePlayerInfo(this.playerName, this.currentShipType || 'default');
    }
    
    // Show ship selection screen
    this.showShipSelection();
  }

  showShipSelection() {
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
      console.error('Game container not found');
      return;
    }

    // Initialize ship selection if not already done
    if (!this.shipSelection) {
      this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
          this.shipSelection.hide();
          this.startGameplay(selection);
        }
      });
    }
    this.shipSelection.show();
  }

  startGameplay(shipSelection) {
    console.log('🔍 Starting gameplay with ship selection:', shipSelection);
    
    // First apply the ship selection
    this.applyShipSelection(shipSelection);
    
    // Set game as running (if this property exists)
    this.isRunning = true;
    
    // Show game UI (using either method)
    if (typeof this.ui !== 'undefined' && typeof this.ui.show === 'function') {
        this.ui.show();
    } else {
        // Show game UI directly
        const gameUI = document.querySelector('.game-ui');
        if (gameUI) {
            gameUI.classList.remove('hidden');
        }
    }
    
    // Show mini-map if it exists
    if (this.miniMap && typeof this.miniMap.show === 'function') {
        this.miniMap.show();
    }
    
    // Create and show controls if not already created
    if (!this.controlsContainer && typeof this.createControlIndicators === 'function') {
        this.createControlIndicators();
    }
    this.fadeInControls();
    
    // IMPORTANT: Double-check that the player ship has a proper collision radius
    if (this.playerShip) {
        this.playerShip.userData.collisionRadius = 0.35; // Use the same reduced value as defined earlier
        console.log('🛡️ Verified player ship collision radius:', this.playerShip.userData.collisionRadius);
    } else {
        console.error('⚠️ Player ship not available when starting gameplay!');
    }
    
    // Manually check for collisions once to make sure it's working
    setTimeout(() => {
        console.log('🔍 Running initial collision check...');
        this.checkObstacleCollisions();
    }, 500);

    // Start animation loop
    this.animate();
    
    console.log('✅ Game started successfully!');
  }

  applyShipSelection(selection) {
    console.log('🔍 Applying ship selection:', selection);
    
    // Clear existing ship model
    if (this.playerShip) {
        // Remove all children (previous ship model)
        while (this.playerShip.children.length > 0) {
            const child = this.playerShip.children[0];
            this.playerShip.remove(child);
        }
    }
    
    // Set ship model based on selection
    const type = selection.type.toUpperCase(); // Make sure it's uppercase for consistency
    this.setShipModel(type);
    this.currentShipType = type;
    
    // Position ship at a random location in the playing area
    // Avoid spawning too close to the center (where other players might spawn)
    const spawnRadius = 30; // Radius from center for spawning
    const randomAngle = Math.random() * Math.PI * 2; // Random angle
    const randomDistance = spawnRadius * (0.5 + Math.random() * 0.5); // Between 50% and 100% of spawn radius
    
    // Calculate position
    const spawnX = Math.cos(randomAngle) * randomDistance;
    const spawnZ = Math.sin(randomAngle) * randomDistance;
    
    // Set player ship position
    if (this.playerShip) {
        this.playerShip.position.set(spawnX, this.playerShip.position.y, spawnZ);
        
        // Set random rotation
        this.playerShip.rotation.y = Math.random() * Math.PI * 2;
        
        console.log(`Player spawned at position: [${spawnX.toFixed(2)}, ${spawnZ.toFixed(2)}], rotation: ${this.playerShip.rotation.y.toFixed(2)}`);
    }
    
    // Apply ship color if specified
    if (selection.color && this.playerShip) {
        const color = new THREE.Color(selection.color);
        
        // Apply color to all meshes in the ship model
        this.playerShip.traverse(child => {
            if (child.isMesh && child.material) {
                try {
                    // Clone the material to avoid affecting other instances
                    if (!child.material._isCloned) {
                        child.material = child.material.clone();
                        child.material._isCloned = true;
                    }
                    
                    // Update material color properties with safety checks
                    if (child.material.color) {
                        child.material.color.set(color);
                    }
                    
                    if (child.material.emissive) {
                        child.material.emissive.set(color);
                        child.material.emissiveIntensity = 0.3;
                    }
                    
                    // Update the material
                    child.material.needsUpdate = true;
                } catch (error) {
                    console.warn('Error setting material properties:', error);
                }
            }
        });
    }
    
    console.log('✅ Ship configuration applied successfully');
    
    // Verify collision detection is working
    console.log('🔍 Verifying collision detection is working');
}

exitToMainMenu() {
    // Stop animation loop
    this.isRunning = false;

    // Hide in-game menu if it exists
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
      menuContainer.classList.add('hidden');
    }

    // Hide game UI
    this.ui.hide();
    if (this.miniMap) {
      this.miniMap.hide();
    }
    this.fadeOutControls();

    // Clean up ship selection if it exists
    if (this.shipSelection) {
      this.shipSelection.hide();
    }

    // Show start screen
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
      startScreen.classList.add('fade-in');
    }

    // Reset game state
    this.resetGameState();
  }

  resetGameState() {
    console.log('🔄 Resetting game state...');
    
    // Reset player position
    if (this.playerShip) {
        this.playerShip.position.set(0, 0.5, 0);
        this.playerShip.rotation.set(0, 0, 0);
    }
    
    // Reset camera to original position
    if (this.camera) {
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);
    }
    
    // Reset player stats
    this.health = this.maxHealth || 100;
    this.energy = this.maxEnergy || 100;
    
    // Update UI - use existing methods if available
    if (typeof this.updateUI === 'function') {
        this.updateUI();
    } else {
        // Update health bar
        const healthBar = document.querySelector('.health-bar .bar-inner');
        if (healthBar) {
            healthBar.style.width = '100%';
        }
        
        // Update energy bar
        const energyBar = document.querySelector('.energy-bar .bar-inner');
        if (energyBar) {
            energyBar.style.width = '100%';
        }
    }
    
    // Original way of clearing lasers
    if (this.lasers) {
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            const laser = this.lasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.lasers = [];
    }
    
    // Clear bouncing lasers
    if (this.bouncingLasers) {
        for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
            const laser = this.bouncingLasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.bouncingLasers = [];
    }
    
    // Clear grenades
    if (this.grenades) {
        for (let i = this.grenades.length - 1; i >= 0; i--) {
            const grenade = this.grenades[i];
            if (grenade.mesh && grenade.mesh.parent) {
                grenade.mesh.parent.remove(grenade.mesh);
            }
        }
        this.grenades = [];
    }
    
    // Reset movement keys
    this.keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        strafeLeft: false,
        strafeRight: false
    };
    
    // Reset weapon state to original
    this.currentWeapon = 'laser';
    this.weaponCooldown = 0;
    this.grenadeTargeting = false;
    
    // Make sure the player exists
    if (!this.playerShip) {
        this.createDefaultShip();
    }
    
    // Reset player velocity (original behavior)
    this.playerVelocity = new THREE.Vector3();
    this.playerRotation = new THREE.Vector3();
    
    // Update weapon UI - use existing method if available
    if (typeof this.updateWeaponUI === 'function') {
        this.updateWeaponUI();
    }
    
    // Update control indicators - use existing method if available
    if (typeof this.updateControlIndicators === 'function') {
        this.updateControlIndicators();
    }
    
    console.log('✅ Game state reset complete');
  }

  handleDirectionalFiring(event) {
    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);

    // Check for intersection with an invisible plane at ship's height
    const planeNormal = new THREE.Vector3(0, 1, 0);
    const shipHeight = this.playerShip.position.y;
    const plane = new THREE.Plane(planeNormal, -shipHeight);
    
    const targetPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, targetPoint);

    if (targetPoint) {
        // Calculate direction from ship to target
        const direction = targetPoint.clone().sub(this.playerShip.position).normalize();
        direction.y = 0; // Keep shots parallel to ground

        // Get the ship's current forward direction
        const shipForward = new THREE.Vector3(0, 0, 1);
        shipForward.applyQuaternion(this.playerShip.quaternion);
        shipForward.y = 0;
        shipForward.normalize();

        // Calculate the angle between ship's forward direction and target direction
        const angle = shipForward.angleTo(direction);
        
        // Only fire if the target is within a reasonable angle (e.g., 60 degrees) from ship's forward direction
        const maxFiringAngle = Math.PI / 3; // 60 degrees
        
        if (angle <= maxFiringAngle) {
            // Fire weapon in the calculated direction
            this.fireCurrentWeapon(direction);
        }
    }
  }

  fireCurrentWeapon(direction) {
    // Check weapon cooldown
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;

    if (now < weaponCooldown) {
        return;
    }

    // Define energy costs for each weapon from GAME_CONFIG
    const energyCosts = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.ENERGY_COST,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.ENERGY_COST,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.ENERGY_COST
    };

    // Check if we have enough energy
    const energyCost = energyCosts[this.currentWeapon];
    if (this.energy < energyCost) {
        console.log(`Not enough energy for ${this.currentWeapon}`);
        return;
    }

    // Set cooldown based on weapon type from GAME_CONFIG
    const cooldowns = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.COOLDOWN,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.COOLDOWN,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.COOLDOWN
    };
    const cooldownTime = cooldowns[this.currentWeapon];

    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);

    // Consume energy
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Update UI with energy change
    if (this.ui && typeof this.ui.updateEnergy === 'function') {
        this.ui.updateEnergy(this.energy, this.maxEnergy);
    }

    // Use target direction if available, otherwise use ship orientation
    let firingDirection;
    
    // If we have a targetDirection from mouse, use that instead of ship orientation
    if (this.targetDirection && (this.currentWeapon === 'LASER' || this.currentWeapon === 'BOUNCE')) {
        firingDirection = this.targetDirection.clone();
        console.log('Using mouse targeting direction:', firingDirection);
    } else {
        // Fall back to ship orientation if no target direction
        firingDirection = direction || new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        console.log('Using ship orientation direction:', firingDirection);
    }
    
    // Ensure direction is normalized
    firingDirection.normalize();
    
    // Get firing position (slightly in front of ship)
    const position = this.playerShip.position.clone().add(firingDirection.clone().multiplyScalar(1.5));
    position.y = 0.5; // Set height

    // Create weapon effect based on type
    switch (this.currentWeapon) {
        case 'LASER':
            this.fireLaser(position, firingDirection);
            this.playSound('laser');
            
            // Send laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection
                });
            }
            break;
        case 'BOUNCE':
            this.fireBouncingLaser(position, firingDirection);
            this.playSound('laser-bounce');
            
            // Send bounce laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection,
                    type: 'bounce'
                });
            }
            break;
        case 'GRENADE':
            // Grenades are handled separately through handleGrenadeTargeting
            break;
    }

    // Visual feedback for firing
    this.createMuzzleFlash(position, firingDirection);

    // Log energy state for debugging
    console.log(`Weapon fired: ${this.currentWeapon}, Energy remaining: ${this.energy}/${this.maxEnergy}`);
}

createMuzzleFlash(position, direction) {
  // Create a quick flash effect at the firing position
  const flashGeometry = new THREE.CircleGeometry(0.3, 16);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
  });
  
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position flash at the weapon position, oriented to face the camera
  flash.position.copy(position);
  flash.position.y += 0.1; // Slightly above ship
  
  // Update flash to always face camera
  flash.lookAt(this.camera.position);
  
  // Add to scene
  this.scene.add(flash);
  
  // Create flash animation with subtle scaling
  let scale = 1;
  const animate = () => {
    scale += 0.2;
    flash.scale.set(scale, scale, scale);
    
    // Reduce opacity as flash grows
    if (flash.material) {
      flash.material.opacity = Math.max(0, 1 - (scale - 1) / 2);
      
      // Remove when fully transparent
      if (flash.material.opacity <= 0) {
        this.scene.remove(flash);
        if (flash.material) flash.material.dispose();
        if (flash.geometry) flash.geometry.dispose();
        return;
      }
    }
    
    // Continue animation
    requestAnimationFrame(animate);
  };
  animate();
}

  fireLaser(position, direction) {
    // Create laser geometry - make it longer and thinner for better visual
    const geometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
    geometry.rotateX(-Math.PI / 2); // Changed rotation to negative to flip direction

    // Create glowing material with better visual effects
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Orient laser along direction - using lookAt for more accurate direction
    const targetPos = position.clone().add(direction.clone().multiplyScalar(10));
    laser.lookAt(targetPos);

    // Add to scene
    this.scene.add(laser);

    // Add point light for glow effect with better parameters
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.set(0, 0, 0); // Center of the laser
    laser.add(light);

    // Add a trail effect
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    this.scene.add(trail);

    // Initialize lasers array if it doesn't exist
    if (!this.lasers) {
      this.lasers = [];
    }

    // Store laser data with enhanced properties
    this.lasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 1.2, // Slightly increased speed for better feel
      lifeTime: 0,
      maxLifeTime: 40,
      trailPoints: [],
      pulsePhase: 0
    });
  }

  fireBouncingLaser(position, direction) {
    // Create bouncing laser geometry - using a smaller sphere for better visuals
    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff99,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Add point light for glow effect
    const light = new THREE.PointLight(0x00ff99, 2, 3);
    laser.add(light);

    // Create enhanced trail effect
    const trail = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({
        color: 0x00ff99,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      })
    );

    // Add to scene
    this.scene.add(laser);
    this.scene.add(trail);

    // Initialize bouncing lasers array if it doesn't exist
    if (!this.bouncingLasers) {
      this.bouncingLasers = [];
    }

    // Store bouncing laser data with improved parameters
    this.bouncingLasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 0.8, // Increased speed for better feel
      bounces: 0,
      maxBounces: 3,
      lifeTime: 0,
      maxLifeTime: 120,
      canHitPlayer: false,
      bounceTimeout: 15, // Reduced timeout for better gameplay
      trailPoints: [],
      pulsePhase: 0
    });
  }

  createHitEffect(position) {
    // Create particle burst effect
    const particleCount = 15;
    const particles = [];
    
    // Create particle material with orange/red color for explosion
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.2, 0.2);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity in all directions
      const velocity = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0;
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.5, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(this.camera.position);
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0xff6600, 3, 6);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles and effects
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }

  showInGameMenu() {
    // Pause the game
    this.isRunning = false;
    
    // Create or reuse the menu element
    let menuContainer = document.getElementById('in-game-menu');
    if (!menuContainer) {
      menuContainer = document.createElement('div');
      menuContainer.id = 'in-game-menu';
      menuContainer.className = 'menu-container';
      document.getElementById('game-container').appendChild(menuContainer);
      
      // Style the menu
      menuContainer.style.position = 'absolute';
      menuContainer.style.top = '50%';
      menuContainer.style.left = '50%';
      menuContainer.style.transform = 'translate(-50%, -50%)';
      menuContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      menuContainer.style.padding = '20px';
      menuContainer.style.borderRadius = '10px';
      menuContainer.style.color = '#fff';
      menuContainer.style.textAlign = 'center';
      menuContainer.style.zIndex = '1000';
      menuContainer.style.border = '2px solid #00ffff';
      menuContainer.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
      menuContainer.style.minWidth = '300px';
    }
    
    // Create menu content
    menuContainer.innerHTML = `
      <h2 style="color: #00ffff; margin-top: 0;">Game Menu</h2>
      <div class="menu-options">
        <button id="resume-button" class="menu-button">Resume Game</button>
        <button id="change-ship-button" class="menu-button">Change Ship</button>
        <button id="exit-button" class="menu-button">Exit to Main Menu</button>
      </div>
    `;
    
    // Style buttons
    const buttons = menuContainer.querySelectorAll('.menu-button');
    buttons.forEach(button => {
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.padding = '10px';
      button.style.margin = '10px 0';
      button.style.backgroundColor = '#001a33';
      button.style.color = '#00ffff';
      button.style.border = '1px solid #00ffff';
      button.style.borderRadius = '5px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '16px';
      button.style.transition = 'all 0.2s';
      
      // Hover effect
      button.onmouseenter = () => {
        button.style.backgroundColor = '#00ffff';
        button.style.color = '#001a33';
      };
      button.onmouseleave = () => {
        button.style.backgroundColor = '#001a33';
        button.style.color = '#00ffff';
      };
    });
    
    // Add event listeners
    document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
    document.getElementById('change-ship-button').addEventListener('click', () => this.showShipChangeScreen());
    document.getElementById('exit-button').addEventListener('click', () => this.exitToMainMenu());
    
    // Show the menu
    menuContainer.classList.remove('hidden');
  }
  
  resumeGame() {
    console.log('Hiding menus');
    
    // Hide ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
    }
    
    // Hide menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
  }
  
  showShipChangeScreen() {
    // Hide the menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
    
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
        console.error('Game container not found');
        return;
    }
    
    // Clean up existing ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
        
        // Safely remove the element from DOM if it exists and has a parent
        if (this.shipSelection.element && this.shipSelection.element.parentNode) {
            this.shipSelection.element.parentNode.removeChild(this.shipSelection.element);
        }
        
        this.shipSelection = null;
    }
    
    // Create new ship selection instance
    this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
            this.shipSelection.hide();
            this.applyShipSelection(selection);
        }
    });
    
    // Show the ship selection UI
    this.shipSelection.show();
  }

  /**
   * Calculate proper ground offset for an object based on its type and geometry
   */
  calculateGroundOffset(model, category, scale) {
    // Get the bounding box
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Calculate the distance from the object's pivot to its bottom
    const pivotToBottom = bbox.min.y;
    
    // The base offset is the distance needed to move the object so its bottom touches the ground
    let groundOffset = -pivotToBottom;
    
    // Add category-specific adjustments with more refined values
    switch(category) {
      case 'rocks':
        // Rocks typically need to be slightly embedded in the ground
        groundOffset += size.y * 0.08;
        break;
      case 'flora':
        // Flora should be firmly planted in the ground
        groundOffset += size.y * 0.03;
        break;
      case 'groundFeatures':
        // Ground features should be partially embedded, varying by model
        if (model.name && model.name.includes('Ground02')) {
          groundOffset += size.y * 0.15; // SP_Ground02 needs more embedding
        } else if (model.name && model.name.includes('Ground05')) {
          groundOffset += size.y * 0.05; // SP_Ground05 needs less embedding
        } else {
          groundOffset += size.y * 0.1; // Default for other ground features
        }
        break;
      case 'crystals':
        // Crystals should appear to be growing from the ground
        groundOffset += size.y * 0.15;
        break;
      case 'mountains':
        // Mountains need to be firmly embedded with varying depths
        const mountainDepth = 0.08 + (Math.random() * 0.05); // Random depth between 8-13%
        groundOffset += size.y * mountainDepth;
        break;
      case 'centerpiece':
        // Centerpiece gets special treatment
        groundOffset += size.y * 0.12;
        break;
      default:
        // Default adjustment for unknown types
        groundOffset += 0;
    }
    
    // Scale the offset according to the object's scale
    // Add a small global offset to prevent z-fighting
    return (groundOffset * scale) + 0.01;
  }

  /**
   * Create a special centerpiece for the landscape
   */
  createCenterpiece() {
    // Create a special formation at a designated spot
    const centerpiece = {
      position: new THREE.Vector3(0, 0, -35), // Prominent position
      models: [
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 2.5, offset: new THREE.Vector3(0, 0, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.8, offset: new THREE.Vector3(2, 0, 1), rotation: Math.PI/4 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.6, offset: new THREE.Vector3(-1.5, 0, -1), rotation: -Math.PI/5 },
        { path: 'assets/models/objects/SP_Ground05.glb', scale: 2.0, offset: new THREE.Vector3(0, -0.5, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Stone01.glb', scale: 1.2, offset: new THREE.Vector3(2.5, 0, -1.5), rotation: Math.PI/3 }
      ]
    };
    
    // Load each model in the centerpiece
    centerpiece.models.forEach((model, index) => {
      const loader = new GLTFLoader();
      loader.load(
        model.path,
        (gltf) => {
          const object = gltf.scene;
          
          // Apply scale
          object.scale.set(model.scale, model.scale, model.scale);
          
          // Position relative to centerpiece
          object.position.copy(centerpiece.position.clone().add(model.offset));
          
          // Apply rotation
          object.rotation.y = model.rotation;
          
          // Add special glow effect for crystals
          if (model.path.includes('Crystal')) {
            object.traverse(node => {
              if (node.isMesh && node.material) {
                node.material.emissive = new THREE.Color(0xff00ff);
                node.material.emissiveIntensity = 0.5;
                
                // Add a point light for extra effect
                const light = new THREE.PointLight(0xff00ff, 2, 10);
                light.position.set(0, 2 * model.scale, 0);
                object.add(light);
              }
            });
          }
          
          // Add to scene
          this.scene.add(object);
          
          // Create collision data
          const bbox = new THREE.Box3().setFromObject(object);
          const size = bbox.getSize(new THREE.Vector3());
          
          // Use improved ground placement
          const groundY = this.calculateGroundOffset(object, 'centerpiece', model.scale);
          object.position.y = groundY + model.offset.y; // Add the intentional offset for composition
          
          // Generate compound collision shapes
          const collisionShapes = this.generateCompoundCollisionShapes(object, 'centerpiece', model.scale);
          
          // Add to obstacles
          this.obstacles.push({
            mesh: object,
            type: 'centerpiece',
            collisionShape: 'compound',
            compoundShapes: collisionShapes.map(shape => {
              // Transform shape centers to world coordinates
              const worldCenter = shape.center.clone();
              worldCenter.add(object.position);
              
              return {
                ...shape,
                center: worldCenter,
                worldRotation: object.rotation.y + (shape.rotation || 0)
              };
            }),
            boundingBox: {
              min: new THREE.Vector3(
                object.position.x - (size.x * model.scale / 2),
                object.position.y - (size.y * model.scale / 2),
                object.position.z - (size.z * model.scale / 2)
              ),
              max: new THREE.Vector3(
                object.position.x + (size.x * model.scale / 2),
                object.position.y + (size.y * model.scale / 2),
                object.position.z + (size.z * model.scale / 2)
              ),
              size: size.clone().multiplyScalar(model.scale),
              rotation: object.rotation.y
            },
            size: Math.max(size.x, size.z) * model.scale * 0.5,
            position: object.position.clone()
          });
          
          console.log(`Centerpiece: Added ${model.path.split('/').pop()} at position [${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)}]`);
        },
        undefined,
        (error) => {
          console.error(`Error loading centerpiece model ${model.path}:`, error);
        }
      );
    });
  }

  /**
   * Create a special effect when colliding with crystals
   */
  createCrystalCollisionEffect(position, isSpecial = false) {
    // Create particles for crystal collision
    const particleCount = isSpecial ? 30 : 15;
    const color = isSpecial ? 0xff00ff : 0x00ffff;
    
    for (let i = 0; i < particleCount; i++) {
      // Create a small glowing cube
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      
      // Position at collision point
      particle.position.copy(position);
      
      // Add small random offset
      particle.position.x += (Math.random() - 0.5) * 2;
      particle.position.y += Math.random() * 3;
      particle.position.z += (Math.random() - 0.5) * 2;
      
      // Add to scene
      this.scene.add(particle);
      
      // Create velocity for particle
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.2 + 0.1,
        (Math.random() - 0.5) * 0.2
      );
      
      // Animate the particle
      const startTime = Date.now();
      const duration = 1000 + Math.random() * 1000; // 1-2 seconds
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Remove particle when animation completes
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return;
        }
        
        // Update position
        particle.position.add(velocity);
        
        // Slow down over time
        velocity.multiplyScalar(0.98);
        
        // Fade out
        particle.material.opacity = 0.8 * (1 - progress);
        
        // Continue animation
        requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
    }
  }

  /**
   * Generate compound collision shapes for more accurate collision detection
   */
  generateCompoundCollisionShapes(model, category, scale) {
    // Generate a compound collision shape based on model geometry and category
    const shapes = [];
    const bbox = new THREE.Box3().setFromObject(model);
    
    // Helper function to add a box shape
    const addBoxShape = (center, size, rotation = 0) => {
      shapes.push({
        type: 'box',
        center: center.clone(),
        halfExtents: size.clone().multiplyScalar(0.5),
        rotation: rotation
      });
    };
    
    // Helper function to add a sphere shape
    const addSphereShape = (center, radius) => {
      shapes.push({
        type: 'sphere',
        center: center.clone(),
        radius: radius
      });
    };
    
    // Different collision shape strategies based on category
    switch(category) {
      case 'rocks':
        // For rocks, use 1-3 overlapping boxes based on size
        const rockSize = bbox.getSize(new THREE.Vector3());
        const rockCenter = new THREE.Vector3();
        bbox.getCenter(rockCenter);
        
        // Main box
        addBoxShape(rockCenter, rockSize);
        
        // For larger rocks, add 1-2 more boxes at slight offsets for better shape approximation
        if (rockSize.x > 1.5 * scale || rockSize.z > 1.5 * scale) {
          // Add a second box, slightly offset and rotated
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3 * rockSize.x,
            0,
            (Math.random() - 0.5) * 0.3 * rockSize.z
          );
          
          const secondSize = new THREE.Vector3(
            rockSize.x * (0.7 + Math.random() * 0.3),
            rockSize.y * 0.9,
            rockSize.z * (0.7 + Math.random() * 0.3)
          );
          
          addBoxShape(rockCenter.clone().add(offset), secondSize, Math.PI * 0.25);
          
          // For very large rocks, add a third box
          if (rockSize.x > 2.5 * scale || rockSize.z > 2.5 * scale) {
            const thirdOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4 * rockSize.x,
              rockSize.y * 0.2,
              (Math.random() - 0.5) * 0.4 * rockSize.z
            );
            
            const thirdSize = new THREE.Vector3(
              rockSize.x * (0.6 + Math.random() * 0.2),
              rockSize.y * 0.7,
              rockSize.z * (0.6 + Math.random() * 0.2)
            );
            
            addBoxShape(rockCenter.clone().add(thirdOffset), thirdSize, Math.PI * 0.125);
          }
        }
        break;
        
      case 'flora':
        // For flora, use a smaller box for the base and a sphere for the top
        const floraSize = bbox.getSize(new THREE.Vector3());
        const floraCenter = new THREE.Vector3();
        bbox.getCenter(floraCenter);
        
        // Box for the base/stem
        const stemSize = new THREE.Vector3(
          floraSize.x * 0.2,
          floraSize.y * 0.6,
          floraSize.z * 0.2
        );
        
        const stemCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (stemSize.y / 2),
          floraCenter.z
        );
        
        addBoxShape(stemCenter, stemSize);
        
        // Sphere for the top/foliage
        const foliageCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (floraSize.y * 0.7),
          floraCenter.z
        );
        
        const foliageRadius = Math.max(floraSize.x, floraSize.z) * 0.5;
        addSphereShape(foliageCenter, foliageRadius);
        break;
        
      case 'mountains':
        // For mountains, use a pyramid-like composition of boxes
        const mountainSize = bbox.getSize(new THREE.Vector3());
        const mountainCenter = new THREE.Vector3();
        bbox.getCenter(mountainCenter);
        
        // Base box (wider)
        const baseSize = new THREE.Vector3(
          mountainSize.x,
          mountainSize.y * 0.3,
          mountainSize.z
        );
        
        const baseCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + (baseSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(baseCenter, baseSize);
        
        // Middle box (narrower)
        const middleSize = new THREE.Vector3(
          mountainSize.x * 0.8,
          mountainSize.y * 0.4,
          mountainSize.z * 0.8
        );
        
        const middleCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + (middleSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(middleCenter, middleSize);
        
        // Top box (narrowest)
        const topSize = new THREE.Vector3(
          mountainSize.x * 0.5,
          mountainSize.y * 0.3,
          mountainSize.z * 0.5
        );
        
        const topCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + middleSize.y + (topSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(topCenter, topSize);
        break;
        
      case 'crystals':
        // For crystals, use a combination of boxes at different angles
        const crystalSize = bbox.getSize(new THREE.Vector3());
        const crystalCenter = new THREE.Vector3();
        bbox.getCenter(crystalCenter);
        
        // Calculate a better fitting box size (narrower)
        const mainCrystalSize = new THREE.Vector3(
          crystalSize.x * 0.7,
          crystalSize.y,
          crystalSize.z * 0.7
        );
        
        // Add the main crystal shape
        addBoxShape(crystalCenter, mainCrystalSize, model.rotation.y);
        
        // For larger crystals, add some angled shards
        if (crystalSize.y > 1.0 * scale) {
          // Add up to 3 additional shards
          const shardCount = 1 + Math.floor(Math.random() * 3);
          
          for (let i = 0; i < shardCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = crystalSize.x * 0.3;
            
            const offset = new THREE.Vector3(
              Math.cos(angle) * distance,
              crystalSize.y * (Math.random() * 0.2),
              Math.sin(angle) * distance
            );
            
            const shardSize = new THREE.Vector3(
              crystalSize.x * (0.2 + Math.random() * 0.3),
              crystalSize.y * (0.4 + Math.random() * 0.4),
              crystalSize.z * (0.2 + Math.random() * 0.3)
            );
            
            const shardRotation = Math.random() * Math.PI;
            addBoxShape(crystalCenter.clone().add(offset), shardSize, shardRotation);
          }
        }
        break;
        
      case 'groundFeatures':
        // For ground features, use a more accurate horizontal shape with the right height
        const groundSize = bbox.getSize(new THREE.Vector3());
        const groundCenter = new THREE.Vector3();
        bbox.getCenter(groundCenter);
        
        // Just use a single box but with better proportions
        const adjustedSize = new THREE.Vector3(
          groundSize.x,
          groundSize.y * 0.7, // Lower height to prevent floating
          groundSize.z
        );
        
        // Center it properly on the ground
        const adjustedCenter = new THREE.Vector3(
          groundCenter.x,
          bbox.min.y + (adjustedSize.y / 2),
          groundCenter.z
        );
        
        addBoxShape(adjustedCenter, adjustedSize, model.rotation.y);
        break;
        
      case 'centerpiece':
        // For centerpiece, create a custom multi-part shape
        const centerpieceSize = bbox.getSize(new THREE.Vector3());
        const centerpieceCenter = new THREE.Vector3();
        bbox.getCenter(centerpieceCenter);
        
        // Main box
        addBoxShape(centerpieceCenter, centerpieceSize);
        
        // Add a sphere on top for the crystal parts
        const sphereCenter = new THREE.Vector3(
          centerpieceCenter.x,
          centerpieceCenter.y + (centerpieceSize.y * 0.2),
          centerpieceCenter.z
        );
        
        const sphereRadius = Math.max(centerpieceSize.x, centerpieceSize.z) * 0.6;
        addSphereShape(sphereCenter, sphereRadius);
        break;
        
      default:
        // Default: just use a box based on the bounding box
        const size = bbox.getSize(new THREE.Vector3());
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        addBoxShape(center, size);
        break;
    }
    
    return shapes;
  }

  updateOtherPlayers() {
    if (!this.networkManager || !this.multiplayerEnabled || !this.assetLoader) return;
  
    const otherPlayers = this.networkManager.getOtherPlayers();
    if (!this.otherPlayerObjects) this.otherPlayerObjects = {};
  
    otherPlayers.forEach(playerData => {
      let playerObject = this.otherPlayerObjects[playerData.id];
  
      if (!playerObject) {
        console.log('Creating new player representation for:', playerData.id);
        const shipType = (playerData.shipType || 'STANDARD').toUpperCase();
        const shipModel = this.assetLoader.getOpponentShipModel(shipType);
  
        if (!shipModel) {
          console.warn(`No model found for ship type: ${shipType}, falling back to default`);
          // Fallback geometry if model fails
          const geometry = new THREE.ConeGeometry(0.5, 1.0, 8);
          geometry.rotateX(Math.PI / 2);
          const material = new THREE.MeshPhongMaterial({ 
            color: playerData.teamColor || 0x00ffff,
            emissive: playerData.teamColor || 0x00ffff,
            emissiveIntensity: 0.5
          });
          const ship = new THREE.Mesh(geometry, material);
          this.scene.add(ship);
          playerObject = { ship, lastUpdate: Date.now() };
        } else {
          // Scale the model consistently (matching player ship scaling)
          shipModel.scale.set(0.45, 0.45, 0.45);
          this.scene.add(shipModel);
          playerObject = { ship: shipModel, lastUpdate: Date.now() };
        }
  
        // Add engine glow
        const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
        engineGlow.position.set(0, 0, -0.7);
        playerObject.ship.add(engineGlow);
        playerObject.engineGlow = engineGlow;
  
        // Add name label
        const nameDiv = document.createElement('div');
        nameDiv.className = 'player-label';
        nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
        const nameLabel = new CSS2DObject(nameDiv);
        nameLabel.position.set(0, 1.8, 0);
        playerObject.ship.add(nameLabel);
        playerObject.nameLabel = nameLabel;
  
        this.otherPlayerObjects[playerData.id] = playerObject;
      }
  
      // Update position and rotation
      if (playerData.position) {
        playerObject.ship.position.lerp(
          new THREE.Vector3(playerData.position.x, playerData.position.y || 0.5, playerData.position.z),
          0.3
        );
      }
      if (playerData.rotation !== undefined) {
        const targetY = playerData.rotation;
        let rotDiff = targetY - playerObject.ship.rotation.y;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerObject.ship.rotation.y += rotDiff * 0.3;
      }
  
      playerObject.lastUpdate = Date.now();
    });
  
    // Clean up disconnected players
    const now = Date.now();
    Object.keys(this.otherPlayerObjects).forEach(id => {
      const playerObj = this.otherPlayerObjects[id];
      if (now - playerObj.lastUpdate > 10000) {
        console.log('Removing disconnected player:', id);
        this.scene.remove(playerObj.ship);
        delete this.otherPlayerObjects[id];
        this.updatePlayerCount();
      }
    });
  }

  // Helper method to send player position and rotation to the server
  sendPlayerPositionUpdate() {
    if (!this.playerShip || !this.networkManager || !this.networkManager.isConnected()) return;
    
    // Create a simple data object with player information
    const playerData = {
      position: {
        x: this.playerShip.position.x,
        y: this.playerShip.position.y,
        z: this.playerShip.position.z
      },
      rotation: this.playerShip.rotation.y,
      shipType: this.currentShipType || 'STANDARD',
      name: this.playerName
    };
    
    // Send the update to the network manager
    this.networkManager.sendPlayerUpdate(playerData);
  }

  // Add the missing setShipModel function
  setShipModel(type) {
    console.log('🔍 Setting ship model:', type);
    
    // Get the ship model from assets
    let model = this.assetLoader.getShipModel(type);
    
    // If model is null or undefined, create fallback model
    if (!model) {
      console.warn('⚠️ Using fallback ship model for type:', type);
      
      // Create a simple geometric shape as fallback
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, 
        specular: 0x111111, 
        shininess: 30 
      });
      model = new THREE.Mesh(geometry, material);
    }
    
    // Clear existing player ship if it exists
    if (this.playerShip) {
      if (this.scene) {
        this.scene.remove(this.playerShip);
      }
      this.playerShip = null;
    }
    
    // Set the new ship model
    this.playerShip = model;
    
    // Position the ship appropriately
    if (this.playerShip && this.scene) {
      this.playerShip.position.set(0, 0.5, 0);
      this.scene.add(this.playerShip);
    }
    
    return this.playerShip;
  }

  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.soundManager) {
      console.log(`Playing sound: ${name}`);
      this.soundManager.playSound(name, position);
    } else {
      console.warn(`Cannot play sound '${name}': SoundManager not initialized`);
    }
  }

  /**
   * Update a remote player's position and rotation
   * @param {string} id - Player ID
   * @param {Object} position - Position coordinates
   * @param {Object} rotation - Rotation coordinates
   */
  updateRemotePlayer(id, position, rotation) {
    // Get existing player or create a new one
    let player = this.remotePlayers.get(id);
    
    if (!player) {
      // Create a new player mesh if this is the first update
      player = this.createRemotePlayerMesh();
      this.remotePlayers.set(id, player);
      this.scene.add(player);
      console.log(`Created new remote player: ${id}`);
    }
    
    // Update player position and rotation
    if (position) {
      player.position.set(position.x, position.y, position.z);
    }
    
    if (rotation) {
      player.rotation.set(rotation.x, rotation.y, rotation.z);
    }
  }
  
  /**
   * Create a mesh for a remote player
   * @returns {THREE.Object3D} Player mesh
   */
  createRemotePlayerMesh() {
    // For simplicity, we'll use a simple colored box for remote players
    const geometry = new THREE.BoxGeometry(1, 1, 2);
    const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red for other players
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'player-label';
    nameLabel.textContent = 'Player';
    
    const playerLabel = new CSS2DObject(nameLabel);
    playerLabel.position.set(0, 1.5, 0);
    mesh.add(playerLabel);
    
    return mesh;
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize game
  const game = new SimpleGame();
  
  // Add start button event listener
  document.getElementById('start-button').addEventListener('click', () => {
    // Get the player name from the input field
    const playerNameInput = document.getElementById('player-name');
    if (playerNameInput && playerNameInput.value.trim() !== '') {
      // Store the player name
      game.playerName = playerNameInput.value.trim();
      console.log(`Player name set to: ${game.playerName}`);
    } else {
      console.log('Using default player name: ' + game.playerName);
    }
    
    // Start the game
    game.startGame();
  });
}); 
### ./index.js END ###

### ./codebase.md BEGIN ###
### DIRECTORY . FOLDER STRUCTURE ###
./
    index.html
    flatten.py
    index.js
    codebase.md
    ui/
        ShipSelectionUI.js
        GameRoom.js
        GameUI.js
        MiniMap.js
    scenes/
        TeamDemo.js
    core/
        Game.js
        TeamManager.js
        Scene.js
        GameEngine.js
        Engine.js
        NetworkManager.js
        InfiniteMap.js
    config/
        ShipConfig.js
        Controls.js
        GameConfig.js
    constants/
    utils/
    styles/
        main.css
        controls.css
    effects/
    assets/
        ModelLoader.js
        SoundManager.js
        .DS_Store
        AssetLoader.js
        textures/
        images/
        models/
            .DS_Store
            textures/
                tex.png
                Colors3.png
            ships/
                ALTSPACE2.glb
                ALTSPACE1.glb
            flora/
                Grass_01.glb
                .DS_Store
                SmalRoots_01.glb
                BigPlant_06.glb
                SP_Plant08.glb
                SP_Plant07.glb
                Mushrooms.glb
                SP_Tree04.glb
                SP_Tree02.glb
                SP_Tree03.glb
                SP_Tree01.glb
                Tenticles_01.glb
            objects/
                .DS_Store
                SP_Stone01.glb
                SP_Mountain03.glb
                SP_Mountain02.glb
                SP_Mountain01.glb
                SP_Ground03.glb
                SP_Ground02.glb
                SP_Ground05.glb
                SP_Ground04.glb
            terrain/
                .DS_Store
                Water.glb
                Terrain.glb
            rocks/
                SP_Rock01.glb
                SP_Rock03.glb
                SP_Rock02.glb
                SP_Rock06.glb
                .DS_Store
                SP_Rock07.glb
                SP_Rock05.glb
                SP_Rock04.glb
                SP_Rock09.glb
                SP_Rock08.glb
        sounds/
            weapon-switch.mp3
            laser.mp3
            bounce.mp3
            weapon-charging.mp3
            grenade-laser.mp3
            laser-bounce.mp3
            weapon-armor-hit.mp3
    entities/
        Ship.js
        obstacles/
        weapons/
            RegularLaser.js
            WeaponSystem.js
            Laser.js
        enemies/
            EnemyManager.js
            Enemy.js
        player/
            Player.js
### DIRECTORY . FOLDER STRUCTURE ###

### DIRECTORY . FLATTENED CONTENT ###
### ./index.html BEGIN ###
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/main.css">
    <link rel="stylesheet" href="./styles/controls.css">
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="loader"></div>
            <p>Loading the quantum realm...</p>
        </div>
    </div>
    
    <div id="start-screen" class="hidden">
        <div class="start-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="player-input">
                <input type="text" id="player-name" maxlength="15" placeholder="Enter your pilot name" />
                <p class="input-info">Your name will be visible to other players</p>
            </div>
            <button id="start-button" class="glow-button">START GAME</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>
    
    <!-- Multiplayer Info -->
    <div id="multiplayer-info" class="hidden">
        <div class="connection-indicator">
            <span>Connection: </span>
            <span id="connection-status">Disconnected</span>
        </div>
        <div class="players-indicator">
            <span>Players: </span>
            <span id="players-count">0</span>
        </div>
    </div>
    
    <!-- Simple HUD for controls info -->
    <div class="controls-info hidden">
        <p>W/↑: Forward | S/↓: Backward</p>
        <p>A/← D/→: Rotate Ship</p>
        <p>Q/E: Strafe Left/Right</p>
        <p>Space: Fire Laser</p>
        <p>Avoid the colored obstacles!</p>
    </div>
</body>
<script type="module" src="./index.js"></script>
</html> 
### ./index.html END ###

### ./flatten.py BEGIN ###
import os
import argparse

def printFolderStructure(directory, output_file):
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n")
    for root, directories, files in os.walk(directory):
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write('{}{}/\n'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            output_file.write('{}{}\n'.format(subindent, f))
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n\n")

def walkFolderTree(folder):
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            yield os.path.join(dirpath, filename)

def main():
    parser = argparse.ArgumentParser(description='Flattens a codebase.')
    parser.add_argument('--folders', nargs='*', help='Base folders to process')
    parser.add_argument('--system_instructions', action='store_true', help='Print system instructions')

    system_instructions = """## System Instructions for Language Model Assistance in Code Debugging

### Role Definition:
- **Act as a software engineer** tasked with assisting in debugging code.
- Provide insights, explanations, and solutions based on the provided codebase information.

### Codebase Markdown File Structure:
- The codebase markdown file represents the actual codebase structure and content.
- It begins with a directory tree representation:
  ```
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  (file tree representation)
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  ```
- Following the directory tree, the contents of each file are displayed:
  ```
  ### path/to/file1 BEGIN ###
  (content of file1)
  ### path/to/file1 END ###
  
  ### path/to/file2 BEGIN ###
  (content of file2)
  ### path/to/file2 END ###
  ```

### Guidelines for Interaction:
- Respond to queries based on the explicit content provided within the markdown file.
- Avoid making assumptions about the code without clear evidence presented in the file content.
- When seeking specific implementation details, refer to the corresponding section in the markdown file, for example:
  ```
  ### folder1/folder2/myfile.ts BEGIN ###
  (specific implementation details)
  ### folder1/folder2/myfile.ts END ###
  ```

### Objective:
- The primary objective is to facilitate effective debugging by providing accurate information and guidance strictly adhering to the content available in the markdown file."""

    args = parser.parse_args()

    if args.system_instructions:
        print(system_instructions)

        if not args.folders:
            return

    if args.folders:
        base_folders = args.folders
        with open('codebase.md', 'w') as output_file:
            for base_folder in base_folders:
                printFolderStructure(base_folder, output_file)
                
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
                for filepath in walkFolderTree(base_folder):
                    content = f"### {filepath} BEGIN ###\n"
                    
                    try:
                        with open(filepath, "r") as f:
                            content += f.read()
                        content += f"\n### {filepath} END ###\n\n"
                    except:
                        continue
                    
                    output_file.write(content)
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
    else:
        print("usage: main.py [-h] --folders FOLDERS [FOLDERS ...] [--system_instructions]")
        print("Error: the following arguments are required: --folders")

if __name__ == "__main__":
    main()
### ./flatten.py END ###

### ./index.js BEGIN ###
import * as THREE from 'three';
import { OrbitControls } from '@three/examples/controls/OrbitControls';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import './styles/main.css';
import { GameUI } from './ui/GameUI';
import { MiniMap } from './ui/MiniMap';
import { CONTROL_SETTINGS, CONTROL_FEEDBACK, DEFAULT_CONTROL_STATE, ControlUtils } from './config/Controls';
import { ShipSelectionUI } from './ui/ShipSelectionUI';
import AssetLoader from './assets/AssetLoader';
import { InfiniteMap } from './core/InfiniteMap';
import { NetworkManager } from './core/NetworkManager';
import { CSS2DRenderer, CSS2DObject } from '@three/examples/renderers/CSS2DRenderer';
import { GAME_CONFIG } from './config/GameConfig';
import { Player } from './entities/player/Player';
import { SoundManager } from './assets/SoundManager';

// Basic Three.js game with a ship
class SimpleGame {
  constructor() {
    // Initialize all properties first
    // Player information
    this.playerName = 'Pilot';  // Default player name
    
    // Create the asset loader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => this.updateLoadingUI(message),
      (type, error) => this.handleLoadError(type, error)
    );
    
    // Initialize SoundManager
    this.soundManager = new SoundManager();
    
    // Asset loading state
    this.loadingState = {
      started: false,
      completed: false,
      errors: []
    };
    
    // Track assets loading
    this.assetsLoaded = false;
    this.shipModelLoaded = false;
    
    // Initialize control state
    this.keys = { ...DEFAULT_CONTROL_STATE };
    
    // Setup animation timing
    this.clock = new THREE.Clock();
    this.lastTime = Date.now();
    
    // Event handling - bind methods
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    
    // Debounce timers
    this.mouseMoveTimer = null;
    this.resizeTimer = null;
    this.weaponCooldowns = new Map();
    this.lastWeaponSwitch = 0;

    // Setup basic Three.js scene
    this.setupScene();
    
    // Create game UI
    this.ui = new GameUI();
    
    // Create player after scene setup (as specified in Task 8)
    this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
      type: 'PLAYER',
      shipModel: 'STANDARD',
      teamColor: 0x00ffff
    });
    this.scene.add(this.player.mesh);
    
    // For backward compatibility with existing code
    this.playerShip = this.player.mesh;
    
    // Game properties
    this.boundarySize = 100; // Size of the playable area
    
    // Initialize player state
    this.health = 100;
    this.maxHealth = 100;
    this.energy = 100;
    this.maxEnergy = 100;
    this.energyRechargeRate = 20; // Units per second
    this.currentWeapon = 'LASER';
    
    // Initialize available weapons
    this.availableWeapons = ['LASER', 'GRENADE', 'BOUNCE'];
    this.weaponIndex = 0; // Start with LASER
    
    // Load assets
    this.loadAssets();
    
    // Setup controls
    this.setupControls();
    
    // Initialize infinite map after scene setup
    this.infiniteMap = new InfiniteMap(this);
    
    // Create mini-map (after scene setup) but keep it hidden initially
    this.miniMap = new MiniMap(this);
    this.miniMap.hide(); // Make sure it starts hidden
    
    // Handle window resize
    window.addEventListener('resize', this.boundHandleResize);
    
    console.log('Simple game initialized!');

    // Add frame counter
    this.frameCount = 0;
    
    // Initialize NetworkManager
    this.networkManager = new NetworkManager();
    
    // Initialize remotePlayers map for multiplayer
    this.remotePlayers = new Map();
    
    this.networkManager.on('connected', () => {
      console.log('Connected to game server!');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from game server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      // Update player count
      this.updatePlayerCount();
    });
    
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      // Remove player mesh if it exists
      const player = this.remotePlayers.get(id);
      if (player) {
        this.scene.remove(player);
        this.remotePlayers.delete(id);
        console.log(`Removed remote player: ${id}`);
      }
      // Update player count
      this.updatePlayerCount();
    });
    
    // Add player update handling
    this.networkManager.on('player_update', (data) => {
      this.updateRemotePlayer(data.id, data.position, data.rotation);
    });
    
    // Add laser shot handling
    this.networkManager.on('laser_shot', (shotData) => {
      console.log('Received laser shot from network:', shotData);
      const position = new THREE.Vector3(shotData.origin.x, shotData.origin.y, shotData.origin.z);
      const direction = new THREE.Vector3(shotData.direction.x, shotData.direction.y, shotData.direction.z);

      if (shotData.type === 'bounce') {
        this.fireBouncingLaser(position, direction);
      } else {
        this.fireLaser(position, direction);
      }
    });
    
    // Add helper method to update player count
    this.updatePlayerCount = () => {
      const count = this.networkManager.getOtherPlayers().length + 1; // +1 for self
      document.getElementById('players-count').textContent = count;
    };
    
    this.multiplayerEnabled = false;
  }
  
  setupScene() {
    // Create Three.js Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a1f); // Dark blue background
    
    // Setup WebGL renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(this.renderer.domElement);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near
      1000 // Far
    );
    
    // Position camera
    this.camera.position.set(0, 7, 15); // Slightly above and behind player
    this.camera.lookAt(0, 0, 0);
    
    // Attach audio listener to camera
    if (this.soundManager) {
      this.camera.add(this.soundManager.getListener());
      console.log('Audio listener attached to camera');
    }
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);
    
    // Create a simple grid floor
    this.createFloor();
    
    // Create some obstacles
    this.createObstacles();
  }
  
  async loadAssets() {
    if (this.loadingState.started) {
        console.warn('🔍 Asset loading already in progress');
        return;
    }
    
    this.updateLoadingUI('Loading game assets...');
    
    try {
        // Create initial player with default ship
        if (!this.player) {
            this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
                type: 'PLAYER',
                shipModel: 'STANDARD',
                teamColor: 0x00ffff
            });
            this.playerShip = this.player.mesh; // For backward compatibility
        }
        
        // Load all assets through AssetLoader
        await this.assetLoader.loadAll();
        this.assetsLoaded = true;
        this.shipModelLoaded = true;
        
        console.log('✅ All assets loaded successfully');
        this.checkLoadingProgress();
    } catch (error) {
        console.error('🔍 Critical error loading assets:', error);
        this.handleLoadError('critical', error);
    }
  }
  
  handleLoadError(assetType, error) {
    console.error(`Error loading ${assetType}:`, error);
    this.loadingState.errors.push({ type: assetType, error: error.message });
    
    // Update UI with error
    this.updateLoadingUI(`Error loading ${assetType}. ${this.loadingState.errors.length} errors total.`);
    
    // If critical error, show error screen
    if (assetType === 'critical') {
      this.showErrorScreen('Failed to load game assets. Please refresh the page.');
    }
  }
  
  updateLoadingUI(message) {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const messageElement = loadingScreen.querySelector('.loading-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  }
  
  showErrorScreen(message) {
    // Create error screen if it doesn't exist
    let errorScreen = document.getElementById('error-screen');
    if (!errorScreen) {
      errorScreen = document.createElement('div');
      errorScreen.id = 'error-screen';
      errorScreen.className = 'error-screen';
      
      const errorMessage = document.createElement('div');
      errorMessage.className = 'error-message';
      errorScreen.appendChild(errorMessage);
      
      const retryButton = document.createElement('button');
      retryButton.textContent = 'Retry';
      retryButton.onclick = () => {
        errorScreen.remove();
        this.loadingState = {
          started: false,
          completed: false,
          errors: []
        };
        this.loadAssets();
      };
      errorScreen.appendChild(retryButton);
      
      document.body.appendChild(errorScreen);
    }
    
    // Update error message
    const messageElement = errorScreen.querySelector('.error-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
  }
  
  checkLoadingProgress() {
    console.log('🔍 Checking loading progress...');
    
    // Log loading state
    console.log('Loading state:', JSON.stringify(this.loadingState, null, 2));
    
    // Define what's required for a fully loaded game
    const requiredAssets = {
      shipModel: this.shipModelLoaded,
      assetsLoaded: this.assetLoader.loadingState.completed
    };
    
    // Check if all required assets are loaded
    const allAssetsLoaded = Object.entries(requiredAssets).every(([key, loaded]) => {
      console.log(`🔍 ${key}: ${loaded ? '✅' : '❌'}`);
      return loaded;
    });
    
    if (allAssetsLoaded) {
      console.log('✅ All required assets loaded!');
      this.loadingState.completed = true;
      this.showStartScreen();
    } else {
      // Log which assets are still pending
      const pendingAssets = Object.entries(requiredAssets)
        .filter(([_, loaded]) => !loaded)
        .map(([key]) => key);
      console.log('⏳ Still waiting for:', pendingAssets);
      
      // Update loading UI
      this.updateLoadingUI(`Loading... (${pendingAssets.join(', ')})`);
      
      // Check again after a delay
      setTimeout(() => this.checkLoadingProgress(), 1000);
    }
  }
  
  showStartScreen() {
    console.log('🔍 Attempting to show start screen');
    
    // Timeout to ensure UI has time to update
    setTimeout(() => {
      // Hide loading screen and show start screen
      const loadingScreen = document.getElementById('loading-screen');
      const startScreen = document.getElementById('start-screen');
      
      console.log('🔍 Loading screen element:', loadingScreen);
      console.log('🔍 Start screen element:', startScreen);
      
      if (loadingScreen) {
        console.log('🔍 Adding fade-out class to loading screen');
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          loadingScreen.classList.add('hidden');
          loadingScreen.classList.remove('fade-out');
          console.log('🔍 Loading screen hidden');
        }, 500);
      } else {
        console.error('🔍 Loading screen element not found!');
      }
      
      if (startScreen) {
        console.log('🔍 Showing start screen');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('fade-in');
      } else {
        console.error('🔍 Start screen element not found!');
      }
      
      console.log('🔍 Game ready to start!');
    }, 500);
  }
  
  addThrusterGlow() {
    // Check if player and player mesh exist
    if (!this.player || !this.player.mesh) {
      console.warn('Cannot add thruster glow: Player or player mesh is not initialized');
      return;
    }
    
    // Create a single, efficient thruster glow effect
    // Use instanced mesh for better performance if you have multiple thrusters
    
    // Create a glow for the thruster
    const thrusterGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 12);
    const thrusterMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending // Use additive blending for better glow effect
    });
    
    const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
    thruster.position.set(0, 0, -0.7); // Position at the back of the ship
    thruster.rotation.x = Math.PI / 2;
    thruster.name = 'thruster'; // Name it for easier reference later
    
    // Add thruster to player mesh
    this.player.mesh.add(thruster);
    
    // Add point light for the thruster
    const thrusterLight = new THREE.PointLight(0x00ffff, 1, 3);
    thrusterLight.position.copy(thruster.position);
    thrusterLight.name = 'thrusterLight';
    
    // Store references for animation
    this.thruster = thruster;
    this.thrusterLight = thrusterLight;
    
    // Create a subtle, animated glow effect with proper initialization
    this.thrusterPulse = { 
      value: 0,
      phase: 0 
    };
    
    // Add to ship model
    if (this.shipModel) {
      this.shipModel.add(thruster);
      this.shipModel.add(thrusterLight);
    }
  }
  
  createFloor() {
    console.log('Creating floor with Terrain.glb model');
    
    // Create a placeholder floor initially - this will be visible until the model loads
    const tempFloorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);
    const tempFloorMaterial = new THREE.MeshBasicMaterial({
      color: 0x000022,
      transparent: true,
      opacity: 0.2,
    });
    
    this.floor = new THREE.Mesh(tempFloorGeometry, tempFloorMaterial);
    this.floor.rotation.x = -Math.PI / 2;
    this.floor.position.y = -0.01;
    this.scene.add(this.floor);
    
    // Also create an invisible raycasting plane that will always work for targeting
    // This ensures mouse input works consistently regardless of the visual floor model
    this.raycastFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        transparent: true, 
        opacity: 0.05, // Very slight visibility for debugging
        side: THREE.DoubleSide
      })
    );
    this.raycastFloor.rotation.x = -Math.PI / 2;
    this.raycastFloor.position.y = 0.1; // Position higher above terrain
    this.scene.add(this.raycastFloor);
    
    // Add debug logging
    console.log('Raycast floor created at height:', this.raycastFloor.position.y, 'and size:', 1000);
    
    // Load texture first
    const textureLoader = new THREE.TextureLoader();
    const texturePromise = new Promise((resolve, reject) => {
      textureLoader.load(
        'assets/models/textures/Colors3.png', 
        texture => {
          console.log('Terrain texture (Colors3.png) loaded successfully');
          // Configure texture 
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(8, 8); // Repeat the texture more times for better detail
          resolve(texture);
        },
        undefined,
        error => {
          console.error('Error loading Colors3.png texture:', error);
          // Try fallback texture
          textureLoader.load(
            'assets/models/textures/tex.png', 
            fallbackTexture => {
              console.log('Fallback texture loaded');
              fallbackTexture.wrapS = THREE.RepeatWrapping;
              fallbackTexture.wrapT = THREE.RepeatWrapping;
              fallbackTexture.repeat.set(5, 5);
              resolve(fallbackTexture);
            },
            undefined,
            fallbackError => {
              console.error('Error loading fallback texture:', fallbackError);
              resolve(null); // Resolve with null to continue without texture
            }
          );
        }
      );
    });
    
    // When texture is loaded (or failed), get the terrain model from AssetLoader
    texturePromise.then(texture => {
      // Get terrain model from AssetLoader
      const terrain = this.assetLoader.getModel('terrain/Terrain.glb');
      
      if (terrain) {
        console.log('Using terrain model from AssetLoader');
        
        // Remove the temporary floor
        if (this.floor) {
          this.scene.remove(this.floor);
          this.floor.geometry.dispose();
          this.floor.material.dispose();
        }
        
        // Clone the model to avoid modifying the original
        const terrainClone = terrain.clone();
        
        // Scale the terrain appropriately
        const terrainScale = 100; // Adjust this value to change the overall size
        terrainClone.scale.set(terrainScale, terrainScale * 0.5, terrainScale);
        
        // Position terrain at center and slightly below zero to avoid z-fighting
        terrainClone.position.set(0, -0.2, 0);
        
        // Apply texture if available
        if (texture) {
          terrainClone.traverse((node) => {
            if (node.isMesh) {
              node.material = node.material.clone(); // Clone material to avoid affecting other instances
              node.material.map = texture;
              node.material.needsUpdate = true;
              
              // Enable shadows
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
        }
        
        // Add to scene
        this.scene.add(terrainClone);
        this.terrain = terrainClone;
        
        console.log('Terrain model added to scene');
        
        // Add a circular highlight around the player's position
        this.createPlayerHighlight();
      } else {
        console.warn('Terrain model not found in AssetLoader, using fallback grid');
        
        // Create a grid as fallback
        const grid = new THREE.GridHelper(100, 100, 0x0000ff, 0x000044);
        grid.position.y = 0;
        this.scene.add(grid);
        this.terrain = grid;
        
        // Add player highlight anyway
        this.createPlayerHighlight();
      }
    });
  }

  // Separate method for player highlight to avoid code duplication
  createPlayerHighlight() {
    // Add a circular highlight around the player's position
    const highlightGeometry = new THREE.CircleGeometry(5, 32);
    const highlightMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
    });
    
    this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    this.playerHighlight.rotation.x = -Math.PI / 2;
    this.playerHighlight.position.y = 0.02; // Slightly above the floor
    this.scene.add(this.playerHighlight);
  }
  
  createBoundaryMarkers() {
    const boundarySize = 25; // Should match constrainToBounds boundary
    const markerSize = 1;
    const markerHeight = 1;
    const numMarkers = 10; // Number of markers per side
    
    const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
    const markerMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0x600000,
      transparent: true,
      opacity: 0.7
    });
    
    const markers = new THREE.Group();
    
    // Create boundary markers along the perimeter
    for (let i = 0; i < numMarkers; i++) {
      const t = (i / (numMarkers - 1)) * 2 - 1; // -1 to 1
      const position = boundarySize * t;
      
      // North edge
      const northMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      northMarker.position.set(position, markerHeight / 2, -boundarySize);
      markers.add(northMarker);
      
      // South edge
      const southMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      southMarker.position.set(position, markerHeight / 2, boundarySize);
      markers.add(southMarker);
      
      // East edge
      const eastMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      eastMarker.position.set(boundarySize, markerHeight / 2, position);
      markers.add(eastMarker);
      
      // West edge
      const westMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      westMarker.position.set(-boundarySize, markerHeight / 2, position);
      markers.add(westMarker);
    }
    
    this.scene.add(markers);
  }
  
  createObstacles() {
    // Create obstacle arrays
    this.obstacles = [];
    
    console.log('🚧 Creating immersive landscape with pathways and scattered crystals');
    
    // Define model categories and paths, with a focus on variety and character
    const obstacleCategories = {
      // Small to medium rocks
      rocks: [
        'SP_Rock01.glb', 
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      // Expanded flora selection
      flora: [
        'Grass_01.glb',
        'Mushrooms.glb',
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SmalRoots_01.glb',
        'Tenticles_01.glb',
        'BigPlant_06.glb'
      ],
      // Expanded ground features for creating pathways
      groundFeatures: [
        'objects/SP_Ground02.glb',
        'objects/SP_Ground03.glb',
        'objects/SP_Ground04.glb',
        'objects/SP_Ground05.glb'
      ],
      // Crystal clusters for interest points
      crystals: [
        'objects/SP_Crystal01.glb',
        'objects/SP_Stone01.glb'
      ],
      // Mountains for landscape borders and key landmarks
      mountains: [
        'objects/SP_Mountain01.glb',
        'objects/SP_Mountain02.glb',
        'objects/SP_Mountain03.glb'
      ]
    };
    
    // Enhanced distribution for a more detailed landscape
    const distribution = {
      rocks: 8,
      flora: 10,
      groundFeatures: 18,  // Increased from 12 to 18
      crystals: 9,
      mountains: 12  // Increased from 4 to 12
    };
    
    // Define some pre-made templates for object groupings
    const templates = [
      // Rock garden template
      {
        position: new THREE.Vector3(25, 0, 15),
        rotation: Math.PI / 6,
        elements: [
          { category: 'rocks', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 2.0, rotation: 0 },
          { category: 'rocks', modelIndex: 2, offset: new THREE.Vector3(3, 0, 1), scale: 1.3, rotation: Math.PI/3 },
          { category: 'rocks', modelIndex: 1, offset: new THREE.Vector3(-2, 0, 2), scale: 1.5, rotation: Math.PI/5 },
          { category: 'flora', modelIndex: 1, offset: new THREE.Vector3(2, 0, 3), scale: 1.2, rotation: 0 }
        ]
      },
      // Flora cluster template
      {
        position: new THREE.Vector3(-20, 0, -18),
        rotation: Math.PI / 4,
        elements: [
          { category: 'flora', modelIndex: 4, offset: new THREE.Vector3(0, 0, 0), scale: 1.8, rotation: 0 },
          { category: 'flora', modelIndex: 0, offset: new THREE.Vector3(2, 0, 2), scale: 1.4, rotation: Math.PI/2 },
          { category: 'flora', modelIndex: 3, offset: new THREE.Vector3(-1.5, 0, 1), scale: 1.2, rotation: Math.PI/6 },
          { category: 'rocks', modelIndex: 3, offset: new THREE.Vector3(1, 0, -2), scale: 1.0, rotation: 0 }
        ]
      },
      // Crystal formation template
      {
        position: new THREE.Vector3(-15, 0, 30),
        rotation: -Math.PI / 3,
        elements: [
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 1.5, rotation: 0 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(1.5, 0, 1), scale: 1.0, rotation: Math.PI/2 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(-1, 0, 1.5), scale: 0.8, rotation: Math.PI/4 },
          { category: 'groundFeatures', modelIndex: 2, offset: new THREE.Vector3(0, -0.2, 0), scale: 1.8, rotation: 0 }
        ]
      }
    ];
    
    // Create main pathways (4 paths coming from center, like a cross)
    const pathways = [
      { direction: new THREE.Vector3(1, 0, 0), width: 5 },   // East
      { direction: new THREE.Vector3(-1, 0, 0), width: 5 },  // West
      { direction: new THREE.Vector3(0, 0, 1), width: 5 },   // North
      { direction: new THREE.Vector3(0, 0, -1), width: 5 }   // South
    ];
    
    // Add some curved pathways to make it more interesting
    pathways.push(
      { 
        direction: new THREE.Vector3(0.7, 0, 0.7), 
        width: 4,
        curve: 0.8 // Will curve around
      },
      { 
        direction: new THREE.Vector3(-0.7, 0, -0.7), 
        width: 4,
        curve: -0.5 // Will curve the other way
      }
    );
    
    // Create some crystal gardens (clusters of crystals)
    const crystalGardens = [
      { x: 30, z: 30, radius: 8, count: 4 },
      { x: -25, z: 20, radius: 6, count: 3 },
      { x: 15, z: -35, radius: 10, count: 5 }
    ];
    
    // Function to check if a position is near a pathway
    const isNearPathway = (x, z, pathWidth) => {
      for (const path of pathways) {
        // Create a vector from center to this position
        const posVector = new THREE.Vector3(x, 0, z);
        const length = posVector.length();
        
        // Normalize the vector to compare direction
        if (length > 0) posVector.divideScalar(length);
        
        // Check if this aligns with any pathway
        const dot = posVector.dot(path.direction);
        
        // If aligned with path direction and not too close to center
        if (dot > 0.7 && length > 15 && length < 40) {
          // Calculate perpendicular distance to path
          const perpFactor = Math.sqrt(1 - dot * dot) * length;
          if (perpFactor < (path.width || pathWidth)) {
            return true;
          }
          
          // For curved paths
          if (path.curve) {
            // Check if in a curved region
            if (length > 20) {
              // Apply curvature - this is simplified but creates a nice effect
              const curveFactor = (length - 20) * path.curve * 0.1;
              const curvePerp = Math.abs(perpFactor - curveFactor);
              if (curvePerp < (path.width || pathWidth)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    
    // Function to check if position is in a crystal garden
    const isInCrystalGarden = (x, z) => {
      for (const garden of crystalGardens) {
        const dx = x - garden.x;
        const dz = z - garden.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance < garden.radius) {
          return garden;
        }
      }
      return null;
    };
    
    // Load and place models as obstacles
    for (const [category, models] of Object.entries(obstacleCategories)) {
      const count = distribution[category];
      
      for (let i = 0; i < count; i++) {
        // Select a random model from this category
        const modelPath = models[Math.floor(Math.random() * models.length)];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Create position based on category
        let x, z;
        let attempts = 0;
        let isValid = false;
        let inGarden = null;
        
        while (!isValid && attempts < 30) {
          attempts++;
          
          if (category === 'groundFeatures') {
            // Ground features go along pathways or in open areas
            if (Math.random() < 0.7) {
              // 70% along pathways
              const angle = Math.random() * Math.PI * 2;
              const distance = 15 + Math.random() * 25; // Between 15-40 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
              
              // If not near a pathway, try again
              if (!isNearPathway(x, z, 6)) continue;
            } else {
              // 30% randomly placed
              x = (Math.random() * 80) - 40;
              z = (Math.random() * 80) - 40;
            }
          } else if (category === 'crystals') {
            // Try to place in crystal gardens
            if (Math.random() < 0.7) {
              // 70% in crystal gardens
              const garden = crystalGardens[Math.floor(Math.random() * crystalGardens.length)];
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * garden.radius;
              x = garden.x + Math.cos(angle) * distance;
              z = garden.z + Math.sin(angle) * distance;
              inGarden = garden;
            } else {
              // 30% scattered elsewhere, avoiding pathways
              x = (Math.random() * 70) - 35;
              z = (Math.random() * 70) - 35;
              
              // If near a pathway, try again
              if (isNearPathway(x, z, 6)) continue;
            }
          } else if (category === 'mountains') {
            // Mountains go on the periphery with more diverse placement
            if (i < 4) {
              // Place 4 mountains at the far corners of the map
              const angle = (Math.PI/4) + (i * Math.PI/2); // Place at 45°, 135°, 225°, 315°
              const distance = 40 + Math.random() * 5; // Between 40-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else if (i < 8) {
              // Place 4 mountains at cardinal directions, but further out
              const angle = (i - 4) * Math.PI/2; // Place at 0°, 90°, 180°, 270°
              const distance = 42 + Math.random() * 8; // Between 42-50 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else {
              // Place remaining mountains randomly but still on periphery
              const angle = Math.random() * Math.PI * 2;
              const distance = 35 + Math.random() * 10; // Between 35-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            }
            
            // If near a pathway, try again (want mountains to border but not block paths)
            if (isNearPathway(x, z, 8)) continue;
          } else {
            // Rocks and flora go anywhere but not on paths
            x = (Math.random() * 80) - 40;
            z = (Math.random() * 80) - 40;
            
            // Avoid pathways for these obstacles
            if (isNearPathway(x, z, 5)) continue;
          }
          
          // Keep all objects away from center spawn
          if (Math.sqrt(x * x + z * z) < 15) continue;
          
          // Position is valid
          isValid = true;
        }
        
        if (!isValid) continue; // Skip if couldn't find valid position
        
        // Scale factors tailored by category and context
        let scale;
        if (category === 'rocks') {
          scale = 1.5 + Math.random() * 1.0; // Larger rocks (1.5-2.5)
        } else if (category === 'flora') {
          scale = 1.2 + Math.random() * 0.8; // Taller flora (1.2-2.0)
        } else if (category === 'groundFeatures') {
          if (isNearPathway(x, z, 6)) {
            // Ground features along pathways have more consistent size
            scale = 1.2 + Math.random() * 0.6; // Medium-sized ground (1.2-1.8)
          } else {
            // Ground features away from pathways can vary more
            scale = 0.8 + Math.random() * 1.4; // Variable ground features (0.8-2.2)
          }
        } else if (category === 'crystals') {
          if (inGarden) {
            // Varied crystal sizes in gardens
            scale = 0.5 + Math.random() * 1.4; // Variety of sizes (0.5-1.9)
          } else {
            // Scattered crystals are smaller
            scale = 0.7 + Math.random() * 0.6; // Smaller scattered (0.7-1.3)
          }
        } else if (category === 'mountains') {
          // More diverse mountain scales based on position
          if (i < 4) {
            // Corner mountains are largest
            scale = 2.2 + Math.random() * 1.3; // Largest mountains (2.2-3.5)
          } else if (i < 8) {
            // Cardinal direction mountains are medium-large
            scale = 1.8 + Math.random() * 1.0; // Medium-large mountains (1.8-2.8)
          } else {
            // Random mountains have varied sizes
            scale = 1.4 + Math.random() * 1.6; // Variable mountains (1.4-3.0)
          }
        }
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale and position
            model.scale.set(scale, scale, scale);
            model.position.set(x, 0, z); // Will adjust y based on model size
            
            // Add randomized rotation, except for ground features on pathways
            if (category === 'groundFeatures' && isNearPathway(x, z, 6)) {
              // Align with nearest pathway for ground features
              const alignAngle = Math.atan2(z, x);
              model.rotation.y = alignAngle + (Math.random() * 0.5 - 0.25); // Slight variation
            } else {
              model.rotation.y = Math.random() * Math.PI * 2;
            }
            
            // Enable shadows with optimization
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Optimize materials while keeping visual quality
                if (node.material) {
                  // Add category-specific visual enhancements
                  if (category === 'crystals' && modelPath.includes('Crystal')) {
                    // Make crystals glow with random colors
                    const crystalColors = [
                      new THREE.Color(0x00ffff), // cyan
                      new THREE.Color(0xff00ff), // magenta
                      new THREE.Color(0x88bbff), // light blue
                      new THREE.Color(0xffaa00)  // orange
                    ];
                    
                    // Random crystal color
                    const crystalColor = crystalColors[Math.floor(Math.random() * crystalColors.length)];
                    node.material.emissive = crystalColor;
                    node.material.emissiveIntensity = 0.3 + Math.random() * 0.3; // 0.3-0.6
                  } else if (category === 'mountains') {
                    // Give mountains a slight purple/blue tint
                    node.material.color = new THREE.Color(0x9090b0);
                  } else if (category === 'groundFeatures') {
                    // Give ground features varied earthy tones
                    const groundColors = [
                      new THREE.Color(0x908070), // tan
                      new THREE.Color(0x807060), // brown
                      new THREE.Color(0x708060), // olive
                      new THREE.Color(0x606070)  // slate
                    ];
                    node.material.color = groundColors[Math.floor(Math.random() * groundColors.length)];
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // IMPROVED COLLISION DETECTION: Use oriented bounding box for more accurate collisions
            // First, compute an accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use the improved ground placement calculation
            const groundY = this.calculateGroundOffset(model, category, scale);
            model.position.y = groundY;
            
            // Generate compound collision shapes for more accurate collision detection
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, scale);
            
            // Create better collision data with compound shapes
            const obstacleData = {
              mesh: model,
              type: category,
              // Advanced collision data
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              // Keep bounding box for broad-phase checks
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * scale / 2),
                  model.position.y - (size.y * scale / 2),
                  model.position.z - (size.z * scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * scale / 2),
                  model.position.y + (size.y * scale / 2),
                  model.position.z + (size.z * scale / 2)
                ),
                size: size.clone().multiplyScalar(scale),
                rotation: model.rotation.y
              },
              // Also keep a simple radius for quick distance checks
              size: Math.max(size.x, size.z) * scale * 0.5,
              position: model.position.clone()
            };
            
            this.obstacles.push(obstacleData);
            
            // Log first few obstacles for debugging
            if (this.obstacles.length <= 3) {
              console.log(`Created ${category} obstacle from ${modelPath}: width=${size.x * scale}, height=${size.y * scale}, depth=${size.z * scale} at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
            }
          },
          undefined, // Progress callback
          (error) => {
            console.error(`Error loading obstacle model ${fullPath}:`, error);
          }
        );
      }
    }
    
    // Create a special centerpiece crystal formation
    this.createCenterpiece();
    
    // Create template-based object groupings for more cohesive landscape
    this.createTemplateGroupings(templates, obstacleCategories);
    
    console.log(`Started loading ${Object.values(distribution).reduce((a, b) => a + b, 0)} obstacles with pathways and crystal gardens`);
  }
  
  /**
   * Create template-based object groupings
   */
  createTemplateGroupings(templates, categoryModels) {
    console.log('Creating template-based object groupings');
    
    templates.forEach((template, templateIndex) => {
      const templatePosition = template.position;
      const templateRotation = template.rotation;
      
      // Process each element in the template
      template.elements.forEach(element => {
        const category = element.category;
        
        // Get the model list for this category
        const models = categoryModels[category];
        if (!models || models.length === 0) return;
        
        // Select model by index or randomly if index is out of bounds
        const modelIndex = element.modelIndex < models.length ? element.modelIndex : Math.floor(Math.random() * models.length);
        const modelPath = models[modelIndex];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Calculate final position with rotation applied to offset
        const offset = element.offset.clone();
        
        // Apply template rotation to the offset
        if (templateRotation) {
          // Create rotation matrix
          const rotMatrix = new THREE.Matrix4().makeRotationY(templateRotation);
          offset.applyMatrix4(rotMatrix);
        }
        
        // Final position combines template position and rotated offset
        const finalPosition = new THREE.Vector3(
          templatePosition.x + offset.x,
          templatePosition.y + offset.y,
          templatePosition.z + offset.z
        );
        
        // Final rotation combines template rotation and element rotation
        const finalRotation = templateRotation + element.rotation;
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale
            model.scale.set(element.scale, element.scale, element.scale);
            
            // Set initial position 
            model.position.copy(finalPosition);
            
            // Apply rotation
            model.rotation.y = finalRotation;
            
            // Enable shadows with appropriate material enhancements
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Apply category-specific visual effects
                if (node.material) {
                  if (category === 'crystals') {
                    // Crystal glow effect
                    node.material.emissive = new THREE.Color(0x88bbff);
                    node.material.emissiveIntensity = 0.3;
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // Compute accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use improved ground placement
            const groundY = this.calculateGroundOffset(model, category, element.scale);
            model.position.y = groundY + element.offset.y; // Apply any intentional Y offset
            
            // Generate compound collision shapes
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, element.scale);
            
            // Add to obstacles array with collision data
            this.obstacles.push({
              mesh: model,
              type: category,
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * element.scale / 2),
                  model.position.y - (size.y * element.scale / 2),
                  model.position.z - (size.z * element.scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * element.scale / 2),
                  model.position.y + (size.y * element.scale / 2),
                  model.position.z + (size.z * element.scale / 2)
                ),
                size: size.clone().multiplyScalar(element.scale),
                rotation: model.rotation.y
              },
              size: Math.max(size.x, size.z) * element.scale * 0.5,
              position: model.position.clone()
            });
            
            console.log(`Template ${templateIndex+1}: Added ${category} model at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
          },
          undefined,
          (error) => {
            console.error(`Error loading template model ${fullPath}:`, error);
          }
        );
      });
    });
  }
  
  setupControls() {
    // Store active keys for visual feedback
    this.activeKeys = new Set();
    
    // Add visual indicators for controls
    this.createControlIndicators();
    
    // Detect if we're on a touch device
    this.isTouchDevice = 'ontouchstart' in window;
    
    // Keyboard controls
    document.addEventListener('keydown', this.boundHandleKeyDown);
    document.addEventListener('keyup', this.boundHandleKeyUp);
    
    // Mouse controls - attach to the canvas for better precision
    const canvas = this.renderer.domElement;
    canvas.addEventListener('click', this.boundHandleClick);
    canvas.addEventListener('mousemove', this.boundHandleMouseMove);
    
    // Setup touch controls for mobile devices
    if (this.isTouchDevice) {
      this.setupTouchControls();
    }
  }
  
  createControlIndicators() {
    console.log('Creating control indicators');
    // Create container if it doesn't exist
    if (!this.controlsContainer) {
        this.controlsContainer = document.createElement('div');
        this.controlsContainer.id = 'controls';
        this.controlsContainer.className = 'control-indicators';
        document.body.appendChild(this.controlsContainer);
        console.log('Control container created');
    }

    // Clear existing indicators
    this.controlsContainer.innerHTML = '';
    
    // Create the movement controls grid
    const movementControls = document.createElement('div');
    movementControls.className = 'movement-controls control-group';
    
    // Create the weapon controls section
    const weaponControls = document.createElement('div');
    weaponControls.className = 'weapon-controls control-group';
    
    // Define the key indicators for movement
    const movementKeys = [
        { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward', gridArea: 'forward' },
        { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward', gridArea: 'backward' },
        { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left', gridArea: 'left' },
        { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right', gridArea: 'right' },
        { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left', gridArea: 'strafeLeft' },
        { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right', gridArea: 'strafeRight' },
        { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon', gridArea: 'fire' }
    ];
    
    // Define the key indicators for weapons
    const weaponKeys = [
        { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser', className: 'weapon-key' },
        { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade', className: 'weapon-key' },
        { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser', className: 'weapon-key' },
        { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon', className: 'weapon-key' }
    ];
    
    // Create movement indicators
    movementKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        movementControls.appendChild(indicator);
    });
    
    // Create weapon indicators
    weaponKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        weaponControls.appendChild(indicator);
    });
    
    // Add a controls hint
    const hint = document.createElement('div');
    hint.className = 'controls-hint';
    hint.textContent = 'Press C to toggle controls visibility';
    
    // Add all elements to controls container
    this.controlsContainer.appendChild(movementControls);
    this.controlsContainer.appendChild(weaponControls);
    this.controlsContainer.appendChild(hint);
    
    console.log('Control indicators created with updated structure');
  }
  
  updateControlIndicators() {
    // Skip if control indicators aren't created yet
    if (!this.controlsContainer) return;
    
    // Update movement keys
    this.updateIndicatorState('forward', this.keys.forward);
    this.updateIndicatorState('backward', this.keys.backward);
    this.updateIndicatorState('left', this.keys.left);
    this.updateIndicatorState('right', this.keys.right);
    this.updateIndicatorState('strafeLeft', this.keys.strafeLeft);
    this.updateIndicatorState('strafeRight', this.keys.strafeRight);
    
    // Update fire state
    this.updateIndicatorState('fire', this.keys.fire);
    
    // Update weapon selection
    this.updateIndicatorState('selectLaser', this.currentWeapon === 'LASER');
    this.updateIndicatorState('selectGrenade', this.currentWeapon === 'GRENADE');
    this.updateIndicatorState('selectBounce', this.currentWeapon === 'BOUNCE');
  }
  
  updateIndicatorState(id, isActive) {
    const indicator = this.controlsContainer?.querySelector(`#indicator-${id}`);
    if (indicator) {
      if (isActive) {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }
  }
  
  handleResize(event) {
    // Debounce resize events
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    
    this.resizeTimer = setTimeout(() => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.resizeTimer = null;
    }, 100);
  }
  
  handleKeyDown(event) {
    // Handle escape key for in-game menu
    if (event.code === 'Escape') {
        this.showInGameMenu();
        return;
    }
    
    // Handle 'C' key to toggle controls visibility
    if (event.code === 'KeyC') {
        console.log('C key pressed - toggling controls');
        this.toggleControls();
        return;
    }
    
    // Handle 'M' key to toggle mini-map
    if (event.code === 'KeyM') {
        this.toggleMiniMap();
        return;
    }

    // Get control action from key mapping
    const action = ControlUtils.getActionForKey(event.code);
    
    // Skip if key isn't mapped or event is repeated
    if (!action || event.repeat) return;
    
    // Handle weapon selection
    if (action.category === 'WEAPONS') {
        if (action.action === 'SWITCH_WEAPON') {
            this.cycleWeapon();
            return;
        } else if (action.action === 'SELECT_LASER') {
            this.selectWeapon('LASER');
            return;
        } else if (action.action === 'SELECT_GRENADE') {
            this.selectWeapon('GRENADE');
            return;
        } else if (action.action === 'SELECT_BOUNCE') {
            this.selectWeapon('BOUNCE');
            return;
        }
    }
    
    // Handle UI controls
    if (action.category === 'UI') {
        if (action.action === 'TOGGLE_MAP') {
            this.toggleMiniMap();
            return;
        } else if (action.action === 'TOGGLE_CONTROLS') {
            this.toggleControls();
            return;
        }
    }
    
    // Set key state to active
    if (action.category === 'MOVEMENT') {
        this.keys[action.action.toLowerCase()] = true;
    }
    
    // Store active key for visual feedback
    this.activeKeys.add(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
    
    // Prevent default browser behavior for game controls
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'Tab', 'KeyM'].includes(event.code)) {
        event.preventDefault();
    }
}
  
  handleKeyUp(event) {
    const action = ControlUtils.getActionForKey(event.code);
    if (!action) return;
    
    // Skip weapon selection keys on keyup
    if (action.category === 'WEAPONS' && action.action.startsWith('SELECT_')) {
      return;
    }
    
    // Set key state to inactive
    if (action.category === 'MOVEMENT') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'WEAPONS') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'UI') {
      this.keys[action.action.toLowerCase()] = false;
    }
    
    // Remove from active keys
    this.activeKeys.delete(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
  }
  
  handleClick(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault) {
        event.preventDefault();
    }
    
    // Prevent rapid-fire clicking
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
        return;
    }
    
    // Get click coordinates relative to canvas
    const rect = this.renderer.domElement.getBoundingClientRect();
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid click coordinates');
        return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Convert to normalized device coordinates
    const mouse = new THREE.Vector2(
        (x / this.renderer.domElement.clientWidth) * 2 - 1,
        -(y / this.renderer.domElement.clientHeight) * 2 + 1
    );
    
    // Handle weapon-specific targeting
    if (this.currentWeapon === 'GRENADE') {
        this.handleGrenadeTargeting({ 
            clientX, 
            clientY,
            preventDefault: () => {} // Add dummy preventDefault for consistency
        });
    } else {
        this.handleDirectionalFiring({ clientX, clientY });
    }
  }
  
  handleMouseMove(event) {
    // Skip if we're moving too frequently (throttle)
    if (this.mouseMoveTimer) {
        return;
    }
    
    // Use requestAnimationFrame for smoother updates
    this.mouseMoveTimer = requestAnimationFrame(() => {
        // Get mouse coordinates relative to canvas
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update targeting indicators for any weapon type
        this.updateTargetingIndicator({
            clientX: event.clientX,
            clientY: event.clientY
        });
        
        // Additional targeting for grenade if that's the current weapon
        if (this.currentWeapon === 'GRENADE') {
            this.updateGrenadeTargetingIndicator({
                clientX: event.clientX,
                clientY: event.clientY
            });
        }
        
        this.mouseMoveTimer = null;
    });
}
  
  handleFireAction() {
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
      return;
    }
    
    // Set cooldown based on weapon type
    const cooldownTime = this.currentWeapon === 'GRENADE' ? 1000 :
                        this.currentWeapon === 'BOUNCE' ? 500 :
                        200;
    
    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);
    this.fireCurrentWeapon();
  }
  
  setupTouchControls() {
    // Create touch control container
    const touchControls = document.createElement('div');
    touchControls.className = 'touch-controls';
    document.body.appendChild(touchControls);
    
    // Create virtual joystick for movement
    const joystickContainer = document.createElement('div');
    joystickContainer.className = 'joystick-container';
    touchControls.appendChild(joystickContainer);
    
    const joystick = document.createElement('div');
    joystick.className = 'joystick';
    joystickContainer.appendChild(joystick);
    
    const joystickKnob = document.createElement('div');
    joystickKnob.className = 'joystick-knob';
    joystick.appendChild(joystickKnob);
    
    // Create fire button
    const fireButton = document.createElement('div');
    fireButton.className = 'touch-button fire-button';
    fireButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.ACTIONS.find(a => a.id === 'fire').label;
    touchControls.appendChild(fireButton);
    
    // Create weapon switch button
    const weaponButton = document.createElement('div');
    weaponButton.className = 'touch-button weapon-button';
    weaponButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.WEAPONS.find(w => w.id === 'switchWeapon').label;
    touchControls.appendChild(weaponButton);
    
    // Joystick handling
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickOrigin.x = rect.left + rect.width / 2;
      joystickOrigin.y = rect.top + rect.height / 2;
      handleJoystickMove(touch);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (joystickActive) {
        const touch = e.touches[0];
        handleJoystickMove(touch);
        e.preventDefault();
      }
    });
    
    document.addEventListener('touchend', (e) => {
      if (joystickActive) {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Reset movement keys using DEFAULT_CONTROL_STATE
        Object.keys(DEFAULT_CONTROL_STATE).forEach(key => {
          if (key.startsWith('forward') || key.startsWith('backward') || 
              key.startsWith('left') || key.startsWith('right') || 
              key.startsWith('strafe')) {
            this.keys[key] = DEFAULT_CONTROL_STATE[key];
          }
        });
        
        this.updateControlIndicators();
      }
    });
    
    const handleJoystickMove = (touch) => {
      const maxDistance = CONTROL_SETTINGS.TOUCH.JOYSTICK_MAX_DISTANCE;
      const deadZone = CONTROL_SETTINGS.TOUCH.JOYSTICK_DEAD_ZONE;
      
      // Calculate distance from center
      const dx = touch.clientX - joystickOrigin.x;
      const dy = touch.clientY - joystickOrigin.y;
      
      // Limit distance to maxDistance
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
      const angle = Math.atan2(dy, dx);
      
      // Move joystick knob
      const knobX = distance * Math.cos(angle);
      const knobY = distance * Math.sin(angle);
      joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
      
      // Convert joystick position to key presses using deadzone
      this.keys.forward = dy < -deadZone;
      this.keys.backward = dy > deadZone;
      this.keys.left = dx < -deadZone;
      this.keys.right = dx > deadZone;
      
      this.updateControlIndicators();
    };
    
    // Fire button handling with weapon cooldown
    let lastFireTime = 0;
    fireButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      const cooldown = CONTROL_SETTINGS.WEAPON_COOLDOWNS[this.currentWeapon];
      
      if (now - lastFireTime >= cooldown) {
        this.keys.fire = true;
        this.fireCurrentWeapon();
        lastFireTime = now;
      }
      
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    fireButton.addEventListener('touchend', (e) => {
      this.keys.fire = false;
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    // Weapon switch button handling with cooldown
    let lastWeaponSwitchTime = 0;
    weaponButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastWeaponSwitchTime >= 200) { // 200ms cooldown for weapon switching
        this.cycleWeapon();
        lastWeaponSwitchTime = now;
      }
      e.preventDefault();
    });
    
    // Enable directional fire on game area tap
    const gameArea = document.querySelector('canvas');
    if (gameArea) {
      let lastTapTime = 0;
      
      gameArea.addEventListener('touchstart', (e) => {
        // Ignore if touch is in control areas
        const touch = e.touches[0];
        const isInControlArea = 
          touchControls.contains(document.elementFromPoint(touch.clientX, touch.clientY));
          
        if (!isInControlArea && this.playerShip) {
          const now = Date.now();
          const doubleTapDelay = CONTROL_SETTINGS.TOUCH.DOUBLE_TAP_DELAY;
          
          // Check for double tap
          if (now - lastTapTime < doubleTapDelay) {
            // Handle double tap action (e.g., special weapon)
            this.cycleWeapon();
          } else {
            // Handle single tap (directional firing)
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // Handle directional firing similarly to mouse
            const touchPoint = new THREE.Vector2(
              (touchX / window.innerWidth) * 2 - 1,
              -(touchY / window.innerHeight) * 2 + 1
            );
            
            // Use raycasting to determine the point in 3D space
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touchPoint, this.camera);
            
            // Check for intersection with the floor
            const intersects = raycaster.intersectObject(this.floor);
            
            if (intersects.length > 0) {
              const targetPoint = intersects[0].point;
              
              // Calculate the direction from the player to the target point
              const shipPosition = this.playerShip.position.clone();
              const direction = targetPoint.clone().sub(shipPosition).normalize();
              
              // Only care about horizontal direction (ignore y component)
              direction.y = 0;
              direction.normalize();
              
              // Store the original rotation
              const originalRotation = this.playerShip.rotation.clone();
              
              // Temporarily rotate the ship to face the target
              this.playerShip.lookAt(shipPosition.clone().add(direction));
              
              // Fire the weapon in that direction
              if (this.currentWeapon === 'GRENADE') {
                // For grenades, we simulate a tap at the target location
                const targetEvent = {
                  clientX: touchX,
                  clientY: touchY,
                  preventDefault: () => {}
                };
                this.handleGrenadeTargeting(targetEvent);
              } else {
                // For lasers and bounce, fire in the direction
                this.fireCurrentWeapon(direction);
              }
              
              // Restore the original rotation
              this.playerShip.rotation.copy(originalRotation);
            }
          }
          
          lastTapTime = now;
          e.preventDefault();
        }
      });
    }
  }
  
  toggleControls() {
    // Clear any existing timeout
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
    
    // Also clear any auto-fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (!this.controlsContainer) {
      this.createControlIndicators();
    }
    
    if (this.controlsContainer.classList.contains('visible')) {
      this.fadeOutControls();
    } else {
      this.fadeInControls();
    }
  }
  
  fadeInControls() {
    console.log('Fading in controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // Remove any classes that might hide the controls
        this.controlsContainer.classList.remove('hidden', 'fading');
        // Add the visible class
        this.controlsContainer.classList.add('visible');
        console.log('Controls should now be visible with class: visible');
        
        // Set a timeout to automatically fade out the controls after 5 seconds
        // (but only if we're in the game and not in a menu)
        if (this.isRunning) {
            this.controlsFadeTimeout = setTimeout(() => {
              console.log('Auto-hiding controls after timeout');
              this.fadeOutControls();
            }, 5000);
        }
    } else {
        console.warn('Control container not found during fade in');
        // Try to create controls if they don't exist
        this.createControlIndicators();
        // And then try to show them
        if (this.controlsContainer) {
            this.controlsContainer.classList.add('visible');
            
            // Also set the auto-fade timeout for the newly created controls
            // (but only if we're in the game and not in a menu)
            if (this.isRunning) {
                this.controlsFadeTimeout = setTimeout(() => {
                  console.log('Auto-hiding newly created controls after timeout');
                  this.fadeOutControls();
                }, 5000);
            }
        }
    }
  }
  
  fadeOutControls() {
    console.log('Fading out controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // First add the fading class for the transition
        this.controlsContainer.classList.add('fading');
        this.controlsContainer.classList.remove('visible');
        
        // After the transition completes, add the hidden class
        setTimeout(() => {
            if (this.controlsContainer) {
                this.controlsContainer.classList.add('hidden');
            }
        }, 500); // Match the transition time from CSS
    } else {
        console.warn('Control container not found during fade out');
    }
  }
  
  updateWeaponUI() {
    // Update UI to reflect weapon change
    if (this.ui) {
        this.ui.updateWeapon(this.currentWeapon);
        
        // Update targeting indicator color if it exists
        if (this.targetingIndicator) {
            const colors = {
                'LASER': new THREE.Color(0x00ffff),
                'GRENADE': new THREE.Color(0xff4500),
                'BOUNCE': new THREE.Color(0x00ff99)
            };
            const color = colors[this.currentWeapon] || colors['LASER'];
            
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
        }
    }
    
    // Log weapon change
    console.log('Weapon updated:', this.currentWeapon);
}

selectWeapon(weaponType) {
    console.log('Selecting specific weapon:', weaponType);
    const index = this.availableWeapons.indexOf(weaponType);
    if (index !== -1) {
        this.weaponIndex = index;
        this.currentWeapon = weaponType;
        console.log('Weapon selection successful');
        
        // Update UI to reflect weapon change
        this.updateWeaponUI();
        
        // Play weapon switch sound if available
        this.playSound('weapon-switch');
    } else {
        console.warn('Attempted to select unavailable weapon:', weaponType);
    }
}
  
  cycleWeapon() {
    console.log('Cycling weapon from:', this.currentWeapon);
    this.weaponIndex = (this.weaponIndex + 1) % this.availableWeapons.length;
    this.currentWeapon = this.availableWeapons[this.weaponIndex];
    console.log('New weapon selected:', this.currentWeapon);
    
    // Update UI to reflect weapon change
    this.updateWeaponUI();
    
    // Play weapon switch sound
    this.playSound('weapon-switch');
}
  
  fireGrenade() {
    console.log("Grenade weapon selected - click to target");
  }
  
  animate() {
    // Call animationFrame with this instance as context
    requestAnimationFrame(this.animate.bind(this));
    
    try {
      // Calculate delta time
      const now = performance.now();
      const deltaTime = (now - this.lastTime) / 1000; // in seconds
      this.lastTime = now;
      
      // Update frame counter
      this.frameCount++;
      
      // Limit update rate
      if (this.frameCount % 2 === 0) { // Reduce update frequency
        // Only update gameplay if the player ship exists
        if (this.playerShip) {
          // Update player
          if (typeof this.updatePlayer === 'function') {
            this.updatePlayer(deltaTime);
          }
          
          // Update other elements - only if they exist
          if (typeof this.updateLasers === 'function') {
            this.updateLasers();
          }
          
          if (typeof this.updateEnergy === 'function') {
            this.updateEnergy(deltaTime);
          }
          
          if (typeof this.updateCamera === 'function') {
            this.updateCamera();
          }
          
          // Update collision detection
          if (typeof this.checkObstacleCollisions === 'function') {
            this.checkObstacleCollisions();
          }
          
          // Update thruster effects
          if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
          }
          
          // Check if boost is active and update energy consumption
          if (this.keys && this.keys.boost && this.energy > 0) {
            this.energy = Math.max(0, this.energy - 30 * deltaTime); // Boost drains energy
            if (this.ui) {
              this.ui.updateEnergy(this.energy, this.maxEnergy);
            }
          }
        }
        
        // Update bounceLasers if they exist
        if (this.bouncingLasers && this.bouncingLasers.length > 0 && 
            typeof this.updateBouncingLasers === 'function') {
          this.updateBouncingLasers();
        }
        
        // Update grenades if they exist
        if (this.grenades && this.grenades.length > 0 && 
            typeof this.updateGrenades === 'function') {
          this.updateGrenades();
        }
        
        // Update multiplayer
        if (this.multiplayerEnabled && this.networkManager) {
          // Send our position and rotation to server
          if (this.playerShip) {
            this.networkManager.sendPlayerUpdate({
              position: {
                x: this.playerShip.position.x,
                y: this.playerShip.position.y,
                z: this.playerShip.position.z
              },
              rotation: this.playerShip.rotation.y,
              name: this.playerName,
              shipType: this.currentShipType || 'default'
            });
          }
          
          // Update other players
          if (typeof this.updateOtherPlayers === 'function') {
            this.updateOtherPlayers();
          }
        }
      }
      
      // Render the scene
      if (this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        
        // Render CSS2D elements if renderer exists
        if (this.labelRenderer) {
          this.labelRenderer.render(this.scene, this.camera);
        }
      }
    } catch (error) {
      console.error("Error in animate loop:", error);
      // Don't rethrow, we want to keep the animation loop running
    }
  }
  
  updatePlayer(deltaTime) {
    if (!this.playerShip) return;
    
    // Save original position in case we need to revert due to collision
    const originalPosition = this.playerShip.position.clone();
    
    // ORIGINAL SHIP MOVEMENT PHYSICS
    const moveSpeed = 10; // Base movement speed
    const rotateSpeed = 2.5; // Base rotation speed
    
    let moved = false; // Track if the ship moved
    
    // Handle forward/backward movement
    if (this.keys.forward) {
        // Move forward
        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(forwardDir, moveSpeed * deltaTime);
        moved = true;
    }
    else if (this.keys.backward) {
        // Move backward
        const backwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(backwardDir, moveSpeed * deltaTime);
        moved = true;
    }

    // Handle left/right rotation
    if (this.keys.left) {
        // Rotate left
        this.playerShip.rotation.y += rotateSpeed * deltaTime;
        moved = true;
    }
    else if (this.keys.right) {
        // Rotate right
        this.playerShip.rotation.y -= rotateSpeed * deltaTime;
        moved = true;
    }
    
    // Update player highlight to follow the player ship
    if (this.playerHighlight) {
        this.playerHighlight.position.x = this.playerShip.position.x;
        this.playerHighlight.position.z = this.playerShip.position.z;
        
        // Add a subtle pulsing effect to the highlight
        const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
        this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
    }
    
    // Check for collisions after movement
    if (moved) {
        this.checkObstacleCollisions();
        
        // If no collisions, update thruster effects
        if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
        }
        
        // Send position update to server if multiplayer is enabled
        if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
            this.sendPlayerPositionUpdate();
        }
    }
  }
  
  updateLasers() {
    if (!this.lasers) return;
    
    for (let i = this.lasers.length - 1; i >= 0; i--) {
      const laser = this.lasers[i];
      
      // Move laser
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update trail effect
      laser.trailPoints.push(laser.mesh.position.clone());
      if (laser.trailPoints.length > 8) { // Reduced trail length for better performance
        laser.trailPoints.shift();
      }
      
      // Update trail geometry
      const positions = new Float32Array(laser.trailPoints.length * 3);
      for (let j = 0; j < laser.trailPoints.length; j++) {
        positions[j * 3] = laser.trailPoints[j].x;
        positions[j * 3 + 1] = laser.trailPoints[j].y;
        positions[j * 3 + 2] = laser.trailPoints[j].z;
      }
      laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Pulse effect
      laser.pulsePhase += 0.3;
      const pulse = Math.sin(laser.pulsePhase) * 0.2 + 0.8;
      laser.mesh.material.opacity = pulse;
      const light = laser.mesh.children[0];
      if (light) {
        light.intensity = pulse * 2;
      }
      
      // Increment lifetime
      laser.lifeTime++;
      
      // Remove old lasers
      if (laser.lifeTime > laser.maxLifeTime) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.lasers.splice(i, 1);
        continue;
      }
      
      // Check for collisions with obstacles
      for (let j = 0; j < this.obstacles.length; j++) {
        const obstacle = this.obstacles[j];
        
        // Simple distance check
        if (laser.mesh.position.distanceTo(obstacle.position) < 1.5) {
          // Create enhanced hit effect
          this.createEnhancedHitEffect(laser.mesh.position.clone(), laser.direction.clone());
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  createEnhancedHitEffect(position, direction) {
    // Create a burst of particles
    const particleCount = 15;
    const particles = [];
    
    // Create particle material
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity based on impact direction
      const spread = Math.PI / 2; // 90 degree spread
      const angle = Math.random() * spread - spread/2;
      const speed = 0.2 + Math.random() * 0.3;
      
      // Calculate velocity
      const velocity = direction.clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle)
        .multiplyScalar(speed);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0; // Full life
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.3, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(position.clone().add(direction));
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }
  
  checkObstacleCollisions() {
    if (!this.playerShip || !this.infiniteMap) {
      console.log('Skipping collision check - player ship or infinite map not available');
      return;
    }
    
    // Get player collision info
    const playerRadius = this.playerShip.userData.collisionRadius || 0.35;
    const playerPos = this.playerShip.position.clone();
    
    // Create player sphere for collision checks
    const playerSphere = {
      center: playerPos,
      radius: playerRadius
    };
    
    // Check collisions with infinite map objects first
    const mapCollision = this.infiniteMap.checkCollisions(playerPos, playerRadius);
    
    if (mapCollision.collided) {
      // Handle collision from infinite map
      this.handleObjectCollision(playerPos, mapCollision.object.position, mapCollision.object.type || 'terrain');
      return; // Stop checking after handling one collision
    }
    
    // Check local obstacles with more accurate collision detection
    for (const obstacle of this.obstacles) {
      if (!obstacle.mesh) continue;
      
      // First, do a quick broad-phase check with spheres for efficiency
      const obstaclePos = obstacle.position.clone();
      const distance = playerPos.distanceTo(obstaclePos);
      const quickCheckDistance = playerRadius + obstacle.size;
      
      // Skip detailed check if clearly not colliding
      if (distance > quickCheckDistance * 1.5) continue;
      
      // Determine if collision happened based on shape type
      let collision = false;
      
      if (obstacle.collisionShape === 'compound' && obstacle.compoundShapes) {
        // Use compound shape collision detection for complex objects
        collision = this.checkCompoundCollision(playerSphere, obstacle.compoundShapes);
      } else if (obstacle.collisionShape === 'complex' && obstacle.boundingBox) {
        // Fall back to oriented bounding box if compound shapes not available
        collision = this.checkBoxCollision(
          playerPos, playerRadius,
          obstacle.boundingBox, 
          obstacle.boundingBox.rotation
        );
      } else {
        // Simplest case: sphere-based collision for backward compatibility
        collision = distance < quickCheckDistance;
      }
      
      if (collision) {
        // Handle the collision
        this.handleObjectCollision(playerPos, obstaclePos, obstacle.type);
        break; // Only handle one collision at a time
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (compound shapes)
   */
  checkCompoundCollision(playerSphere, compoundShapes) {
    // Check collision against each shape in the compound
    for (const shape of compoundShapes) {
      let collision = false;
      
      if (shape.type === 'box') {
        // Box vs sphere collision
        collision = this.checkBoxSphereCollision(
          shape.center,
          shape.halfExtents,
          shape.worldRotation || 0,
          playerSphere
        );
      } else if (shape.type === 'sphere') {
        // Sphere vs sphere collision (simpler case)
        const distance = playerSphere.center.distanceTo(shape.center);
        collision = distance < (playerSphere.radius + shape.radius);
      }
      
      if (collision) {
        return true; // Collision with any part means collision with the compound
      }
    }
    
    return false; // No collision with any part
  }
  
  /**
   * Check collision between a rotated box and a sphere
   */
  checkBoxSphereCollision(boxCenter, boxHalfExtents, boxRotation, sphere) {
    // Transform sphere center to box space (accounting for rotation)
    const toSphere = new THREE.Vector3().subVectors(sphere.center, boxCenter);
    
    // Apply inverse rotation to get into box space
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(-boxRotation);
      toSphere.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on box to sphere in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-boxHalfExtents.x, Math.min(boxHalfExtents.x, toSphere.x)),
      Math.max(-boxHalfExtents.y, Math.min(boxHalfExtents.y, toSphere.y)),
      Math.max(-boxHalfExtents.z, Math.min(boxHalfExtents.z, toSphere.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(boxRotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to sphere center (for efficiency)
    const squaredDistance = sphere.center.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than sphere radius squared
    return squaredDistance < (sphere.radius * sphere.radius);
  }

  /**
   * Handle collision with any object
   */
  handleObjectCollision(playerPos, objectPos, objectType) {
    console.log(`COLLISION DETECTED with ${objectType}: Pushing ship back`);
    
    // Push player away from obstacle
    const pushDir = new THREE.Vector3()
      .subVectors(playerPos, objectPos)
      .normalize();
      
    // Adjust push force based on object type
    let pushForce = 0.7; // Default push force
    let damageAmount = 5; // Default damage
    
    // Customize collision response based on type
    switch(objectType) {
      case 'rocks':
        pushForce = 0.85; // Rocks push strongly
        damageAmount = 8;
        break;
      case 'specialObjects':
      case 'groundFeatures':
        pushForce = 0.75; // Ground features push medium
        damageAmount = 6;
        break;
      case 'mountains':
        pushForce = 1.0; // Mountains push very strongly
        damageAmount = 10;
        break;
      case 'crystals':
        pushForce = 0.7; // Crystals push medium but with special effect
        damageAmount = 7;
        
        // Add special crystal collision effect
        this.createCrystalCollisionEffect(objectPos);
        break;
      case 'centerpiece':
        pushForce = 0.9; // Centerpiece pushes strongly
        damageAmount = 9;
        
        // Add special centerpiece collision effect
        this.createCrystalCollisionEffect(objectPos, true);
        break;
      case 'flora':
        pushForce = 0.6; // Flora pushes gently
        damageAmount = 3;
        break;
      default:
        // Use default values
        break;
    }
    
    // Apply the push force
    this.playerShip.position.addScaledVector(pushDir, pushForce);
    
    // Flash collision warning
    this.flashCollisionWarning();
    
    // Apply damage if the function exists
    if (typeof this.applyDamage === 'function') {
      this.applyDamage(damageAmount);
    }
    
    // Play appropriate collision sound based on object type
    let soundToPlay = 'collision';
    
    if (objectType === 'specialObjects') {
      // Crystal-like sounds for special objects
      soundToPlay = 'crystalHit';
    } else if (objectType === 'mountains') {
      // Heavy impact for mountains
      soundToPlay = 'heavyImpact';
    }
    
    // Play the sound if it exists, otherwise fall back to default collision
    if (this.playSound) {
      try {
        this.playSound(soundToPlay);
      } catch (e) {
        // Fall back to default if sound doesn't exist
        try {
          this.playSound('collision');
        } catch (e2) {
          // No sound available
        }
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (oriented box)
   */
  checkBoxCollision(playerPos, playerRadius, box, rotation) {
    // Get box center
    const boxCenter = new THREE.Vector3(
      (box.min.x + box.max.x) / 2,
      (box.min.y + box.max.y) / 2,
      (box.min.z + box.max.z) / 2
    );
    
    // Calculate half extents of box
    const halfExtents = new THREE.Vector3(
      (box.max.x - box.min.x) / 2,
      (box.max.y - box.min.y) / 2,
      (box.max.z - box.min.z) / 2
    );
    
    // Vector from box center to player
    const toPlayer = new THREE.Vector3().subVectors(playerPos, boxCenter);
    
    // If we have rotation, apply inverse rotation to convert to box space
    if (rotation) {
      // Create rotation matrix for the box (negative rotation to invert)
      const rotMatrix = new THREE.Matrix4().makeRotationY(-rotation);
      toPlayer.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on the box to the player in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-halfExtents.x, Math.min(halfExtents.x, toPlayer.x)),
      Math.max(-halfExtents.y, Math.min(halfExtents.y, toPlayer.y)),
      Math.max(-halfExtents.z, Math.min(halfExtents.z, toPlayer.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (rotation) {
      // Create rotation matrix for the box
      const rotMatrix = new THREE.Matrix4().makeRotationY(rotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to player center
    const squaredDistance = playerPos.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than player radius squared
    return squaredDistance < (playerRadius * playerRadius);
  }
  
  updateCamera() {
    // Check if cameraTargetPosition is initialized
    if (!this.cameraTargetPosition) {
      this.cameraTargetPosition = new THREE.Vector3();
      this.cameraTargetLookAt = new THREE.Vector3();
      this.cameraSmoothingFactor = 0.05;
    }
    
    // If playerShip doesn't exist, early return
    if (!this.playerShip) return;
    
    // Define the camera offset from the player
    const offsetY = 18; // Height above the player
    const offsetZ = -16; // Distance behind the player (adjusted for larger ship)
    
    // Get the player's forward direction vector (simplified)
    const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
    
    // Calculate camera target position (directly above and slightly behind player)
    this.cameraTargetPosition.copy(this.playerShip.position);
    this.cameraTargetPosition.y += offsetY;
    
    // Move camera back based on player's orientation
    const backOffset = forwardDir.clone().multiplyScalar(offsetZ);
    this.cameraTargetPosition.add(backOffset);
    
    // Smoothly move camera toward target position
    this.camera.position.lerp(this.cameraTargetPosition, this.cameraSmoothingFactor);
    
    // Make camera look at the player
    this.cameraTargetLookAt.copy(this.playerShip.position);
    this.camera.lookAt(this.cameraTargetLookAt);
  }
  
  updateThrusterEffects() {
    // Skip if ship model isn't loaded
    if (!this.shipModel || !this.thruster || !this.thrusterLight) return;
    
    // Use stored references instead of finding children each time
    const { thruster, thrusterLight } = this;
    
    // Base thruster scale and opacity on movement
    const isMovingForward = this.keys.forward;
    const isMovingBackward = this.keys.backward;
    
    // Update thruster pulse for ambient animation
    this.thrusterPulse.value = (this.thrusterPulse.value + 0.1) % (Math.PI * 2);
    const pulseEffect = Math.sin(this.thrusterPulse.value) * 0.1;
    
    if (isMovingForward) {
      // Full thruster when moving forward
      const randomScale = 1 + Math.random() * 0.2 + pulseEffect;
      thruster.scale.set(1, 1, randomScale);
      thruster.material.opacity = 0.7 + Math.random() * 0.3;
      thrusterLight.intensity = 1.2 + Math.random() * 0.3 + pulseEffect;
      
      // Add color variation for a more dynamic effect
      const hue = (Date.now() % 1000) / 1000; // Cycle through colors over time
      thruster.material.color.setHSL(hue, 1, 0.5);
      thrusterLight.color.setHSL(hue, 1, 0.5);
    } else if (isMovingBackward) {
      // Reduced thruster when moving backward
      const randomScale = 0.3 + Math.random() * 0.1 + pulseEffect * 0.5;
      thruster.scale.set(0.5, 0.5, randomScale);
      thruster.material.opacity = 0.4 + Math.random() * 0.2;
      thrusterLight.intensity = 0.6 + Math.random() * 0.2 + pulseEffect * 0.5;
      
      // Cooler color for reverse thrust
      thruster.material.color.setHSL(0.6, 1, 0.5); // Blue-ish
      thrusterLight.color.setHSL(0.6, 1, 0.5);
    } else {
      // Idle state with subtle pulsing
      const idleScale = 0.3 + pulseEffect;
      thruster.scale.set(0.3, 0.3, idleScale);
      thruster.material.opacity = 0.3 + pulseEffect;
      thrusterLight.intensity = 0.4 + pulseEffect;
      
      // Neutral color for idle
      thruster.material.color.setHSL(0.5, 0.7, 0.5); // Cyan-ish
      thrusterLight.color.setHSL(0.5, 0.7, 0.5);
    }
    
    // Performance optimization: only update material if it's visible
    if (thruster.material.opacity < 0.01) {
      thruster.visible = false;
      thrusterLight.visible = false;
    } else {
      thruster.visible = true;
      thrusterLight.visible = true;
    }
  }
  
  flashCollisionWarning() {
    // Create a full-screen flash effect for collision
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'collision-flash';
    document.body.appendChild(flashOverlay);
    
    // Remove after animation completes
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, 150);
  }
  
  updateEnergy(deltaTime) {
    // Validate parameters
    if (typeof deltaTime !== 'number' || deltaTime < 0) {
        console.warn('Invalid deltaTime in updateEnergy:', deltaTime);
        return;
    }

    // Initialize energy values if undefined
    if (typeof this.energy !== 'number') this.energy = 0;
    if (typeof this.maxEnergy !== 'number') this.maxEnergy = 100;
    if (typeof this.energyRechargeRate !== 'number') this.energyRechargeRate = 20;

    // Store old energy for change detection
    const oldEnergy = this.energy;

    // Calculate recharge amount
    const rechargeAmount = this.energyRechargeRate * deltaTime;
    
    // Apply recharge with bounds checking
    this.energy = Math.min(this.maxEnergy, this.energy + rechargeAmount);

    // Update UI only if energy changed
    if (this.energy !== oldEnergy) {
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        }

        // Play charging sound when energy is low (under 10%)
        if (this.energy < (this.maxEnergy * 0.1)) {
            this.playSound('weapon-charging');
        }

        // Log significant energy changes (more than 1 unit) for debugging
        if (Math.abs(this.energy - oldEnergy) > 1) {
            console.log(`Energy updated: ${oldEnergy.toFixed(1)} -> ${this.energy.toFixed(1)} (Δ${deltaTime.toFixed(3)}s)`);
        }
    }
  }
  
  updateGrenades() {
    if (!this.grenades || this.grenades.length === 0) return;
    
    for (let i = this.grenades.length - 1; i >= 0; i--) {
      const grenade = this.grenades[i];
      
      // If the grenade has exploded, handle explosion effects
      if (grenade.exploded) {
        // Increase the explosion radius until maximum
        grenade.explosionMesh.scale.addScalar(0.2);
        grenade.explosionLight.intensity -= 0.1;
        
        // Remove explosion after it's done
        if (grenade.explosionLight.intensity <= 0) {
          this.scene.remove(grenade.explosionMesh);
          this.scene.remove(grenade.trail);
          this.grenades.splice(i, 1);
        }
        continue;
      }
      
      // Update the grenade position along the arc
      grenade.progress += 0.02;
      
      if (grenade.progress >= 1) {
        // Explode when reaching the target
        this.explodeGrenade(grenade, i);
      } else {
        // Move along a quadratic bezier curve for arcing trajectory
        const p0 = grenade.startPos;
        const p1 = grenade.midPos;
        const p2 = grenade.endPos;
        
        // Quadratic bezier formula: p = (1-t)^2 * p0 + 2(1-t)t * p1 + t^2 * p2
        const t = grenade.progress;
        const oneMinusT = 1 - t;
        
        grenade.mesh.position.x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
        grenade.mesh.position.y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
        grenade.mesh.position.z = oneMinusT * oneMinusT * p0.z + 2 * oneMinusT * t * p1.z + t * t * p2.z;
        
        // Add trail effect
        const point = grenade.mesh.position.clone();
        grenade.trailPoints.push(point);
        
        // Keep only the last 20 trail points
        if (grenade.trailPoints.length > 20) {
          grenade.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(grenade.trailPoints.length * 3);
        for (let j = 0; j < grenade.trailPoints.length; j++) {
          positions[j * 3] = grenade.trailPoints[j].x;
          positions[j * 3 + 1] = grenade.trailPoints[j].y;
          positions[j * 3 + 2] = grenade.trailPoints[j].z;
        }
        
        grenade.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        grenade.trail.geometry.attributes.position.needsUpdate = true;
      }
    }
  }
  
  explodeGrenade(grenade, index) {
    // Remove the grenade mesh
    this.scene.remove(grenade.mesh);
    
    // Create explosion geometry
    const explosionGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const explosionMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8
    });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(grenade.mesh.position);
    
    // Add to scene
    this.scene.add(explosionMesh);
    
    // Add explosion light
    const explosionLight = new THREE.PointLight(0xff6600, 3, 10);
    explosionMesh.add(explosionLight);
    
    // Mark as exploded
    grenade.exploded = true;
    grenade.explosionMesh = explosionMesh;
    grenade.explosionLight = explosionLight;
    
    // Calculate damage radius
    const explosionCenter = grenade.mesh.position.clone();
    const maxDamage = 50; // Maximum damage at center - 50% of health
    const damageRadius = grenade.explosionRadius || 4; // Default radius of 4 units
    
    // Check for obstacle hits in explosion radius
    for (const obstacle of this.obstacles) {
      const distance = obstacle.position.distanceTo(explosionCenter);
      if (distance < damageRadius) {
        // Calculate damage based on distance (linear falloff)
        const damagePercent = 1 - (distance / damageRadius);
        const hitPoint = obstacle.position.clone().add(
          explosionCenter.clone().sub(obstacle.position).normalize().multiplyScalar(distance * 0.8)
        );
        this.createHitEffect(hitPoint);
      }
    }
    
    // Check for player damage
    const playerPosition = this.playerShip.position.clone();
    playerPosition.y = 0; // Project to ground plane
    const grenadePosition = explosionCenter.clone();
    grenadePosition.y = 0; // Project to ground plane
    
    const playerDistance = playerPosition.distanceTo(grenadePosition);
    if (playerDistance < damageRadius) {
      // Calculate damage with distance falloff
      const damagePercent = 1 - (playerDistance / damageRadius);
      const damage = Math.floor(maxDamage * damagePercent);
      
      // Apply damage to player
      this.health = Math.max(0, this.health - damage);
      
      // Update UI
      if (this.ui) {
        this.ui.updateHealth(this.health, this.maxHealth);
      }
      
      // Visual feedback
      this.flashCollisionWarning();
      this.createHitEffect(playerPosition);
    }
  }
  
  updateBouncingLasers() {
    if (!this.bouncingLasers || this.bouncingLasers.length === 0) return;
    
    const playerPos = this.playerShip ? this.playerShip.position.clone() : null;
    
    // Update each laser
    for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
      const laser = this.bouncingLasers[i];
      
      // Skip invalid lasers
      if (!laser || !laser.mesh) continue;
      
      // Update laser position
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update the trail
      if (laser.trail) {
        // Add current position to trail points
        laser.trailPoints.push(laser.mesh.position.clone());
        
        // Limit the number of trail points
        if (laser.trailPoints.length > 20) {
          laser.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(laser.trailPoints.length * 3);
        for (let j = 0; j < laser.trailPoints.length; j++) {
          positions[j * 3] = laser.trailPoints[j].x;
          positions[j * 3 + 1] = laser.trailPoints[j].y;
          positions[j * 3 + 2] = laser.trailPoints[j].z;
        }
        
        // Update geometry
        laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        laser.trail.geometry.attributes.position.needsUpdate = true;
      }
      
      // Check for collisions with obstacles
      let collision = false;
      let closestPoint = null;
      let closestDistance = Infinity;
      let closestNormal = null;
      
      // Check for collision with each obstacle
      for (const obstacle of this.obstacles) {
        if (!obstacle.geometry) continue;
        
        let intersection = null;
        let normal = null;
        
        if (obstacle.geometry instanceof THREE.SphereGeometry) {
          const radius = obstacle.geometry.parameters.radius;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else if (obstacle.geometry instanceof THREE.CylinderGeometry) {
          const radius = obstacle.geometry.parameters.radiusTop;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else {
          // For boxes, use bounding sphere as approximation
          const boundingSphere = obstacle.geometry.boundingSphere;
          if (!boundingSphere) {
            obstacle.geometry.computeBoundingSphere();
          }
          const sphere = new THREE.Sphere(
            obstacle.position,
            obstacle.geometry.boundingSphere.radius
          );
          intersection = tempRay.intersectSphere(sphere, tempVector);
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        }
        
        if (intersection) {
          const dist = laser.mesh.position.distanceTo(intersection);
          if (dist < closestDist && dist < laser.speed * 1.2) {
            closestDist = dist;
            closestPoint = intersection;
            closestNormal = normal;
          }
        }
      }
      
      // Handle bounce if collision found
      if (closestPoint && closestNormal) {
        // Position at intersection point
        laser.mesh.position.copy(closestPoint);
        
        // Calculate reflection direction
        const dot = laser.direction.dot(closestNormal);
        const reflection = laser.direction.clone()
          .sub(closestNormal.multiplyScalar(2 * dot))
          .normalize();
        
        // Update direction with some randomness for more interesting bounces
        const randomAngle = (Math.random() - 0.5) * 0.2; // Small random angle
        reflection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
        laser.direction.copy(reflection);
        
        // Increment bounce count
        laser.bounces++;
        
        // Create bounce effect
        this.createBounceEffect(closestPoint.clone(), closestNormal.clone());
        
        // Play bounce sound
        this.playSound('bounce');
        
        // Enable player collision after first bounce
        laser.canHitPlayer = true;
        
        // Increase speed slightly with each bounce
        laser.speed *= 1.1;
        
        bounced = true;
      }
      
      // If no bounce, move normally
      if (!bounced) {
        laser.mesh.position.copy(nextPosition);
      }
      
      // Check for enemy collisions - new code
      if (this.enemyManager && this.enemyManager.enemies.length > 0) {
        for (let j = this.enemyManager.enemies.length - 1; j >= 0; j--) {
          const enemy = this.enemyManager.enemies[j];
          if (!enemy.isActive) continue;
          
          const enemyPos = enemy.mesh.position.clone();
          enemyPos.y = 0.5; // Adjust to match laser height
          
          // Check if the laser hit the enemy
          const hitDistance = 0.7; // Collision distance for enemy hits
          if (laser.mesh.position.distanceTo(enemyPos) < hitDistance) {
            // Enemy hit
            enemy.takeDamage(10); // Damage the enemy
            
            // Create hit effect
            this.createHitEffect(enemyPos);
            
            // Play hit sound
            this.playSound('weapon-armor-hit');
            
            // Remove laser
            this.scene.remove(laser.mesh);
            this.scene.remove(laser.trail);
            this.bouncingLasers.splice(i, 1);
            break; // Exit the enemy loop
          }
        }
      }
      
      // Check for player collision
      if (laser.canHitPlayer) {
        const playerPos = this.playerShip.position.clone();
        playerPos.y = 0.5;
        
        if (laser.mesh.position.distanceTo(playerPos) < 1) {
          // Player hit
          this.health -= 10;
          if (this.health < 0) this.health = 0;
          
          // Update UI
          this.ui.updateHealth(this.health, this.maxHealth);
          
          // Visual feedback
          this.flashCollisionWarning();
          this.createBounceEffect(playerPos, new THREE.Vector3(0, 1, 0));
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.bouncingLasers.splice(i, 1);
          continue;
        }
      }
      
      // Update lifetime
      laser.lifeTime++;
      
      // Remove if too old or too many bounces
      if (laser.lifeTime > laser.maxLifeTime || laser.bounces >= laser.maxBounces) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.bouncingLasers.splice(i, 1);
      }
    }
  }
  
  // Create a special effect for laser bounces
  createBounceEffect(position, normal) {
    // Create a particle burst effect at the bounce point
    const particleCount = 20;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    // Add a flash of light at bounce point
    const bounceLight = new THREE.PointLight(0x00ffcc, 3, 5);
    bounceLight.position.copy(position);
    this.scene.add(bounceLight);
    
    // Create a ring effect at bounce point
    const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(position);
    
    // Orient the ring according to the normal
    if (Math.abs(normal.y) > 0.99) { // If normal is pointing mainly up/down
      ring.rotation.x = Math.PI / 2; // Rotate to lie flat
    } else {
      // Point the ring along the normal
      const rotationAxis = new THREE.Vector3(0, 1, 0).cross(normal).normalize();
      const angle = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0)));
      ring.setRotationFromAxisAngle(rotationAxis, angle);
    }
    
    this.scene.add(ring);
    
    // Create particles around bounce point
    for (let i = 0; i < particleCount; i++) {
      // Random direction from bounce point
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(2)).normalize();
      
      // Starting at bounce point
      const startPoint = position.clone();
      particlePositions[i * 3] = startPoint.x;
      particlePositions[i * 3 + 1] = startPoint.y;
      particlePositions[i * 3 + 2] = startPoint.z;
      
      // Random sizes for particles
      particleSizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.1,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Store particle velocities
    const particleVelocities = [];
    for (let i = 0; i < particleCount; i++) {
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1, 
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(1.5)).normalize();
      
      // Random speed
      const speed = Math.random() * 0.1 + 0.05;
      particleVelocities.push(direction.multiplyScalar(speed));
    }
    
    // Animate particles and effects
    let frameCount = 0;
    const maxFrames = 30;
    
    const animate = () => {
      frameCount++;
      
      // Update particles
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x;
        positions[i * 3 + 1] += particleVelocities[i].y;
        positions[i * 3 + 2] += particleVelocities[i].z;
        
        // Slow down particles over time
        particleVelocities[i].multiplyScalar(0.95);
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Fade the light
      bounceLight.intensity *= 0.85;
      
      // Expand and fade the ring
      ring.scale.addScalar(0.15);
      ring.material.opacity *= 0.9;
      
      // Fade the particles
      particles.material.opacity *= 0.92;
      
      if (frameCount < maxFrames) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(bounceLight);
        this.scene.remove(ring);
        this.scene.remove(particles);
      }
    };
    
    // Start animation
    animate();
  }
  
  // Now add new methods to handle grenade targeting
  updateGrenadeTargetingIndicator(event) {
    // Create targeting indicator if it doesn't exist
    if (!this.grenadeTargetIndicator) {
      // Create targeting indicator
      const targetGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
      const targetMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, 
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      this.grenadeTargetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
      this.grenadeTargetIndicator.rotation.x = Math.PI / 2; // Make it horizontal
      
      // Add pulsing animation
      this.grenadeTargetIndicator.pulse = 0;
      
      // Add to scene
      this.scene.add(this.grenadeTargetIndicator);
    }
    
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // Update indicator color based on range
        if (distance > maxRange) {
          this.grenadeTargetIndicator.material.color.set(0xff0000); // Red for out of range
        } else {
          this.grenadeTargetIndicator.material.color.set(0x00ff00); // Green for valid
        }
        
        // Position the targeting indicator
        this.grenadeTargetIndicator.position.copy(targetPoint);
        this.grenadeTargetIndicator.position.y = 0.1; // Slightly above floor
        
        // Pulse animation
        this.grenadeTargetIndicator.pulse += 0.1;
        const scale = 1 + 0.2 * Math.sin(this.grenadeTargetIndicator.pulse);
        this.grenadeTargetIndicator.scale.set(scale, scale, scale);
        
        // Store target point for launching
        this.grenadeTargetPoint = targetPoint.clone();
    }
  }
  
  handleGrenadeTargeting(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Validate energy before proceeding
    if (!this.energy || !this.maxEnergy) {
        console.warn('Energy values invalid:', { energy: this.energy, maxEnergy: this.maxEnergy });
        return;
    }
    
    // Check if we have enough energy - now requires FULL energy
    if (this.energy < this.maxEnergy) {
        console.log("Not enough energy for grenade");
        return;
    }
    
    // Validate event coordinates
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid grenade target coordinates');
        return;
    }
    
    // Get the position where to throw the grenade
    const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // If beyond max range, limit to max range
        if (distance > maxRange) {
            toTarget.normalize().multiplyScalar(maxRange);
            targetPoint.copy(shipPosition).add(toTarget);
        }
        
        // Consume full energy
        this.energy = 0;
        
        // Update UI with energy change
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        } else {
            console.warn('UI energy update failed');
        }
        
        // Create and launch the grenade
        this.launchGrenade(targetPoint);
    }
  }
  
  launchGrenade(targetPoint) {
    // Create grenade mesh
    const grenadeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const grenadeMaterial = new THREE.MeshPhongMaterial({
      color: 0xff4500,
      emissive: 0xff2000,
      emissiveIntensity: 0.5
    });
    const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial);
    
    // Position at the ship
    grenade.position.copy(this.playerShip.position);
    grenade.position.y = 0.5; // Slightly above floor
    
    // Add to scene
    this.scene.add(grenade);
    
    // Add grenade trail effect
    const trail = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({
        color: 0xff4500,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      })
    );
    this.scene.add(trail);
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(0xff4500, 1, 3);
    grenade.add(light);
    
    // Store grenade data for animation
    if (!this.grenades) {
      this.grenades = [];
    }
    
    // Calculate the arc of the grenade
    const startPos = grenade.position.clone();
    const endPos = targetPoint.clone();
    const midPos = startPos.clone().add(endPos.clone().sub(startPos).multiplyScalar(0.5));
    midPos.y += 5; // Arc height
    
    this.grenades.push({
      mesh: grenade,
      trail: trail,
      startPos: startPos,
      midPos: midPos,
      endPos: endPos,
      progress: 0,
      exploded: false,
      explosionRadius: 4,
      trailPoints: []
    });

    // Play grenade launch sound
    this.playSound('grenade-laser');
  }
  
  // Add a method to show targeting indicator for all weapons
  updateTargetingIndicator(event) {
    // Skip if indicator was recently updated
    if (this.lastIndicatorUpdate && Date.now() - this.lastIndicatorUpdate < 16) {
        return;
    }
    this.lastIndicatorUpdate = Date.now();

    // Get the mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Log the normalized mouse position occasionally
    if (Math.random() < 0.01) {
      console.log('Mouse normalized position:', mouse);
    }
    
    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Check for intersection with the raycastFloor
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    // Log raycasting results occasionally for debugging
    if (Math.random() < 0.01) {
      console.log('Raycast results:', { 
        intersections: intersects.length, 
        raycastFloorExists: !!this.raycastFloor,
        raycastFloorPosition: this.raycastFloor ? this.raycastFloor.position.y : 'N/A'
      });
    }
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Create or update targeting indicator
        if (!this.targetingIndicator) {
            console.log('Creating new targeting indicator');
            // Create a more efficient indicator using a single geometry
            const geometry = new THREE.Group();
            
            // Outer ring with fewer segments - MAKE LARGER
            const outerRing = new THREE.RingGeometry(0.8, 1.0, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8, // Increased opacity
                side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerRing, material);
            
            // Inner ring with fewer segments - MAKE LARGER
            const innerRing = new THREE.RingGeometry(0.2, 0.4, 16);
            const inner = new THREE.Mesh(innerRing, material.clone());
            
            // Simplified crosshair - MAKE LARGER
            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = new Float32Array([
                -0.6, 0, 0,
                0.6, 0, 0,
                0, -0.6, 0,
                0, 0.6, 0
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));
            const lines = new THREE.LineSegments(lineGeometry, material.clone());
            
            geometry.add(outer);
            geometry.add(inner);
            geometry.add(lines);
            
            this.targetingIndicator = geometry;
            this.targetingIndicator.rotation.x = Math.PI / 2;
            this.scene.add(this.targetingIndicator);
        }
        
        // Update position - INCREASE HEIGHT
        this.targetingIndicator.position.copy(targetPoint);
        this.targetingIndicator.position.y = 0.5; // Much higher above the terrain
        
        // Update color based on weapon type
        const colors = {
            'LASER': new THREE.Color(0x00ffff),
            'GRENADE': new THREE.Color(0xff4500),
            'BOUNCE': new THREE.Color(0x00ff99)
        };
        const color = colors[this.currentWeapon] || colors['LASER'];
        
        // Only update colors if they've changed
        if (!this.lastWeaponColor || this.lastWeaponColor !== this.currentWeapon) {
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
            this.lastWeaponColor = this.currentWeapon;
        }
        
        // Simplified pulse animation
        if (!this.targetingIndicator.pulse) {
            this.targetingIndicator.pulse = 0;
        }
        this.targetingIndicator.pulse = (this.targetingIndicator.pulse + 0.1) % (Math.PI * 2);
        const pulseScale = 1.0 + 0.1 * Math.sin(this.targetingIndicator.pulse);
        this.targetingIndicator.scale.setScalar(pulseScale);
        
        // Show indicator
        this.targetingIndicator.visible = true;
        
        // Reset fade timeout
        if (this.targetingTimeout) {
            clearTimeout(this.targetingTimeout);
        }
        this.targetingTimeout = setTimeout(() => {
            if (this.targetingIndicator && this.targetingIndicator.visible) {
                this.targetingIndicator.visible = false;
            }
        }, 1000);
        
        // Extract target direction for firing
        const direction = new THREE.Vector3()
            .subVectors(targetPoint, this.playerShip.position)
            .normalize();
        
        // Store direction for firing
        this.targetDirection = direction;
    }
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggleMiniMap() {
    if (this.miniMap) {
      this.miniMap.toggle();
    }
  }
  
  // Add cleanup method
  cleanup() {
    // Stop and remove all sounds
    this.soundPools.forEach(pool => {
      pool.forEach(wrapper => {
        if (wrapper.sound.isPlaying) {
          wrapper.sound.stop();
        }
        wrapper.sound.buffer = null;
      });
    });
    
    // Clear sound pools and loaded sounds
    this.soundPools.clear();
    this.loadedSounds.clear();
    this.soundLoadPromises.clear();
    
    // Remove audio listener from camera
    if (this.audioListener) {
      this.camera.remove(this.audioListener);
      this.audioListener = null;
    }
    
    // Remove event listeners
    window.removeEventListener('resize', this.boundHandleResize);
    document.removeEventListener('keydown', this.boundHandleKeyDown);
    document.removeEventListener('keyup', this.boundHandleKeyUp);
    document.removeEventListener('click', this.boundHandleClick);
    document.removeEventListener('mousemove', this.boundHandleMouseMove);
    
    // Clear timers
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = null;
    }
    
    if (this.mouseMoveTimer) {
      clearTimeout(this.mouseMoveTimer);
      this.mouseMoveTimer = null;
    }
    
    // Clear weapon cooldowns
    this.weaponCooldowns.clear();
    
    // Clear key states
    Object.keys(this.keys).forEach(key => {
      this.keys[key] = false;
    });
    this.activeKeys.clear();
  }

  startGame() {
    console.log("Starting game...");
    
    // Get player name from input
    const playerNameInput = document.getElementById('player-name');
    this.playerName = playerNameInput.value.trim() || 'Pilot-' + Math.floor(Math.random() * 1000);
    
    // Hide start screen
    const startScreen = document.getElementById('start-screen');
    startScreen.classList.add('hidden');
    
    // Enable multiplayer mode by default
    this.multiplayerEnabled = true;
    
    // Connect to server
    if (this.networkManager) {
      this.networkManager.connect();
      
      // Show multiplayer info UI
      const multiplayerInfo = document.getElementById('multiplayer-info');
      if (multiplayerInfo) {
        multiplayerInfo.classList.remove('hidden');
      }
      
      // Update player info on server
      this.networkManager.updatePlayerInfo(this.playerName, this.currentShipType || 'default');
    }
    
    // Show ship selection screen
    this.showShipSelection();
  }

  showShipSelection() {
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
      console.error('Game container not found');
      return;
    }

    // Initialize ship selection if not already done
    if (!this.shipSelection) {
      this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
          this.shipSelection.hide();
          this.startGameplay(selection);
        }
      });
    }
    this.shipSelection.show();
  }

  startGameplay(shipSelection) {
    console.log('🔍 Starting gameplay with ship selection:', shipSelection);
    
    // First apply the ship selection
    this.applyShipSelection(shipSelection);
    
    // Set game as running (if this property exists)
    this.isRunning = true;
    
    // Show game UI (using either method)
    if (typeof this.ui !== 'undefined' && typeof this.ui.show === 'function') {
        this.ui.show();
    } else {
        // Show game UI directly
        const gameUI = document.querySelector('.game-ui');
        if (gameUI) {
            gameUI.classList.remove('hidden');
        }
    }
    
    // Show mini-map if it exists
    if (this.miniMap && typeof this.miniMap.show === 'function') {
        this.miniMap.show();
    }
    
    // Create and show controls if not already created
    if (!this.controlsContainer && typeof this.createControlIndicators === 'function') {
        this.createControlIndicators();
    }
    this.fadeInControls();
    
    // IMPORTANT: Double-check that the player ship has a proper collision radius
    if (this.playerShip) {
        this.playerShip.userData.collisionRadius = 0.35; // Use the same reduced value as defined earlier
        console.log('🛡️ Verified player ship collision radius:', this.playerShip.userData.collisionRadius);
    } else {
        console.error('⚠️ Player ship not available when starting gameplay!');
    }
    
    // Manually check for collisions once to make sure it's working
    setTimeout(() => {
        console.log('🔍 Running initial collision check...');
        this.checkObstacleCollisions();
    }, 500);

    // Start animation loop
    this.animate();
    
    console.log('✅ Game started successfully!');
  }

  applyShipSelection(selection) {
    console.log('🔍 Applying ship selection:', selection);
    
    // Clear existing ship model
    if (this.playerShip) {
        // Remove all children (previous ship model)
        while (this.playerShip.children.length > 0) {
            const child = this.playerShip.children[0];
            this.playerShip.remove(child);
        }
    }
    
    // Set ship model based on selection
    const type = selection.type.toUpperCase(); // Make sure it's uppercase for consistency
    this.setShipModel(type);
    this.currentShipType = type;
    
    // Position ship at a random location in the playing area
    // Avoid spawning too close to the center (where other players might spawn)
    const spawnRadius = 30; // Radius from center for spawning
    const randomAngle = Math.random() * Math.PI * 2; // Random angle
    const randomDistance = spawnRadius * (0.5 + Math.random() * 0.5); // Between 50% and 100% of spawn radius
    
    // Calculate position
    const spawnX = Math.cos(randomAngle) * randomDistance;
    const spawnZ = Math.sin(randomAngle) * randomDistance;
    
    // Set player ship position
    if (this.playerShip) {
        this.playerShip.position.set(spawnX, this.playerShip.position.y, spawnZ);
        
        // Set random rotation
        this.playerShip.rotation.y = Math.random() * Math.PI * 2;
        
        console.log(`Player spawned at position: [${spawnX.toFixed(2)}, ${spawnZ.toFixed(2)}], rotation: ${this.playerShip.rotation.y.toFixed(2)}`);
    }
    
    // Apply ship color if specified
    if (selection.color && this.playerShip) {
        const color = new THREE.Color(selection.color);
        
        // Apply color to all meshes in the ship model
        this.playerShip.traverse(child => {
            if (child.isMesh && child.material) {
                try {
                    // Clone the material to avoid affecting other instances
                    if (!child.material._isCloned) {
                        child.material = child.material.clone();
                        child.material._isCloned = true;
                    }
                    
                    // Update material color properties with safety checks
                    if (child.material.color) {
                        child.material.color.set(color);
                    }
                    
                    if (child.material.emissive) {
                        child.material.emissive.set(color);
                        child.material.emissiveIntensity = 0.3;
                    }
                    
                    // Update the material
                    child.material.needsUpdate = true;
                } catch (error) {
                    console.warn('Error setting material properties:', error);
                }
            }
        });
    }
    
    console.log('✅ Ship configuration applied successfully');
    
    // Verify collision detection is working
    console.log('🔍 Verifying collision detection is working');
}

exitToMainMenu() {
    // Stop animation loop
    this.isRunning = false;

    // Hide in-game menu if it exists
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
      menuContainer.classList.add('hidden');
    }

    // Hide game UI
    this.ui.hide();
    if (this.miniMap) {
      this.miniMap.hide();
    }
    this.fadeOutControls();

    // Clean up ship selection if it exists
    if (this.shipSelection) {
      this.shipSelection.hide();
    }

    // Show start screen
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
      startScreen.classList.add('fade-in');
    }

    // Reset game state
    this.resetGameState();
  }

  resetGameState() {
    console.log('🔄 Resetting game state...');
    
    // Reset player position
    if (this.playerShip) {
        this.playerShip.position.set(0, 0.5, 0);
        this.playerShip.rotation.set(0, 0, 0);
    }
    
    // Reset camera to original position
    if (this.camera) {
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);
    }
    
    // Reset player stats
    this.health = this.maxHealth || 100;
    this.energy = this.maxEnergy || 100;
    
    // Update UI - use existing methods if available
    if (typeof this.updateUI === 'function') {
        this.updateUI();
    } else {
        // Update health bar
        const healthBar = document.querySelector('.health-bar .bar-inner');
        if (healthBar) {
            healthBar.style.width = '100%';
        }
        
        // Update energy bar
        const energyBar = document.querySelector('.energy-bar .bar-inner');
        if (energyBar) {
            energyBar.style.width = '100%';
        }
    }
    
    // Original way of clearing lasers
    if (this.lasers) {
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            const laser = this.lasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.lasers = [];
    }
    
    // Clear bouncing lasers
    if (this.bouncingLasers) {
        for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
            const laser = this.bouncingLasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.bouncingLasers = [];
    }
    
    // Clear grenades
    if (this.grenades) {
        for (let i = this.grenades.length - 1; i >= 0; i--) {
            const grenade = this.grenades[i];
            if (grenade.mesh && grenade.mesh.parent) {
                grenade.mesh.parent.remove(grenade.mesh);
            }
        }
        this.grenades = [];
    }
    
    // Reset movement keys
    this.keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        strafeLeft: false,
        strafeRight: false
    };
    
    // Reset weapon state to original
    this.currentWeapon = 'laser';
    this.weaponCooldown = 0;
    this.grenadeTargeting = false;
    
    // Make sure the player exists
    if (!this.playerShip) {
        this.createDefaultShip();
    }
    
    // Reset player velocity (original behavior)
    this.playerVelocity = new THREE.Vector3();
    this.playerRotation = new THREE.Vector3();
    
    // Update weapon UI - use existing method if available
    if (typeof this.updateWeaponUI === 'function') {
        this.updateWeaponUI();
    }
    
    // Update control indicators - use existing method if available
    if (typeof this.updateControlIndicators === 'function') {
        this.updateControlIndicators();
    }
    
    console.log('✅ Game state reset complete');
  }

  handleDirectionalFiring(event) {
    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);

    // Check for intersection with an invisible plane at ship's height
    const planeNormal = new THREE.Vector3(0, 1, 0);
    const shipHeight = this.playerShip.position.y;
    const plane = new THREE.Plane(planeNormal, -shipHeight);
    
    const targetPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, targetPoint);

    if (targetPoint) {
        // Calculate direction from ship to target
        const direction = targetPoint.clone().sub(this.playerShip.position).normalize();
        direction.y = 0; // Keep shots parallel to ground

        // Get the ship's current forward direction
        const shipForward = new THREE.Vector3(0, 0, 1);
        shipForward.applyQuaternion(this.playerShip.quaternion);
        shipForward.y = 0;
        shipForward.normalize();

        // Calculate the angle between ship's forward direction and target direction
        const angle = shipForward.angleTo(direction);
        
        // Only fire if the target is within a reasonable angle (e.g., 60 degrees) from ship's forward direction
        const maxFiringAngle = Math.PI / 3; // 60 degrees
        
        if (angle <= maxFiringAngle) {
            // Fire weapon in the calculated direction
            this.fireCurrentWeapon(direction);
        }
    }
  }

  fireCurrentWeapon(direction) {
    // Check weapon cooldown
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;

    if (now < weaponCooldown) {
        return;
    }

    // Define energy costs for each weapon from GAME_CONFIG
    const energyCosts = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.ENERGY_COST,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.ENERGY_COST,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.ENERGY_COST
    };

    // Check if we have enough energy
    const energyCost = energyCosts[this.currentWeapon];
    if (this.energy < energyCost) {
        console.log(`Not enough energy for ${this.currentWeapon}`);
        return;
    }

    // Set cooldown based on weapon type from GAME_CONFIG
    const cooldowns = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.COOLDOWN,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.COOLDOWN,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.COOLDOWN
    };
    const cooldownTime = cooldowns[this.currentWeapon];

    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);

    // Consume energy
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Update UI with energy change
    if (this.ui && typeof this.ui.updateEnergy === 'function') {
        this.ui.updateEnergy(this.energy, this.maxEnergy);
    }

    // Use target direction if available, otherwise use ship orientation
    let firingDirection;
    
    // If we have a targetDirection from mouse, use that instead of ship orientation
    if (this.targetDirection && (this.currentWeapon === 'LASER' || this.currentWeapon === 'BOUNCE')) {
        firingDirection = this.targetDirection.clone();
        console.log('Using mouse targeting direction:', firingDirection);
    } else {
        // Fall back to ship orientation if no target direction
        firingDirection = direction || new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        console.log('Using ship orientation direction:', firingDirection);
    }
    
    // Ensure direction is normalized
    firingDirection.normalize();
    
    // Get firing position (slightly in front of ship)
    const position = this.playerShip.position.clone().add(firingDirection.clone().multiplyScalar(1.5));
    position.y = 0.5; // Set height

    // Create weapon effect based on type
    switch (this.currentWeapon) {
        case 'LASER':
            this.fireLaser(position, firingDirection);
            this.playSound('laser');
            
            // Send laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection
                });
            }
            break;
        case 'BOUNCE':
            this.fireBouncingLaser(position, firingDirection);
            this.playSound('laser-bounce');
            
            // Send bounce laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection,
                    type: 'bounce'
                });
            }
            break;
        case 'GRENADE':
            // Grenades are handled separately through handleGrenadeTargeting
            break;
    }

    // Visual feedback for firing
    this.createMuzzleFlash(position, firingDirection);

    // Log energy state for debugging
    console.log(`Weapon fired: ${this.currentWeapon}, Energy remaining: ${this.energy}/${this.maxEnergy}`);
}

createMuzzleFlash(position, direction) {
  // Create a quick flash effect at the firing position
  const flashGeometry = new THREE.CircleGeometry(0.3, 16);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
  });
  
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position flash at the weapon position, oriented to face the camera
  flash.position.copy(position);
  flash.position.y += 0.1; // Slightly above ship
  
  // Update flash to always face camera
  flash.lookAt(this.camera.position);
  
  // Add to scene
  this.scene.add(flash);
  
  // Create flash animation with subtle scaling
  let scale = 1;
  const animate = () => {
    scale += 0.2;
    flash.scale.set(scale, scale, scale);
    
    // Reduce opacity as flash grows
    if (flash.material) {
      flash.material.opacity = Math.max(0, 1 - (scale - 1) / 2);
      
      // Remove when fully transparent
      if (flash.material.opacity <= 0) {
        this.scene.remove(flash);
        if (flash.material) flash.material.dispose();
        if (flash.geometry) flash.geometry.dispose();
        return;
      }
    }
    
    // Continue animation
    requestAnimationFrame(animate);
  };
  animate();
}

  fireLaser(position, direction) {
    // Create laser geometry - make it longer and thinner for better visual
    const geometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
    geometry.rotateX(-Math.PI / 2); // Changed rotation to negative to flip direction

    // Create glowing material with better visual effects
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Orient laser along direction - using lookAt for more accurate direction
    const targetPos = position.clone().add(direction.clone().multiplyScalar(10));
    laser.lookAt(targetPos);

    // Add to scene
    this.scene.add(laser);

    // Add point light for glow effect with better parameters
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.set(0, 0, 0); // Center of the laser
    laser.add(light);

    // Add a trail effect
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    this.scene.add(trail);

    // Initialize lasers array if it doesn't exist
    if (!this.lasers) {
      this.lasers = [];
    }

    // Store laser data with enhanced properties
    this.lasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 1.2, // Slightly increased speed for better feel
      lifeTime: 0,
      maxLifeTime: 40,
      trailPoints: [],
      pulsePhase: 0
    });
  }

  fireBouncingLaser(position, direction) {
    // Create bouncing laser geometry - using a smaller sphere for better visuals
    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff99,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Add point light for glow effect
    const light = new THREE.PointLight(0x00ff99, 2, 3);
    laser.add(light);

    // Create enhanced trail effect
    const trail = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({
        color: 0x00ff99,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      })
    );

    // Add to scene
    this.scene.add(laser);
    this.scene.add(trail);

    // Initialize bouncing lasers array if it doesn't exist
    if (!this.bouncingLasers) {
      this.bouncingLasers = [];
    }

    // Store bouncing laser data with improved parameters
    this.bouncingLasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 0.8, // Increased speed for better feel
      bounces: 0,
      maxBounces: 3,
      lifeTime: 0,
      maxLifeTime: 120,
      canHitPlayer: false,
      bounceTimeout: 15, // Reduced timeout for better gameplay
      trailPoints: [],
      pulsePhase: 0
    });
  }

  createHitEffect(position) {
    // Create particle burst effect
    const particleCount = 15;
    const particles = [];
    
    // Create particle material with orange/red color for explosion
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.2, 0.2);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity in all directions
      const velocity = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0;
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.5, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(this.camera.position);
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0xff6600, 3, 6);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles and effects
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }

  showInGameMenu() {
    // Pause the game
    this.isRunning = false;
    
    // Create or reuse the menu element
    let menuContainer = document.getElementById('in-game-menu');
    if (!menuContainer) {
      menuContainer = document.createElement('div');
      menuContainer.id = 'in-game-menu';
      menuContainer.className = 'menu-container';
      document.getElementById('game-container').appendChild(menuContainer);
      
      // Style the menu
      menuContainer.style.position = 'absolute';
      menuContainer.style.top = '50%';
      menuContainer.style.left = '50%';
      menuContainer.style.transform = 'translate(-50%, -50%)';
      menuContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      menuContainer.style.padding = '20px';
      menuContainer.style.borderRadius = '10px';
      menuContainer.style.color = '#fff';
      menuContainer.style.textAlign = 'center';
      menuContainer.style.zIndex = '1000';
      menuContainer.style.border = '2px solid #00ffff';
      menuContainer.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
      menuContainer.style.minWidth = '300px';
    }
    
    // Create menu content
    menuContainer.innerHTML = `
      <h2 style="color: #00ffff; margin-top: 0;">Game Menu</h2>
      <div class="menu-options">
        <button id="resume-button" class="menu-button">Resume Game</button>
        <button id="change-ship-button" class="menu-button">Change Ship</button>
        <button id="exit-button" class="menu-button">Exit to Main Menu</button>
      </div>
    `;
    
    // Style buttons
    const buttons = menuContainer.querySelectorAll('.menu-button');
    buttons.forEach(button => {
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.padding = '10px';
      button.style.margin = '10px 0';
      button.style.backgroundColor = '#001a33';
      button.style.color = '#00ffff';
      button.style.border = '1px solid #00ffff';
      button.style.borderRadius = '5px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '16px';
      button.style.transition = 'all 0.2s';
      
      // Hover effect
      button.onmouseenter = () => {
        button.style.backgroundColor = '#00ffff';
        button.style.color = '#001a33';
      };
      button.onmouseleave = () => {
        button.style.backgroundColor = '#001a33';
        button.style.color = '#00ffff';
      };
    });
    
    // Add event listeners
    document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
    document.getElementById('change-ship-button').addEventListener('click', () => this.showShipChangeScreen());
    document.getElementById('exit-button').addEventListener('click', () => this.exitToMainMenu());
    
    // Show the menu
    menuContainer.classList.remove('hidden');
  }
  
  resumeGame() {
    console.log('Hiding menus');
    
    // Hide ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
    }
    
    // Hide menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
  }
  
  showShipChangeScreen() {
    // Hide the menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
    
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
        console.error('Game container not found');
        return;
    }
    
    // Clean up existing ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
        
        // Safely remove the element from DOM if it exists and has a parent
        if (this.shipSelection.element && this.shipSelection.element.parentNode) {
            this.shipSelection.element.parentNode.removeChild(this.shipSelection.element);
        }
        
        this.shipSelection = null;
    }
    
    // Create new ship selection instance
    this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
            this.shipSelection.hide();
            this.applyShipSelection(selection);
        }
    });
    
    // Show the ship selection UI
    this.shipSelection.show();
  }

  /**
   * Calculate proper ground offset for an object based on its type and geometry
   */
  calculateGroundOffset(model, category, scale) {
    // Get the bounding box
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Calculate the distance from the object's pivot to its bottom
    const pivotToBottom = bbox.min.y;
    
    // The base offset is the distance needed to move the object so its bottom touches the ground
    let groundOffset = -pivotToBottom;
    
    // Add category-specific adjustments with more refined values
    switch(category) {
      case 'rocks':
        // Rocks typically need to be slightly embedded in the ground
        groundOffset += size.y * 0.08;
        break;
      case 'flora':
        // Flora should be firmly planted in the ground
        groundOffset += size.y * 0.03;
        break;
      case 'groundFeatures':
        // Ground features should be partially embedded, varying by model
        if (model.name && model.name.includes('Ground02')) {
          groundOffset += size.y * 0.15; // SP_Ground02 needs more embedding
        } else if (model.name && model.name.includes('Ground05')) {
          groundOffset += size.y * 0.05; // SP_Ground05 needs less embedding
        } else {
          groundOffset += size.y * 0.1; // Default for other ground features
        }
        break;
      case 'crystals':
        // Crystals should appear to be growing from the ground
        groundOffset += size.y * 0.15;
        break;
      case 'mountains':
        // Mountains need to be firmly embedded with varying depths
        const mountainDepth = 0.08 + (Math.random() * 0.05); // Random depth between 8-13%
        groundOffset += size.y * mountainDepth;
        break;
      case 'centerpiece':
        // Centerpiece gets special treatment
        groundOffset += size.y * 0.12;
        break;
      default:
        // Default adjustment for unknown types
        groundOffset += 0;
    }
    
    // Scale the offset according to the object's scale
    // Add a small global offset to prevent z-fighting
    return (groundOffset * scale) + 0.01;
  }

  /**
   * Create a special centerpiece for the landscape
   */
  createCenterpiece() {
    // Create a special formation at a designated spot
    const centerpiece = {
      position: new THREE.Vector3(0, 0, -35), // Prominent position
      models: [
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 2.5, offset: new THREE.Vector3(0, 0, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.8, offset: new THREE.Vector3(2, 0, 1), rotation: Math.PI/4 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.6, offset: new THREE.Vector3(-1.5, 0, -1), rotation: -Math.PI/5 },
        { path: 'assets/models/objects/SP_Ground05.glb', scale: 2.0, offset: new THREE.Vector3(0, -0.5, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Stone01.glb', scale: 1.2, offset: new THREE.Vector3(2.5, 0, -1.5), rotation: Math.PI/3 }
      ]
    };
    
    // Load each model in the centerpiece
    centerpiece.models.forEach((model, index) => {
      const loader = new GLTFLoader();
      loader.load(
        model.path,
        (gltf) => {
          const object = gltf.scene;
          
          // Apply scale
          object.scale.set(model.scale, model.scale, model.scale);
          
          // Position relative to centerpiece
          object.position.copy(centerpiece.position.clone().add(model.offset));
          
          // Apply rotation
          object.rotation.y = model.rotation;
          
          // Add special glow effect for crystals
          if (model.path.includes('Crystal')) {
            object.traverse(node => {
              if (node.isMesh && node.material) {
                node.material.emissive = new THREE.Color(0xff00ff);
                node.material.emissiveIntensity = 0.5;
                
                // Add a point light for extra effect
                const light = new THREE.PointLight(0xff00ff, 2, 10);
                light.position.set(0, 2 * model.scale, 0);
                object.add(light);
              }
            });
          }
          
          // Add to scene
          this.scene.add(object);
          
          // Create collision data
          const bbox = new THREE.Box3().setFromObject(object);
          const size = bbox.getSize(new THREE.Vector3());
          
          // Use improved ground placement
          const groundY = this.calculateGroundOffset(object, 'centerpiece', model.scale);
          object.position.y = groundY + model.offset.y; // Add the intentional offset for composition
          
          // Generate compound collision shapes
          const collisionShapes = this.generateCompoundCollisionShapes(object, 'centerpiece', model.scale);
          
          // Add to obstacles
          this.obstacles.push({
            mesh: object,
            type: 'centerpiece',
            collisionShape: 'compound',
            compoundShapes: collisionShapes.map(shape => {
              // Transform shape centers to world coordinates
              const worldCenter = shape.center.clone();
              worldCenter.add(object.position);
              
              return {
                ...shape,
                center: worldCenter,
                worldRotation: object.rotation.y + (shape.rotation || 0)
              };
            }),
            boundingBox: {
              min: new THREE.Vector3(
                object.position.x - (size.x * model.scale / 2),
                object.position.y - (size.y * model.scale / 2),
                object.position.z - (size.z * model.scale / 2)
              ),
              max: new THREE.Vector3(
                object.position.x + (size.x * model.scale / 2),
                object.position.y + (size.y * model.scale / 2),
                object.position.z + (size.z * model.scale / 2)
              ),
              size: size.clone().multiplyScalar(model.scale),
              rotation: object.rotation.y
            },
            size: Math.max(size.x, size.z) * model.scale * 0.5,
            position: object.position.clone()
          });
          
          console.log(`Centerpiece: Added ${model.path.split('/').pop()} at position [${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)}]`);
        },
        undefined,
        (error) => {
          console.error(`Error loading centerpiece model ${model.path}:`, error);
        }
      );
    });
  }

  /**
   * Create a special effect when colliding with crystals
   */
  createCrystalCollisionEffect(position, isSpecial = false) {
    // Create particles for crystal collision
    const particleCount = isSpecial ? 30 : 15;
    const color = isSpecial ? 0xff00ff : 0x00ffff;
    
    for (let i = 0; i < particleCount; i++) {
      // Create a small glowing cube
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      
      // Position at collision point
      particle.position.copy(position);
      
      // Add small random offset
      particle.position.x += (Math.random() - 0.5) * 2;
      particle.position.y += Math.random() * 3;
      particle.position.z += (Math.random() - 0.5) * 2;
      
      // Add to scene
      this.scene.add(particle);
      
      // Create velocity for particle
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.2 + 0.1,
        (Math.random() - 0.5) * 0.2
      );
      
      // Animate the particle
      const startTime = Date.now();
      const duration = 1000 + Math.random() * 1000; // 1-2 seconds
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Remove particle when animation completes
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return;
        }
        
        // Update position
        particle.position.add(velocity);
        
        // Slow down over time
        velocity.multiplyScalar(0.98);
        
        // Fade out
        particle.material.opacity = 0.8 * (1 - progress);
        
        // Continue animation
        requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
    }
  }

  /**
   * Generate compound collision shapes for more accurate collision detection
   */
  generateCompoundCollisionShapes(model, category, scale) {
    // Generate a compound collision shape based on model geometry and category
    const shapes = [];
    const bbox = new THREE.Box3().setFromObject(model);
    
    // Helper function to add a box shape
    const addBoxShape = (center, size, rotation = 0) => {
      shapes.push({
        type: 'box',
        center: center.clone(),
        halfExtents: size.clone().multiplyScalar(0.5),
        rotation: rotation
      });
    };
    
    // Helper function to add a sphere shape
    const addSphereShape = (center, radius) => {
      shapes.push({
        type: 'sphere',
        center: center.clone(),
        radius: radius
      });
    };
    
    // Different collision shape strategies based on category
    switch(category) {
      case 'rocks':
        // For rocks, use 1-3 overlapping boxes based on size
        const rockSize = bbox.getSize(new THREE.Vector3());
        const rockCenter = new THREE.Vector3();
        bbox.getCenter(rockCenter);
        
        // Main box
        addBoxShape(rockCenter, rockSize);
        
        // For larger rocks, add 1-2 more boxes at slight offsets for better shape approximation
        if (rockSize.x > 1.5 * scale || rockSize.z > 1.5 * scale) {
          // Add a second box, slightly offset and rotated
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3 * rockSize.x,
            0,
            (Math.random() - 0.5) * 0.3 * rockSize.z
          );
          
          const secondSize = new THREE.Vector3(
            rockSize.x * (0.7 + Math.random() * 0.3),
            rockSize.y * 0.9,
            rockSize.z * (0.7 + Math.random() * 0.3)
          );
          
          addBoxShape(rockCenter.clone().add(offset), secondSize, Math.PI * 0.25);
          
          // For very large rocks, add a third box
          if (rockSize.x > 2.5 * scale || rockSize.z > 2.5 * scale) {
            const thirdOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4 * rockSize.x,
              rockSize.y * 0.2,
              (Math.random() - 0.5) * 0.4 * rockSize.z
            );
            
            const thirdSize = new THREE.Vector3(
              rockSize.x * (0.6 + Math.random() * 0.2),
              rockSize.y * 0.7,
              rockSize.z * (0.6 + Math.random() * 0.2)
            );
            
            addBoxShape(rockCenter.clone().add(thirdOffset), thirdSize, Math.PI * 0.125);
          }
        }
        break;
        
      case 'flora':
        // For flora, use a smaller box for the base and a sphere for the top
        const floraSize = bbox.getSize(new THREE.Vector3());
        const floraCenter = new THREE.Vector3();
        bbox.getCenter(floraCenter);
        
        // Box for the base/stem
        const stemSize = new THREE.Vector3(
          floraSize.x * 0.2,
          floraSize.y * 0.6,
          floraSize.z * 0.2
        );
        
        const stemCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (stemSize.y / 2),
          floraCenter.z
        );
        
        addBoxShape(stemCenter, stemSize);
        
        // Sphere for the top/foliage
        const foliageCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (floraSize.y * 0.7),
          floraCenter.z
        );
        
        const foliageRadius = Math.max(floraSize.x, floraSize.z) * 0.5;
        addSphereShape(foliageCenter, foliageRadius);
        break;
        
      case 'mountains':
        // For mountains, use a pyramid-like composition of boxes
        const mountainSize = bbox.getSize(new THREE.Vector3());
        const mountainCenter = new THREE.Vector3();
        bbox.getCenter(mountainCenter);
        
        // Base box (wider)
        const baseSize = new THREE.Vector3(
          mountainSize.x,
          mountainSize.y * 0.3,
          mountainSize.z
        );
        
        const baseCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + (baseSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(baseCenter, baseSize);
        
        // Middle box (narrower)
        const middleSize = new THREE.Vector3(
          mountainSize.x * 0.8,
          mountainSize.y * 0.4,
          mountainSize.z * 0.8
        );
        
        const middleCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + (middleSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(middleCenter, middleSize);
        
        // Top box (narrowest)
        const topSize = new THREE.Vector3(
          mountainSize.x * 0.5,
          mountainSize.y * 0.3,
          mountainSize.z * 0.5
        );
        
        const topCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + middleSize.y + (topSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(topCenter, topSize);
        break;
        
      case 'crystals':
        // For crystals, use a combination of boxes at different angles
        const crystalSize = bbox.getSize(new THREE.Vector3());
        const crystalCenter = new THREE.Vector3();
        bbox.getCenter(crystalCenter);
        
        // Calculate a better fitting box size (narrower)
        const mainCrystalSize = new THREE.Vector3(
          crystalSize.x * 0.7,
          crystalSize.y,
          crystalSize.z * 0.7
        );
        
        // Add the main crystal shape
        addBoxShape(crystalCenter, mainCrystalSize, model.rotation.y);
        
        // For larger crystals, add some angled shards
        if (crystalSize.y > 1.0 * scale) {
          // Add up to 3 additional shards
          const shardCount = 1 + Math.floor(Math.random() * 3);
          
          for (let i = 0; i < shardCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = crystalSize.x * 0.3;
            
            const offset = new THREE.Vector3(
              Math.cos(angle) * distance,
              crystalSize.y * (Math.random() * 0.2),
              Math.sin(angle) * distance
            );
            
            const shardSize = new THREE.Vector3(
              crystalSize.x * (0.2 + Math.random() * 0.3),
              crystalSize.y * (0.4 + Math.random() * 0.4),
              crystalSize.z * (0.2 + Math.random() * 0.3)
            );
            
            const shardRotation = Math.random() * Math.PI;
            addBoxShape(crystalCenter.clone().add(offset), shardSize, shardRotation);
          }
        }
        break;
        
      case 'groundFeatures':
        // For ground features, use a more accurate horizontal shape with the right height
        const groundSize = bbox.getSize(new THREE.Vector3());
        const groundCenter = new THREE.Vector3();
        bbox.getCenter(groundCenter);
        
        // Just use a single box but with better proportions
        const adjustedSize = new THREE.Vector3(
          groundSize.x,
          groundSize.y * 0.7, // Lower height to prevent floating
          groundSize.z
        );
        
        // Center it properly on the ground
        const adjustedCenter = new THREE.Vector3(
          groundCenter.x,
          bbox.min.y + (adjustedSize.y / 2),
          groundCenter.z
        );
        
        addBoxShape(adjustedCenter, adjustedSize, model.rotation.y);
        break;
        
      case 'centerpiece':
        // For centerpiece, create a custom multi-part shape
        const centerpieceSize = bbox.getSize(new THREE.Vector3());
        const centerpieceCenter = new THREE.Vector3();
        bbox.getCenter(centerpieceCenter);
        
        // Main box
        addBoxShape(centerpieceCenter, centerpieceSize);
        
        // Add a sphere on top for the crystal parts
        const sphereCenter = new THREE.Vector3(
          centerpieceCenter.x,
          centerpieceCenter.y + (centerpieceSize.y * 0.2),
          centerpieceCenter.z
        );
        
        const sphereRadius = Math.max(centerpieceSize.x, centerpieceSize.z) * 0.6;
        addSphereShape(sphereCenter, sphereRadius);
        break;
        
      default:
        // Default: just use a box based on the bounding box
        const size = bbox.getSize(new THREE.Vector3());
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        addBoxShape(center, size);
        break;
    }
    
    return shapes;
  }

  updateOtherPlayers() {
    if (!this.networkManager || !this.multiplayerEnabled || !this.assetLoader) return;
  
    const otherPlayers = this.networkManager.getOtherPlayers();
    if (!this.otherPlayerObjects) this.otherPlayerObjects = {};
  
    otherPlayers.forEach(playerData => {
      let playerObject = this.otherPlayerObjects[playerData.id];
  
      if (!playerObject) {
        console.log('Creating new player representation for:', playerData.id);
        const shipType = (playerData.shipType || 'STANDARD').toUpperCase();
        const shipModel = this.assetLoader.getOpponentShipModel(shipType);
  
        if (!shipModel) {
          console.warn(`No model found for ship type: ${shipType}, falling back to default`);
          // Fallback geometry if model fails
          const geometry = new THREE.ConeGeometry(0.5, 1.0, 8);
          geometry.rotateX(Math.PI / 2);
          const material = new THREE.MeshPhongMaterial({ 
            color: playerData.teamColor || 0x00ffff,
            emissive: playerData.teamColor || 0x00ffff,
            emissiveIntensity: 0.5
          });
          const ship = new THREE.Mesh(geometry, material);
          this.scene.add(ship);
          playerObject = { ship, lastUpdate: Date.now() };
        } else {
          // Scale the model consistently (matching player ship scaling)
          shipModel.scale.set(0.45, 0.45, 0.45);
          this.scene.add(shipModel);
          playerObject = { ship: shipModel, lastUpdate: Date.now() };
        }
  
        // Add engine glow
        const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
        engineGlow.position.set(0, 0, -0.7);
        playerObject.ship.add(engineGlow);
        playerObject.engineGlow = engineGlow;
  
        // Add name label
        const nameDiv = document.createElement('div');
        nameDiv.className = 'player-label';
        nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
        const nameLabel = new CSS2DObject(nameDiv);
        nameLabel.position.set(0, 1.8, 0);
        playerObject.ship.add(nameLabel);
        playerObject.nameLabel = nameLabel;
  
        this.otherPlayerObjects[playerData.id] = playerObject;
      }
  
      // Update position and rotation
      if (playerData.position) {
        playerObject.ship.position.lerp(
          new THREE.Vector3(playerData.position.x, playerData.position.y || 0.5, playerData.position.z),
          0.3
        );
      }
      if (playerData.rotation !== undefined) {
        const targetY = playerData.rotation;
        let rotDiff = targetY - playerObject.ship.rotation.y;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerObject.ship.rotation.y += rotDiff * 0.3;
      }
  
      playerObject.lastUpdate = Date.now();
    });
  
    // Clean up disconnected players
    const now = Date.now();
    Object.keys(this.otherPlayerObjects).forEach(id => {
      const playerObj = this.otherPlayerObjects[id];
      if (now - playerObj.lastUpdate > 10000) {
        console.log('Removing disconnected player:', id);
        this.scene.remove(playerObj.ship);
        delete this.otherPlayerObjects[id];
        this.updatePlayerCount();
      }
    });
  }

  // Helper method to send player position and rotation to the server
  sendPlayerPositionUpdate() {
    if (!this.playerShip || !this.networkManager || !this.networkManager.isConnected()) return;
    
    // Create a simple data object with player information
    const playerData = {
      position: {
        x: this.playerShip.position.x,
        y: this.playerShip.position.y,
        z: this.playerShip.position.z
      },
      rotation: this.playerShip.rotation.y,
      shipType: this.currentShipType || 'STANDARD',
      name: this.playerName
    };
    
    // Send the update to the network manager
    this.networkManager.sendPlayerUpdate(playerData);
  }

  // Add the missing setShipModel function
  setShipModel(type) {
    console.log('🔍 Setting ship model:', type);
    
    // Get the ship model from assets
    let model = this.assetLoader.getShipModel(type);
    
    // If model is null or undefined, create fallback model
    if (!model) {
      console.warn('⚠️ Using fallback ship model for type:', type);
      
      // Create a simple geometric shape as fallback
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, 
        specular: 0x111111, 
        shininess: 30 
      });
      model = new THREE.Mesh(geometry, material);
    }
    
    // Clear existing player ship if it exists
    if (this.playerShip) {
      if (this.scene) {
        this.scene.remove(this.playerShip);
      }
      this.playerShip = null;
    }
    
    // Set the new ship model
    this.playerShip = model;
    
    // Position the ship appropriately
    if (this.playerShip && this.scene) {
      this.playerShip.position.set(0, 0.5, 0);
      this.scene.add(this.playerShip);
    }
    
    return this.playerShip;
  }

  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.soundManager) {
      console.log(`Playing sound: ${name}`);
      this.soundManager.playSound(name, position);
    } else {
      console.warn(`Cannot play sound '${name}': SoundManager not initialized`);
    }
  }

  /**
   * Update a remote player's position and rotation
   * @param {string} id - Player ID
   * @param {Object} position - Position coordinates
   * @param {Object} rotation - Rotation coordinates
   */
  updateRemotePlayer(id, position, rotation) {
    // Get existing player or create a new one
    let player = this.remotePlayers.get(id);
    
    if (!player) {
      // Create a new player mesh if this is the first update
      player = this.createRemotePlayerMesh();
      this.remotePlayers.set(id, player);
      this.scene.add(player);
      console.log(`Created new remote player: ${id}`);
    }
    
    // Update player position and rotation
    if (position) {
      player.position.set(position.x, position.y, position.z);
    }
    
    if (rotation) {
      player.rotation.set(rotation.x, rotation.y, rotation.z);
    }
  }
  
  /**
   * Create a mesh for a remote player
   * @returns {THREE.Object3D} Player mesh
   */
  createRemotePlayerMesh() {
    // For simplicity, we'll use a simple colored box for remote players
    const geometry = new THREE.BoxGeometry(1, 1, 2);
    const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red for other players
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'player-label';
    nameLabel.textContent = 'Player';
    
    const playerLabel = new CSS2DObject(nameLabel);
    playerLabel.position.set(0, 1.5, 0);
    mesh.add(playerLabel);
    
    return mesh;
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize game
  const game = new SimpleGame();
  
  // Add start button event listener
  document.getElementById('start-button').addEventListener('click', () => {
    // Get the player name from the input field
    const playerNameInput = document.getElementById('player-name');
    if (playerNameInput && playerNameInput.value.trim() !== '') {
      // Store the player name
      game.playerName = playerNameInput.value.trim();
      console.log(`Player name set to: ${game.playerName}`);
    } else {
      console.log('Using default player name: ' + game.playerName);
    }
    
    // Start the game
    game.startGame();
  });
}); 
### ./index.js END ###


### ./codebase.md END ###

### ./ui/ShipSelectionUI.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import { ShipSelector, SHIP_TYPES, SHIP_STATUS } from '../config/ShipConfig';
import { TEAM_COLORS } from '../core/TeamManager';
import AssetLoader from '../assets/AssetLoader';

export class ShipSelectionUI {
    constructor(container, options = {}) {
        this.container = container;
        if (!this.container) {
            console.error('Game container not found');
            return;
        }
        
        this.options = {
            onShipSelect: null,
            isPremium: false,
            ...options
        };

        this.selectedShip = 'scout';
        this.selectedColor = '#00ff00';
        this.previewScene = null;
        this.previewCamera = null;
        this.previewRenderer = null;
        this.currentModel = null;
        
        // Initialize the asset loader
        this.assetLoader = new AssetLoader().setCallbacks(
            (message) => console.log(`Ship Selection: ${message}`),
            (type, error) => console.error(`Ship Selection Error: ${type} - ${error}`)
        );
        
        this.createUI();
        // Add a small delay to ensure DOM is fully ready
        setTimeout(() => {
            this.setupPreview();
            this.loadShipModels();
        }, 100);
    }

    createUI() {
        // Create main container
        this.element = document.createElement('div');
        this.element.className = 'ship-selection';
        this.element.innerHTML = `
            <div class="ship-selection-header">
                <h2>Choose Your Quantum Ship</h2>
                <div class="color-picker">
                    <label>Ship Color:</label>
                    <input type="color" value="${this.selectedColor}">
                </div>
            </div>
            <div class="ships-container">
                <div class="ship-option selected" data-ship="scout">
                    <h3>Scout</h3>
                    <p>Fast and agile, but lightly armored</p>
                    <div class="stats">
                        <div class="stat">
                            <label>Health</label>
                            <div class="stat-bar"><div style="width: 53%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Speed</label>
                            <div class="stat-bar"><div style="width: 100%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Size</label>
                            <div class="stat-bar"><div style="width: 67%"></div></div>
                        </div>
                    </div>
                </div>
                <div class="ship-option" data-ship="interceptor">
                    <h3>Interceptor</h3>
                    <p>Balanced combat vessel</p>
                    <div class="stats">
                        <div class="stat">
                            <label>Health</label>
                            <div class="stat-bar"><div style="width: 80%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Speed</label>
                            <div class="stat-bar"><div style="width: 85%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Size</label>
                            <div class="stat-bar"><div style="width: 75%"></div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="preview-section">
                <h3>Ship Preview</h3>
                <div id="ship-preview"></div>
            </div>
            <div class="ship-details">
                <div class="ship-name">Scout</div>
                <p class="ship-description">Fast and agile, but lightly armored</p>
                
                <div class="ship-details-left">
                    <div class="stat">
                        <label>Health</label>
                        <div class="stat-bar"><div style="width: 53%"></div></div>
                        <span class="stat-value">53%</span>
                    </div>
                    <div class="stat">
                        <label>Speed</label>
                        <div class="stat-bar"><div style="width: 100%"></div></div>
                        <span class="stat-value">100%</span>
                    </div>
                    <div class="stat">
                        <label>Size</label>
                        <div class="stat-bar"><div style="width: 67%"></div></div>
                        <span class="stat-value">67%</span>
                    </div>
                </div>
                
                <div class="ship-details-right">
                    <div class="special-abilities">
                        <h4>Special Abilities</h4>
                        <div class="ability">Quick Boost</div>
                        <div class="ability">Stealth Mode</div>
                    </div>
                </div>
            </div>
            <button class="launch-button">Launch</button>
        `;

        // Add to container
        this.container.appendChild(this.element);

        // Add class to properly show the UI
        this.element.classList.add('visible');

        // Setup event listeners
        this.setupEventListeners();
    }

    setupPreview() {
        // Get preview container
        this.previewContainer = this.element.querySelector('#ship-preview');
        if (!this.previewContainer) {
            console.error('Preview container not found');
            return;
        }

        // Set initial dimensions
        this.previewContainer.style.width = '100%';
        this.previewContainer.style.height = '150px';

        // Create scene
        this.previewScene = new THREE.Scene();
        this.previewScene.background = new THREE.Color(0x000011);

        // Create camera
        this.previewCamera = new THREE.PerspectiveCamera(
            65,
            this.previewContainer.clientWidth / this.previewContainer.clientHeight,
            0.1,
            1000
        );
        this.previewCamera.position.set(0, 0.3, 2.5);
        this.previewCamera.lookAt(0, 0, 0);

        // Create renderer
        this.previewRenderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        this.previewRenderer.setSize(this.previewContainer.clientWidth, this.previewContainer.clientHeight);
        this.previewRenderer.setClearColor(0x000011);
        this.previewContainer.appendChild(this.previewRenderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        this.previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1, 1, 1).normalize();
        this.previewScene.add(directionalLight);

        // Add a grid to help with orientation
        const gridHelper = new THREE.GridHelper(8, 8, 0x333333, 0x222222);
        gridHelper.position.y = -0.5;
        this.previewScene.add(gridHelper);

        // Handle window resize
        window.addEventListener('resize', () => {
            if (this.previewContainer && this.previewCamera && this.previewRenderer) {
                this.previewCamera.aspect = this.previewContainer.clientWidth / this.previewContainer.clientHeight;
                this.previewCamera.updateProjectionMatrix();
                this.previewRenderer.setSize(this.previewContainer.clientWidth, this.previewContainer.clientHeight);
            }
        });

        // Start animation
        this.animate();
    }

    setupEventListeners() {
        // Store bound handlers for cleanup
        this.boundHandleShipSelection = this.handleShipSelection.bind(this);
        this.boundHandleLaunch = this.handleLaunch.bind(this);
        this.boundHandleColorChange = this.handleColorChange.bind(this);
        this.boundHandleResize = this.handleResize.bind(this);
        
        // Ship selection - make sure to use the right selector
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(option => {
            option.addEventListener('click', this.boundHandleShipSelection);
        });
        
        // Launch button
        const launchButton = this.element.querySelector('.launch-button');
        launchButton.addEventListener('click', this.boundHandleLaunch);
        
        // Color picker
        const colorPicker = this.element.querySelector('input[type="color"]');
        colorPicker.addEventListener('change', this.boundHandleColorChange);
        
        // Handle window resize for the preview
        window.addEventListener('resize', this.boundHandleResize);
    }

    selectShip(shipType) {
        this.selectedShip = shipType;
        
        // Update details section
        const details = this.element.querySelector('.ship-details');
        const shipName = details.querySelector('.ship-name');
        const shipDesc = details.querySelector('.ship-description');
        
        const config = this.getShipConfig();
        shipName.textContent = config.name;
        shipDesc.textContent = config.description;
        
        // Update the stats
        const leftSection = details.querySelector('.ship-details-left');
        leftSection.innerHTML = '';
        
        Object.entries(config.stats).forEach(([key, value]) => {
            const percentage = Math.round(value * 100);
            const statElement = document.createElement('div');
            statElement.className = 'stat';
            statElement.innerHTML = `
                <label>${key.charAt(0).toUpperCase() + key.slice(1)}</label>
                <div class="stat-bar"><div style="width: ${percentage}%"></div></div>
                <span class="stat-value">${percentage}%</span>
            `;
            leftSection.appendChild(statElement);
        });
        
        // Update abilities
        const abilitiesContainer = details.querySelector('.special-abilities');
        abilitiesContainer.innerHTML = '<h4>Special Abilities</h4>';
        config.abilities.forEach(ability => {
            const abilityEl = document.createElement('div');
            abilityEl.className = 'ability';
            abilityEl.textContent = ability;
            abilitiesContainer.appendChild(abilityEl);
        });
        
        // Update preview
        this.updatePreview();
    }

    async loadShipModels() {
        try {
            // Load ships using the central AssetLoader
            await this.assetLoader.loadModels();
            console.log('Ship models loaded successfully via AssetLoader');
            
            // Set initial preview
            this.updatePreview();
        } catch (error) {
            console.error('Error loading ship models:', error);
        }
    }

    updatePreview() {
        // Remove current model if it exists
        if (this.currentModel) {
            this.previewScene.remove(this.currentModel);
            this.currentModel = null;
        }

        // Convert selectedShip to the format expected by AssetLoader
        const modelKey = this.selectedShip.toUpperCase();
        
        // Get the model from AssetLoader and clone it
        const model = this.assetLoader.getShipModel(modelKey);
        
        if (model) {
            this.currentModel = model;
            
            // Update material color
            this.currentModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    try {
                        // Clone material to avoid affecting other instances
                        child.material = child.material.clone();
                        
                        // Apply color with safety checks
                        if (child.material.color) {
                            child.material.color = new THREE.Color(this.selectedColor);
                        }
                        
                        if (child.material.emissive) {
                            child.material.emissive = new THREE.Color(this.selectedColor).multiplyScalar(0.3);
                        }
                        
                        child.material.needsUpdate = true;
                    } catch (error) {
                        console.warn('Error setting preview material properties:', error);
                    }
                }
            });

            // Set preview-specific scale
            this.currentModel.scale.set(0.25, 0.25, 0.25);
            this.currentModel.position.set(0, 0, 0);
            this.currentModel.rotation.set(0, 0, 0);

            // Add to scene
            this.previewScene.add(this.currentModel);
        } else {
            console.log('Model not available for preview');
        }
    }

    animate = () => {
        if (!this.previewRenderer || !this.previewScene || !this.previewCamera) {
            return;
        }
        
        requestAnimationFrame(this.animate);

        // Rotate the model if it exists
        if (this.currentModel) {
            this.currentModel.rotation.y += 0.01;
        }

        this.previewRenderer.render(this.previewScene, this.previewCamera);
    }

    getShipConfig() {
        if (this.selectedShip === 'scout') {
            return {
                type: 'fighter',
                name: 'Scout',
                description: 'Fast and agile, but lightly armored',
                stats: {
                    health: 0.53,
                    speed: 1.0,
                    size: 0.67,
                    turnSpeed: 1.0,
                    acceleration: 1.0
                },
                abilities: ['Quick Boost', 'Stealth Mode']
            };
        } else {
            return {
                type: 'experimental',
                name: 'Interceptor',
                description: 'Balanced combat vessel',
                stats: {
                    health: 0.8,
                    speed: 0.85,
                    size: 0.75,
                    turnSpeed: 0.7,
                    acceleration: 0.9
                },
                abilities: ['Shield Generator', 'EMP Burst']
            };
        }
    }

    show() {
        this.element.classList.add('visible');
    }

    hide() {
        this.element.classList.add('hidden');
    }

    updateOptions(newOptions) {
        this.options = {
            ...this.options,
            ...newOptions
        };
    }

    cleanup() {
        // Stop animation loop
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        
        // Clean up event listeners using the stored bound handlers
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(option => {
            option.removeEventListener('click', this.boundHandleShipSelection);
        });
        
        const launchButton = this.element.querySelector('.launch-button');
        if (launchButton) {
            launchButton.removeEventListener('click', this.boundHandleLaunch);
        }
        
        const colorPicker = this.element.querySelector('input[type="color"]');
        if (colorPicker) {
            colorPicker.removeEventListener('change', this.boundHandleColorChange);
        }
        
        window.removeEventListener('resize', this.boundHandleResize);
        
        // Clean up THREE.js resources
        if (this.previewRenderer) {
            this.previewRenderer.dispose();
        }
        
        if (this.previewScene) {
            // Let Three.js handle most of the cleanup, but we should clear the scene
            this.previewScene = null;
        }
        
        // No need to explicitly dispose of models as they're managed by AssetLoader
        this.previewRenderer = null;
        this.previewCamera = null;
        this.currentModel = null;
    }

    handleShipSelection = (event) => {
        const option = event.currentTarget;
        const shipType = option.dataset.ship;
        console.log(`Selecting ship: ${shipType}`);
        this.selectShip(shipType);
        
        // Update UI to show selected
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(opt => {
            opt.classList.remove('selected');
        });
        option.classList.add('selected');
    }
    
    handleLaunch = () => {
        if (this.selectedShip && this.options.onShipSelect) {
            console.log(`Launching with ship: ${this.selectedShip}`);
            
            // Create selection data in the format the game expects
            const selectionData = {
                type: this.selectedShip.toUpperCase(),
                color: this.selectedColor,
                config: this.getShipConfig()
            };
            
            // Hide UI before calling the callback
            this.hide();
            
            // Clean up resources
            this.cleanup();
            
            // First remove the element from the DOM to prevent any interference
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            
            // Then call the callback with ship selection data
            this.options.onShipSelect(selectionData);
        }
    }
    
    handleColorChange = (event) => {
        this.selectedColor = event.target.value;
        this.updatePreview();
    }
    
    handleResize = () => {
        if (this.previewRenderer && this.previewCamera) {
            const container = this.previewContainer;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            this.previewCamera.aspect = width / height;
            this.previewCamera.updateProjectionMatrix();
            
            this.previewRenderer.setSize(width, height);
        }
    }
} 
### ./ui/ShipSelectionUI.js END ###

### ./ui/GameRoom.js BEGIN ###
import * as THREE from 'three';

export class GameRoom {
  constructor(scene, size = { width: 60, height: 60 }, theme = 'space-station') {
    this.scene = scene;
    this.size = size;
    this.theme = theme;
    
    // Room properties
    this.roomObjects = [];
    this.obstacles = [];
    this.spawnPoints = [];
    this.coverPoints = [];
    this.roomCenter = new THREE.Vector3(0, 0, 0);
    
    // Generate room
    this.generateRoom();
  }
  
  generateRoom() {
    // Create room floor
    this.createFloor();
    
    // Create room walls
    this.createWalls();
    
    // Add obstacles and cover points
    this.addObstacles();
    
    // Add spawn points
    this.addSpawnPoints();
    
    // Add decorative elements
    this.addDecorations();
  }
  
  createFloor() {
    // Create floor with grid texture
    const floorGeometry = new THREE.PlaneGeometry(this.size.width, this.size.height);
    
    // Create custom shader material for grid effect
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: this.getThemeColors().floor,
      roughness: 0.8,
      metalness: 0.2,
      emissive: this.getThemeColors().floorEmissive,
      emissiveIntensity: 0.1
    });
    
    // Create floor mesh
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(0, 0, 0);
    this.scene.add(floor);
    this.roomObjects.push(floor);
    
    // Add grid lines
    this.addGridLines();
  }
  
  addGridLines() {
    // Create grid material
    const gridMaterial = new THREE.LineBasicMaterial({ 
      color: this.getThemeColors().grid,
      transparent: true,
      opacity: 0.3
    });
    
    // Create horizontal grid lines
    const gridStep = 5;
    const halfWidth = this.size.width / 2;
    const halfHeight = this.size.height / 2;
    
    const gridHelper = new THREE.GridHelper(
      Math.max(this.size.width, this.size.height), 
      Math.max(this.size.width, this.size.height) / gridStep
    );
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    gridHelper.position.y = 0.02; // Slightly above floor to prevent z-fighting
    this.scene.add(gridHelper);
    this.roomObjects.push(gridHelper);
  }
  
  createWalls() {
    // Create walls around the room
    const wallHeight = 3;
    const wallThickness = 1;
    
    // Calculate positions
    const halfWidth = this.size.width / 2;
    const halfHeight = this.size.height / 2;
    
    // Get theme wall material
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: this.getThemeColors().wall,
      emissive: this.getThemeColors().wallEmissive,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.7
    });
    
    // North Wall
    const northWall = new THREE.Mesh(
      new THREE.BoxGeometry(this.size.width + wallThickness * 2, wallHeight, wallThickness),
      wallMaterial
    );
    northWall.position.set(0, wallHeight / 2, -halfHeight - wallThickness/2);
    this.scene.add(northWall);
    this.roomObjects.push(northWall);
    this.obstacles.push({
      type: 'wall',
      position: northWall.position.clone(),
      size: new THREE.Vector3(this.size.width + wallThickness*2, wallHeight, wallThickness)
    });
    
    // South Wall
    const southWall = new THREE.Mesh(
      new THREE.BoxGeometry(this.size.width + wallThickness * 2, wallHeight, wallThickness),
      wallMaterial
    );
    southWall.position.set(0, wallHeight / 2, halfHeight + wallThickness/2);
    this.scene.add(southWall);
    this.roomObjects.push(southWall);
    this.obstacles.push({
      type: 'wall',
      position: southWall.position.clone(),
      size: new THREE.Vector3(this.size.width + wallThickness*2, wallHeight, wallThickness)
    });
    
    // East Wall
    const eastWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, this.size.height + wallThickness * 2),
      wallMaterial
    );
    eastWall.position.set(halfWidth + wallThickness/2, wallHeight / 2, 0);
    this.scene.add(eastWall);
    this.roomObjects.push(eastWall);
    this.obstacles.push({
      type: 'wall',
      position: eastWall.position.clone(),
      size: new THREE.Vector3(wallThickness, wallHeight, this.size.height + wallThickness*2)
    });
    
    // West Wall
    const westWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, this.size.height + wallThickness * 2),
      wallMaterial
    );
    westWall.position.set(-halfWidth - wallThickness/2, wallHeight / 2, 0);
    this.scene.add(westWall);
    this.roomObjects.push(westWall);
    this.obstacles.push({
      type: 'wall',
      position: westWall.position.clone(),
      size: new THREE.Vector3(wallThickness, wallHeight, this.size.height + wallThickness*2)
    });
  }
  
  addObstacles() {
    // Add between 5-10 random obstacles in the room
    const obstacleCount = 5 + Math.floor(Math.random() * 6);
    
    for (let i = 0; i < obstacleCount; i++) {
      this.addRandomObstacle();
    }
  }
  
  addRandomObstacle() {
    // Types of obstacles: block, cylinder, barrier
    const types = ['block', 'cylinder', 'barrier'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random position in the room
    const halfWidth = this.size.width / 2 - 5; // Stay away from walls
    const halfHeight = this.size.height / 2 - 5;
    
    const x = (Math.random() * 2 - 1) * halfWidth;
    const z = (Math.random() * 2 - 1) * halfHeight;
    
    // Random size
    const width = 2 + Math.random() * 5;
    const height = 1 + Math.random() * 2;
    const depth = 2 + Math.random() * 5;
    
    // Create obstacle based on type
    let mesh;
    let obstacleData = {
      type: 'obstacle',
      position: new THREE.Vector3(x, height/2, z)
    };
    
    switch (type) {
      case 'block':
        const blockGeometry = new THREE.BoxGeometry(width, height, depth);
        const blockMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.5,
          metalness: 0.5
        });
        mesh = new THREE.Mesh(blockGeometry, blockMaterial);
        mesh.position.set(x, height/2, z);
        obstacleData.size = new THREE.Vector3(width, height, depth);
        break;
        
      case 'cylinder':
        const radius = width / 2;
        const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 16);
        const cylinderMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.5,
          metalness: 0.5
        });
        mesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        mesh.position.set(x, height/2, z);
        obstacleData.radius = radius;
        obstacleData.height = height;
        break;
        
      case 'barrier':
        const barrierGeometry = new THREE.BoxGeometry(width, height, 0.5);
        const barrierMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.4,
          roughness: 0.3,
          metalness: 0.7,
          transparent: true,
          opacity: 0.8
        });
        mesh = new THREE.Mesh(barrierGeometry, barrierMaterial);
        mesh.position.set(x, height/2, z);
        
        // Random rotation
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        obstacleData.size = new THREE.Vector3(width, height, 0.5);
        obstacleData.rotation = mesh.rotation.clone();
        break;
    }
    
    this.scene.add(mesh);
    this.roomObjects.push(mesh);
    this.obstacles.push(obstacleData);
    
    // Add a cover point near this obstacle
    this.coverPoints.push(new THREE.Vector3(
      x + (Math.random() - 0.5) * 3,
      0,
      z + (Math.random() - 0.5) * 3
    ));
  }
  
  addSpawnPoints() {
    // Add spawn points in the corners
    const halfWidth = this.size.width / 2 - 8;
    const halfHeight = this.size.height / 2 - 8;
    
    // Four corners
    this.spawnPoints.push(
      new THREE.Vector3(-halfWidth, 0, -halfHeight),
      new THREE.Vector3(halfWidth, 0, -halfHeight),
      new THREE.Vector3(-halfWidth, 0, halfHeight),
      new THREE.Vector3(halfWidth, 0, halfHeight)
    );
    
    // Add a few more random spawn points
    for (let i = 0; i < 4; i++) {
      const x = (Math.random() * 2 - 1) * halfWidth;
      const z = (Math.random() * 2 - 1) * halfHeight;
      this.spawnPoints.push(new THREE.Vector3(x, 0, z));
    }
  }
  
  addDecorations() {
    // Add decorative elements based on theme
    const decorationCount = 10 + Math.floor(Math.random() * 10);
    
    // Add lights around the room
    for (let i = 0; i < decorationCount; i++) {
      this.addRandomDecoration();
    }
    
    // Add room lights
    this.addRoomLights();
  }
  
  addRandomDecoration() {
    // Types of decorations: console, crate, panel
    const types = ['console', 'crate', 'panel'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random position near walls
    const halfWidth = this.size.width / 2 - 2;
    const halfHeight = this.size.height / 2 - 2;
    
    let x, z;
    const nearWall = Math.random() > 0.5;
    
    if (nearWall) {
      // Position near a wall
      if (Math.random() > 0.5) {
        // Near east/west wall
        x = (Math.random() > 0.5 ? 1 : -1) * halfWidth;
        z = (Math.random() * 2 - 1) * halfHeight;
      } else {
        // Near north/south wall
        x = (Math.random() * 2 - 1) * halfWidth;
        z = (Math.random() > 0.5 ? 1 : -1) * halfHeight;
      }
    } else {
      // Random position
      x = (Math.random() * 2 - 1) * halfWidth;
      z = (Math.random() * 2 - 1) * halfHeight;
    }
    
    // Create decoration based on type
    let mesh;
    
    switch (type) {
      case 'console':
        const consoleGeometry = new THREE.BoxGeometry(2, 1, 1);
        const consoleMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().console,
          emissive: this.getThemeColors().consoleEmissive,
          emissiveIntensity: 0.5,
          roughness: 0.3,
          metalness: 0.8
        });
        mesh = new THREE.Mesh(consoleGeometry, consoleMaterial);
        
        // Add a light on top
        const consoleLight = new THREE.PointLight(
          this.getThemeColors().consoleLight, 
          0.5, 
          5
        );
        consoleLight.position.set(0, 1, 0);
        mesh.add(consoleLight);
        break;
        
      case 'crate':
        const crateGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const crateMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().crate,
          roughness: 0.7,
          metalness: 0.2
        });
        mesh = new THREE.Mesh(crateGeometry, crateMaterial);
        break;
        
      case 'panel':
        const panelGeometry = new THREE.PlaneGeometry(2, 1.5);
        const panelMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().panel,
          emissive: this.getThemeColors().panelEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.4,
          metalness: 0.6,
          side: THREE.DoubleSide
        });
        mesh = new THREE.Mesh(panelGeometry, panelMaterial);
        
        // Orient towards center
        mesh.lookAt(this.roomCenter);
        // Adjust to be vertical
        mesh.rotation.x = 0;
        break;
    }
    
    mesh.position.set(x, 0.75, z);
    this.scene.add(mesh);
    this.roomObjects.push(mesh);
  }
  
  addRoomLights() {
    // Ambient light for the room
    const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
    this.scene.add(ambientLight);
    this.roomObjects.push(ambientLight);
    
    // Add main overhead light
    const mainLight = new THREE.PointLight(
      this.getThemeColors().mainLight, 
      1, 
      100
    );
    mainLight.position.set(0, 15, 0);
    this.scene.add(mainLight);
    this.roomObjects.push(mainLight);
    
    // Add accent lights in corners
    const cornerLightPositions = [
      new THREE.Vector3(-this.size.width / 3, 5, -this.size.height / 3),
      new THREE.Vector3(this.size.width / 3, 5, -this.size.height / 3),
      new THREE.Vector3(-this.size.width / 3, 5, this.size.height / 3),
      new THREE.Vector3(this.size.width / 3, 5, this.size.height / 3)
    ];
    
    for (const position of cornerLightPositions) {
      const cornerLight = new THREE.PointLight(
        this.getThemeColors().accentLight,
        0.6,
        30
      );
      cornerLight.position.copy(position);
      this.scene.add(cornerLight);
      this.roomObjects.push(cornerLight);
    }
  }
  
  getRandomSpawnPoint() {
    if (this.spawnPoints.length === 0) return new THREE.Vector3(0, 0, 0);
    return this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)].clone();
  }
  
  /**
   * Get all obstacles in the room, including walls and other objects
   * @returns {Array} Array of obstacles with position and size/radius information
   */
  getObstacles() {
    const obstacles = [];
    
    // Add walls
    if (this.walls && this.walls.length > 0) {
      obstacles.push(...this.walls.map(wall => ({
        type: 'wall',
        position: wall.position.clone(),
        size: wall.size ? { x: wall.size.x, y: wall.size.y, z: wall.size.z } : { x: 1, y: 1, z: 1 },
        rotation: wall.rotation ? wall.rotation.clone() : new THREE.Euler()
      })));
    }
    
    // Add other obstacles like pillars, etc.
    if (this.obstacles && this.obstacles.length > 0) {
      obstacles.push(...this.obstacles.map(obstacle => {
        if (obstacle.geometry && obstacle.geometry.type.includes('Cylinder')) {
          // Cylindrical obstacles
          return {
            type: 'cylinder',
            position: obstacle.position.clone(),
            radius: obstacle.geometry.parameters?.radiusTop || 1,
            height: obstacle.geometry.parameters?.height || 2
          };
        } else {
          // Box obstacles
          return {
            type: 'box',
            position: obstacle.position.clone(),
            size: {
              x: obstacle.scale.x,
              y: obstacle.scale.y,
              z: obstacle.scale.z
            },
            rotation: obstacle.rotation.clone()
          };
        }
      }));
    }
    
    // Add environmental hazards if they exist
    if (this.hazards && this.hazards.length > 0) {
      obstacles.push(...this.hazards.map(hazard => ({
        type: 'hazard',
        position: hazard.position.clone(),
        radius: hazard.radius || 1,
        damage: hazard.damage || 10
      })));
    }
    
    return obstacles;
  }
  
  cleanup() {
    // Remove all room objects from the scene
    for (const object of this.roomObjects) {
      this.scene.remove(object);
      
      // Dispose geometries and materials
      if (object.geometry) {
        object.geometry.dispose();
      }
      
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    }
    
    // Clear arrays
    this.roomObjects = [];
    this.obstacles = [];
    this.spawnPoints = [];
    this.coverPoints = [];
  }
  
  getThemeColors() {
    // Return colors based on room theme
    switch(this.theme) {
      case 'alien-hive':
        return {
          floor: 0x112211,
          floorEmissive: 0x224422,
          wall: 0x336633,
          wallEmissive: 0x44ff44,
          grid: 0x33ff33,
          obstacle: 0x225522,
          obstacleEmissive: 0x33ff33,
          console: 0x336633,
          consoleEmissive: 0x44ff66,
          consoleLight: 0x66ff66,
          crate: 0x225522,
          panel: 0x112211,
          panelEmissive: 0x33ff33,
          mainLight: 0x33ff33,
          accentLight: 0x66ff66
        };
      case 'neon-city':
        return {
          floor: 0x000011,
          floorEmissive: 0x000033,
          wall: 0x110022,
          wallEmissive: 0xff00ff,
          grid: 0x0088ff,
          obstacle: 0x220033,
          obstacleEmissive: 0xff00ff,
          console: 0x330044,
          consoleEmissive: 0xff00ff,
          consoleLight: 0xff00ff,
          crate: 0x110022,
          panel: 0x220044,
          panelEmissive: 0xff00aa,
          mainLight: 0xffffff,
          accentLight: 0xff00ff
        };
      case 'space-station':
      default:
        return {
          floor: 0x111122,
          floorEmissive: 0x0000ff,
          wall: 0x334455,
          wallEmissive: 0x0088ff,
          grid: 0x0088ff,
          obstacle: 0x334455,
          obstacleEmissive: 0x0088ff,
          console: 0x223344,
          consoleEmissive: 0x00ffff,
          consoleLight: 0x00ffff,
          crate: 0x445566,
          panel: 0x223344,
          panelEmissive: 0x0088ff,
          mainLight: 0xaaccff,
          accentLight: 0x0088ff
        };
    }
  }
} 
### ./ui/GameRoom.js END ###

### ./ui/GameUI.js BEGIN ###
/**
 * GameUI class for handling all game UI elements
 */
export class GameUI {
  constructor() {
    this.uiContainer = null;
    this.controlsInfo = null;
    this.healthBar = null;
    this.energyBar = null;
    this.weaponIndicator = null;

    this.createUI();
  }

  /**
   * Create all UI elements
   */
  createUI() {
    // Remove existing controls-info if it exists
    const oldControls = document.querySelector('.controls-info');
    if (oldControls) {
      oldControls.remove();
    }

    // Create main UI container
    this.uiContainer = document.createElement('div');
    this.uiContainer.className = 'game-ui';
    this.uiContainer.id = 'game-ui';
    document.body.appendChild(this.uiContainer);

    // Create status bars container
    const statusBars = document.createElement('div');
    statusBars.className = 'status-bars';
    this.uiContainer.appendChild(statusBars);

    // Create health bar
    const healthBarContainer = document.createElement('div');
    healthBarContainer.className = 'bar-container health-bar-container';
    statusBars.appendChild(healthBarContainer);

    const healthLabel = document.createElement('div');
    healthLabel.className = 'bar-label';
    healthLabel.innerHTML = '❤️'; // Heart emoji for health
    healthBarContainer.appendChild(healthLabel);

    const healthBarOuter = document.createElement('div');
    healthBarOuter.className = 'bar-outer';
    healthBarContainer.appendChild(healthBarOuter);

    this.healthBar = document.createElement('div');
    this.healthBar.className = 'bar-inner health-bar';
    healthBarOuter.appendChild(this.healthBar);

    // Create health percentage display
    this.healthPercentage = document.createElement('div');
    this.healthPercentage.className = 'bar-percentage';
    this.healthPercentage.textContent = '100%';
    healthBarContainer.appendChild(this.healthPercentage);

    // Create energy bar
    const energyBarContainer = document.createElement('div');
    energyBarContainer.className = 'bar-container energy-bar-container';
    statusBars.appendChild(energyBarContainer);

    const energyLabel = document.createElement('div');
    energyLabel.className = 'bar-label';
    energyLabel.innerHTML = '⚡'; // Lightning emoji for energy
    energyBarContainer.appendChild(energyLabel);

    const energyBarOuter = document.createElement('div');
    energyBarOuter.className = 'bar-outer';
    energyBarContainer.appendChild(energyBarOuter);

    this.energyBar = document.createElement('div');
    this.energyBar.className = 'bar-inner energy-bar';
    energyBarOuter.appendChild(this.energyBar);

    // Create energy percentage display
    this.energyPercentage = document.createElement('div');
    this.energyPercentage.className = 'bar-percentage';
    this.energyPercentage.textContent = '100%';
    energyBarContainer.appendChild(this.energyPercentage);

    // Create weapon indicator
    this.weaponIndicator = document.createElement('div');
    this.weaponIndicator.className = 'weapon-indicator';
    this.uiContainer.appendChild(this.weaponIndicator);

    const weaponLabel = document.createElement('div');
    weaponLabel.className = 'weapon-label';
    weaponLabel.textContent = '🔫';  // Weapon emoji
    this.weaponIndicator.appendChild(weaponLabel);

    this.weaponName = document.createElement('div');
    this.weaponName.className = 'weapon-name laser';
    this.weaponName.textContent = 'LASER';
    this.weaponIndicator.appendChild(this.weaponName);

    // Initially hide the UI
    this.uiContainer.classList.add('hidden');
  }

  /**
   * Show the UI
   */
  show() {
    if (this.uiContainer) {
      this.uiContainer.classList.remove('hidden');
      this.uiContainer.style.display = 'flex';
      this.uiContainer.style.opacity = '1';
    }
  }

  /**
   * Hide the UI
   */
  hide() {
    if (this.uiContainer) {
      this.uiContainer.classList.add('hidden');
      this.uiContainer.style.display = 'none';
      this.uiContainer.style.opacity = '0';
    }
  }

  /**
   * Update health bar
   * @param {number} health - Current health value
   * @param {number} maxHealth - Maximum health value
   */
  updateHealth(health, maxHealth) {
    const percentage = (health / maxHealth) * 100;
    this.healthBar.style.width = `${percentage}%`;

    // Change color based on health level
    if (percentage < 30) {
      this.healthBar.classList.add('critical');
    } else if (percentage < 60) {
      this.healthBar.classList.remove('critical');
      this.healthBar.classList.add('warning');
    } else {
      this.healthBar.classList.remove('critical', 'warning');
    }

    this.healthPercentage.textContent = `${percentage.toFixed(0)}%`;
  }

  /**
   * Update energy bar
   * @param {number} energy - Current energy value
   * @param {number} maxEnergy - Maximum energy value
   */
  updateEnergy(energy, maxEnergy) {
    const percentage = (energy / maxEnergy) * 100;
    this.energyBar.style.width = `${percentage}%`;

    // Change color based on energy level
    if (percentage < 30) {
      this.energyBar.classList.add('critical');
    } else if (percentage < 60) {
      this.energyBar.classList.remove('critical');
      this.energyBar.classList.add('warning');
    } else {
      this.energyBar.classList.remove('critical', 'warning');
    }

    this.energyPercentage.textContent = `${percentage.toFixed(0)}%`;
  }

  /**
   * Update weapon indicator
   * @param {string} weaponName - Name of the current weapon
   */
  updateWeapon(weaponName) {
    this.weaponName.textContent = weaponName;

    // Remove all weapon classes
    this.weaponName.classList.remove('laser', 'grenade', 'bounce');

    // Add the appropriate class for styling
    switch(weaponName.toLowerCase()) {
      case 'laser':
        this.weaponName.classList.add('laser');
        break;
      case 'grenade':
        this.weaponName.classList.add('grenade');
        break;
      case 'bounce':
        this.weaponName.classList.add('bounce');
        break;
    }
  }
} 
### ./ui/GameUI.js END ###

### ./ui/MiniMap.js BEGIN ###
/**
 * MiniMap class for displaying a top-down radar view of the game
 */
export class MiniMap {
  constructor(game) {
    this.game = game;
    this.visible = true;
    this.container = null;
    this.canvas = null;
    this.ctx = null;
    this.mapScale = 15; // Scale factor for map (pixels per world unit)
    
    // Scale factor for converting world coordinates to mini-map coordinates
    this.scale = 0.08;
    
    // Mini-map center offset in pixels
    this.offsetX = 0;
    this.offsetY = 0;
    
    this.createMiniMap();
  }
  
  /**
   * Create the mini-map UI
   */
  createMiniMap() {
    this.container = document.createElement('div');
    this.container.className = 'mini-map-container';
    document.body.appendChild(this.container);
    
    // Create mini-map area
    const miniMap = document.createElement('div');
    miniMap.className = 'mini-map';
    this.container.appendChild(miniMap);
    
    // Add subtle M key hint
    const hint = document.createElement('div');
    hint.className = 'mini-map-hint';
    hint.textContent = 'M';
    this.container.appendChild(hint);
    
    // Create canvas for drawing
    this.canvas = document.createElement('canvas');
    this.canvas.width = 300;
    this.canvas.height = 300;
    miniMap.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    
    // Calculate center offset
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
  }
  
  /**
   * Update the mini-map with current game state
   */
  update() {
    if (!this.visible || !this.ctx || !this.game.playerShip) return;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw background
    this.ctx.fillStyle = 'rgba(0, 20, 40, 0.2)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw grid lines
    this.drawGridLines();
    
    // Draw objects from infinite map
    this.drawObjects();
    
    // Draw player
    this.drawPlayer();
    
    // Draw enemies (if any exist)
    if (this.game.enemies) {
      this.drawEnemies();
    }
  }
  
  /**
   * Draw grid lines on mini-map
   */
  drawGridLines() {
    const gridSize = 10; // World units
    const gridLines = 20; // Number of grid lines in each direction
    
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
    this.ctx.lineWidth = 0.5;
    
    // Get player position
    const playerX = this.game.playerShip.position.x;
    const playerZ = this.game.playerShip.position.z;
    
    const startX = Math.floor(playerX / gridSize) * gridSize - (gridLines * gridSize / 2);
    const startZ = Math.floor(playerZ / gridSize) * gridSize - (gridLines * gridSize / 2);
    
    // Draw vertical lines
    for (let i = 0; i <= gridLines; i++) {
      const worldX = startX + i * gridSize;
      const mapX = this.worldToMapX(worldX);
      
      this.ctx.beginPath();
      this.ctx.moveTo(mapX, 0);
      this.ctx.lineTo(mapX, this.canvas.height);
      this.ctx.stroke();
    }
    
    // Draw horizontal lines
    for (let i = 0; i <= gridLines; i++) {
      const worldZ = startZ + i * gridSize;
      const mapY = this.worldToMapY(worldZ);
      
      this.ctx.beginPath();
      this.ctx.moveTo(0, mapY);
      this.ctx.lineTo(this.canvas.width, mapY);
      this.ctx.stroke();
    }
  }
  
  /**
   * Draw objects from infinite map chunks
   */
  drawObjects() {
    if (!this.game.infiniteMap) return;
    
    // Get nearby chunks
    const playerPos = this.game.playerShip.position;
    const currentKey = this.game.infiniteMap.getChunkKey(playerPos.x, playerPos.z);
    const nearbyChunks = this.game.infiniteMap.getNearbyChunks(currentKey);
    
    // Draw objects from each chunk
    for (const chunk of nearbyChunks) {
      for (const object of chunk.objects) {
        // Get object position
        const x = object.position.x;
        const z = object.position.z;
        
        // Convert to mini-map coordinates
        const mapX = this.worldToMapX(x);
        const mapY = this.worldToMapY(z);
        
        // Set color based on object type
        switch (object.type) {
          case 'flora':
            this.ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            break;
          case 'rocks':
            this.ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            break;
          case 'objects':
            this.ctx.fillStyle = 'rgba(255, 69, 0, 0.7)';
            break;
          default:
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        }
        
        // Draw object dot
        this.ctx.beginPath();
        this.ctx.arc(mapX, mapY, object.radius * this.scale, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
  
  /**
   * Draw player on mini-map
   */
  drawPlayer() {
    // Get player position
    const x = this.game.playerShip.position.x;
    const z = this.game.playerShip.position.z;
    
    // Convert to mini-map coordinates
    const mapX = this.worldToMapX(x);
    const mapY = this.worldToMapY(z);
    
    // Draw player direction cone
    this.drawPlayerDirection(mapX, mapY);
    
    // Draw player dot
    this.ctx.fillStyle = '#00ffff';
    this.ctx.beginPath();
    this.ctx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw player glow
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(mapX, mapY, 5, 0, Math.PI * 2);
    this.ctx.stroke();
  }
  
  /**
   * Draw player direction indicator
   */
  drawPlayerDirection(mapX, mapY) {
    // Get player rotation
    const angle = this.game.playerShip.rotation.y;
    
    // Draw direction indicator
    this.ctx.save();
    this.ctx.translate(mapX, mapY);
    this.ctx.rotate(-angle); // Negative because z-axis is inverted
    
    // Draw triangular direction indicator
    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
    this.ctx.beginPath();
    this.ctx.moveTo(0, -10); // Pointing up
    this.ctx.lineTo(-5, 0);
    this.ctx.lineTo(5, 0);
    this.ctx.closePath();
    this.ctx.fill();
    
    this.ctx.restore();
  }
  
  /**
   * Draw enemies on mini-map
   */
  drawEnemies() {
    this.ctx.fillStyle = '#ff3333';
    
    for (const enemy of this.game.enemies) {
      // Get position
      const x = enemy.position.x;
      const z = enemy.position.z;
      
      // Convert to mini-map coordinates
      const mapX = this.worldToMapX(x);
      const mapY = this.worldToMapY(z);
      
      // Draw enemy dot
      this.ctx.beginPath();
      this.ctx.arc(mapX, mapY, 2, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  /**
   * Convert world X coordinate to mini-map X coordinate
   */
  worldToMapX(x) {
    // Get player position
    const playerX = this.game.playerShip.position.x;
    
    // Apply scale and center on player
    return this.offsetX + (x - playerX) * this.scale;
  }
  
  /**
   * Convert world Z coordinate to mini-map Y coordinate
   */
  worldToMapY(z) {
    // Get player position
    const playerZ = this.game.playerShip.position.z;
    
    // Apply scale and center on player (note the negation since Z goes forward)
    return this.offsetY + (z - playerZ) * this.scale;
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggle() {
    this.visible = !this.visible;
    
    if (this.visible) {
      this.show();
    } else {
      this.hide();
    }
  }
  
  /**
   * Show mini-map
   */
  show() {
    this.container.classList.remove('hidden');
    this.visible = true;
  }
  
  /**
   * Hide mini-map
   */
  hide() {
    this.container.classList.add('hidden');
    this.visible = false;
  }
} 
### ./ui/MiniMap.js END ###

### ./scenes/TeamDemo.js BEGIN ###
import * as THREE from 'three';
import { TeamManager, GAME_MODES } from '../core/TeamManager';
import { Enemy } from '../entities/enemies/Enemy';
import { Player } from '../entities/player/Player';

export class TeamDemo {
    constructor(scene, options = {}) {
        this.scene = scene;
        this.options = {
            gameMode: GAME_MODES.TEAM_VS_TEAM,
            playerCount: 2,
            enemyCount: 4,
            ...options
        };

        // Initialize team manager
        this.teamManager = new TeamManager(this.options.gameMode);
        
        // Initialize collections
        this.players = new Map();
        this.enemies = new Map();
        
        // Setup demo
        this.setupDemo();
    }

    setupDemo() {
        // Create players
        for (let i = 0; i < this.options.playerCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                1,
                (Math.random() - 0.5) * 20
            );
            
            const player = new Player(this.scene, position);
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`player${i}`);
            
            player.setTeam(teamId, color);
            this.players.set(`player${i}`, player);
            
            // Log player creation
            console.log(`Created player ${i} on team ${teamId} with color ${color.toString(16)}`);
        }

        // Create enemies
        for (let i = 0; i < this.options.enemyCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                1,
                (Math.random() - 0.5) * 20
            );
            
            const enemyType = ['BASIC', 'HUNTER', 'PATROLLER'][Math.floor(Math.random() * 3)];
            const enemy = new Enemy(this.scene, position, {
                type: enemyType,
                shipModel: ['STANDARD', 'INTERCEPTOR', 'HEAVY', 'SCOUT'][Math.floor(Math.random() * 4)]
            });
            
            // Assign to a random team
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`enemy${i}`);
            enemy.setTeam(teamId, color);
            
            this.enemies.set(`enemy${i}`, enemy);
            
            // Log enemy creation
            console.log(`Created ${enemyType} enemy ${i} on team ${teamId} with color ${color.toString(16)}`);
        }
    }

    update(deltaTime) {
        // Convert players to array for enemy targeting
        const playerArray = Array.from(this.players.values());
        
        // Update all entities
        this.players.forEach(player => {
            if (player.isActive) {
                player.update(deltaTime);
            }
        });

        this.enemies.forEach(enemy => {
            if (enemy.isActive) {
                enemy.update(deltaTime, playerArray, []);
            }
        });
    }

    handleCollisions() {
        // Check collisions between all active entities
        const activeEntities = [
            ...Array.from(this.players.values()).filter(p => p.isActive),
            ...Array.from(this.enemies.values()).filter(e => e.isActive)
        ];

        for (let i = 0; i < activeEntities.length; i++) {
            for (let j = i + 1; j < activeEntities.length; j++) {
                const entity1 = activeEntities[i];
                const entity2 = activeEntities[j];

                // Skip collision check if entities are on the same team
                if (this.teamManager.arePlayersOnSameTeam(entity1.teamId, entity2.teamId)) {
                    continue;
                }

                // Simple distance-based collision
                const distance = entity1.mesh.position.distanceTo(entity2.mesh.position);
                const minDistance = entity1.options.size + entity2.options.size;

                if (distance < minDistance) {
                    // Handle collision
                    entity1.takeDamage(10);
                    entity2.takeDamage(10);
                }
            }
        }
    }

    getTeamScores() {
        return this.teamManager.getTeamScores();
    }

    setGameMode(mode) {
        this.options.gameMode = mode;
        this.teamManager.setGameMode(mode);
        
        // Reassign all entities to teams
        this.players.forEach((player, id) => {
            const { teamId, color } = this.teamManager.assignPlayerToTeam(id);
            player.setTeam(teamId, color);
        });

        this.enemies.forEach((enemy, id) => {
            const { teamId, color } = this.teamManager.assignPlayerToTeam(id);
            enemy.setTeam(teamId, color);
        });
    }
} 
### ./scenes/TeamDemo.js END ###

### ./core/Game.js BEGIN ###
import { GameEngine } from './GameEngine';
import { GameUI } from '../ui/GameUI';
import { MiniMap } from '../ui/MiniMap';
import { GAME_CONFIG } from '../config/GameConfig';
import * as THREE from 'three';
import { TeamManager, GAME_MODES } from './TeamManager';
import { ShipSelectionUI } from '../ui/ShipSelectionUI';
import { Player } from '../entities/player/Player';
import { Enemy } from '../entities/enemies/Enemy';

export class Game {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            gameMode: GAME_MODES.FREE_FOR_ALL,
            isPremium: false,
            ...options
        };

        // Initialize core components
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Setup renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.container.appendChild(this.renderer.domElement);

        // Initialize managers
        this.teamManager = new TeamManager(this.options.gameMode);
        
        // Game state
        this.isRunning = false;
        this.entities = new Map();
        
        // Setup window resize handler
        window.addEventListener('resize', () => this.handleResize());
        
        // Initialize ship selection
        this.initShipSelection();
    }

    initShipSelection() {
        this.shipSelection = new ShipSelectionUI(this.container, {
            isPremium: this.options.isPremium,
            onShipSelect: (selection) => this.startGame(selection)
        });
    }

    startGame(playerSelection) {
        // Hide ship selection
        this.shipSelection.hide();
        
        // Create player
        const player = new Player(this.scene, new THREE.Vector3(0, 0, 0), {
            ...playerSelection.config.stats,
            shipModel: playerSelection.config.model
        });

        // Assign team/color in FFA mode
        const { teamId } = this.teamManager.assignPlayerToTeam('player1');
        player.setTeam(teamId, parseInt(playerSelection.color.replace(/[^\d,]/g, '').split(',').map(x => parseInt(x)).join('')));

        // Store player
        this.entities.set('player1', player);

        // Add some AI players for testing
        this.addAIPlayers(5);

        // Start game loop
        this.isRunning = true;
        this.animate();
    }

    addAIPlayers(count) {
        for (let i = 0; i < count; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 40,
                0,
                (Math.random() - 0.5) * 40
            );

            const enemy = new Enemy(this.scene, position, {
                type: Math.random() > 0.5 ? 'HUNTER' : 'PATROLLER',
                shipModel: ['SCOUT', 'INTERCEPTOR', 'STANDARD'][Math.floor(Math.random() * 3)]
            });

            // Assign team/color
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`ai${i}`);
            enemy.setTeam(teamId, color);

            // Store enemy
            this.entities.set(`ai${i}`, enemy);
        }
    }

    animate() {
        if (!this.isRunning) return;

        requestAnimationFrame(() => this.animate());

        const deltaTime = 16; // Assuming 60fps for now
        
        // Update all entities
        const playerArray = Array.from(this.entities.values());
        this.entities.forEach(entity => {
            if (entity instanceof Enemy) {
                entity.update(deltaTime, playerArray, []);
            } else {
                entity.update(deltaTime);
            }
        });

        // Handle collisions
        this.handleCollisions();

        // Render
        this.renderer.render(this.scene, this.camera);
    }

    handleCollisions() {
        const entities = Array.from(this.entities.values()).filter(e => e.isActive);

        for (let i = 0; i < entities.length; i++) {
            for (let j = i + 1; j < entities.length; j++) {
                const entity1 = entities[i];
                const entity2 = entities[j];

                // Skip collision check if entities are on the same team
                if (this.teamManager.arePlayersOnSameTeam(entity1.teamId, entity2.teamId)) {
                    continue;
                }

                // Simple distance-based collision
                const distance = entity1.mesh.position.distanceTo(entity2.mesh.position);
                const minDistance = entity1.options.size + entity2.options.size;

                if (distance < minDistance) {
                    entity1.takeDamage(10);
                    entity2.takeDamage(10);
                }
            }
        }
    }

    handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }

    destroy() {
        this.isRunning = false;
        
        // Clean up entities
        this.entities.forEach(entity => entity.destroy());
        this.entities.clear();

        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);

        // Clean up THREE.js resources
        this.scene.traverse(object => {
            if (object.geometry) object.geometry.dispose();
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });

        // Remove renderer
        this.renderer.dispose();
        this.container.removeChild(this.renderer.domElement);
    }
} 
### ./core/Game.js END ###

### ./core/TeamManager.js BEGIN ###
export const TEAM_COLORS = {
    RED: 0xff0000,
    BLUE: 0x0000ff,
    YELLOW: 0xffff00,
    GREEN: 0x00ff00,
    PURPLE: 0x800080,
    CYAN: 0x00ffff,
    ORANGE: 0xffa500,
    PINK: 0xff69b4
};

export const GAME_MODES = {
    FREE_FOR_ALL: 'FFA',
    TEAM_VS_TEAM: 'TVT',
    MULTI_TEAM: 'MT'
};

export class TeamManager {
    constructor(gameMode = GAME_MODES.FREE_FOR_ALL) {
        this.gameMode = gameMode;
        this.teams = new Map();
        this.playerTeams = new Map();
        this.teamColors = new Map();
        this.nextTeamId = 1;
        this.usedColors = new Set();
        
        // Initialize default team configurations
        this.initializeTeams();
    }

    initializeTeams() {
        switch (this.gameMode) {
            case GAME_MODES.TEAM_VS_TEAM:
                this.createTeam('RED', TEAM_COLORS.RED);
                this.createTeam('BLUE', TEAM_COLORS.BLUE);
                break;
            case GAME_MODES.MULTI_TEAM:
                this.createTeam('RED', TEAM_COLORS.RED);
                this.createTeam('BLUE', TEAM_COLORS.BLUE);
                this.createTeam('YELLOW', TEAM_COLORS.YELLOW);
                this.createTeam('GREEN', TEAM_COLORS.GREEN);
                break;
            case GAME_MODES.FREE_FOR_ALL:
                // Teams will be created dynamically as players join
                break;
        }
    }

    createTeam(name, color) {
        const teamId = this.nextTeamId++;
        this.teams.set(teamId, {
            id: teamId,
            name,
            color,
            players: new Set(),
            score: 0
        });
        this.teamColors.set(teamId, color);
        this.usedColors.add(color);
        return teamId;
    }

    generateUniqueColor() {
        const availableColors = Object.values(TEAM_COLORS)
            .filter(color => !this.usedColors.has(color));

        if (availableColors.length > 0) {
            return availableColors[Math.floor(Math.random() * availableColors.length)];
        }

        // If all predefined colors are used, generate a random color
        return Math.floor(Math.random() * 0xffffff);
    }

    assignPlayerToTeam(playerId, preferredTeamId = null) {
        if (this.gameMode === GAME_MODES.FREE_FOR_ALL) {
            // In FFA, each player gets their own team
            const color = this.generateUniqueColor();
            const teamId = this.createTeam(`Player ${playerId}`, color);
            this.playerTeams.set(playerId, teamId);
            this.teams.get(teamId).players.add(playerId);
            return { teamId, color };
        }

        if (preferredTeamId && this.teams.has(preferredTeamId)) {
            const team = this.teams.get(preferredTeamId);
            team.players.add(playerId);
            this.playerTeams.set(playerId, preferredTeamId);
            return { teamId: preferredTeamId, color: team.color };
        }

        // Auto-balance teams
        let smallestTeam = null;
        let smallestSize = Infinity;

        for (const [teamId, team] of this.teams) {
            if (team.players.size < smallestSize) {
                smallestTeam = team;
                smallestSize = team.players.size;
            }
        }

        if (smallestTeam) {
            smallestTeam.players.add(playerId);
            this.playerTeams.set(playerId, smallestTeam.id);
            return { teamId: smallestTeam.id, color: smallestTeam.color };
        }

        throw new Error('No teams available for assignment');
    }

    removePlayer(playerId) {
        const teamId = this.playerTeams.get(playerId);
        if (teamId) {
            const team = this.teams.get(teamId);
            if (team) {
                team.players.delete(playerId);
                // In FFA mode, remove empty teams
                if (this.gameMode === GAME_MODES.FREE_FOR_ALL && team.players.size === 0) {
                    this.teams.delete(teamId);
                    this.teamColors.delete(teamId);
                }
            }
            this.playerTeams.delete(playerId);
        }
    }

    getTeamColor(teamId) {
        return this.teamColors.get(teamId);
    }

    getPlayerTeam(playerId) {
        const teamId = this.playerTeams.get(playerId);
        return this.teams.get(teamId);
    }

    updateTeamScore(teamId, points) {
        const team = this.teams.get(teamId);
        if (team) {
            team.score += points;
        }
    }

    getTeamScores() {
        const scores = [];
        for (const [teamId, team] of this.teams) {
            scores.push({
                teamId,
                name: team.name,
                color: team.color,
                score: team.score,
                playerCount: team.players.size
            });
        }
        return scores.sort((a, b) => b.score - a.score);
    }

    arePlayersOnSameTeam(player1Id, player2Id) {
        return this.playerTeams.get(player1Id) === this.playerTeams.get(player2Id);
    }

    setGameMode(newMode) {
        if (newMode === this.gameMode) return;
        
        // Clear existing teams
        this.teams.clear();
        this.playerTeams.clear();
        this.teamColors.clear();
        this.usedColors.clear();
        this.nextTeamId = 1;
        
        // Set new game mode and initialize teams
        this.gameMode = newMode;
        this.initializeTeams();
    }
} 
### ./core/TeamManager.js END ###

### ./core/Scene.js BEGIN ###
import * as THREE from 'three';

class Scene {
    constructor(engine) {
        this.engine = engine;
        this.scene = engine.scene;
        
        // Scene elements
        this.floor = null;
        this.playerHighlight = null;
        this.obstacles = [];
        
        // Scene properties
        this.boundarySize = 25;
        this.gridSize = 100;
        this.gridDivisions = 100;
    }

    init() {
        this.createFloor();
        this.createBoundaryMarkers();
        this.createObstacles();
        return this;
    }

    createFloor() {
        // Create grid
        const gridHelper = new THREE.GridHelper(
            this.gridSize,
            this.gridDivisions,
            0x444444,
            0x222222
        );
        this.engine.add(gridHelper);

        // Create floor with glow effect
        const floorGeometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize);
        const floorMaterial = new THREE.MeshBasicMaterial({
            color: 0x000022,
            transparent: true,
            opacity: 0.2,
        });

        this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
        this.floor.rotation.x = -Math.PI / 2;
        this.floor.position.y = -0.01;
        this.engine.add(this.floor);

        // Create player highlight
        const highlightGeometry = new THREE.CircleGeometry(5, 32);
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.1,
        });

        this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        this.playerHighlight.rotation.x = -Math.PI / 2;
        this.playerHighlight.position.y = 0.02;
        this.engine.add(this.playerHighlight);
    }

    createBoundaryMarkers() {
        const markerSize = 1;
        const markerHeight = 1;
        const numMarkers = 10;

        const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
        const markerMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0x600000,
            transparent: true,
            opacity: 0.7
        });

        const markers = new THREE.Group();

        for (let i = 0; i < numMarkers; i++) {
            const t = (i / (numMarkers - 1)) * 2 - 1;
            const position = this.boundarySize * t;

            ['north', 'south', 'east', 'west'].forEach(direction => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                
                switch(direction) {
                    case 'north':
                        marker.position.set(position, markerHeight / 2, -this.boundarySize);
                        break;
                    case 'south':
                        marker.position.set(position, markerHeight / 2, this.boundarySize);
                        break;
                    case 'east':
                        marker.position.set(this.boundarySize, markerHeight / 2, position);
                        break;
                    case 'west':
                        marker.position.set(-this.boundarySize, markerHeight / 2, position);
                        break;
                }
                
                markers.add(marker);
            });
        }

        this.engine.add(markers);
    }

    createObstacles() {
        const numObstacles = 15;
        
        for (let i = 0; i < numObstacles; i++) {
            const obstacle = this.createRandomObstacle();
            if (obstacle) {
                this.obstacles.push(obstacle);
                this.engine.add(obstacle);
            }
        }
    }

    createRandomObstacle() {
        const shapeType = Math.floor(Math.random() * 3);
        let geometry, size;

        // Create random geometry
        switch(shapeType) {
            case 0: // Box
                size = 1.5 + Math.random() * 3;
                const height = 3 + Math.random() * 4;
                geometry = new THREE.BoxGeometry(size, height, size);
                break;
            case 1: // Cylinder
                const radius = 1 + Math.random() * 2;
                const cylinderHeight = 4 + Math.random() * 5;
                geometry = new THREE.CylinderGeometry(radius, radius, cylinderHeight, 16);
                size = radius * 2;
                break;
            case 2: // Sphere
                const sphereRadius = 1.5 + Math.random() * 2;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                size = sphereRadius * 2;
                break;
        }

        // Create neon material
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
        const material = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color.clone().multiplyScalar(0.5),
            shininess: 100
        });

        // Create mesh
        const obstacle = new THREE.Mesh(geometry, material);

        // Add point light
        const light = new THREE.PointLight(color, 0.5, 5);
        light.position.set(0, 0, 0);
        obstacle.add(light);

        // Set random position (avoiding player spawn area)
        let x, z;
        let validPosition = false;

        while (!validPosition) {
            x = (Math.random() - 0.5) * 45;
            z = (Math.random() - 0.5) * 45;
            
            const distanceFromOrigin = Math.sqrt(x * x + z * z);
            if (distanceFromOrigin > 10) {
                validPosition = true;
            }
        }

        const y = shapeType === 2 ? Math.random() * 3 : size / 2;
        obstacle.position.set(x, y, z);

        return obstacle;
    }

    updatePlayerHighlight(playerPosition) {
        if (this.playerHighlight) {
            this.playerHighlight.position.x = playerPosition.x;
            this.playerHighlight.position.z = playerPosition.z;
            
            const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
            this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
        }
    }

    getFloor() {
        return this.floor;
    }

    getObstacles() {
        return this.obstacles;
    }

    getBoundarySize() {
        return this.boundarySize;
    }

    cleanup() {
        // Cleanup all obstacles
        this.obstacles.forEach(obstacle => {
            obstacle.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        });
        
        // Clear arrays
        this.obstacles = [];
    }
}

export default Scene; 
### ./core/Scene.js END ###

### ./core/GameEngine.js BEGIN ###
import * as THREE from 'three';
import { Player } from '../entities/player/Player';
import { WeaponSystem } from '../entities/weapons/WeaponSystem';
import { EnemyManager } from '../entities/enemies/EnemyManager';
import { GameRoom } from '../ui/GameRoom';
import { SoundManager } from '../assets/SoundManager';
import { RegularLaser } from '../entities/weapons/RegularLaser';
import { GameUI } from '../ui/GameUI';
import { NetworkManager } from './NetworkManager';
import { AssetLoader } from '../assets/AssetLoader';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';

export class GameEngine {
  constructor() {
    // Initialize properties
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.player = null;
    this.score = 0;
    this.isRunning = false;
    this.lastTime = 0;
    this.collisionThreshold = 0.5; // Collision distance threshold
    
    // Game mode and settings
    this.gameMode = 'ffa'; // Default game mode: free-for-all
    this.roomTheme = 'space-station'; // Default room theme
    this.roomSize = { width: 60, height: 60 }; // Default room size
    
    // Initialize UI
    this.ui = new GameUI();
    
    // Multiplayer properties
    this.players = {};  // Will store other players
    this.playerId = null;  // Will be set when joining a game
    this.multiplayerEnabled = false;
    this.teams = {
      red: { score: 0, players: [] },
      blue: { score: 0, players: [] }
    };
    
    // Add NetworkManager instance
    this.networkManager = new NetworkManager();
    
    // Initialize AssetLoader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => console.log(`GameEngine: ${message}`),
      (type, error) => this.handleAssetError(type, error)
    );
    
    // Asset loading state
    this.assetsLoaded = false;
    
    // Initialize Three.js components
    this.initThree();
    
    // Initialize weapon system
    this.weaponSystem = new WeaponSystem(this.scene);
    
    // Initialize enemy manager (will be used for AI opponents)
    this.enemyManager = new EnemyManager(this.scene, this.roomSize.width / 2);
    
    // Initialize game elements
    this.initGame();
  }
  
  initThree() {
    // Create scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000011);
    
    // Create isometric-style camera
    this.camera = new THREE.PerspectiveCamera(
      45, // Lower FOV for more isometric-like view
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    
    // Set camera to isometric position
    this.camera.position.set(40, 40, 40); // Position it at a distance
    this.camera.lookAt(0, 0, 0); // Look at the center of the room
    
    // Create renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    
    // Add renderer to DOM
    document.getElementById('game-container').appendChild(this.renderer.domElement);
  }
  
  async initGame() {
    console.log('Initializing game...');
    
    // Create clock for timing
    this.clock = new THREE.Clock();
    
    // Initialize scene if not set
    if (!this.scene) {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x000011); // Dark blue background
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x444444);
      this.scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1).normalize();
      this.scene.add(directionalLight);
    }
    
    // Initialize camera if not set
    if (!this.camera) {
      this.camera = new THREE.PerspectiveCamera(
        75, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
      );
      this.camera.position.set(0, 10, -10);
      this.camera.lookAt(0, 0, 0);
    }
    
    // Initialize renderer if not set
    if (!this.renderer) {
      this.renderer = new THREE.WebGLRenderer({ antialias: true });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.shadowMap.enabled = true;
      document.body.appendChild(this.renderer.domElement);
    }
    
    // Load assets before proceeding
    try {
      console.log('Loading game assets...');
      this.assetsLoaded = await this.assetLoader.loadAll();
      console.log('Assets loaded successfully:', this.assetsLoaded);
    } catch (error) {
      console.error('Failed to load assets:', error);
      this.handleAssetError('critical', error);
      return;
    }
    
    // Initialize sound manager
    this.soundManager = new SoundManager();
    
    // Initialize player
    this.player = new Player(this.scene, this.camera, this.soundManager);
    
    // Initialize weapon system
    this.weaponSystem = new WeaponSystem(this.scene, this.soundManager);
    
    // Equip player with weapons
    this.player.equipWeapon('primary', new RegularLaser(this.weaponSystem));
    
    // Initialize enemy manager
    this.enemyManager = new EnemyManager(this.scene, this.weaponSystem, this.soundManager);
    
    // Initialize the first room
    this.initializeFirstRoom();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Setup network listeners only after assets are loaded
    if (this.assetsLoaded) {
      this.setupNetworkListeners();
    }
    
    // Show UI
    this.showGameUI();
    
    // Game is now initialized
    this.isInitialized = true;
    console.log('Game initialization complete!');
  }
  
  initGameModeUI() {
    // Clear any existing game mode UI
    const existingUI = document.querySelector('.team-indicator');
    if (existingUI) {
      existingUI.remove();
    }
    
    // Only add UI for team-based modes in multiplayer
    if (!this.multiplayerEnabled) return;
    
    switch (this.gameMode) {
      case 'tdm': // Team Deathmatch
      case 'ctf': // Capture The Flag
        // Create team scores indicator
        const teamIndicator = document.createElement('div');
        teamIndicator.className = 'team-indicator';
        
        const redTeam = document.createElement('div');
        redTeam.className = 'team-score team-red';
        redTeam.innerHTML = 'RED: <span id="red-score">0</span>';
        
        const blueTeam = document.createElement('div');
        blueTeam.className = 'team-score team-blue';
        blueTeam.innerHTML = 'BLUE: <span id="blue-score">0</span>';
        
        teamIndicator.appendChild(redTeam);
        teamIndicator.appendChild(blueTeam);
        
        document.getElementById('game-container').appendChild(teamIndicator);
        
        // Add flag status indicator for CTF mode
        if (this.gameMode === 'ctf') {
          const flagStatus = document.createElement('div');
          flagStatus.className = 'flag-status';
          
          const blueFlag = document.createElement('div');
          blueFlag.className = 'flag-blue';
          blueFlag.innerHTML = '<div class="flag-icon"></div> <span id="blue-flag-status">SECURE</span>';
          
          const redFlag = document.createElement('div');
          redFlag.className = 'flag-red';
          redFlag.innerHTML = '<div class="flag-icon"></div> <span id="red-flag-status">SECURE</span>';
          
          flagStatus.appendChild(blueFlag);
          flagStatus.appendChild(redFlag);
          
          document.getElementById('game-container').appendChild(flagStatus);
        }
        break;
        
      case 'koth': // King of the Hill
        // Create control point status
        const controlIndicator = document.createElement('div');
        controlIndicator.className = 'team-indicator';
        
        const controlPoint = document.createElement('div');
        controlPoint.className = 'team-score';
        controlPoint.innerHTML = 'CONTROL: <span id="control-status">NEUTRAL</span>';
        
        controlIndicator.appendChild(controlPoint);
        document.getElementById('game-container').appendChild(controlIndicator);
        break;
    }
  }
  
  setGameMode(mode) {
    this.gameMode = mode;
    console.log(`Game mode set to: ${mode}`);
    
    // Update UI for the new game mode
    this.initGameModeUI();
  }
  
  setRoomTheme(theme) {
    this.roomTheme = theme;
    console.log(`Room theme set to: ${theme}`);
    
    // If a room exists, regenerate it with the new theme
    if (this.gameRoom) {
      this.gameRoom.cleanup();
      this.gameRoom = new GameRoom(this.scene, this.roomSize, this.roomTheme);
      this.obstacles = this.gameRoom.getObstacles();
    }
  }
  
  start() {
    this.isRunning = true;
    this.lastTime = performance.now();
    
    // Start incrementing score over time (for single player only)
    if (!this.multiplayerEnabled) {
      this.scoreInterval = setInterval(() => {
        this.updateScore(1);
      }, 1000);
      
      // Start the enemy spawner
      this.spawnEnemyTimer = setInterval(() => {
        this.enemyManager.increaseDifficulty(0.05);
        this.enemyManager.increaseMaxEnemies(1);
      }, 30000); // Increase difficulty every 30 seconds
    }
    
    this.gameLoop(this.lastTime);
  }
  
  restart() {
    // Clear timers
    if (this.scoreInterval) {
      clearInterval(this.scoreInterval);
    }
    
    if (this.spawnEnemyTimer) {
      clearInterval(this.spawnEnemyTimer);
    }
    
    // Reset game state
    this.score = 0;
    this.updateScore();
    
    // Clear all projectiles
    this.weaponSystem.clearAllProjectiles();
    
    // Clear enemies
    this.enemyManager.clear();
    
    // Reset player
    this.player.reset();
    
    // Regenerate room
    this.gameRoom.cleanup();
    this.gameRoom = new GameRoom(this.scene, this.roomSize, this.roomTheme);
    this.obstacles = this.gameRoom.getObstacles();
    
    // Position player at spawn point
    const spawnPoint = this.gameRoom.getRandomSpawnPoint();
    this.player.mesh.position.copy(spawnPoint);
    
    // Multiplayer reset
    if (this.multiplayerEnabled) {
      // Reset team scores
      this.teams.red.score = 0;
      this.teams.blue.score = 0;
      this.updateTeamScores();
      
      // Reset multiplayer state (will be implemented with actual networking)
      console.log("Resetting multiplayer state");
    }
    
    // Start score increment timer (for single player)
    if (!this.multiplayerEnabled) {
      this.scoreInterval = setInterval(() => {
        this.updateScore(1);
      }, 1000);
      
      // Start the enemy spawner
      this.spawnEnemyTimer = setInterval(() => {
        this.enemyManager.increaseDifficulty(0.05);
        this.enemyManager.increaseMaxEnemies(1);
      }, 30000); // Increase difficulty every 30 seconds
    }
    
    // Start the game
    this.isRunning = true;
    this.lastTime = performance.now();
    this.gameLoop(this.lastTime);
  }
  
  gameLoop(currentTime) {
    if (!this.isRunning) return;
    
    // Calculate delta time
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // Update game state
    this.update();
    
    // Render scene
    this.renderer.render(this.scene, this.camera);
    
    // Continue the game loop
    requestAnimationFrame(this.gameLoop.bind(this));
  }
  
  update() {
    // Get delta time from the clock
    const deltaTime = this.clock.getDelta();
    
    // Skip update if game is paused
    if (this.isPaused) return;
    
    // Get obstacles from current room
    const obstacles = this.currentRoom?.getObstacles() || [];
    
    // Update player
    if (this.player) {
      this.player.update(deltaTime);
      
      // Check player collisions with obstacles
      if (this.currentRoom) {
        const collided = this.player.checkObstacleCollisions(obstacles);
        if (collided) {
          // Handle collision response here
          console.log('Player collided with obstacle');
        }
      }
    }
    
    // Update enemies
    if (this.enemyManager) {
      this.enemyManager.update(deltaTime, obstacles, this.player);
    }
    
    // Update weapons
    if (this.weaponSystem) {
      // Get targets (player and enemies)
      const targets = [this.player, ...this.enemyManager.getEnemies()].filter(target => target && target.isAlive);
      
      // Check weapon collisions
      const hits = this.weaponSystem.checkCollisions(targets, obstacles);
      
      // Handle hits
      for (const hit of hits) {
        if (hit.target !== 'wall' && typeof hit.target.takeDamage === 'function') {
          hit.target.takeDamage(hit.projectile.damage);
        }
        
        // Create explosion effect
        this.createExplosion(hit.position, hit.projectile.explosionSize || 0.5);
      }
      
      // Update weapon system
      this.weaponSystem.update(deltaTime);
    }
    
    // Update current room
    if (this.currentRoom) {
      this.currentRoom.update(deltaTime);
    }
    
    // Check if player has completed the current room
    if (this.currentRoom && this.player) {
      const isRoomCompleted = this.currentRoom.checkCompletion(this.player);
      if (isRoomCompleted && !this.isTransitioning) {
        this.transitionToNextRoom();
      }
    }
    
    // Update UI
    this.updateUI();
    
    // Send player updates if multiplayer is enabled
    if (this.multiplayerEnabled && this.networkManager.isConnected()) {
      this.sendPlayerUpdate();
    }
  }
  
  updateCamera() {
    // For isometric view, we maintain the camera's relative position 
    // but move it to follow the player
    const cameraOffset = new THREE.Vector3(40, 40, 40);
    
    // We want to keep the isometric angle but position relative to player
    this.camera.position.set(
      this.player.mesh.position.x + cameraOffset.x,
      cameraOffset.y, // Keep the same height
      this.player.mesh.position.z + cameraOffset.z
    );
    
    // Look at the player
    this.camera.lookAt(
      this.player.mesh.position.x,
      0, // Look at ground level
      this.player.mesh.position.z
    );
  }
  
  updateOtherPlayers(deltaTime) {
    // This will be replaced with actual networking code
    // For now, just a placeholder for the multiplayer functionality
    for (const playerId in this.players) {
      const player = this.players[playerId];
      // In real implementation, we'd interpolate positions from the server
    }
  }
  
  checkPlayerCollisions() {
    // Check for collisions with other players
    // This will be implemented with actual networking
  }
  
  updateGameMode(deltaTime) {
    // Handle game mode specific logic
    switch (this.gameMode) {
      case 'tdm': // Team Deathmatch
        // Just update scores when players are hit, already handled in processHitResults
        break;
        
      case 'ctf': // Capture The Flag
        // Check for flag captures, etc.
        this.updateCTFLogic(deltaTime);
        break;
        
      case 'koth': // King of the Hill
        // Check for hill control
        this.updateKOTHLogic(deltaTime);
        break;
        
      case 'ffa': // Free For All
      default:
        // Individual scores, handled in processHitResults
        break;
    }
  }
  
  updateCTFLogic(deltaTime) {
    // This will be implemented with actual flag capture logic
    // For now, just a placeholder
  }
  
  updateKOTHLogic(deltaTime) {
    // This will be implemented with actual hill control logic
    // For now, just a placeholder
  }
  
  processHitResults(hitResults) {
    // Process hits from weapon system
    for (const hit of hitResults) {
      // If hit a wall or obstacle, create a visual effect
      if (hit.target === 'wall' || hit.target === 'obstacle') {
        this.createHitEffect(hit.position);
      } 
      // If hit a target (enemy or player), damage it
      else if (hit.target && hit.target.takeDamage) {
        const damage = hit.projectile.options.damage || 10;
        const destroyed = hit.target.takeDamage(damage);
        
        if (destroyed) {
          if (this.multiplayerEnabled) {
            // Handle multiplayer scoring based on game mode
            switch (this.gameMode) {
              case 'tdm': // Team Deathmatch
                // Add score to the team that got the kill
                const targetTeam = hit.target.team;
                const attackerTeam = this.player.team;
                
                if (targetTeam !== attackerTeam) {
                  this.teams[attackerTeam].score += 1;
                  this.updateTeamScores();
                }
                break;
                
              default: // FFA and other modes
                this.updateScore(25); // Points for destroying a target
                break;
            }
          } else {
            // Single player scoring
            this.updateScore(25); // Points for destroying an enemy
          }
        }
      }
    }
  }
  
  createHitEffect(position) {
    // Create a simple flash effect at the hit position
    const geometry = new THREE.SphereGeometry(0.2, 8, 8);
    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    
    const flash = new THREE.Mesh(geometry, material);
    flash.position.copy(position);
    this.scene.add(flash);
    
    // Animate and remove after short duration
    const startTime = Date.now();
    const duration = 300;
    
    const animateFlash = () => {
      const elapsed = Date.now() - startTime;
      if (elapsed < duration) {
        const scale = 1 + elapsed / duration;
        flash.scale.set(scale, scale, scale);
        material.opacity = 0.8 * (1 - elapsed / duration);
        requestAnimationFrame(animateFlash);
      } else {
        this.scene.remove(flash);
        geometry.dispose();
        material.dispose();
      }
    };
    
    animateFlash();
  }
  
  checkObstacleCollisions(position, radius) {
    // Simple collision check with obstacles
    for (const obstacle of this.obstacles) {
      if (obstacle.type === 'wall') {
        // Box collision with walls
        const halfSize = new THREE.Vector3().copy(obstacle.size).multiplyScalar(0.5);
        
        // Check if position is within the bounding box of the wall
        if (
          position.x > obstacle.position.x - halfSize.x - radius &&
          position.x < obstacle.position.x + halfSize.x + radius &&
          position.z > obstacle.position.z - halfSize.z - radius &&
          position.z < obstacle.position.z + halfSize.z + radius
        ) {
          return true;
        }
      } else if (obstacle.radius) {
        // Cylinder collision
        const dx = position.x - obstacle.position.x;
        const dz = position.z - obstacle.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < obstacle.radius + radius) {
          return true;
        }
      } else if (obstacle.size) {
        // Box collision with rotation if needed
        const halfSize = new THREE.Vector3().copy(obstacle.size).multiplyScalar(0.5);
        
        // For simplicity, just do a bounding sphere check for now
        const dx = position.x - obstacle.position.x;
        const dz = position.z - obstacle.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        // Use the larger dimension as the bounding radius
        const boundingRadius = Math.max(halfSize.x, halfSize.z);
        
        if (distance < boundingRadius + radius) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  updateScore(points = 0) {
    this.score += points;
    document.getElementById('score-value').textContent = this.score;
  }
  
  updateTeamScores() {
    // Update team scores in the UI
    if (this.multiplayerEnabled && (this.gameMode === 'tdm' || this.gameMode === 'ctf')) {
      document.getElementById('red-score').textContent = this.teams.red.score;
      document.getElementById('blue-score').textContent = this.teams.blue.score;
    }
  }
  
  gameOver() {
    this.isRunning = false;
    
    // Clear score interval
    if (this.scoreInterval) {
      clearInterval(this.scoreInterval);
      this.scoreInterval = null;
    }
    
    // Clear enemy spawner
    if (this.spawnEnemyTimer) {
      clearInterval(this.spawnEnemyTimer);
      this.spawnEnemyTimer = null;
    }
    
    // Hide game UI and show game over screen
    if (this.ui) {
      this.ui.hide();
    }
    document.getElementById('final-score').textContent = this.score;
    document.getElementById('game-over').classList.remove('hidden');
  }
  
  handleResize() {
    // Update camera aspect ratio
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    
    // Update renderer size
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  
  // Multiplayer methods
  enableMultiplayer() {
    this.multiplayerEnabled = true;
    console.log("Multiplayer mode enabled");
    
    // Show multiplayer info in UI
    document.getElementById('multiplayer-info').classList.remove('hidden');
    
    // Set up NetworkManager event listeners
    this.setupNetworkListeners();
    
    // Connect to server
    this.connectToServer();
  }
  
  disableMultiplayer() {
    this.multiplayerEnabled = false;
    console.log("Multiplayer mode disabled");
    
    // Hide multiplayer info in UI
    document.getElementById('multiplayer-info').classList.add('hidden');
    
    // Disconnect from server
    this.disconnectFromServer();
  }
  
  setupNetworkListeners() {
    // Clear existing listeners
    this.networkManager.removeAllListeners();
    
    // Handle player joined
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      
      // Create other player visual representation
      const newPlayer = this.createOtherPlayer(playerData);
      this.players[playerData.id] = newPlayer;
      
      // Update player count in UI
      document.getElementById('players-count').textContent = Object.keys(this.players).length + 1; // +1 for local player
    });
    
    // Handle player left
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      
      // Remove player from scene
      if (this.players[id]) {
        this.scene.remove(this.players[id].mesh);
        delete this.players[id];
        
        // Update player count in UI
        document.getElementById('players-count').textContent = Object.keys(this.players).length + 1; // +1 for local player
      }
    });
    
    // Handle player update
    this.networkManager.on('player_update', (data) => {
      if (this.players[data.id]) {
        this.updateOtherPlayer(this.players[data.id], data);
      }
    });
    
    // Handle laser shot from other players
    this.networkManager.on('laser_shot', (data) => {
      // Create laser from other player
      if (data.origin && data.direction) {
        this.createLaserFromPlayer(data.origin, data.direction, data.playerId);
      }
    });
    
    // Handle connection status
    this.networkManager.on('connected', () => {
      console.log('Connected to server');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    // Handle player ID assignment
    this.networkManager.on('player_id', (id) => {
      this.playerId = id;
      console.log('Assigned player ID:', id);
    });
  }
  
  connectToServer(serverUrl = 'http://localhost:3000') {
    if (!this.multiplayerEnabled) return;
    
    console.log(`Connecting to multiplayer server: ${serverUrl}`);
    this.networkManager.connect(serverUrl);
    
    // Update player count in UI
    document.getElementById('players-count').textContent = '1';
    
    // Assign player to a team if in team mode
    if (this.gameMode === 'tdm' || this.gameMode === 'ctf') {
      const team = Math.random() > 0.5 ? 'red' : 'blue';
      this.player.team = team;
      this.teams[team].players.push(this.playerId);
      console.log(`Assigned to team: ${team}`);
    }
  }
  
  disconnectFromServer() {
    console.log("Disconnecting from multiplayer server");
    
    // Use NetworkManager to disconnect
    this.networkManager.disconnect();
    
    // Reset multiplayer state
    this.playerId = null;
    
    // Remove other players from scene
    for (const id in this.players) {
      this.scene.remove(this.players[id].mesh);
    }
    
    // Reset players and teams
    this.players = {};
    this.teams.red.players = [];
    this.teams.blue.players = [];
    this.player.team = null;
  }
  
  sendPlayerUpdate() {
    if (!this.multiplayerEnabled || !this.networkManager.isConnected()) return;
    if (!this.player || !this.player.mesh) return;
    
    const playerData = {
      position: {
        x: this.player.mesh.position.x,
        y: this.player.mesh.position.y,
        z: this.player.mesh.position.z
      },
      rotation: this.player.mesh.rotation.y,
      team: this.player.team,
      name: this.playerName,
      shipType: this.player.shipType
    };
    
    this.networkManager.sendPlayerUpdate(playerData);
  }
  
  createLaserFromPlayer(origin, direction, playerId) {
    // Implement this method to spawn a laser from another player
    // Similar to your existing laser creation code but from a different origin
    const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
    
    // Determine color based on player's team if applicable
    let laserColor = 0xff0000; // Default red
    if (this.players[playerId] && this.players[playerId].team) {
      laserColor = this.players[playerId].team === 'red' ? 0xff0000 : 0x0000ff;
    }
    
    const laserMaterial = new THREE.MeshBasicMaterial({ 
      color: laserColor,
      emissive: laserColor,
      emissiveIntensity: 1.0
    });
    
    const laser = new THREE.Mesh(laserGeometry, laserMaterial);
    
    // Set laser position and rotation
    laser.position.copy(origin);
    
    // Set laser direction
    const laserDirection = new THREE.Vector3().copy(direction);
    laser.lookAt(laserDirection.add(origin));
    
    // Rotate to align with direction
    laser.rotateX(Math.PI / 2);
    
    // Add to scene
    this.scene.add(laser);
    
    // Add to lasers array for update
    this.lasers.push({
      mesh: laser,
      direction: laserDirection.normalize(),
      speed: 0.5, // Adjust as needed
      playerId: playerId
    });
    
    return laser;
  }
  
  /**
   * Initialize the first game room
   */
  initializeFirstRoom() {
    // Clean up any existing room
    if (this.currentRoom) {
      this.currentRoom.cleanup();
    }
    
    // Create a new room
    this.currentRoom = new GameRoom(
      this.scene, 
      { width: 60, height: 60 }, 
      this.roomTheme || 'space-station'
    );
    
    // Position player at spawn point
    if (this.player && this.currentRoom) {
      const spawnPoint = this.currentRoom.getRandomSpawnPoint();
      this.player.mesh.position.copy(spawnPoint);
    }
    
    // Reset current level
    this.currentLevel = 1;
    
    // Update UI
    this.updateLevelDisplay();
  }
  
  /**
   * Update the level display in the UI
   */
  updateLevelDisplay() {
    const levelElement = document.getElementById('level-value');
    if (levelElement) {
      levelElement.textContent = this.currentLevel;
    }
  }
  
  /**
   * Create an explosion effect at the given position
   */
  createExplosion(position, size = 0.5) {
    // Create a sphere for the explosion
    const geometry = new THREE.SphereGeometry(size, 8, 8);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });
    
    const explosion = new THREE.Mesh(geometry, material);
    explosion.position.copy(position);
    this.scene.add(explosion);
    
    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 10);
    light.position.copy(position);
    this.scene.add(light);
    
    // Animate the explosion
    let scale = 1.0;
    const expandSpeed = 2.0;
    const duration = 0.5; // seconds
    let elapsed = 0;
    
    const animate = (deltaTime) => {
      elapsed += deltaTime;
      const progress = elapsed / duration;
      
      if (progress >= 1) {
        // Remove the explosion
        this.scene.remove(explosion);
        this.scene.remove(light);
        return;
      }
      
      // Expand and fade out
      scale += expandSpeed * deltaTime;
      explosion.scale.set(scale, scale, scale);
      
      // Fade out
      const opacity = 1 - progress;
      material.opacity = opacity;
      light.intensity = 2 * opacity;
      
      // Continue animation
      requestAnimationFrame((timestamp) => {
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        animate(delta / 1000); // Convert ms to seconds
      });
    };
    
    // Start animation
    const lastTimestamp = performance.now();
    animate(0);
  }
  
  /**
   * Transition to the next room/level
   */
  transitionToNextRoom() {
    // Set transition flag
    this.isTransitioning = true;
    
    // Fade out effect
    // Here you would implement a visual fade-out effect
    
    // After fade out, create new room
    setTimeout(() => {
      // Clean up old room
      if (this.currentRoom) {
        this.currentRoom.cleanup();
      }
      
      // Increment level
      this.currentLevel++;
      
      // Create new room with increased difficulty
      this.currentRoom = new GameRoom(
        this.scene,
        { width: 60, height: 60 },
        this.roomTheme || 'space-station',
        { 
          difficulty: this.currentLevel * 0.2,
          obstacleCount: Math.min(10 + this.currentLevel, 30)
        }
      );
      
      // Position player at spawn point
      if (this.player && this.currentRoom) {
        const spawnPoint = this.currentRoom.getRandomSpawnPoint();
        this.player.mesh.position.copy(spawnPoint);
      }
      
      // Update UI
      this.updateLevelDisplay();
      
      // Increase enemy manager difficulty
      if (this.enemyManager) {
        this.enemyManager.increaseDifficulty(0.1 * this.currentLevel);
        this.enemyManager.increaseMaxEnemies(1);
      }
      
      // Fade in effect
      // Here you would implement a visual fade-in effect
      
      // Reset transition flag
      setTimeout(() => {
        this.isTransitioning = false;
      }, 500); // After fade-in completes
      
    }, 1000); // After fade-out completes
  }
  
  /**
   * Update UI elements
   */
  updateUI() {
    // Update health and energy displays
    if (this.player) {
      // Update health
      const healthElement = document.getElementById('health-value');
      if (healthElement) {
        healthElement.textContent = Math.round(this.player.health);
        
        // Update health bar
        const healthBar = document.getElementById('health-bar-inner');
        if (healthBar) {
          const healthPercent = (this.player.health / this.player.maxHealth) * 100;
          healthBar.style.width = `${healthPercent}%`;
        }
      }
      
      // Update energy
      const energyElement = document.getElementById('energy-value');
      if (energyElement) {
        energyElement.textContent = Math.round(this.player.energy);
        
        // Update energy bar
        const energyBar = document.getElementById('energy-bar-inner');
        if (energyBar) {
          const energyPercent = (this.player.energy / this.player.maxEnergy) * 100;
          energyBar.style.width = `${energyPercent}%`;
        }
      }
      
      // Update shield
      const shieldElement = document.getElementById('shield-value');
      if (shieldElement) {
        shieldElement.textContent = Math.round(this.player.shields);
        
        // Update shield bar
        const shieldBar = document.getElementById('shield-bar-inner');
        if (shieldBar) {
          const shieldPercent = (this.player.shields / this.player.maxShields) * 100;
          shieldBar.style.width = `${shieldPercent}%`;
        }
      }
    }
    
    // Update score
    const scoreElement = document.getElementById('score-value');
    if (scoreElement && this.player) {
      scoreElement.textContent = this.player.score;
    }
  }
  
  /**
   * Setup event listeners for window resizing and UI controls
   */
  setupEventListeners() {
    // Handle window resize
    window.addEventListener('resize', () => this.handleResize());
    
    // Handle pause/resume game
    const pauseButton = document.getElementById('pause-button');
    if (pauseButton) {
      pauseButton.addEventListener('click', () => {
        this.isPaused = !this.isPaused;
        pauseButton.textContent = this.isPaused ? 'Resume' : 'Pause';
      });
    }
    
    // Handle restart game
    const restartButton = document.getElementById('restart-button');
    if (restartButton) {
      restartButton.addEventListener('click', () => this.restart());
    }
  }
  
  /**
   * Show the game UI elements
   */
  showGameUI() {
    // Show game UI
    if (this.ui) {
      this.ui.show();
    }
    
    // Hide any splash screens or menus
    const splashScreen = document.getElementById('splash-screen');
    if (splashScreen) {
      splashScreen.style.display = 'none';
    }
  }
  
  // Create visual representation for other players
  createOtherPlayer(playerData) {
    console.log('Creating other player with data:', playerData);
    
    // Ensure assets are loaded
    if (!this.assetsLoaded) {
      console.warn('Attempting to create player before assets are loaded');
      return null;
    }
    
    // Get ship type from player data or default to STANDARD
    const shipType = playerData.shipType || 'STANDARD';
    console.log('Using ship type:', shipType);
    
    // Try to get ship model from asset loader first
    let ship = null;
    try {
      ship = this.assetLoader.getOpponentShipModel(shipType);
      if (ship) {
        console.log('Successfully loaded ship model for type:', shipType);
        ship.scale.set(0.45, 0.45, 0.45);
      }
    } catch (error) {
      console.warn('Failed to load ship model:', error);
    }
    
    // Fallback to geometry if model loading failed
    if (!ship) {
      console.log('Using fallback geometry for ship type:', shipType);
      // Create geometry based on ship type
      let geometry;
      switch(shipType) {
        case 'INTERCEPTOR':
          geometry = new THREE.ConeGeometry(0.4, 1.25, 4);
          break;
        case 'HEAVY':
          geometry = new THREE.CylinderGeometry(0.6, 0.7, 1.0, 6);
          break;
        case 'SCOUT':
          geometry = new THREE.ConeGeometry(0.3, 1.1, 5);
          break;
        case 'STANDARD':
        default:
          geometry = new THREE.ConeGeometry(0.5, 1.0, 3);
          break;
      }
      
      // Rotate geometry to align with movement direction
      geometry.rotateX(Math.PI / 2);
      
      // Create material based on team color
      const shipColor = playerData.teamColor || 0x00ffff;
      const material = new THREE.MeshPhongMaterial({ 
        color: shipColor, 
        emissive: shipColor,
        emissiveIntensity: 0.5,
        shininess: 100
      });
      
      // Create mesh
      ship = new THREE.Mesh(geometry, material);
    }
    
    // Add engine glow effect
    const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
    engineGlow.position.set(0, 0, -0.5);
    ship.add(engineGlow);
    
    // Add ship to scene
    this.scene.add(ship);
    
    // Create name label
    const nameDiv = document.createElement('div');
    nameDiv.className = 'player-label';
    nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
    
    const nameLabel = new CSS2DObject(nameDiv);
    nameLabel.position.set(0, 1, 0);
    ship.add(nameLabel);
    
    // Set initial position if provided
    if (playerData.position) {
      ship.position.set(
        playerData.position.x,
        playerData.position.y || 0.5,
        playerData.position.z
      );
    }
    
    // Set initial rotation if provided
    if (playerData.rotation !== undefined) {
      ship.rotation.y = playerData.rotation;
    }
    
    console.log('Player object created successfully:', {
      id: playerData.id,
      name: playerData.name,
      shipType,
      position: ship.position.toArray(),
      rotation: ship.rotation.y
    });
    
    // Return the player object
    return {
      mesh: ship,
      nameLabel,
      engineGlow,
      team: playerData.team,
      health: 100,
      shipType,
      lastUpdate: Date.now()
    };
  }
  
  // Update other player with new data
  updateOtherPlayer(player, data) {
    if (!player || !player.mesh) {
      console.warn('Invalid player object for update:', { player, data });
      return;
    }
    
    const now = Date.now();
    const timeSinceLastUpdate = now - (player.lastUpdate || 0);
    console.log(`Updating player ${data.id}, time since last update: ${timeSinceLastUpdate}ms`);
    
    // Update position with smooth lerping
    if (data.position) {
      const targetPos = new THREE.Vector3(
        data.position.x,
        data.position.y || 0.5,
        data.position.z
      );
      
      const currentPos = player.mesh.position.clone();
      player.mesh.position.lerp(targetPos, 0.3);
      
      // Log position change
      const distance = currentPos.distanceTo(player.mesh.position);
      if (distance > 0.01) {
        console.log('Position updated:', {
          from: currentPos.toArray(),
          to: player.mesh.position.toArray(),
          distance: distance.toFixed(3)
        });
      }
    }
    
    // Update rotation with smooth interpolation
    if (data.rotation !== undefined) {
      const currentRotation = player.mesh.rotation.y;
      
      // Find shortest rotation path
      let rotDiff = data.rotation - currentRotation;
      if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
      if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
      
      const newRotation = currentRotation + rotDiff * 0.3;
      player.mesh.rotation.y = newRotation;
      
      // Log significant rotation changes
      if (Math.abs(rotDiff) > 0.1) {
        console.log('Rotation updated:', {
          from: currentRotation.toFixed(3),
          to: newRotation.toFixed(3),
          difference: rotDiff.toFixed(3)
        });
      }
    }
    
    // Update team if changed
    if (data.team !== undefined && data.team !== player.team) {
      console.log('Team changed:', { from: player.team, to: data.team });
      player.team = data.team;
    }
    
    // Update last update timestamp
    player.lastUpdate = now;
  }

  handleAssetError(type, error) {
    console.error(`Asset loading error (${type}):`, error);
    if (type === 'critical') {
      // Show error UI
      this.ui.showError('Failed to load game assets. Please refresh the page.');
    }
  }
} 
### ./core/GameEngine.js END ###

### ./core/Engine.js BEGIN ###
import * as THREE from 'three';

class Engine {
    constructor() {
        // Core engine properties
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        this.lastTime = Date.now();
        
        // Bind methods
        this.animate = this.animate.bind(this);
        this.handleResize = this.handleResize.bind(this);
    }

    init() {
        this.setupScene();
        this.setupRenderer();
        this.setupCamera();
        this.setupLights();
        this.setupEventListeners();
        
        return this;
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000011);
    }

    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
    }

    setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);

        // Camera smoothing properties
        this.cameraTargetPosition = new THREE.Vector3();
        this.cameraTargetLookAt = new THREE.Vector3();
        this.cameraSmoothingFactor = 0.05;
    }

    setupLights() {
        const ambientLight = new THREE.AmbientLight(0x404040);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        this.scene.add(directionalLight);
    }

    setupEventListeners() {
        window.addEventListener('resize', this.handleResize);
    }

    handleResize() {
        if (this.camera && this.renderer) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    animate() {
        requestAnimationFrame(this.animate);

        const now = Date.now();
        const deltaTime = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // Update game state
        if (this.update) {
            this.update(deltaTime);
        }

        // Render scene
        if (this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }

    start() {
        this.animate();
    }

    cleanup() {
        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);

        // Cleanup THREE.js resources
        this.scene?.traverse(object => {
            if (object.geometry) {
                object.geometry.dispose();
            }
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });

        // Dispose of renderer
        if (this.renderer) {
            this.renderer.dispose();
            document.body.removeChild(this.renderer.domElement);
        }
    }

    // Utility methods for scene management
    add(...objects) {
        objects.forEach(object => this.scene.add(object));
    }

    remove(...objects) {
        objects.forEach(object => this.scene.remove(object));
    }
}

export default Engine; 
### ./core/Engine.js END ###

### ./core/NetworkManager.js BEGIN ###
import { EventEmitter } from 'events';
import { io } from 'socket.io-client';

export class NetworkManager extends EventEmitter {
  constructor() {
    super();
    this.socket = null;
    this.playerId = null;
    this.connected = false;
    this.players = new Map();
    this.lastUpdateTime = 0;
    this.updateInterval = 50; // 20 updates per second
  }

  connect(serverUrl = 'http://localhost:3000') {
    // Don't reconnect if already connected
    if (this.connected) return;

    // Create socket connection
    this.socket = io(serverUrl, {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 10
    });

    // Set up event handlers
    this.socket.on('connect', () => {
      console.log('Connected to game server');
      this.connected = true;
      this.emit('connected');
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from game server');
      this.connected = false;
      this.emit('disconnected');
    });

    this.socket.on('player_id', (id) => {
      this.playerId = id;
      console.log(`Assigned player ID: ${id}`);
      this.emit('player_id', id);
    });

    this.socket.on('player_joined', (player) => {
      if (player.id !== this.playerId) {
        this.players.set(player.id, player);
        console.log(`Player joined: ${player.id}`);
        this.emit('player_joined', player);
      }
    });

    this.socket.on('player_left', (id) => {
      this.players.delete(id);
      console.log(`Player left: ${id}`);
      this.emit('player_left', id);
    });

    this.socket.on('player_update', (update) => {
      if (update.id !== this.playerId) {
        const player = this.players.get(update.id);
        if (player) {
          // Update the player with new data
          Object.assign(player, update);
          player.lastUpdate = Date.now();
          this.emit('player_update', update);
        }
      }
    });

    this.socket.on('laser_shot', (data) => {
      if (data.playerId !== this.playerId) {
        this.emit('laser_shot', data);
      }
    });

    // Handle initial player list
    this.socket.on('players', (players) => {
      players.forEach(player => {
        if (player.id !== this.playerId) {
          this.players.set(player.id, player);
        }
      });
      this.emit('players', players);
    });

    // Handle error
    this.socket.on('error', (error) => {
      console.error('Socket error:', error);
      this.emit('error', error);
    });
  }

  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.playerId = null;
      this.connected = false;
      this.players.clear();
    }
  }

  sendPlayerUpdate(data) {
    if (!this.connected || !this.socket) return;

    const now = Date.now();
    // Throttle updates to save bandwidth
    if (now - this.lastUpdateTime < this.updateInterval) return;
    
    this.lastUpdateTime = now;
    
    this.socket.emit('player_update', {
      id: this.playerId,
      ...data
    });
  }

  sendLaserShot(data) {
    if (!this.connected || !this.socket) return;
    
    this.socket.emit('laser_shot', {
      playerId: this.playerId,
      ...data
    });
  }

  updatePlayerInfo(name, shipType) {
    if (!this.connected || !this.socket) return;
    
    this.socket.emit('player_info', {
      id: this.playerId,
      name: name,
      shipType: shipType
    });
  }

  // Get all other players (not including self)
  getOtherPlayers() {
    return Array.from(this.players.values());
  }

  isConnected() {
    return this.connected;
  }

  getPlayerId() {
    return this.playerId;
  }
} 
### ./core/NetworkManager.js END ###

### ./core/InfiniteMap.js BEGIN ###
import * as THREE from 'three';

/**
 * Manages an infinite map system using chunks
 */
export class InfiniteMap {
  constructor(game) {
    this.game = game;
    this.chunks = new Map(); // Map of loaded chunks
    this.chunkSize = 100; // Size of each chunk in world units
    this.loadDistance = 2; // Number of chunks to load in each direction
    this.cullingDistance = 3; // Number of chunks before culling
    
    // Track current chunk
    this.currentChunkX = 0;
    this.currentChunkZ = 0;
    
    // Asset categories for random placement
    this.assetCategories = {
      flora: [
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SP_Tree01.glb',
        'SP_Tree02.glb',
        'SP_Tree03.glb',
        'SP_Tree04.glb',
      ],
      rocks: [
        'SP_Rock01.glb',
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      objects: [
        'SP_Crystal01.glb',
        'SP_Ground02.glb',
        'SP_Ground03.glb',
        'SP_Ground04.glb',
        'SP_Ground05.glb',
        'SP_Mountain01.glb',
        'SP_Mountain02.glb',
        'SP_Mountain03.glb',
        'SP_Stone01.glb'
      ]
    };
  }

  /**
   * Get chunk key from world coordinates
   */
  getChunkKey(x, z) {
    const chunkX = Math.floor(x / this.chunkSize);
    const chunkZ = Math.floor(z / this.chunkSize);
    return `${chunkX},${chunkZ}`;
  }

  /**
   * Update chunks based on player position
   */
  update(playerPosition) {
    // Get current chunk from player position
    const newChunkX = Math.floor(playerPosition.x / this.chunkSize);
    const newChunkZ = Math.floor(playerPosition.z / this.chunkSize);

    // If chunk changed, update loaded chunks
    if (newChunkX !== this.currentChunkX || newChunkZ !== this.currentChunkZ) {
      this.currentChunkX = newChunkX;
      this.currentChunkZ = newChunkZ;
      this.updateLoadedChunks();
    }
  }

  /**
   * Update which chunks are loaded based on current position
   */
  updateLoadedChunks() {
    // Track which chunks should be kept
    const chunksToKeep = new Set();

    // Calculate chunks to load
    for (let x = -this.loadDistance; x <= this.loadDistance; x++) {
      for (let z = -this.loadDistance; z <= this.loadDistance; z++) {
        const chunkX = this.currentChunkX + x;
        const chunkZ = this.currentChunkZ + z;
        const key = `${chunkX},${chunkZ}`;
        chunksToKeep.add(key);

        // Load chunk if not already loaded
        if (!this.chunks.has(key)) {
          this.loadChunk(chunkX, chunkZ);
        }
      }
    }

    // Unload chunks that are too far away
    for (const [key, chunk] of this.chunks) {
      if (!chunksToKeep.has(key)) {
        const distance = Math.max(
          Math.abs(chunk.x - this.currentChunkX),
          Math.abs(chunk.z - this.currentChunkZ)
        );

        if (distance > this.cullingDistance) {
          this.unloadChunk(key);
        }
      }
    }
  }

  /**
   * Load a new chunk at the specified coordinates
   */
  loadChunk(chunkX, chunkZ) {
    const key = `${chunkX},${chunkZ}`;
    
    // Create chunk container
    const chunk = {
      x: chunkX,
      z: chunkZ,
      objects: [],
      group: new THREE.Group()
    };

    // Calculate world position of chunk corner
    const worldX = chunkX * this.chunkSize;
    const worldZ = chunkZ * this.chunkSize;

    // Add random objects to chunk
    this.populateChunk(chunk, worldX, worldZ);

    // Add chunk to scene
    this.game.scene.add(chunk.group);
    this.chunks.set(key, chunk);
  }

  /**
   * Populate a chunk with random objects
   */
  populateChunk(chunk, worldX, worldZ) {
    // Number of objects to place in each category
    const counts = {
      flora: this.getRandomInt(3, 6),
      rocks: this.getRandomInt(2, 4),
      objects: this.getRandomInt(1, 3)
    };

    // Place objects from each category
    for (const [category, assets] of Object.entries(this.assetCategories)) {
      for (let i = 0; i < counts[category]; i++) {
        // Get random asset from category
        const assetPath = assets[Math.floor(Math.random() * assets.length)];
        
        // Calculate random position within chunk
        const x = worldX + Math.random() * this.chunkSize;
        const z = worldZ + Math.random() * this.chunkSize;

        // Load and place object
        this.game.assetLoader.loadModel(`models/${category}/${assetPath}`)
          .then(model => {
            // Random rotation
            model.rotation.y = Math.random() * Math.PI * 2;

            // Random scale based on category
            let scale = 1;
            if (category === 'flora') {
              scale = 0.5 + Math.random() * 0.5;
            } else if (category === 'rocks') {
              scale = 0.3 + Math.random() * 0.4;
            } else {
              scale = 0.2 + Math.random() * 0.3;
            }
            model.scale.set(scale, scale, scale);

            // Position object
            model.position.set(x, 0, z);

            // Add to chunk group
            chunk.group.add(model);

            // Store object data for collision
            chunk.objects.push({
              model,
              position: model.position.clone(),
              radius: this.calculateCollisionRadius(model, scale),
              type: category
            });
          })
          .catch(error => console.error('Error loading model:', error));
      }
    }
  }

  /**
   * Calculate appropriate collision radius for an object
   */
  calculateCollisionRadius(model, scale) {
    // Calculate using bounding box for more accuracy
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Use the larger of width or depth (horizontal dimensions)
    const radius = Math.max(size.x, size.z) / 2;
    
    // Apply scale
    const scaledRadius = radius * scale;
    
    // Add small padding (10%) for better collision detection
    return scaledRadius * 1.1;
  }

  /**
   * Unload a chunk and remove it from the scene
   */
  unloadChunk(key) {
    const chunk = this.chunks.get(key);
    if (chunk) {
      // Remove from scene
      this.game.scene.remove(chunk.group);
      
      // Dispose of geometries and materials
      chunk.group.traverse(object => {
        if (object.geometry) {
          object.geometry.dispose();
        }
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach(material => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });

      // Remove from chunks map
      this.chunks.delete(key);
    }
  }

  /**
   * Get random integer between min and max (inclusive)
   */
  getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * Check for collisions with objects in nearby chunks
   */
  checkCollisions(position, radius) {
    const currentKey = this.getChunkKey(position.x, position.z);
    const nearbyChunks = this.getNearbyChunks(currentKey);
    
    // First, do a quick sphere-based check for efficiency
    for (const chunk of nearbyChunks) {
      for (const object of chunk.objects) {
        const distance = position.distanceTo(object.position);
        const quickCheckDistance = radius + object.radius;
        
        // Skip detailed check if clearly not colliding
        if (distance > quickCheckDistance * 1.2) continue;
        
        // For close objects, do a more accurate bounding box check
        const model = object.model;
        
        // Get bounding box in world space
        const bbox = new THREE.Box3().setFromObject(model);
        
        // Create a sphere representing the player
        const playerSphere = {
          center: position.clone(),
          radius: radius
        };
        
        // Check if sphere intersects with box - simple approximation
        const collision = this.checkSphereBoxIntersection(playerSphere, bbox);
        
        if (collision) {
          return {
            collided: true,
            object: {
              position: object.position.clone(),
              radius: object.radius,
              type: object.type
            },
            distance: distance
          };
        }
      }
    }
    
    return { collided: false };
  }

  /**
   * Check if a sphere intersects with a box
   */
  checkSphereBoxIntersection(sphere, box) {
    // Find the closest point on the box to the sphere
    const closestPoint = new THREE.Vector3().copy(sphere.center);
    
    // For each axis, clamp the sphere center to the box bounds
    closestPoint.x = Math.max(box.min.x, Math.min(box.max.x, closestPoint.x));
    closestPoint.y = Math.max(box.min.y, Math.min(box.max.y, closestPoint.y));
    closestPoint.z = Math.max(box.min.z, Math.min(box.max.z, closestPoint.z));
    
    // Calculate distance from closest point to sphere center
    const distance = closestPoint.distanceTo(sphere.center);
    
    // If this distance is less than the sphere radius, we have a collision
    return distance < sphere.radius;
  }

  /**
   * Get array of chunks near the specified chunk
   */
  getNearbyChunks(key) {
    const [x, z] = key.split(',').map(Number);
    const nearby = [];
    
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        const nearbyKey = `${x + dx},${z + dz}`;
        const chunk = this.chunks.get(nearbyKey);
        if (chunk) {
          nearby.push(chunk);
        }
      }
    }
    
    return nearby;
  }
} 
### ./core/InfiniteMap.js END ###

### ./config/ShipConfig.js BEGIN ###
export const SHIP_TYPES = {
    SCOUT: 'SCOUT',
    INTERCEPTOR: 'INTERCEPTOR',
    HEAVY: 'HEAVY'
};

export const SHIP_STATUS = {
    FREE: 'FREE',
    PREMIUM: 'PREMIUM'
};

export const SHIP_CONFIGS = {
    [SHIP_TYPES.SCOUT]: {
        name: 'Scout',
        description: 'Fast and agile, but lightly armored',
        status: SHIP_STATUS.FREE,
        stats: {
            health: 80,
            speed: 0.2,
            size: 0.8,
            turnSpeed: 0.15,
            acceleration: 0.12
        },
        model: 'SCOUT',
        abilities: ['Quick Boost', 'Stealth Mode']
    },
    [SHIP_TYPES.INTERCEPTOR]: {
        name: 'Interceptor',
        description: 'Balanced combat vessel',
        status: SHIP_STATUS.FREE,
        stats: {
            health: 100,
            speed: 0.15,
            size: 1.0,
            turnSpeed: 0.1,
            acceleration: 0.1
        },
        model: 'INTERCEPTOR',
        abilities: ['Shield Burst', 'EMP Blast']
    },
    [SHIP_TYPES.HEAVY]: {
        name: 'Heavy Destroyer',
        description: 'Premium battle cruiser with superior firepower',
        status: SHIP_STATUS.PREMIUM,
        stats: {
            health: 150,
            speed: 0.12,
            size: 1.2,
            turnSpeed: 0.08,
            acceleration: 0.08
        },
        model: 'HEAVY',
        abilities: ['Heavy Shield', 'Missile Barrage', 'Area Denial']
    }
};

export class ShipSelector {
    static getAvailableShips(isPremium = false) {
        return Object.entries(SHIP_CONFIGS)
            .filter(([_, config]) => 
                config.status === SHIP_STATUS.FREE || 
                (isPremium && config.status === SHIP_STATUS.PREMIUM)
            )
            .map(([type, config]) => ({
                type,
                ...config
            }));
    }

    static getShipConfig(type) {
        return SHIP_CONFIGS[type];
    }

    static isShipAvailable(type, isPremium = false) {
        const config = SHIP_CONFIGS[type];
        return config && (
            config.status === SHIP_STATUS.FREE || 
            (isPremium && config.status === SHIP_STATUS.PREMIUM)
        );
    }
} 
### ./config/ShipConfig.js END ###

### ./config/Controls.js BEGIN ###
// Control configuration for the game
// This file centralizes all control-related settings and mappings

// Key mappings for different actions
export const KEY_MAPPINGS = {
    // Movement controls
    MOVEMENT: {
        FORWARD: ['KeyW', 'ArrowUp'],
        BACKWARD: ['KeyS', 'ArrowDown'],
        LEFT: ['KeyA', 'ArrowLeft'],
        RIGHT: ['KeyD', 'ArrowRight'],
        STRAFE_LEFT: ['KeyQ'],
        STRAFE_RIGHT: ['KeyE']
    },
    // Weapon controls
    WEAPONS: {
        FIRE: ['Space'],
        SELECT_LASER: ['Digit1'],
        SELECT_GRENADE: ['Digit2'],
        SELECT_BOUNCE: ['Digit3'],
        SWITCH_WEAPON: ['KeyX']
    },
    // UI controls
    UI: {
        TOGGLE_MAP: ['KeyM'],
        TOGGLE_CONTROLS: ['KeyC']
    }
};

// Control settings and configurations
export const CONTROL_SETTINGS = {
    // Movement settings
    MOVEMENT: {
        ROTATION_SPEED: 2.5,
        SHIP_SPEED: 30,
        ACCELERATION: 1.0,
        DECELERATION: 0.95,
        STRAFE_SPEED_MULTIPLIER: 0.8
    },
    // Weapon cooldowns (in milliseconds)
    WEAPON_COOLDOWNS: {
        LASER: 200,
        BOUNCE: 500,
        GRENADE: 1000
    },
    // Touch controls settings
    TOUCH: {
        JOYSTICK_MAX_DISTANCE: 40,
        JOYSTICK_DEAD_ZONE: 10,
        DOUBLE_TAP_DELAY: 300
    }
};

// Visual feedback settings for controls
export const CONTROL_FEEDBACK = {
    INDICATORS: {
        MOVEMENT: [
            { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward' },
            { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward' },
            { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left' },
            { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right' },
            { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left' },
            { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right' }
        ],
        WEAPONS: [
            { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser' },
            { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade' },
            { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser' },
            { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon' }
        ],
        ACTIONS: [
            { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon' }
        ]
    }
};

// Default control state
export const DEFAULT_CONTROL_STATE = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    strafeLeft: false,
    strafeRight: false,
    fire: false,
    switchWeapon: false
};

// Helper functions for control handling
export const ControlUtils = {
    /**
     * Check if a key code matches any of the specified actions
     * @param {string} keyCode - The key code to check
     * @param {string} action - The action to check against
     * @param {string} category - The category of the action (MOVEMENT, WEAPONS, UI)
     * @returns {boolean} - Whether the key matches the action
     */
    isKeyMatch: (keyCode, action, category) => {
        return KEY_MAPPINGS[category]?.[action]?.includes(keyCode) || false;
    },

    /**
     * Get the action for a given key code
     * @param {string} keyCode - The key code to check
     * @returns {Object|null} - The matching action and category, or null if no match
     */
    getActionForKey: (keyCode) => {
        for (const [category, actions] of Object.entries(KEY_MAPPINGS)) {
            for (const [action, keys] of Object.entries(actions)) {
                if (keys.includes(keyCode)) {
                    return { category, action };
                }
            }
        }
        return null;
    },

    /**
     * Check if a key is a weapon selection key
     * @param {string} keyCode - The key code to check
     * @returns {boolean} - Whether the key is a weapon selection key
     */
    isWeaponSelectionKey: (keyCode) => {
        return KEY_MAPPINGS.WEAPONS.SELECT_LASER.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SELECT_GRENADE.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SELECT_BOUNCE.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SWITCH_WEAPON.includes(keyCode);
    }
}; 
### ./config/Controls.js END ###

### ./config/GameConfig.js BEGIN ###
export const GAME_CONFIG = {
    PLAYER: {
        INITIAL_HEALTH: 100,
        INITIAL_ENERGY: 100,
        ENERGY_RECHARGE_RATE: 20,
        MOVEMENT_SPEED: 0.1,
        ROTATION_SPEED: 0.05,
        COLLISION_RADIUS: 0.8
    },
    
    WEAPONS: {
        LASER: {
            COOLDOWN: 200,
            SPEED: 1.2,
            DAMAGE: 10,
            ENERGY_COST: 25,
            TRAIL_LENGTH: 8
        },
        BOUNCE: {
            COOLDOWN: 500,
            SPEED: 0.8,
            DAMAGE: 25,
            ENERGY_COST: 50,
            MAX_BOUNCES: 3,
            TRAIL_LENGTH: 12
        },
        GRENADE: {
            COOLDOWN: 1000,
            EXPLOSION_RADIUS: 4,
            MAX_DAMAGE: 50,
            ENERGY_COST: 100,
            TRAIL_LENGTH: 20
        }
    },
    
    SCENE: {
        BOUNDARY_SIZE: 25,
        GRID_SIZE: 100,
        GRID_DIVISIONS: 100,
        NUM_OBSTACLES: 15,
        MIN_OBSTACLE_DISTANCE: 10
    },
    
    CAMERA: {
        FOV: 75,
        NEAR: 0.1,
        FAR: 1000,
        POSITION: {
            Y: 18,
            Z: -16
        },
        SMOOTHING: 0.05
    },
    
    COLORS: {
        BACKGROUND: 0x000011,
        GRID: {
            MAIN: 0x444444,
            SECONDARY: 0x222222
        },
        LASER: 0x00ffff,
        BOUNCE: 0x00ff99,
        GRENADE: 0xff4500
    },
    
    EFFECTS: {
        PULSE_SPEED: 0.2,
        TRAIL_OPACITY: 0.5,
        GLOW_INTENSITY: 2
    }
};

// Weapon type constants
export const WEAPON_TYPES = {
    LASER: 'LASER',
    BOUNCE: 'BOUNCE',
    GRENADE: 'GRENADE'
}; 
### ./config/GameConfig.js END ###

### ./styles/main.css BEGIN ###
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --neon-text-color: #f40183;
  --neon-border-color: #08f;
  --bg-color: #000;
  --secondary-color: #0ff;
  --accent-color: #ff00ff;
  --success-color: #00ff88;
  --warning-color: #ffaa00;
  --danger-color: #ff3300;
}

body {
  font-family: 'Orbitron', sans-serif;
  background-color: var(--bg-color);
  color: #fff;
  overflow: hidden;
}

/* Loading Screen */
#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--bg-color);
  z-index: 100;
}

.loading-content {
  text-align: center;
}

.loading-content h1 {
  font-size: 4rem;
  margin-bottom: 2rem;
  text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--neon-text-color),
    0 0 20px var(--neon-text-color), 0 0 25px var(--neon-text-color),
    0 0 30px var(--neon-text-color), 0 0 35px var(--neon-text-color);
}

.loader {
  border: 5px solid transparent;
  border-top: 5px solid var(--neon-text-color);
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem;
  box-shadow: 0 0 10px var(--neon-text-color);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Start Screen Enhancements */
#start-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  background: radial-gradient(circle at center, rgba(15, 30, 60, 0.5) 0%, rgba(0, 0, 0, 0.95) 70%);
  overflow: hidden;
}

#start-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(125deg, rgba(0, 60, 255, 0.05), rgba(120, 0, 170, 0.05));
  z-index: -1;
}

.start-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 600px;
  width: 90%;
  padding: 2rem;
  border-radius: 8px;
  background: rgba(5, 10, 20, 0.7);
  box-shadow: 0 0 40px rgba(0, 195, 255, 0.15);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(48, 197, 255, 0.2);
  transform: translateY(0);
  animation: float 6s ease-in-out infinite;
}

@keyframes float {
  0% { transform: translateY(0px); }
  50% { transform: translateY(-15px); }
  100% { transform: translateY(0px); }
}

.start-content h1 {
  font-size: 3.5rem;
  font-weight: 900;
  margin-bottom: 2rem;
  text-align: center;
  color: #fff;
  text-shadow: 
    0 0 10px #ff007b,
    0 0 20px #ff007b,
    0 0 30px #ff007b,
    0 0 40px #ff007b;
  letter-spacing: 0.1em;
  animation: pulsate 2s infinite;
}

@keyframes pulsate {
  0% { text-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 30px #ff007b, 0 0 40px #ff007b; }
  50% { text-shadow: 0 0 15px #ff007b, 0 0 25px #ff007b, 0 0 35px #ff007b, 0 0 50px #ff007b; }
  100% { text-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 30px #ff007b, 0 0 40px #ff007b; }
}

/* Buttons */
.glow-button {
  background-color: transparent;
  color: var(--neon-border-color);
  border: 0.2rem solid var(--neon-border-color);
  border-radius: 0.5rem;
  padding: 1rem 2rem;
  font-size: 1.5rem;
  font-family: 'Orbitron', sans-serif;
  cursor: pointer;
  transition: all 0.3s;
  text-shadow: 0 0 5px var(--neon-border-color), 0 0 10px var(--neon-border-color);
  box-shadow: 0 0 10px var(--neon-border-color), inset 0 0 10px var(--neon-border-color);
}

.glow-button:hover {
  background-color: var(--neon-border-color);
  color: #000;
  box-shadow: 0 0 20px var(--neon-border-color), inset 0 0 20px #000;
}

/* Canvas */
canvas {
  display: block;
}

/* HUD Elements */
.hud {
  position: fixed;
  top: 20px;
  left: 20px;
  color: var(--secondary-color);
  font-size: 1rem;
  text-shadow: 0 0 5px var(--secondary-color);
  z-index: 100;
  pointer-events: none;
}

/* Controls info */
.controls-info {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #00ffff;
  border-radius: 10px;
  padding: 20px;
  color: #fff;
  text-align: center;
  z-index: 1000;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
  animation: fadeIn 0.5s ease-in-out;
}

.controls-info h3 {
  color: #00ffff;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 24px;
}

.controls-info p {
  margin: 8px 0;
  font-size: 16px;
  color: #eee;
}

.controls-info.fade-out {
  animation: fadeOut 0.5s ease-in-out forwards;
}

/* Ensure these keyframes are defined */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Fix hidden class */
.hidden {
  display: none !important;
}

/* Controls */
.control-indicators {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 15px;
  transition: opacity 0.5s ease, transform 0.3s ease;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.4);
  backdrop-filter: blur(5px);
}

.control-indicators.visible {
  opacity: 1;
  transform: translateY(0);
}

.control-indicators.fading {
  opacity: 0.2;
  transform: translateY(10px);
}

.control-indicators.hidden {
  opacity: 0;
  transform: translateY(30px);
  pointer-events: none;
}

.control-group {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}

.movement-controls {
  display: grid;
  grid-template-areas:
    ".    forward    ."
    "left backward right"
    "strafeLeft fire strafeRight";
  grid-gap: 5px;
}

.weapon-controls {
  display: flex;
  justify-content: center;
  gap: 10px;
}

.key-indicator {
  width: 50px;
  height: 50px;
  background: rgba(20, 20, 30, 0.8);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #aaf;
  font-family: 'Rajdhani', sans-serif;
  border: 1px solid rgba(0, 200, 255, 0.2);
  transition: all 0.2s ease;
  box-shadow: 0 0 5px rgba(0, 200, 255, 0.1);
  overflow: hidden;
}

.key-indicator.active {
  background: rgba(0, 150, 200, 0.4);
  color: #fff;
  border-color: rgba(0, 255, 255, 0.8);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
  transform: scale(1.05);
}

.key-indicator .key {
  font-size: 12px;
  background: rgba(0, 0, 0, 0.5);
  padding: 2px 5px;
  border-radius: 4px;
  margin-bottom: 3px;
  font-weight: bold;
}

.key-indicator .label {
  font-size: 18px;
  line-height: 1;
}

.weapon-key {
  background: rgba(30, 20, 40, 0.8);
  border-color: rgba(255, 100, 255, 0.2);
}

.weapon-key.active {
  background: rgba(150, 0, 200, 0.4);
  border-color: rgba(255, 100, 255, 0.8);
  box-shadow: 0 0 15px rgba(255, 100, 255, 0.5);
}

.controls-hint {
  text-align: center;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
  margin-top: 5px;
  font-family: 'Rajdhani', sans-serif;
}

/* Game UI */
.game-ui {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10;
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 220px;
  background: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  backdrop-filter: blur(5px);
  box-shadow: 0 0 15px rgba(0, 200, 255, 0.2);
  border: 1px solid rgba(0, 200, 255, 0.3);
  transition: all 0.3s ease;
}

.game-ui.hidden {
  display: none;
  opacity: 0;
}

.status-bars {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.bar-container {
  display: flex;
  align-items: center;
  gap: 10px;
}

.bar-container {
  flex-direction: row;
}

.bar-label {
  width: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: #fff;
  font-weight: bold;
  order: 1;
}

.bar-outer {
  flex: 1;
  height: 10px;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 5px;
  overflow: hidden;
  position: relative;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
  order: 2;
}

.bar-inner {
  height: 100%;
  transition: width 0.3s ease, background-color 0.3s ease;
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.health-bar {
  background: linear-gradient(90deg, #0f0, #5f0);
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
}

.health-bar.warning {
  background: linear-gradient(90deg, #ff0, #fa0);
  box-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
}

.health-bar.critical {
  background: linear-gradient(90deg, #f00, #a00);
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
  animation: pulse-critical 0.8s infinite;
}

.energy-bar {
  background: linear-gradient(90deg, #00f, #06f);
  box-shadow: 0 0 8px rgba(0, 0, 255, 0.5);
}

.energy-bar.warning {
  background: linear-gradient(90deg, #09f, #07a);
  box-shadow: 0 0 8px rgba(0, 100, 255, 0.5);
}

.energy-bar.critical {
  background: linear-gradient(90deg, #07f, #059);
  box-shadow: 0 0 8px rgba(0, 50, 255, 0.5);
}

.weapon-indicator {
  display: flex;
  align-items: center;
  margin-top: 5px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 5px;
  padding: 5px 10px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.weapon-label {
  font-size: 14px;
  color: #aaa;
  margin-right: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.weapon-name {
  flex: 1;
  text-align: right;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  letter-spacing: 1px;
  text-shadow: 0 0 5px currentColor;
}

.weapon-name.laser {
  color: #0ff;
}

.weapon-name.grenade {
  color: #f70;
}

.weapon-name.bounce {
  color: #0f6;
}

/* Health bar shine effect */
.bar-inner::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 50%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: shine 2s infinite;
}

@keyframes shine {
  0% { left: -100%; }
  100% { left: 200%; }
}

@media (max-width: 768px) {
  .game-ui {
    top: 10px;
    left: 10px;
    width: 180px;
    padding: 10px;
  }
  
  .bar-label, .weapon-label {
    font-size: 12px;
  }
  
  .weapon-name {
    font-size: 14px;
  }
}

.bar-percentage {
  margin-left: 5px;
  color: #fff;
  font-size: 12px;
  min-width: 40px;
  text-align: right;
  order: 3;
}

/* Position indicators in the grid */
#indicator-forward { grid-area: forward; }
#indicator-backward { grid-area: backward; }
#indicator-left { grid-area: left; }
#indicator-right { grid-area: right; }
#indicator-strafeLeft { grid-area: strafeLeft; }
#indicator-strafeRight { grid-area: strafeRight; }
#indicator-fire { grid-area: fire; }

/* Special styling for fire key */
#indicator-fire {
  width: 80px;
  grid-column: span 3;
}

/* Collision Flash Effect */
.collision-flash {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 0, 0, 0.2);
  z-index: 1000;
  pointer-events: none;
  animation: flash 0.15s ease-out;
}

@keyframes flash {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

/* Score Display */
.score-display {
  position: fixed;
  top: 20px;
  right: 20px;
  font-size: 1.5rem;
  color: var(--neon-text-color);
  text-shadow: 0 0 5px var(--neon-text-color);
  z-index: 100;
}

/* Mobile Touch Controls */
.touch-controls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 90;
  display: none; /* Hidden by default, shown on touch devices */
  justify-content: space-between;
  align-items: center;
  pointer-events: none;
  height: 120px;
}

/* Media query for touch devices */
@media (pointer: coarse) {
  .touch-controls {
    display: flex;
  }
  
  .controls-info {
    display: none; /* Hide keyboard controls info on touch devices */
  }
}

/* Controls toggle button for touch devices */
.controls-toggle-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 101;
  background: rgba(0, 0, 0, 0.6);
  color: #00ffff;
  border: 1px solid rgba(0, 255, 255, 0.4);
  border-radius: 10px;
  padding: 10px 15px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 16px;
  cursor: pointer;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  transition: all 0.3s ease;
  display: none; /* Hidden by default, shown on touch devices */
}

.controls-toggle-button:hover,
.controls-toggle-button:active {
  background: rgba(0, 50, 70, 0.8);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

/* Responsive designs for different devices */

/* Base styles (desktop) */
.control-indicators {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 15px;
  transition: opacity 0.5s ease, transform 0.3s ease;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.4);
  backdrop-filter: blur(5px);
}

.key-indicator {
  width: 50px;
  height: 50px;
}

.key-indicator .key {
  font-size: 12px;
}

.key-indicator .label {
  font-size: 18px;
}

/* Large tablet and desktop (landscape) */
@media (min-width: 1024px) {
  .control-indicators {
    bottom: 30px;
    left: 30px;
    padding: 20px;
  }
  
  .key-indicator {
    width: 60px;
    height: 60px;
  }
  
  .key-indicator .key {
    font-size: 14px;
  }
  
  .key-indicator .label {
    font-size: 22px;
  }
  
  .game-ui {
    top: 30px;
    left: 30px;
    width: 250px;
  }
}

/* iPad and smaller tablets */
@media (min-width: 768px) and (max-width: 1023px) {
  .control-indicators {
    bottom: 20px;
    left: 20px;
    padding: 15px;
  }
  
  .key-indicator {
    width: 55px;
    height: 55px;
  }
  
  .game-ui {
    width: 220px;
  }
}

/* Mobile phones (portrait) */
@media (max-width: 767px) {
  .control-indicators {
    bottom: 10px;
    left: 10px;
    padding: 10px;
    gap: 8px;
  }
  
  .key-indicator {
    width: 40px;
    height: 40px;
  }
  
  .key-indicator .key {
    font-size: 10px;
  }
  
  .key-indicator .label {
    font-size: 14px;
  }
  
  .game-ui {
    top: 10px;
    left: 10px;
    width: 180px;
    padding: 10px;
  }
  
  .bar-label, .weapon-label {
    font-size: 12px;
  }
  
  .weapon-name {
    font-size: 14px;
  }
  
  .controls-toggle-button {
    display: block;
    font-size: 14px;
    padding: 8px 12px;
  }
}

/* Very small screens and iPhones in portrait */
@media (max-width: 375px) {
  .control-indicators {
    bottom: 5px;
    left: 5px;
    padding: 8px;
    gap: 5px;
  }
  
  .key-indicator {
    width: 35px;
    height: 35px;
  }
  
  .key-indicator .key {
    font-size: 8px;
  }
  
  .key-indicator .label {
    font-size: 12px;
  }
  
  .game-ui {
    width: 150px;
  }
}

/* Touch device specific styles */
@media (pointer: coarse) {
  .controls-toggle-button {
    display: block;
  }
  
  /* Make touch targets larger */
  .key-indicator {
    min-width: 44px;
    min-height: 44px;
  }
}

/* iPhone-specific fixes - ensure proper viewport */
@media only screen and (max-device-width: 812px) and (-webkit-min-device-pixel-ratio: 2) {
  .touch-controls {
    bottom: env(safe-area-inset-bottom, 20px);
    padding-bottom: 10px;
  }
  
  .controls-toggle-button {
    bottom: env(safe-area-inset-bottom, 20px);
    right: env(safe-area-inset-right, 20px);
  }
}

/* Fix for notched phones */
@supports (padding: max(0px)) {
  .touch-controls {
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }
}

.joystick-container {
  width: 150px;
  height: 150px;
  margin-left: 10px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
}

.joystick {
  width: 100px;
  height: 100px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 50%;
  border: 2px solid rgba(0, 200, 255, 0.3);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.2);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.joystick-knob {
  width: 40px;
  height: 40px;
  background: rgba(0, 200, 255, 0.7);
  border-radius: 50%;
  box-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
  position: absolute;
  transition: transform 0.1s ease;
}

.touch-button {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  background: rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
  border: 2px solid rgba(0, 200, 255, 0.3);
  pointer-events: auto;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.fire-button {
  margin-right: 10px;
  background: rgba(50, 0, 0, 0.5);
  border-color: rgba(255, 100, 100, 0.4);
  box-shadow: 0 0 10px rgba(255, 100, 100, 0.3);
}

.weapon-button {
  margin-right: 90px;
  background: rgba(0, 30, 50, 0.5);
}

/* Mini-Map */
.mini-map-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 95;
  width: 180px;
  height: 180px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 8px;
  padding: 5px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.3);
  backdrop-filter: blur(3px);
  transition: all 0.3s ease;
  transform-origin: bottom right;
  overflow: hidden;
}

.mini-map-container.hidden {
  transform: scale(0);
  opacity: 0;
}

.mini-map {
  width: 100%;
  height: 100%;
  background: rgba(0, 20, 40, 0.4);
  border-radius: 5px;
  border: 1px solid rgba(0, 255, 255, 0.2);
  overflow: hidden;
}

.mini-map canvas {
  width: 100%;
  height: 100%;
}

/* Subtle M key hint */
.mini-map-hint {
  position: absolute;
  bottom: 7px;
  right: 7px;
  font-size: 10px;
  color: rgba(0, 255, 255, 0.5);
  font-family: 'Rajdhani', sans-serif;
  opacity: 0.7;
  text-shadow: 0 0 2px rgba(0, 255, 255, 0.5);
  pointer-events: none;
}

/* Responsive adjustments for mini-map */
@media (max-width: 768px) {
  .mini-map-container {
    width: 150px;
    height: 150px;
  }
}

@media (max-width: 480px) {
  .mini-map-container {
    bottom: 150px; /* Position above touch controls on mobile */
    width: 120px;
    height: 120px;
  }
}

/* Game container */
#game-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 1;
}

#game-container canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Error screen */
#error-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 1100;
  color: #ff0000;
}

/* Animations */
.fade-in {
  animation: fadeIn 0.5s ease-in forwards;
}

.fade-out {
  animation: fadeOut 0.5s ease-out forwards;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Controls display */
#controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  padding: 15px;
  border-radius: 10px;
  z-index: 700;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
  border: 1px solid rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
}

#controls.visible {
  opacity: 1;
  visibility: visible;
}

.control-section {
  margin: 10px;
  display: flex;
  gap: 10px;
  align-items: center;
}

.control-indicator {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 8px 12px;
  border-radius: 5px;
  background: rgba(0, 20, 40, 0.6);
  border: 1px solid rgba(0, 255, 255, 0.1);
  transition: all 0.2s ease;
}

.control-indicator.active {
  background: rgba(0, 100, 150, 0.4);
  border-color: rgba(0, 255, 255, 0.5);
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
}

/* Touch controls */
.touch-controls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 600;
  display: none;
}

@media (hover: none) and (pointer: coarse) {
  .touch-controls {
    display: block;
  }
}

.joystick-container {
  width: 120px;
  height: 120px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  position: relative;
}

.joystick {
  width: 60px;
  height: 60px;
  background: rgba(0, 255, 255, 0.3);
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.touch-button {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  color: #fff;
  font-size: 12px;
  text-align: center;
}

.ship-selection {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50%;
    max-width: 600px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ffff;
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    z-index: 1000;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

.ship-selection.visible {
    opacity: 1;
    visibility: visible;
}

.ship-selection.hidden {
    opacity: 0;
    visibility: hidden;
}

.ship-selection-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.3);
}

.ship-selection-header h2 {
    color: #00ffff;
    margin: 0;
    font-size: 18px;
}

.ships-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 10px;
}

.ship-option {
    background: rgba(0, 20, 40, 0.5);
    border: 1px solid #333;
    border-radius: 8px;
    padding: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 13px;
}

.ship-option h3 {
    color: #00ffff;
    margin: 0 0 2px 0;
    font-size: 15px;
}

.ship-option p {
    margin: 0 0 5px 0;
    font-size: 11px;
}

.stat {
    margin: 3px 0;
    display: flex;
    align-items: center;
}

.stat label {
    display: inline-block;
    width: 80px;
    color: #888;
    font-size: 11px;
}

.preview-section {
    text-align: center;
    margin-bottom: 10px;
}

.preview-section h3 {
    color: #00ffff;
    margin-bottom: 5px;
    font-size: 15px;
}

#ship-preview {
    width: 100%;
    height: 150px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #333;
}

.ship-details {
    padding: 8px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    margin-bottom: 10px;
    border: 1px solid #333;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-gap: 10px;
}

.ship-details-left {
    grid-column: 1;
}

.ship-details-right {
    grid-column: 2;
}

.ship-name {
    color: #00ffff;
    margin: 0 0 2px 0;
    font-size: 15px;
    grid-column: 1 / -1;
}

.ship-description {
    color: #aaa;
    margin-bottom: 5px;
    font-size: 11px;
    grid-column: 1 / -1;
}

.special-abilities {
    margin-top: 5px;
}

.special-abilities h4 {
    color: #00ffff;
    margin: 0 0 5px 0;
    font-size: 13px;
}

.ability {
    display: inline-block;
    margin: 2px;
    padding: 3px 6px;
    background: rgba(0, 255, 255, 0.1);
    border: 1px solid #00ffff;
    border-radius: 4px;
    color: #00ffff;
    font-size: 11px;
}

.launch-button {
    display: block;
    width: 150px;
    margin: 0 auto;
    padding: 8px 15px;
    background: #00ff00;
    border: none;
    border-radius: 5px;
    color: #000;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    align-self: center;
}

.stat-bar {
    display: inline-block;
    flex: 1;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    margin: 0 5px;
}

.stat-bar > div {
    height: 100%;
    background: #00ffff;
    transition: width 0.3s ease;
}

.stat-value {
    width: 40px;
    text-align: right;
    color: #00ffff;
    font-size: 11px;
}

.visible {
    display: flex;
    flex-direction: column;
}

/* Player Name Input Styling */
.player-input {
  margin: 20px 0 30px;
  width: 100%;
  max-width: 350px;
  position: relative;
}

#player-name {
  width: 100%;
  padding: 15px 20px;
  border: 2px solid #30c5ff;
  background-color: rgba(0, 10, 30, 0.7);
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  text-align: center;
  border-radius: 4px;
  box-shadow: 
    0 0 10px rgba(48, 197, 255, 0.5),
    0 0 20px rgba(48, 197, 255, 0.2);
  transition: all 0.3s ease;
  outline: none;
  letter-spacing: 1px;
  position: relative;
  backdrop-filter: blur(5px);
}

#player-name:focus {
  border-color: #ff3e88;
  box-shadow: 
    0 0 15px rgba(255, 62, 136, 0.6),
    0 0 30px rgba(255, 62, 136, 0.3);
  transform: scale(1.02);
}

#player-name::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.input-info {
  margin-top: 10px;
  font-size: 12px;
  color: #8af3ff;
  text-align: center;
  opacity: 0.8;
  letter-spacing: 0.5px;
  font-weight: 400;
}

/* Enhanced Start Button */
#start-button {
  margin-top: 20px;
  padding: 15px 40px;
  font-size: 18px;
  font-weight: 600;
  letter-spacing: 2px;
  color: #fff;
  background: linear-gradient(45deg, #0062ff, #00c3ff);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 
    0 0 15px rgba(0, 195, 255, 0.7),
    0 0 30px rgba(0, 195, 255, 0.4);
  position: relative;
  overflow: hidden;
  font-family: 'Orbitron', sans-serif;
  text-transform: uppercase;
}

#start-button::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    to bottom right,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.1) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  transform: rotate(45deg);
  animation: shine 3s infinite;
}

#start-button:hover {
  transform: translateY(-3px) scale(1.05);
  box-shadow: 
    0 0 20px rgba(0, 195, 255, 0.8),
    0 0 40px rgba(0, 195, 255, 0.5);
  background: linear-gradient(45deg, #00c3ff, #0062ff);
}

#start-button:active {
  transform: translateY(1px) scale(0.98);
  box-shadow: 
    0 0 10px rgba(0, 195, 255, 0.6),
    0 0 20px rgba(0, 195, 255, 0.3);
}

@keyframes shine {
  0% { left: -100%; }
  20% { left: 100%; }
  100% { left: 100%; }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .start-content h1 {
    font-size: 2.5rem;
  }
  
  #player-name {
    font-size: 14px;
    padding: 12px 15px;
  }
  
  #start-button {
    padding: 12px 30px;
    font-size: 16px;
  }
}

@media (max-width: 480px) {
  .start-content h1 {
    font-size: 2rem;
  }
  
  .start-content {
    padding: 1.5rem;
  }
}

/* Multiplayer Information */
#multiplayer-info {
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  color: #00ffff;
  padding: 10px;
  border-radius: 5px;
  font-family: 'Orbitron', sans-serif;
  border: 1px solid #00ffff;
  z-index: 100;
}

.connection-indicator, .players-indicator {
  margin: 5px 0;
  display: flex;
  justify-content: space-between;
}

#connection-status {
  color: #ff3333;
  font-weight: bold;
}

#connection-status.connected {
  color: #33ff33;
}

#players-count {
  color: #ffff33;
  font-weight: bold;
}

/* Player Labels */
.player-label {
  color: #00ffff;
  font-family: 'Orbitron', sans-serif;
  padding: 2px 6px;
  border-radius: 4px;
  background-color: rgba(0, 0, 0, 0.7);
  font-size: 10px;
  white-space: nowrap;
  text-align: center;
  transform: translate(-50%, -50%);
  pointer-events: none;
  text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
} 
### ./styles/main.css END ###

### ./styles/controls.css BEGIN ###
#controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 10px;
    z-index: 1000;
    transition: opacity 0.5s ease;
    pointer-events: none;
}

.control-section {
    display: flex;
    gap: 10px;
    padding: 0 15px;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
}

.control-section:last-child {
    border-right: none;
}

.control-indicator {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 40px;
}

.control-indicator .key {
    background: rgba(255, 255, 255, 0.1);
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 12px;
    color: #fff;
    margin-bottom: 4px;
}

.control-indicator .label {
    font-size: 16px;
    color: #fff;
}

.control-indicator .tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
}

.control-indicator:hover .tooltip {
    opacity: 1;
}

/* Mobile and tablet adjustments */
@media (max-width: 768px) {
    #controls {
        flex-direction: column;
        bottom: 10px;
        gap: 10px;
        padding: 10px;
    }
    
    .control-section {
        border-right: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding: 10px 0;
    }
    
    .control-section:last-child {
        border-bottom: none;
    }
    
    .control-indicator {
        min-width: 30px;
    }
    
    .control-indicator .key {
        font-size: 10px;
        padding: 3px 6px;
    }
    
    .control-indicator .label {
        font-size: 14px;
    }
} 
### ./styles/controls.css END ###

### ./assets/ModelLoader.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader';

// Manager to handle and cache all loaded models
export class ModelLoader {
  constructor() {
    // Cache for storing loaded models to avoid reloading
    this.modelCache = new Map();
    
    // Create loaders
    this.gltfLoader = new GLTFLoader();
    
    // Loading manager to track progress
    this.loadingManager = new THREE.LoadingManager();
    this.loadingManager.onProgress = (url, loaded, total) => {
      const progress = (loaded / total) * 100;
      console.log(`Loading: ${Math.round(progress)}% (${url})`);
    };
    
    // Set up loaders with manager
    this.gltfLoader.manager = this.loadingManager;
  }
  
  /**
   * Load a 3D model from path
   * @param {string} path - Path to the model file, relative to the assets directory
   * @returns {Promise} - Promise that resolves with the loaded model
   */
  loadModel(path) {
    // Add assets prefix for webpack build
    const assetPath = path.startsWith('assets/') ? path : `assets/${path}`;
    
    // Check if model is already in cache
    if (this.modelCache.has(assetPath)) {
      return Promise.resolve(this.modelCache.get(assetPath).clone());
    }
    
    // If not in cache, load it
    return new Promise((resolve, reject) => {
      this.gltfLoader.load(
        assetPath,
        (gltf) => {
          // Store original in cache
          this.modelCache.set(assetPath, gltf.scene.clone());
          
          // Process the model for better performance
          this.processModel(gltf.scene);
          
          resolve(gltf.scene);
        },
        (progress) => {
          // Optional progress callback
        },
        (error) => {
          console.error(`Error loading model from ${assetPath}:`, error);
          reject(error);
        }
      );
    });
  }
  
  /**
   * Process model to optimize it
   * @param {THREE.Group} model - The loaded model
   */
  processModel(model) {
    console.log('Processing model in ModelLoader, initial scale:', model.scale.x, model.scale.y, model.scale.z);
    
    // Traverse the model and optimize materials, geometries, etc.
    model.traverse((node) => {
      if (node.isMesh) {
        console.log(`ModelLoader found mesh: ${node.name}, Scale:`, node.scale);
        
        // Enable shadows
        node.castShadow = true;
        node.receiveShadow = true;
        
        // Keep materials but ensure they're properly configured
        if (node.material) {
          // Ensure material has appropriate render settings
          node.material.needsUpdate = true;
        }
      }
    });
    
    // Center the model if needed
    this.centerModel(model);
    
    console.log('Model after processing, final scale:', model.scale.x, model.scale.y, model.scale.z);
  }
  
  /**
   * Center the model at its geometric center
   * @param {THREE.Group} model - The model to center
   */
  centerModel(model) {
    // Create a bounding box for the model
    const boundingBox = new THREE.Box3().setFromObject(model);
    
    // Calculate the center of the bounding box
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    
    // Move the model so its center is at the origin
    model.position.sub(center);
  }
  
  /**
   * Clear the model cache (useful when memory needs to be freed)
   */
  clearCache() {
    this.modelCache.clear();
  }
  
  /**
   * Get a list of all loaded model paths
   * @returns {Array} - Array of paths to loaded models
   */
  getLoadedModelPaths() {
    return Array.from(this.modelCache.keys());
  }
} 
### ./assets/ModelLoader.js END ###

### ./assets/SoundManager.js BEGIN ###
import * as THREE from 'three';

/**
 * SoundManager class for managing game audio
 */
export class SoundManager {
  constructor() {
    // Initialize audio listeners, buffers, and sources
    this.listener = new THREE.AudioListener();
    this.sounds = new Map();
    this.music = null;
    this.isMuted = false;
    
    // Default volumes
    this.effectsVolume = 0.5;
    this.musicVolume = 0.3;
    
    // Preload common sounds
    this.preloadSounds();
    
    // Setup audio control buttons
    this.setupAudioControls();
  }
  
  /**
   * Preload common game sounds
   */
  preloadSounds() {
    // Create a sound loader
    const audioLoader = new THREE.AudioLoader();
    
    // Define common sounds to preload with updated paths
    const soundsToLoad = [
      { name: 'laser', path: 'assets/sounds/laser.mp3' },
      { name: 'explosion', path: 'assets/sounds/explosion.mp3' },
      { name: 'hit', path: 'assets/sounds/hit.mp3' },
      { name: 'powerup', path: 'assets/sounds/powerup.mp3' },
      { name: 'engine', path: 'assets/sounds/engine.mp3', loop: true },
      { name: 'laser-bounce', path: 'assets/sounds/laser-bounce.mp3' },
      { name: 'weapon-switch', path: 'assets/sounds/weapon-switch.mp3' },
      { name: 'collision', path: 'assets/sounds/collision.mp3' },
      { name: 'weapon-charging', path: 'assets/sounds/weapon-charging.mp3' },
      { name: 'bounce', path: 'assets/sounds/bounce.mp3' },
      { name: 'weapon-armor-hit', path: 'assets/sounds/weapon-armor-hit.mp3' },
      { name: 'grenade-laser', path: 'assets/sounds/grenade-laser.mp3' }
    ];
    
    // Load each sound
    soundsToLoad.forEach(soundInfo => {
      try {
        const sound = new THREE.Audio(this.listener);
        
        audioLoader.load(
          soundInfo.path,
          buffer => {
            sound.setBuffer(buffer);
            sound.setVolume(this.effectsVolume);
            if (soundInfo.loop) {
              sound.setLoop(true);
            }
            this.sounds.set(soundInfo.name, sound);
            console.log(`Loaded sound: ${soundInfo.name}`);
          },
          xhr => {
            console.log(`${soundInfo.name}: ${(xhr.loaded / xhr.total * 100)}% loaded`);
          },
          error => {
            console.error(`Error loading sound ${soundInfo.name}:`, error);
          }
        );
      } catch (error) {
        console.error(`Failed to setup sound ${soundInfo.name}:`, error);
      }
    });
    
    // Load background music with updated path
    try {
      this.music = new THREE.Audio(this.listener);
      audioLoader.load(
        'assets/sounds/background_music.mp3',
        buffer => {
          this.music.setBuffer(buffer);
          this.music.setVolume(this.musicVolume);
          this.music.setLoop(true);
        },
        xhr => {
          console.log(`Background music: ${(xhr.loaded / xhr.total * 100)}% loaded`);
        },
        error => {
          console.error('Error loading background music:', error);
        }
      );
    } catch (error) {
      console.error('Failed to setup background music:', error);
    }
  }
  
  /**
   * Setup audio control buttons
   */
  setupAudioControls() {
    // Add event listeners for audio controls if they exist in the DOM
    const muteButton = document.getElementById('mute-button');
    if (muteButton) {
      muteButton.addEventListener('click', () => this.toggleMute());
    }
    
    const effectsVolumeSlider = document.getElementById('effects-volume');
    if (effectsVolumeSlider) {
      effectsVolumeSlider.value = this.effectsVolume * 100;
      effectsVolumeSlider.addEventListener('input', (e) => {
        this.setEffectsVolume(e.target.value / 100);
      });
    }
    
    const musicVolumeSlider = document.getElementById('music-volume');
    if (musicVolumeSlider) {
      musicVolumeSlider.value = this.musicVolume * 100;
      musicVolumeSlider.addEventListener('input', (e) => {
        this.setMusicVolume(e.target.value / 100);
      });
    }
  }
  
  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.isMuted) return;
    
    const sound = this.sounds.get(name);
    if (!sound) {
      console.warn(`Sound '${name}' not found`);
      return;
    }
    
    let soundToPlay = sound;
    
    // If sound is already playing, create a new instance
    if (sound.isPlaying) {
      try {
        // Create a new audio instance
        if (position) {
          // For positional audio
          const soundClone = new THREE.PositionalAudio(this.listener);
          soundClone.setBuffer(sound.buffer);
          soundClone.setVolume(this.effectsVolume);
          soundClone.setRefDistance(10); // Distance at which the volume is at full
          soundToPlay = soundClone;
        } else {
          // For non-positional audio - create new instead of cloning
          const soundClone = new THREE.Audio(this.listener);
          soundClone.setBuffer(sound.buffer);
          soundClone.setVolume(this.effectsVolume);
          soundToPlay = soundClone;
        }
        
        // Clean up clone after playing
        soundToPlay.onEnded = () => {
          if (soundToPlay.source) {
            soundToPlay.disconnect();
            soundToPlay.source = null; // Prevent memory leaks
          }
        };
      } catch (error) {
        console.error("Error creating new sound instance:", error);
        // If cloning fails, don't play any sound rather than crashing
        return;
      }
    }
    
    // If position is provided, make it positional
    if (position && !sound.isPlaying) {
      // We're using the original sound, convert it to positional if needed
      if (!(soundToPlay instanceof THREE.PositionalAudio)) {
        try {
          // Create new positional audio
          const positionalSound = new THREE.PositionalAudio(this.listener);
          positionalSound.setBuffer(sound.buffer);
          positionalSound.setVolume(this.effectsVolume);
          positionalSound.setRefDistance(10);
          soundToPlay = positionalSound;
        } catch (error) {
          console.error("Error creating positional audio:", error);
          // Fall back to non-positional
        }
      }
    }
    
    // Apply position if provided
    if (position && soundToPlay instanceof THREE.PositionalAudio) {
      try {
        // Check if we need to add this to an object in the scene
        const dummyObject = new THREE.Object3D();
        dummyObject.position.copy(position);
        dummyObject.add(soundToPlay);
        
        // Cleanup function to remove the dummy object after playing
        soundToPlay.onEnded = () => {
          if (dummyObject.parent) dummyObject.parent.remove(dummyObject);
          if (soundToPlay.source) {
            soundToPlay.disconnect();
            soundToPlay.source = null;
          }
        };
        
        // Add to scene or listener (we assume listener is in scene)
        if (this.listener && this.listener.parent) {
          this.listener.parent.add(dummyObject);
        } else {
          console.warn('Audio listener has no parent, positional audio may not work correctly');
          // Just play non-positional as fallback
        }
      } catch (error) {
        console.error("Error setting up positional audio:", error);
        // Fall back to just playing the sound
      }
    }
    
    // Play the sound
    try {
      soundToPlay.play();
    } catch (error) {
      console.error("Error playing sound:", error);
    }
  }
  
  /**
   * Start playing background music
   */
  playMusic() {
    if (this.isMuted || !this.music || this.music.isPlaying) return;
    
    this.music.play();
  }
  
  /**
   * Stop background music
   */
  stopMusic() {
    if (!this.music || !this.music.isPlaying) return;
    
    this.music.stop();
  }
  
  /**
   * Toggle mute state for all audio
   */
  toggleMute() {
    this.isMuted = !this.isMuted;
    
    // Update mute button if it exists
    const muteButton = document.getElementById('mute-button');
    if (muteButton) {
      muteButton.textContent = this.isMuted ? '🔇' : '🔊';
    }
    
    if (this.isMuted) {
      // Pause all sounds
      this.sounds.forEach(sound => {
        if (sound.isPlaying) {
          sound.pause();
        }
      });
      
      // Pause music
      if (this.music && this.music.isPlaying) {
        this.music.pause();
      }
    } else {
      // Resume music
      if (this.music && !this.music.isPlaying) {
        this.music.play();
      }
    }
  }
  
  /**
   * Set volume for sound effects
   * @param {number} volume - Volume level (0-1)
   */
  setEffectsVolume(volume) {
    this.effectsVolume = Math.max(0, Math.min(1, volume));
    
    // Update all sound effects with new volume
    this.sounds.forEach(sound => {
      sound.setVolume(this.effectsVolume);
    });
  }
  
  /**
   * Set volume for background music
   * @param {number} volume - Volume level (0-1)
   */
  setMusicVolume(volume) {
    this.musicVolume = Math.max(0, Math.min(1, volume));
    
    if (this.music) {
      this.music.setVolume(this.musicVolume);
    }
  }
  
  /**
   * Get the audio listener for positioning
   * @returns {THREE.AudioListener} The audio listener
   */
  getListener() {
    return this.listener;
  }
} 
### ./assets/SoundManager.js END ###

### ./assets/AssetLoader.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';

class AssetLoader {
    constructor() {
        this.loadingState = {
            started: false,
            completed: false,
            errors: [],
            timeouts: new Map(),
            retryCount: new Map(),
            maxRetries: 3,
            loadingPromises: new Map()
        };

        this.assets = {
            models: new Map(),
            sounds: new Map(),
            textures: new Map()
        };

        this.onProgress = null;
        this.onError = null;
    }

    setCallbacks(onProgress, onError) {
        this.onProgress = onProgress;
        this.onError = onError;
        return this;
    }

    async loadAll() {
        if (this.loadingState.started) {
            console.warn('Asset loading already in progress');
            return;
        }

        this.loadingState.started = true;
        this.loadingState.completed = false;
        this.loadingState.errors = [];

        try {
            const modelsToLoad = [
                'ships/ALTSPACE1.glb',
                'ships/ALTSPACE2.glb',
                'terrain/Terrain.glb',
                'terrain/Water.glb',
                'objects/SP_Stone01.glb',
                'objects/SP_Ground05.glb'
            ];

            const loader = new GLTFLoader();
            
            for (const model of modelsToLoad) {
                try {
                    const loaded = await this.loadWithRetry(() => 
                        this.loadModel(loader, model, `assets/models/${model}`)
                    );
                    if (loaded) {
                        console.log(`✅ Successfully loaded model: ${model}`);
                        
                        // Add aliases for ship models
                        if (model === 'ships/ALTSPACE1.glb') {
                            this.assets.models.set('FIGHTER', this.assets.models.get(model));
                            this.assets.models.set('SCOUT', this.assets.models.get(model));
                        } else if (model === 'ships/ALTSPACE2.glb') {
                            this.assets.models.set('INTERCEPTOR', this.assets.models.get(model));
                            this.assets.models.set('EXPERIMENTAL', this.assets.models.get(model));
                        }
                    }
                } catch (error) {
                    console.error(`⛔ Failed to load model ${model}:`, error);
                    this.handleError('model', error);
                }
            }

            this.loadingState.completed = true;
            return true;
        } catch (error) {
            this.handleError('critical', error);
            return false;
        }
    }

    async loadModel(loader, key, path) {
        return new Promise((resolve, reject) => {
            console.log(`🔍 Actually loading model: ${key} from: ${path}`);
            
            const timeoutId = setTimeout(() => {
                reject(new Error(`Model loading timeout: ${key}`));
            }, 15000);

            loader.load(
                path,
                (gltf) => {
                    clearTimeout(timeoutId);
                    console.log(`✅ Successfully loaded model: ${key}`);
                    
                    // Store the original model before any scaling
                    this.assets.models.set(key, gltf.scene);
                    this.onProgress?.(`Loaded model: ${key}`);
                    resolve();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100);
                    this.onProgress?.(`Loading ${key}: ${Math.round(percent)}%`);
                },
                (error) => {
                    clearTimeout(timeoutId);
                    console.error(`⛔ Error loading model ${key}:`, error.message);
                    reject(new Error(`Error loading model ${key}: ${error.message}`));
                }
            );
        });
    }

    async loadTextures() {
        const textureLoader = new THREE.TextureLoader();
        const texturePaths = {
            // Add texture paths when needed
        };

        const loadPromises = Object.entries(texturePaths).map(([key, path]) => {
            return this.loadWithRetry(() => this.loadTexture(textureLoader, key, path));
        });

        await Promise.all(loadPromises);
    }

    async loadTexture(loader, key, path) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Texture loading timeout: ${key}`));
            }, 10000);

            loader.load(
                path,
                (texture) => {
                    clearTimeout(timeoutId);
                    this.assets.textures.set(key, texture);
                    this.onProgress?.(`Loaded texture: ${key}`);
                    resolve();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100);
                    this.onProgress?.(`Loading ${key}: ${Math.round(percent)}%`);
                },
                (error) => {
                    clearTimeout(timeoutId);
                    reject(new Error(`Error loading texture ${key}: ${error.message}`));
                }
            );
        });
    }

    async loadWithRetry(loadFunction) {
        const key = loadFunction.name || 'unknown';
        let retryCount = 0;

        while (retryCount < this.loadingState.maxRetries) {
            try {
                return await loadFunction();
            } catch (error) {
                retryCount++;
                if (retryCount === this.loadingState.maxRetries) {
                    this.handleError(key, error);
                    throw error;
                }
                console.warn(`Retrying ${key} (attempt ${retryCount}/${this.loadingState.maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            }
        }
    }

    handleError(assetType, error) {
        console.error(`Error loading ${assetType}:`, error);
        this.loadingState.errors.push({ type: assetType, error: error.message });
        this.onError?.(assetType, error.message);
    }

    getModel(key) {
        return this.assets.models.get(key);
    }

    getTexture(key) {
        return this.assets.textures.get(key);
    }

    isLoaded() {
        return this.loadingState.completed;
    }

    getErrors() {
        return this.loadingState.errors;
    }

    cleanup() {
        // Dispose of all loaded assets
        this.assets.models.forEach(model => {
            model.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        });

        this.assets.textures.forEach(texture => texture.dispose());

        // Clear all maps
        this.assets.models.clear();
        this.assets.textures.clear();

        // Reset loading state
        this.loadingState = {
            started: false,
            completed: false,
            errors: [],
            timeouts: new Map(),
            retryCount: new Map(),
            maxRetries: 3,
            loadingPromises: new Map()
        };
    }

    // Force ship sizes to be consistent
    normalizeShipSizes() {
        console.log('🛠️ NORMALIZING SHIP SIZES');
        
        // Check what models we have
        const modelKeys = Array.from(this.assets.models.keys());
        console.log('Available models:', modelKeys);
        
        // Skip if no models are loaded
        if (this.assets.models.size === 0) {
            console.warn('⚠️ No models loaded yet, skipping normalization');
            return;
        }
        
        // Set all models to scale 1
        modelKeys.forEach(key => {
            try {
                const model = this.assets.models.get(key);
                if (model) {
                    console.log(`Setting standard scale 1.0 for ${key}`);
                    model.scale.set(1, 1, 1);
                }
            } catch (error) {
                console.error(`Error setting scale for model ${key}:`, error);
            }
        });
        
        console.log('🛠️ SHIP SIZE NORMALIZATION COMPLETE');
    }
    
    // Method to get a cloned ship model
    getShipModel(key) {
        try {
            console.log(`Getting ship model: ${key}`);
            
            // First try direct key lookup
            let model = this.assets.models.get(key);
            
            // If not found, try the file path
            if (!model) {
                model = this.assets.models.get(`ships/${key}.glb`);
            }
            
            // If still not found, try aliases
            if (!model) {
                console.log(`Trying to find model by alias: ${key}`);
                if (key === 'FIGHTER' || key === 'SCOUT') {
                    model = this.assets.models.get('ships/ALTSPACE1.glb');
                } else if (key === 'INTERCEPTOR' || key === 'EXPERIMENTAL') {
                    model = this.assets.models.get('ships/ALTSPACE2.glb');
                }
            }
            
            if (!model) {
                console.warn(`Ship model with key "${key}" not found!`);
                return null;
            }
            
            return this.cloneAndPrepareModel(model);
        } catch (error) {
            console.error(`Error cloning ship model ${key}:`, error);
            return null;
        }
    }

    // New method to handle model cloning and preparation
    cloneAndPrepareModel(model) {
        // DIAGNOSTIC: Log scale before cloning
        console.log(`DIAGNOSTIC: Original model scale before clone - [${model.scale.x}, ${model.scale.y}, ${model.scale.z}]`);
        
        // Clone the model
        const cloned = model.clone();
        
        // Apply consistent scaling as specified in Task 12
        cloned.scale.set(0.45, 0.45, 0.45);
        
        // Ensure materials are properly cloned
        cloned.traverse(node => {
            if (node.isMesh && node.material) {
                // Clone material to prevent sharing between instances
                node.material = node.material.clone();
                
                // Ensure material properties are set
                if (!node.material.color) node.material.color = new THREE.Color(0xffffff);
                if (!node.material.emissive) node.material.emissive = new THREE.Color(0x000000);
                
                // Enable shadows
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // DIAGNOSTIC: Log scale after cloning
        console.log(`DIAGNOSTIC: Cloned model scale - [${cloned.scale.x}, ${cloned.scale.y}, ${cloned.scale.z}]`);
        
        return cloned;
    }

    // Method to get a cloned ship model for opponents
    getOpponentShipModel(key) {
        try {
            console.log(`Getting opponent ship model: ${key}`);
            // Use the same model loading logic as getShipModel
            const model = this.getShipModel(key);
            
            if (!model) {
                console.warn(`No model found for opponent ship type: ${key}`);
                return null;
            }
            
            // Clone the model to ensure each opponent has their own instance
            const clonedModel = model.clone();
            
            // Apply any opponent-specific modifications here if needed
            // For example, different materials or effects
            
            return clonedModel;
        } catch (error) {
            console.error(`Error getting opponent ship model ${key}:`, error);
            return null;
        }
    }

    // Add the loadModels method used by ShipSelectionUI
    async loadModels() {
        console.log('Loading ship models for selection UI');
        
        if (this.assets.models.has('FIGHTER') && this.assets.models.has('INTERCEPTOR')) {
            console.log('Ship models already loaded, using cached versions');
            return true;
        }
        
        const shipModels = [
            'ships/ALTSPACE1.glb',
            'ships/ALTSPACE2.glb'
        ];
        
        const loader = new GLTFLoader();
        
        for (const model of shipModels) {
            try {
                const loaded = await this.loadWithRetry(() => 
                    this.loadModel(loader, model, `assets/models/${model}`)
                );
                if (loaded) {
                    console.log(`✅ Successfully loaded ship model: ${model} for selection UI`);
                    
                    // Add aliases for ship models
                    if (model === 'ships/ALTSPACE1.glb') {
                        this.assets.models.set('FIGHTER', this.assets.models.get(model));
                        this.assets.models.set('SCOUT', this.assets.models.get(model));
                    } else if (model === 'ships/ALTSPACE2.glb') {
                        this.assets.models.set('INTERCEPTOR', this.assets.models.get(model));
                        this.assets.models.set('EXPERIMENTAL', this.assets.models.get(model));
                    }
                }
            } catch (error) {
                console.error(`⛔ Failed to load ship model ${model}:`, error);
                this.handleError('model', error);
            }
        }
        
        return true;
    }
}

export default AssetLoader; 
### ./assets/AssetLoader.js END ###

### ./entities/Ship.js BEGIN ###
import * as THREE from 'three';
import { EventEmitter } from 'events';

export class Ship extends EventEmitter {
    constructor(scene, position, options = {}) {
        super();
        
        this.scene = scene;
        this.options = { 
            health: 100, 
            speed: 0.1,
            type: 'BASIC',
            teamId: null,
            teamColor: 0xffffff,
            maxHealth: 100,
            size: 1.0,
            shipModel: 'STANDARD',
            ...options 
        };
        
        this.health = this.options.health;
        this.maxHealth = this.options.maxHealth;
        this.isActive = true;
        this.teamId = this.options.teamId;
        this.mesh = null;
        
        // Initialize the ship if position is provided
        if (position) {
            this.createMesh(position);
            // Add to scene if mesh was created
            if (this.mesh) {
                this.scene.add(this.mesh);
            }
            // Initialize effects
            this.initializeEffects();
        }
    }

    createMesh(position) {
        // This is a base method that can be overridden by subclasses
        // In the base class, implement default behavior
        
        const geometry = this.createGeometry();
        const material = this.createMaterial();
        
        // Create mesh
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(position || new THREE.Vector3());
        this.mesh.position.y = this.options.size;
        
        // Add engine glow
        this.addEngineGlow();
        
        return this.mesh;
    }
    
    createGeometry() {
        // Ship models based on type
        const models = {
            STANDARD: () => new THREE.ConeGeometry(this.options.size, this.options.size * 2, 3),
            INTERCEPTOR: () => {
                const geometry = new THREE.ConeGeometry(this.options.size * 0.8, this.options.size * 2.5, 4);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            },
            HEAVY: () => new THREE.CylinderGeometry(
                this.options.size * 1.2,
                this.options.size * 1.4,
                this.options.size * 2,
                6
            ),
            SCOUT: () => {
                const geometry = new THREE.ConeGeometry(this.options.size * 0.6, this.options.size * 2.2, 5);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            }
        };

        // Get geometry based on ship model or fallback to STANDARD
        const geometry = (models[this.options.shipModel] || models.STANDARD)();
        geometry.rotateX(Math.PI / 2);
        
        return geometry;
    }
    
    createMaterial() {
        // Create material with team color and effects
        return new THREE.MeshStandardMaterial({
            color: this.options.teamColor,
            emissive: this.options.teamColor,
            emissiveIntensity: 0.5,
            metalness: 0.7,
            roughness: 0.3
        });
    }

    addEngineGlow() {
        const engineLight = new THREE.PointLight(this.options.teamColor, 1, 2);
        engineLight.position.set(0, 0, -this.options.size);
        this.mesh.add(engineLight);
    }

    initializeEffects() {
        this.effects = {
            damageTween: null,
            enginePulse: { value: 0 }
        };
    }

    update(deltaTime) {
        if (!this.isActive) return;

        // Update engine pulse effect
        this.updateEngineEffect(deltaTime);
    }

    updateEngineEffect(deltaTime) {
        this.effects.enginePulse.value += deltaTime * 0.005;
        const pulseIntensity = 0.5 + 0.2 * Math.sin(this.effects.enginePulse.value);
        this.material.emissiveIntensity = pulseIntensity;
    }

    takeDamage(amount) {
        if (!this.isActive) return;

        this.health = Math.max(0, this.health - amount);
        this.flashOnDamage();

        if (this.health <= 0) {
            this.destroy();
        }

        // Emit damage event
        this.emit('damage', {
            amount,
            remainingHealth: this.health,
            maxHealth: this.maxHealth
        });
    }

    flashOnDamage() {
        const originalEmissive = this.material.emissive.getHex();
        this.material.emissive.setHex(0xffffff);

        setTimeout(() => {
            if (this.material) {
                this.material.emissive.setHex(originalEmissive);
            }
        }, 100);
    }

    destroy() {
        if (!this.isActive) return;

        this.isActive = false;
        this.createExplosionEffect();
        
        // Emit destroy event
        this.emit('destroy', {
            position: this.mesh.position.clone(),
            teamId: this.teamId
        });

        // Remove from scene after explosion
        setTimeout(() => {
            if (this.mesh && this.mesh.parent) {
                this.mesh.parent.remove(this.mesh);
            }
        }, 1000);
    }

    createExplosionEffect() {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];
        const particles = [];

        for (let i = 0; i < particleCount; i++) {
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            velocities.push(velocity);
            particles.push(new THREE.Vector3(0, 0, 0));
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: this.options.teamColor,
            size: 0.2,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        particleSystem.position.copy(this.mesh.position);
        this.scene.add(particleSystem);

        const startTime = Date.now();
        const duration = 1000;

        const animateExplosion = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed < duration) {
                for (let i = 0; i < particleCount; i++) {
                    particles[i].add(velocities[i]);
                    positions[i * 3] = particles[i].x;
                    positions[i * 3 + 1] = particles[i].y;
                    positions[i * 3 + 2] = particles[i].z;
                }
                geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - (elapsed / duration);
                requestAnimationFrame(animateExplosion);
            } else {
                this.scene.remove(particleSystem);
            }
        };

        animateExplosion();
    }

    setTeam(teamId, teamColor) {
        this.teamId = teamId;
        this.options.teamColor = teamColor;
        if (this.material) {
            this.material.color.setHex(teamColor);
            this.material.emissive.setHex(teamColor);
        }
    }
} 
### ./entities/Ship.js END ###

### ./entities/weapons/RegularLaser.js BEGIN ###
import * as THREE from 'three';
import { Laser } from './Laser';

/**
 * RegularLaser weapon class
 */
export class RegularLaser extends Laser {
  constructor(weaponSystem) {
    super(weaponSystem.scene, null, null, {
      damage: 10, range: 50, speed: 50, color: 0x00ffff
    });
    this.weaponSystem = weaponSystem;
    this.cooldown = 0.2;
    this.currentCooldown = 0;
    this.energyCost = 5;
  }
  
  /**
   * Update cooldown timer and laser position
   * @param {number} deltaTime - Time since last frame in seconds
   */
  update(deltaTime) {
    // Call parent update to handle movement and range checking
    super.update(deltaTime);
    
    // Handle cooldown timer
    if (this.currentCooldown > 0) {
      this.currentCooldown -= deltaTime;
    }
  }
  
  /**
   * Check if weapon can fire
   * @param {object} player - Player object with energy properties
   * @returns {boolean} - True if weapon can fire
   */
  canFire(player) {
    return this.currentCooldown <= 0 && player.energy >= this.energyCost;
  }
  
  /**
   * Fire the weapon
   * @param {THREE.Vector3} position - Starting position of projectile
   * @param {THREE.Vector3} direction - Direction to fire
   * @param {object} player - Player object for energy management
   * @returns {boolean} - True if weapon fired successfully
   */
  fire(position, direction, options = {}) {
    // Position and orient the laser
    this.mesh.position.copy(position);
    this.direction = direction.normalize();
    this.initialPosition = position.clone();
    
    // Store initial properties
    this.teamId = options.teamId;
    
    // Set color based on team
    if (options.teamColor) {
      if (this.mesh.material) {
        this.mesh.material.color.set(options.teamColor);
      }
    }
    
    // Play sound if available
    if (this.weaponSystem.scene.soundManager) {
      this.weaponSystem.scene.soundManager.playSound('laser', position);
    }
    
    return this;
  }
  
  /**
   * Create a laser projectile
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Direction to fire
   * @returns {object} - Projectile object
   */
  createProjectile(position, direction) {
    // Create laser geometry and material
    const geometry = new THREE.CylinderGeometry(
      this.size.width, 
      this.size.width, 
      this.size.length, 
      8
    );
    
    // Rotate geometry to point along z-axis
    geometry.rotateX(Math.PI / 2);
    
    // Create glowing material
    const material = new THREE.MeshBasicMaterial({
      color: this.color,
      transparent: true,
      opacity: 0.8
    });
    
    // Create mesh
    const mesh = new THREE.Mesh(geometry, material);
    
    // Set initial position
    mesh.position.copy(position);
    
    // Set rotation to match direction
    mesh.quaternion.setFromUnitVectors(
      new THREE.Vector3(0, 0, 1), 
      direction.clone().normalize()
    );
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(this.color, 1, 2);
    mesh.add(light);
    
    // Create projectile object
    const projectile = {
      mesh: mesh,
      direction: direction.clone().normalize(),
      speed: this.speed,
      distance: 0,
      maxDistance: this.range,
      damage: this.damage,
      isActive: true,
      owner: 'player',
      type: 'laser',
      explosionSize: this.explosionSize,
      
      // Update method
      update: function(deltaTime) {
        if (!this.isActive) return false;
        
        // Move projectile
        const moveAmount = this.speed * deltaTime;
        this.mesh.position.addScaledVector(this.direction, moveAmount);
        this.distance += moveAmount;
        
        // Deactivate if max distance reached
        if (this.distance >= this.maxDistance) {
          this.isActive = false;
          return false;
        }
        
        return true;
      },
      
      // Handle collision
      handleCollision: function() {
        this.isActive = false;
      },
      
      // Get current position
      get position() {
        return this.mesh.position;
      }
    };
    
    return projectile;
  }
} 
### ./entities/weapons/RegularLaser.js END ###

### ./entities/weapons/WeaponSystem.js BEGIN ###
import * as THREE from 'three';
import { Laser } from './Laser';

export class WeaponSystem {
  constructor(scene) {
    this.scene = scene;
    this.projectiles = [];
    
    // Weapon types
    this.weaponTypes = {
      LASER: {
        name: 'Regular Laser',
        color: 0x00ffff,
        cooldown: 300,
        length: 3,
        thickness: 0.1,
        speed: 0.3,
        damage: 10
      },
      BOUNCE_LASER: {
        name: 'Bounce Laser',
        color: 0xff00ff,
        cooldown: 500,
        length: 2.5,
        thickness: 0.15,
        speed: 0.25,
        damage: 8,
        bounces: 3
      },
      QUANTUM_GRENADE: {
        name: 'Quantum Grenade',
        color: 0xffff00,
        cooldown: 1000,
        speed: 0.15,
        radius: 0.3,
        damage: 25,
        areaEffectRadius: 5,
        delay: 3000
      }
    };
    
    // Audio (will be implemented later)
    this.audioEnabled = false;
  }
  
  fireWeapon(weaponType, position, direction, options = {}) {
    const config = this.weaponTypes[weaponType] || this.weaponTypes['LASER'];
    let projectile = this.createLaser(position, direction, {
      ...config,
      ...options
    });
    
    if (projectile) {
      this.projectiles.push(projectile);
    }
    
    // Network synchronization if available
    if (this.scene.networkManager) {
      this.scene.networkManager.emit('laser_shot', {
        origin: position,
        direction: direction,
        type: weaponType
      });
    }
    
    return projectile;
  }
  
  createLaser(position, direction, config) {
    // Create laser projectile
    return new Laser(this.scene, position, direction, config);
  }
  
  update(deltaTime) {
    // Update all projectiles
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const projectile = this.projectiles[i];
      
      // Update projectile
      projectile.update(deltaTime);
      
      // Remove inactive projectiles
      if (!projectile.isActive) {
        this.projectiles.splice(i, 1);
      }
    }
  }
  
  checkCollisions(targets, obstacles) {
    const hitResults = [];
    
    // Skip if no active projectiles
    if (this.projectiles.length === 0) return hitResults;
    
    // Ensure targets is an array
    const targetArray = Array.isArray(targets) ? targets : [];
    
    // Format obstacles to wall segments if needed
    const wallSegments = this.formatObstacles(obstacles);
    
    // Check each projectile for collisions
    for (const projectile of this.projectiles) {
      if (!projectile.isActive) continue;
      
      // Check wall collisions
      if (wallSegments && this.checkWallCollision(projectile, wallSegments)) {
        hitResults.push({
          projectile: projectile,
          target: 'wall',
          position: projectile.position.clone()
        });
        
        // Handle the hit
        projectile.handleCollision();
        continue;
      }
      
      // Check target collisions
      if (targetArray.length > 0) {
        for (const target of targetArray) {
          if (this.checkTargetCollision(projectile, target)) {
            hitResults.push({
              projectile: projectile,
              target: target,
              position: projectile.position.clone()
            });
            
            // Handle the hit
            projectile.handleCollision();
            break;
          }
        }
      }
    }
    
    return hitResults;
  }
  
  formatObstacles(obstacles) {
    // If obstacles is already an array of wall segments, return it
    if (Array.isArray(obstacles) && obstacles.length > 0 && 
        obstacles[0].start && obstacles[0].end) {
      return obstacles;
    }
    
    // Format obstacles into wall segments if they're in the GameRoom format
    if (Array.isArray(obstacles)) {
      const wallSegments = [];
      
      for (const obstacle of obstacles) {
        if (!obstacle || !obstacle.position) continue;
        
        if (obstacle.type === 'wall' && obstacle.size) {
          // Create line segments for walls
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          // Determine if it's a horizontal or vertical wall
          if (obstacle.size.x > obstacle.size.z) {
            // Horizontal wall
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z),
              end: new THREE.Vector3(x + halfWidth, 0, z)
            });
          } else {
            // Vertical wall
            wallSegments.push({
              start: new THREE.Vector3(x, 0, z - halfDepth),
              end: new THREE.Vector3(x, 0, z + halfDepth)
            });
          }
        } else if (obstacle.radius) {
          // For cylindrical obstacles, we'll approximate with line segments
          const segments = 8; // Number of line segments to approximate circle
          const center = obstacle.position;
          const radius = obstacle.radius;
          
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2;
            const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
            const x1 = center.x + Math.cos(angle1) * radius;
            const z1 = center.z + Math.sin(angle1) * radius;
            const x2 = center.x + Math.cos(angle2) * radius;
            const z2 = center.z + Math.sin(angle2) * radius;
            
            wallSegments.push({
              start: new THREE.Vector3(x1, 0, z1),
              end: new THREE.Vector3(x2, 0, z2)
            });
          }
        } else if (obstacle.size) {
          // Box obstacle - create four wall segments
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z - halfDepth),
            end: new THREE.Vector3(x + halfWidth, 0, z - halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x + halfWidth, 0, z - halfDepth),
            end: new THREE.Vector3(x + halfWidth, 0, z + halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x + halfWidth, 0, z + halfDepth),
            end: new THREE.Vector3(x - halfWidth, 0, z + halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z + halfDepth),
            end: new THREE.Vector3(x - halfWidth, 0, z - halfDepth)
          });
        }
      }
      
      return wallSegments;
    }
    
    // If obstacles is not in a recognized format, return an empty array
    return [];
  }
  
  checkWallCollision(projectile, wallSegments) {
    // Simple collision check for laser projectiles
    const projectilePosition = new THREE.Vector2(
      projectile.position.x,
      projectile.position.z
    );
    
    const radius = projectile.options.thickness;
    
    // Check each wall segment
    for (const segment of wallSegments) {
      const wallStart = new THREE.Vector2(segment.start.x, segment.start.z);
      const wallEnd = new THREE.Vector2(segment.end.x, segment.end.z);
      
      // Calculate closest point on wall segment to projectile
      const wallVector = wallEnd.clone().sub(wallStart);
      const projectileToWallStart = projectilePosition.clone().sub(wallStart);
      
      // Project projectile onto wall line
      const wallLength = wallVector.length();
      const wallDirection = wallVector.clone().normalize();
      const projectionLength = projectileToWallStart.dot(wallDirection);
      
      // Find closest point on wall segment
      let closestPoint;
      if (projectionLength < 0) {
        closestPoint = wallStart;
      } else if (projectionLength > wallLength) {
        closestPoint = wallEnd;
      } else {
        closestPoint = wallStart.clone().add(wallDirection.multiplyScalar(projectionLength));
      }
      
      // Calculate distance from projectile to closest point
      const distance = projectilePosition.distanceTo(closestPoint);
      
      // Check if collision occurred
      if (distance < radius) {
        return true;
      }
    }
    
    return false;
  }
  
  checkTargetCollision(projectile, target) {
    // Simple distance-based collision check
    if (!target.mesh) return false;
    
    // Get target position (assume it has a mesh with position)
    const targetPosition = target.mesh.position;
    
    // Calculate distance
    const distance = projectile.position.distanceTo(targetPosition);
    
    // Simple radius check (can be enhanced later)
    const collisionThreshold = 0.5 + projectile.options.thickness;
    return distance < collisionThreshold;
  }
  
  clearAllProjectiles() {
    // Deactivate all projectiles
    for (const projectile of this.projectiles) {
      projectile.deactivate();
    }
    
    // Clear array
    this.projectiles = [];
  }
} 
### ./entities/weapons/WeaponSystem.js END ###

### ./entities/weapons/Laser.js BEGIN ###
import * as THREE from 'three';

export class Laser {
  constructor(scene, position, direction, options = {}) {
    this.scene = scene;
    this.options = { speed: 0.3, color: 0x00ffff, ...options };
    this.mesh = this.createMesh();
    if (position) this.mesh.position.copy(position);
    if (direction) this.direction = direction.normalize();
    this.scene.add(this.mesh);
    this.isActive = true;
  }

  createMesh() {
    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: this.options.color });
    return new THREE.Mesh(geometry, material);
  }
  
  update(deltaTime) {
    if (!this.isActive) return;
    
    // Move in direction
    if (this.direction) {
      this.mesh.position.add(
        this.direction.clone().multiplyScalar(this.options.speed * deltaTime)
      );
    }
    
    // Check if laser has exceeded its range
    if (this.options.range) {
      const distance = this.mesh.position.distanceTo(this.initialPosition);
      if (distance > this.options.range) {
        this.deactivate();
      }
    }
  }
  
  deactivate() {
    if (!this.isActive) return;
    
    this.isActive = false;
    if (this.mesh && this.scene) {
      this.scene.remove(this.mesh);
    }
    
    // Dispose of geometry and materials
    if (this.mesh) {
      if (this.mesh.geometry) this.mesh.geometry.dispose();
      if (this.mesh.material) {
        if (Array.isArray(this.mesh.material)) {
          this.mesh.material.forEach(material => material.dispose());
        } else {
          this.mesh.material.dispose();
        }
      }
    }
  }
} 
### ./entities/weapons/Laser.js END ###

### ./entities/enemies/EnemyManager.js BEGIN ###
import * as THREE from 'three';
import { Enemy } from './Enemy';

export class EnemyManager {
  constructor(scene, mazeSize = 10) {
    this.scene = scene;
    this.mazeSize = mazeSize;
    this.enemies = [];
    
    // Enemy types with their probabilities and configs
    this.enemyTypes = {
      BASIC: {
        probability: 0.6,
        color: 0xff0000,
        health: 30,
        speed: 0.005
      },
      HUNTER: {
        probability: 0.3,
        color: 0xff00ff,
        health: 20,
        speed: 0.008,
        detectionRadius: 15
      },
      PATROLLER: {
        probability: 0.1,
        color: 0xffaa00,
        health: 40,
        speed: 0.004
      }
    };
    
    // Spawn settings
    this.maxEnemies = 10;
    this.spawnInterval = 5000; // 5 seconds
    this.lastSpawnTime = 0;
    this.spawnDistanceFromPlayer = 10;
    this.difficulty = 1; // Scales over time
  }
  
  update(deltaTime, playerPosition, obstacles) {
    // Check if we should spawn new enemies
    this.checkSpawn(playerPosition);
    
    // Ensure obstacles are correctly formatted for enemies
    const wallSegments = this.formatObstaclesForCollision(obstacles);
    
    // Update all active enemies
    for (let i = this.enemies.length - 1; i >= 0; i--) {
      const enemy = this.enemies[i];
      
      // Skip inactive enemies - they'll be removed later
      if (!enemy.isActive) {
        this.enemies.splice(i, 1);
        continue;
      }
      
      // Update enemy behavior
      enemy.update(deltaTime, playerPosition, wallSegments);
    }
  }
  
  checkSpawn(playerPosition) {
    // Skip if player position isn't available
    if (!playerPosition) return;
    
    const currentTime = Date.now();
    
    // Check if it's time to spawn and we're under the limit
    if (currentTime - this.lastSpawnTime > this.spawnInterval && this.enemies.length < this.maxEnemies) {
      this.lastSpawnTime = currentTime;
      this.spawnEnemy(playerPosition);
    }
  }
  
  spawnEnemy(playerPosition) {
    // Determine spawn position (away from player)
    const spawnPosition = this.getSpawnPosition(playerPosition);
    if (!spawnPosition) return;
    
    // Determine enemy type based on probabilities
    const enemyType = this.selectEnemyType();
    
    // Get configuration for selected enemy type
    const typeConfig = this.enemyTypes[enemyType];
    
    // Scale difficulty based on current level
    const healthMultiplier = 1 + (this.difficulty - 1) * 0.2;
    const speedMultiplier = 1 + (this.difficulty - 1) * 0.1;
    
    // Create enemy with adjusted settings
    const enemy = new Enemy(this.scene, spawnPosition, {
      type: enemyType,
      color: typeConfig.color,
      health: typeConfig.health * healthMultiplier,
      speed: typeConfig.speed * speedMultiplier,
      detectionRadius: typeConfig.detectionRadius || 10
    });
    
    // Add to active enemies list
    this.enemies.push(enemy);
    
    return enemy;
  }
  
  getSpawnPosition(playerPosition) {
    // Try to find a valid spawn position
    for (let attempt = 0; attempt < 10; attempt++) {
      // Generate random angle around player
      const angle = Math.random() * Math.PI * 2;
      
      // Calculate position at random distance from player (between min and max)
      const minDistance = this.spawnDistanceFromPlayer;
      const maxDistance = this.spawnDistanceFromPlayer + 5;
      const distance = minDistance + Math.random() * (maxDistance - minDistance);
      
      // Calculate position
      const x = playerPosition.x + Math.cos(angle) * distance;
      const z = playerPosition.z + Math.sin(angle) * distance;
      
      // Check if position is within maze bounds
      if (Math.abs(x) < this.mazeSize * 0.8 && Math.abs(z) < this.mazeSize * 0.8) {
        return new THREE.Vector3(x, 0, z);
      }
    }
    
    // If all attempts failed, return null
    return null;
  }
  
  selectEnemyType() {
    // Random value between 0 and 1
    const rand = Math.random();
    
    // Calculate cumulative probability
    let cumulativeProbability = 0;
    
    for (const [type, config] of Object.entries(this.enemyTypes)) {
      cumulativeProbability += config.probability;
      
      if (rand <= cumulativeProbability) {
        return type;
      }
    }
    
    // Fallback to basic enemy
    return 'BASIC';
  }
  
  increaseMaxEnemies(amount = 1) {
    this.maxEnemies += amount;
  }
  
  increaseDifficulty(amount = 0.1) {
    this.difficulty += amount;
    
    // Also decrease spawn interval as difficulty increases
    this.spawnInterval = Math.max(1000, this.spawnInterval - 100);
  }
  
  checkCollisions(playerPosition, playerRadius = 0.5) {
    // Check for collisions between player and enemies
    if (!playerPosition) return false;
    
    for (const enemy of this.enemies) {
      if (!enemy.isActive) continue;
      
      // Simple distance-based collision check
      const distance = enemy.mesh.position.distanceTo(playerPosition);
      
      // If collision detected
      if (distance < playerRadius + enemy.options.size) {
        return enemy;
      }
    }
    
    return null;
  }
  
  clear() {
    // Remove all enemies
    for (const enemy of this.enemies) {
      enemy.destroy();
    }
    
    this.enemies = [];
  }
  
  // Convert obstacle data to wall segments format for collision detection
  formatObstaclesForCollision(obstacles) {
    if (!obstacles || !Array.isArray(obstacles)) return [];
    
    const wallSegments = [];
    
    for (const obstacle of obstacles) {
      if (obstacle.type === 'wall' && obstacle.position && obstacle.size) {
        // Create wall segments from obstacle bounds
        const halfWidth = obstacle.size.x / 2;
        const halfDepth = obstacle.size.z / 2;
        const x = obstacle.position.x;
        const z = obstacle.position.z;
        
        // Create four wall segments for each rectangular wall
        if (obstacle.size.x > obstacle.size.z) {
          // Horizontal wall (longer in x direction)
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z),
            end: new THREE.Vector3(x + halfWidth, 0, z)
          });
        } else {
          // Vertical wall (longer in z direction)
          wallSegments.push({
            start: new THREE.Vector3(x, 0, z - halfDepth),
            end: new THREE.Vector3(x, 0, z + halfDepth)
          });
        }
      } else if (obstacle.type === 'obstacle' && obstacle.position) {
        // Create a simple boundary for other obstacles
        if (obstacle.radius) {
          // For cylindrical obstacles, create a circle approximation using 8 segments
          const radius = obstacle.radius;
          const center = obstacle.position;
          const segments = 8;
          
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2;
            const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
            const x1 = center.x + Math.cos(angle1) * radius;
            const z1 = center.z + Math.sin(angle1) * radius;
            const x2 = center.x + Math.cos(angle2) * radius;
            const z2 = center.z + Math.sin(angle2) * radius;
            
            wallSegments.push({
              start: new THREE.Vector3(x1, 0, z1),
              end: new THREE.Vector3(x2, 0, z2)
            });
          }
        } else if (obstacle.size) {
          // For box obstacles, create four wall segments
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          // Handle rotation if present
          let rotation = 0;
          if (obstacle.rotation) {
            rotation = obstacle.rotation.y;
          }
          
          if (rotation) {
            // Rotated rectangle - more complex calculation
            // For simplicity, we'll just create a simpler collision boundary
            const radius = Math.max(halfWidth, halfDepth);
            const segments = 8;
            
            for (let i = 0; i < segments; i++) {
              const angle1 = (i / segments) * Math.PI * 2;
              const angle2 = ((i + 1) / segments) * Math.PI * 2;
              
              const x1 = x + Math.cos(angle1) * radius;
              const z1 = z + Math.sin(angle1) * radius;
              const x2 = x + Math.cos(angle2) * radius;
              const z2 = z + Math.sin(angle2) * radius;
              
              wallSegments.push({
                start: new THREE.Vector3(x1, 0, z1),
                end: new THREE.Vector3(x2, 0, z2)
              });
            }
          } else {
            // Axis-aligned rectangle - simpler
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z - halfDepth),
              end: new THREE.Vector3(x + halfWidth, 0, z - halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x + halfWidth, 0, z - halfDepth),
              end: new THREE.Vector3(x + halfWidth, 0, z + halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x + halfWidth, 0, z + halfDepth),
              end: new THREE.Vector3(x - halfWidth, 0, z + halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z + halfDepth),
              end: new THREE.Vector3(x - halfWidth, 0, z - halfDepth)
            });
          }
        }
      }
    }
    
    return wallSegments;
  }
} 
### ./entities/enemies/EnemyManager.js END ###

### ./entities/enemies/Enemy.js BEGIN ###
import * as THREE from 'three';
import { Ship } from '../Ship';

export class Enemy extends Ship {
  constructor(scene, position, options = {}) {
    // Set default enemy options
    const enemyOptions = {
      type: 'BASIC',
      health: 30,
      speed: 0.005,
      size: 0.6,
      detectionRadius: 10,
      attackRange: 8,
      shipModel: 'STANDARD',
      ...options
    };
    
    super(scene, position, enemyOptions);
    
    // Enemy-specific properties
    this.targetPosition = null;
    this.lastDirectionChange = 0;
    this.directionChangeInterval = 2000 + Math.random() * 2000;
    this.currentTarget = null;
    this.lastAttackTime = 0;
    this.attackCooldown = 1000;
  }
  
  update(deltaTime, players, wallSegments) {
    if (!this.isActive) return;
    
    super.update(deltaTime);
    
    // Update behavior based on enemy type
    switch (this.options.type) {
      case 'HUNTER':
        this.updateHunter(deltaTime, players, wallSegments);
        break;
      case 'PATROLLER':
        this.updatePatroller(deltaTime, wallSegments);
        break;
      case 'BASIC':
      default:
        this.updateBasic(deltaTime, players, wallSegments);
        break;
    }
  }
  
  updateBasic(deltaTime, players, wallSegments) {
    const currentTime = Date.now();
    
    // Find nearest enemy player
    let nearestTarget = this.findNearestEnemyPlayer(players);
    
    if (nearestTarget && this.isInRange(nearestTarget.position, this.options.detectionRadius)) {
      // If enemy player is in range, engage
      this.currentTarget = nearestTarget;
      this.engageTarget(deltaTime, wallSegments);
    } else {
      // Random movement when no target
      if (currentTime - this.lastDirectionChange > this.directionChangeInterval) {
        this.lastDirectionChange = currentTime;
        const angle = Math.random() * Math.PI * 2;
        this.direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
        this.directionChangeInterval = 2000 + Math.random() * 2000;
      }
      
      if (this.direction) {
        this.moveWithCollision(this.direction, deltaTime, wallSegments);
      }
    }
  }
  
  updateHunter(deltaTime, players, wallSegments) {
    const nearestTarget = this.findNearestEnemyPlayer(players);
    
    if (nearestTarget && this.isInRange(nearestTarget.position, this.options.detectionRadius)) {
      this.currentTarget = nearestTarget;
      this.engageTarget(deltaTime, wallSegments);
    } else {
      this.updateBasic(deltaTime, players, wallSegments);
    }
  }
  
  updatePatroller(deltaTime, wallSegments) {
    if (!this.targetPosition || this.mesh.position.distanceTo(this.targetPosition) < 0.5) {
      this.targetPosition = new THREE.Vector3(
        this.mesh.position.x + (Math.random() * 10 - 5),
        this.mesh.position.y,
        this.mesh.position.z + (Math.random() * 10 - 5)
      );
    }
    
    const toTarget = new THREE.Vector3().subVectors(this.targetPosition, this.mesh.position).normalize();
    this.moveWithCollision(toTarget, deltaTime, wallSegments);
  }
  
  engageTarget(deltaTime, wallSegments) {
    if (!this.currentTarget || !this.currentTarget.isActive) {
      this.currentTarget = null;
      return;
    }

    const toTarget = new THREE.Vector3().subVectors(
      this.currentTarget.position,
      this.mesh.position
    );
    
    const distance = toTarget.length();
    
    if (distance < this.options.attackRange) {
      // Attack if in range and cooldown is ready
      const currentTime = Date.now();
      if (currentTime - this.lastAttackTime > this.attackCooldown) {
        this.attack();
        this.lastAttackTime = currentTime;
      }
      
      // Maintain distance
      if (distance < this.options.attackRange * 0.5) {
        this.moveWithCollision(toTarget.normalize().negate(), deltaTime, wallSegments);
      }
    } else {
      // Move towards target
      this.moveWithCollision(toTarget.normalize(), deltaTime, wallSegments);
    }
    
    // Face target
    const angle = Math.atan2(toTarget.x, toTarget.z);
    this.mesh.rotation.y = angle;
  }
  
  moveWithCollision(direction, deltaTime, wallSegments) {
    const movement = direction.clone().multiplyScalar(this.options.speed * deltaTime);
    const previousPosition = this.mesh.position.clone();
    
    this.mesh.position.add(movement);
    
    if (this.checkWallCollision(wallSegments)) {
      this.mesh.position.copy(previousPosition);
      this.direction = direction.clone().reflect(new THREE.Vector3(1, 0, 0));
    }
    
    // Face movement direction
    if (direction.length() > 0) {
      const angle = Math.atan2(direction.x, direction.z);
      this.mesh.rotation.y = angle;
    }
  }
  
  findNearestEnemyPlayer(players) {
    let nearestDistance = Infinity;
    let nearestPlayer = null;

    players.forEach(player => {
      if (player.isActive && player.teamId !== this.teamId) {
        const distance = this.mesh.position.distanceTo(player.mesh.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestPlayer = player;
        }
      }
    });

    return nearestPlayer;
  }
  
  isInRange(position, range) {
    return this.mesh.position.distanceTo(position) <= range;
  }
  
  attack() {
    // Emit attack event for weapon system to handle
    this.emit('attack', {
      position: this.mesh.position.clone(),
      direction: new THREE.Vector3().subVectors(
        this.currentTarget.mesh.position,
        this.mesh.position
      ).normalize(),
      teamId: this.teamId
    });
  }
  
  checkWallCollision(wallSegments) {
    const pos = this.mesh.position;
    for (const segment of wallSegments) {
      const closest = this.getClosestPoint(pos, segment.start, segment.end);
      if (pos.distanceTo(closest) < this.options.size) return true;
    }
    return false;
  }

  getClosestPoint(point, start, end) {
    const line = end.clone().sub(start);
    const t = Math.max(0, Math.min(1, point.clone().sub(start).dot(line) / line.lengthSq()));
    return start.clone().add(line.multiplyScalar(t));
  }
} 
### ./entities/enemies/Enemy.js END ###

### ./entities/player/Player.js BEGIN ###
import * as THREE from 'three';
import { ModelLoader } from '../../assets/ModelLoader';
import { KEY_MAPPINGS, CONTROL_SETTINGS, DEFAULT_CONTROL_STATE, ControlUtils } from '../../config/Controls';
import { Ship } from '../Ship';

export class Player extends Ship {
  constructor(scene, position, options = {}) {
    // Set default player options
    const playerOptions = {
      type: 'PLAYER',
      health: 100,
      maxHealth: 100,
      speed: 0.15,
      size: 1.0,
      shipModel: 'STANDARD',
      ...options
    };
    
    super(scene, position, playerOptions);
    
    // Player-specific properties
    this.moveDirection = new THREE.Vector3();
    this.velocity = new THREE.Vector3();
    this.rotation = new THREE.Euler();
    this.quaternion = new THREE.Quaternion();
    this.targetQuaternion = new THREE.Quaternion();
    
    // Movement state
    this.moveState = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      boost: false
    };
    
    // Bind event handler methods to preserve 'this' context
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    
    // Initialize controls
    this.setupControls();
  }

  setupControls() {
    // Keyboard controls
    document.addEventListener('keydown', this.handleKeyDown);
    document.addEventListener('keyup', this.handleKeyUp);
    
    // Mouse controls for aiming
    document.addEventListener('mousemove', this.handleMouseMove);
  }

  handleKeyDown(event) {
    switch(event.code) {
        case 'KeyW':
        this.moveState.forward = true;
          break;
        case 'KeyS':
        this.moveState.backward = true;
          break;
        case 'KeyA':
        this.moveState.left = true;
          break;
        case 'KeyD':
        this.moveState.right = true;
          break;
      case 'ShiftLeft':
        this.moveState.boost = true;
          break;
      }
  }
    
  handleKeyUp(event) {
    switch(event.code) {
        case 'KeyW':
        this.moveState.forward = false;
          break;
        case 'KeyS':
        this.moveState.backward = false;
          break;
        case 'KeyA':
        this.moveState.left = false;
          break;
        case 'KeyD':
        this.moveState.right = false;
        break;
      case 'ShiftLeft':
        this.moveState.boost = false;
          break;
      }
  }

  handleMouseMove(event) {
    // Update rotation based on mouse position
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // Calculate target rotation
    this.rotation.y = Math.atan2(mouseX, mouseY);
    this.targetQuaternion.setFromEuler(this.rotation);
  }
  
  update(deltaTime) {
    if (!this.isActive) return;
    
    super.update(deltaTime);
    
    // Update movement
    this.updateMovement(deltaTime);
    
    // Update rotation
    this.updateRotation(deltaTime);
    
    // Emit position update event
    this.emit('positionUpdate', {
      position: this.mesh.position.clone(),
      rotation: this.mesh.rotation.clone(),
      teamId: this.teamId
    });
  }

  updateMovement(deltaTime) {
    // Reset movement direction
    this.moveDirection.set(0, 0, 0);
    
    // Calculate movement direction based on input state
    if (this.moveState.forward) this.moveDirection.z -= 1;
    if (this.moveState.backward) this.moveDirection.z += 1;
    if (this.moveState.left) this.moveDirection.x -= 1;
    if (this.moveState.right) this.moveDirection.x += 1;
    
    // Normalize movement direction
    if (this.moveDirection.lengthSq() > 0) {
      this.moveDirection.normalize();
    }
    
    // Apply speed and boost
    const currentSpeed = this.moveState.boost ? this.options.speed * 1.5 : this.options.speed;
    
    // Update velocity with smooth acceleration
    const acceleration = 0.1;
    this.velocity.lerp(this.moveDirection.multiplyScalar(currentSpeed), acceleration);
    
    // Apply velocity
    this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
    
    // Keep player within bounds (example bounds)
    const bounds = 50;
    this.mesh.position.x = Math.max(-bounds, Math.min(bounds, this.mesh.position.x));
    this.mesh.position.z = Math.max(-bounds, Math.min(bounds, this.mesh.position.z));
    
    // Broadcast position updates for multiplayer
    if (this.networkManager) {
      this.networkManager.emit('player_move', {
        position: this.mesh.position,
        rotation: this.mesh.rotation,
      });
    }
  }

  updateRotation(deltaTime) {
    // Smoothly interpolate current rotation to target rotation
    this.mesh.quaternion.slerp(this.targetQuaternion, 0.1);
  }

  getForwardDirection() {
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(this.mesh.quaternion);
    return forward;
  }

  getRightDirection() {
    const right = new THREE.Vector3(1, 0, 0);
    right.applyQuaternion(this.mesh.quaternion);
    return right;
  }

  // Override destroy to handle player-specific cleanup
  destroy() {
    if (!this.isActive) return;
    
    // Remove event listeners
    document.removeEventListener('keydown', this.handleKeyDown);
    document.removeEventListener('keyup', this.handleKeyUp);
    document.removeEventListener('mousemove', this.handleMouseMove);
    
    // Call parent destroy method
    super.destroy();
    
    // Emit player destroyed event
    this.emit('playerDestroyed', {
      position: this.mesh.position.clone(),
      teamId: this.teamId
    });
  }
} 
### ./entities/player/Player.js END ###

### DIRECTORY . FLATTENED CONTENT ###
### DIRECTORY . FOLDER STRUCTURE ###
./
    index.html
    flatten.py
    index.js
    codebase.md
    ui/
        ShipSelectionUI.js
        GameRoom.js
        GameUI.js
        MiniMap.js
    scenes/
        TeamDemo.js
    core/
        Game.js
        TeamManager.js
        Scene.js
        GameEngine.js
        Engine.js
        NetworkManager.js
        InfiniteMap.js
    config/
        ShipConfig.js
        Controls.js
        GameConfig.js
    constants/
    utils/
    styles/
        main.css
        controls.css
    effects/
    assets/
        ModelLoader.js
        SoundManager.js
        .DS_Store
        AssetLoader.js
        textures/
        images/
        models/
            .DS_Store
            textures/
                tex.png
                Colors3.png
            ships/
                ALTSPACE2.glb
                ALTSPACE1.glb
            flora/
                Grass_01.glb
                .DS_Store
                SmalRoots_01.glb
                BigPlant_06.glb
                SP_Plant08.glb
                SP_Plant07.glb
                Mushrooms.glb
                SP_Tree04.glb
                SP_Tree02.glb
                SP_Tree03.glb
                SP_Tree01.glb
                Tenticles_01.glb
            objects/
                .DS_Store
                SP_Stone01.glb
                SP_Mountain03.glb
                SP_Mountain02.glb
                SP_Mountain01.glb
                SP_Ground03.glb
                SP_Ground02.glb
                SP_Ground05.glb
                SP_Ground04.glb
            terrain/
                .DS_Store
                Water.glb
                Terrain.glb
            rocks/
                SP_Rock01.glb
                SP_Rock03.glb
                SP_Rock02.glb
                SP_Rock06.glb
                .DS_Store
                SP_Rock07.glb
                SP_Rock05.glb
                SP_Rock04.glb
                SP_Rock09.glb
                SP_Rock08.glb
        sounds/
            weapon-switch.mp3
            laser.mp3
            bounce.mp3
            weapon-charging.mp3
            grenade-laser.mp3
            laser-bounce.mp3
            weapon-armor-hit.mp3
    entities/
        Ship.js
        obstacles/
        weapons/
            RegularLaser.js
            WeaponSystem.js
            Laser.js
        enemies/
            EnemyManager.js
            Enemy.js
        player/
            Player.js
### DIRECTORY . FOLDER STRUCTURE ###

### DIRECTORY . FLATTENED CONTENT ###
### ./index.html BEGIN ###
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/main.css">
    <link rel="stylesheet" href="./styles/controls.css">
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="loader"></div>
            <p>Loading the quantum realm...</p>
        </div>
    </div>
    
    <div id="start-screen" class="hidden">
        <div class="start-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="player-input">
                <input type="text" id="player-name" maxlength="15" placeholder="Enter your pilot name" />
                <p class="input-info">Your name will be visible to other players</p>
            </div>
            <button id="start-button" class="glow-button">START GAME</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>
    
    <!-- Multiplayer Info -->
    <div id="multiplayer-info" class="hidden">
        <div class="connection-indicator">
            <span>Connection: </span>
            <span id="connection-status">Disconnected</span>
        </div>
        <div class="players-indicator">
            <span>Players: </span>
            <span id="players-count">0</span>
        </div>
    </div>
    
    <!-- Simple HUD for controls info -->
    <div class="controls-info hidden">
        <p>W/↑: Forward | S/↓: Backward</p>
        <p>A/← D/→: Rotate Ship</p>
        <p>Q/E: Strafe Left/Right</p>
        <p>Space: Fire Laser</p>
        <p>Avoid the colored obstacles!</p>
    </div>
</body>
<script type="module" src="./index.js"></script>
</html> 
### ./index.html END ###

### ./flatten.py BEGIN ###
import os
import argparse

def printFolderStructure(directory, output_file):
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n")
    for root, directories, files in os.walk(directory):
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write('{}{}/\n'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            output_file.write('{}{}\n'.format(subindent, f))
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n\n")

def walkFolderTree(folder):
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            yield os.path.join(dirpath, filename)

def main():
    parser = argparse.ArgumentParser(description='Flattens a codebase.')
    parser.add_argument('--folders', nargs='*', help='Base folders to process')
    parser.add_argument('--system_instructions', action='store_true', help='Print system instructions')

    system_instructions = """## System Instructions for Language Model Assistance in Code Debugging

### Role Definition:
- **Act as a software engineer** tasked with assisting in debugging code.
- Provide insights, explanations, and solutions based on the provided codebase information.

### Codebase Markdown File Structure:
- The codebase markdown file represents the actual codebase structure and content.
- It begins with a directory tree representation:
  ```
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  (file tree representation)
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  ```
- Following the directory tree, the contents of each file are displayed:
  ```
  ### path/to/file1 BEGIN ###
  (content of file1)
  ### path/to/file1 END ###
  
  ### path/to/file2 BEGIN ###
  (content of file2)
  ### path/to/file2 END ###
  ```

### Guidelines for Interaction:
- Respond to queries based on the explicit content provided within the markdown file.
- Avoid making assumptions about the code without clear evidence presented in the file content.
- When seeking specific implementation details, refer to the corresponding section in the markdown file, for example:
  ```
  ### folder1/folder2/myfile.ts BEGIN ###
  (specific implementation details)
  ### folder1/folder2/myfile.ts END ###
  ```

### Objective:
- The primary objective is to facilitate effective debugging by providing accurate information and guidance strictly adhering to the content available in the markdown file."""

    args = parser.parse_args()

    if args.system_instructions:
        print(system_instructions)

        if not args.folders:
            return

    if args.folders:
        base_folders = args.folders
        with open('codebase.md', 'w') as output_file:
            for base_folder in base_folders:
                printFolderStructure(base_folder, output_file)
                
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
                for filepath in walkFolderTree(base_folder):
                    content = f"### {filepath} BEGIN ###\n"
                    
                    try:
                        with open(filepath, "r") as f:
                            content += f.read()
                        content += f"\n### {filepath} END ###\n\n"
                    except:
                        continue
                    
                    output_file.write(content)
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
    else:
        print("usage: main.py [-h] --folders FOLDERS [FOLDERS ...] [--system_instructions]")
        print("Error: the following arguments are required: --folders")

if __name__ == "__main__":
    main()
### ./flatten.py END ###

### ./index.js BEGIN ###
import * as THREE from 'three';
import { OrbitControls } from '@three/examples/controls/OrbitControls';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import './styles/main.css';
import { GameUI } from './ui/GameUI';
import { MiniMap } from './ui/MiniMap';
import { CONTROL_SETTINGS, CONTROL_FEEDBACK, DEFAULT_CONTROL_STATE, ControlUtils } from './config/Controls';
import { ShipSelectionUI } from './ui/ShipSelectionUI';
import AssetLoader from './assets/AssetLoader';
import { InfiniteMap } from './core/InfiniteMap';
import { NetworkManager } from './core/NetworkManager';
import { CSS2DRenderer, CSS2DObject } from '@three/examples/renderers/CSS2DRenderer';
import { GAME_CONFIG } from './config/GameConfig';
import { Player } from './entities/player/Player';
import { SoundManager } from './assets/SoundManager';

// Basic Three.js game with a ship
class SimpleGame {
  constructor() {
    // Initialize all properties first
    // Player information
    this.playerName = 'Pilot';  // Default player name
    
    // Create the asset loader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => this.updateLoadingUI(message),
      (type, error) => this.handleLoadError(type, error)
    );
    
    // Initialize SoundManager
    this.soundManager = new SoundManager();
    
    // Asset loading state
    this.loadingState = {
      started: false,
      completed: false,
      errors: []
    };
    
    // Track assets loading
    this.assetsLoaded = false;
    this.shipModelLoaded = false;
    
    // Initialize control state
    this.keys = { ...DEFAULT_CONTROL_STATE };
    
    // Setup animation timing
    this.clock = new THREE.Clock();
    this.lastTime = Date.now();
    
    // Event handling - bind methods
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    
    // Debounce timers
    this.mouseMoveTimer = null;
    this.resizeTimer = null;
    this.weaponCooldowns = new Map();
    this.lastWeaponSwitch = 0;

    // Setup basic Three.js scene
    this.setupScene();
    
    // Create game UI
    this.ui = new GameUI();
    
    // Create player after scene setup (as specified in Task 8)
    this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
      type: 'PLAYER',
      shipModel: 'STANDARD',
      teamColor: 0x00ffff
    });
    this.scene.add(this.player.mesh);
    
    // For backward compatibility with existing code
    this.playerShip = this.player.mesh;
    
    // Game properties
    this.boundarySize = 100; // Size of the playable area
    
    // Initialize player state
    this.health = 100;
    this.maxHealth = 100;
    this.energy = 100;
    this.maxEnergy = 100;
    this.energyRechargeRate = 20; // Units per second
    this.currentWeapon = 'LASER';
    
    // Initialize available weapons
    this.availableWeapons = ['LASER', 'GRENADE', 'BOUNCE'];
    this.weaponIndex = 0; // Start with LASER
    
    // Load assets
    this.loadAssets();
    
    // Setup controls
    this.setupControls();
    
    // Initialize infinite map after scene setup
    this.infiniteMap = new InfiniteMap(this);
    
    // Create mini-map (after scene setup) but keep it hidden initially
    this.miniMap = new MiniMap(this);
    this.miniMap.hide(); // Make sure it starts hidden
    
    // Handle window resize
    window.addEventListener('resize', this.boundHandleResize);
    
    console.log('Simple game initialized!');

    // Add frame counter
    this.frameCount = 0;
    
    // Initialize NetworkManager
    this.networkManager = new NetworkManager();
    
    // Initialize remotePlayers map for multiplayer
    this.remotePlayers = new Map();
    
    this.networkManager.on('connected', () => {
      console.log('Connected to game server!');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from game server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      // Update player count
      this.updatePlayerCount();
    });
    
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      // Remove player mesh if it exists
      const player = this.remotePlayers.get(id);
      if (player) {
        this.scene.remove(player);
        this.remotePlayers.delete(id);
        console.log(`Removed remote player: ${id}`);
      }
      // Update player count
      this.updatePlayerCount();
    });
    
    // Add player update handling
    this.networkManager.on('player_update', (data) => {
      this.updateRemotePlayer(data.id, data.position, data.rotation);
    });
    
    // Add laser shot handling
    this.networkManager.on('laser_shot', (shotData) => {
      console.log('Received laser shot from network:', shotData);
      const position = new THREE.Vector3(shotData.origin.x, shotData.origin.y, shotData.origin.z);
      const direction = new THREE.Vector3(shotData.direction.x, shotData.direction.y, shotData.direction.z);

      if (shotData.type === 'bounce') {
        this.fireBouncingLaser(position, direction);
      } else {
        this.fireLaser(position, direction);
      }
    });
    
    // Add helper method to update player count
    this.updatePlayerCount = () => {
      const count = this.networkManager.getOtherPlayers().length + 1; // +1 for self
      document.getElementById('players-count').textContent = count;
    };
    
    this.multiplayerEnabled = false;
  }
  
  setupScene() {
    // Create Three.js Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a1f); // Dark blue background
    
    // Setup WebGL renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(this.renderer.domElement);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near
      1000 // Far
    );
    
    // Position camera
    this.camera.position.set(0, 7, 15); // Slightly above and behind player
    this.camera.lookAt(0, 0, 0);
    
    // Attach audio listener to camera
    if (this.soundManager) {
      this.camera.add(this.soundManager.getListener());
      console.log('Audio listener attached to camera');
    }
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);
    
    // Create a simple grid floor
    this.createFloor();
    
    // Create some obstacles
    this.createObstacles();
  }
  
  async loadAssets() {
    if (this.loadingState.started) {
        console.warn('🔍 Asset loading already in progress');
        return;
    }
    
    this.updateLoadingUI('Loading game assets...');
    
    try {
        // Create initial player with default ship
        if (!this.player) {
            this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
                type: 'PLAYER',
                shipModel: 'STANDARD',
                teamColor: 0x00ffff
            });
            this.playerShip = this.player.mesh; // For backward compatibility
        }
        
        // Load all assets through AssetLoader
        await this.assetLoader.loadAll();
        this.assetsLoaded = true;
        this.shipModelLoaded = true;
        
        console.log('✅ All assets loaded successfully');
        this.checkLoadingProgress();
    } catch (error) {
        console.error('🔍 Critical error loading assets:', error);
        this.handleLoadError('critical', error);
    }
  }
  
  handleLoadError(assetType, error) {
    console.error(`Error loading ${assetType}:`, error);
    this.loadingState.errors.push({ type: assetType, error: error.message });
    
    // Update UI with error
    this.updateLoadingUI(`Error loading ${assetType}. ${this.loadingState.errors.length} errors total.`);
    
    // If critical error, show error screen
    if (assetType === 'critical') {
      this.showErrorScreen('Failed to load game assets. Please refresh the page.');
    }
  }
  
  updateLoadingUI(message) {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const messageElement = loadingScreen.querySelector('.loading-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  }
  
  showErrorScreen(message) {
    // Create error screen if it doesn't exist
    let errorScreen = document.getElementById('error-screen');
    if (!errorScreen) {
      errorScreen = document.createElement('div');
      errorScreen.id = 'error-screen';
      errorScreen.className = 'error-screen';
      
      const errorMessage = document.createElement('div');
      errorMessage.className = 'error-message';
      errorScreen.appendChild(errorMessage);
      
      const retryButton = document.createElement('button');
      retryButton.textContent = 'Retry';
      retryButton.onclick = () => {
        errorScreen.remove();
        this.loadingState = {
          started: false,
          completed: false,
          errors: []
        };
        this.loadAssets();
      };
      errorScreen.appendChild(retryButton);
      
      document.body.appendChild(errorScreen);
    }
    
    // Update error message
    const messageElement = errorScreen.querySelector('.error-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
  }
  
  checkLoadingProgress() {
    console.log('🔍 Checking loading progress...');
    
    // Log loading state
    console.log('Loading state:', JSON.stringify(this.loadingState, null, 2));
    
    // Define what's required for a fully loaded game
    const requiredAssets = {
      shipModel: this.shipModelLoaded,
      assetsLoaded: this.assetLoader.loadingState.completed
    };
    
    // Check if all required assets are loaded
    const allAssetsLoaded = Object.entries(requiredAssets).every(([key, loaded]) => {
      console.log(`🔍 ${key}: ${loaded ? '✅' : '❌'}`);
      return loaded;
    });
    
    if (allAssetsLoaded) {
      console.log('✅ All required assets loaded!');
      this.loadingState.completed = true;
      this.showStartScreen();
    } else {
      // Log which assets are still pending
      const pendingAssets = Object.entries(requiredAssets)
        .filter(([_, loaded]) => !loaded)
        .map(([key]) => key);
      console.log('⏳ Still waiting for:', pendingAssets);
      
      // Update loading UI
      this.updateLoadingUI(`Loading... (${pendingAssets.join(', ')})`);
      
      // Check again after a delay
      setTimeout(() => this.checkLoadingProgress(), 1000);
    }
  }
  
  showStartScreen() {
    console.log('🔍 Attempting to show start screen');
    
    // Timeout to ensure UI has time to update
    setTimeout(() => {
      // Hide loading screen and show start screen
      const loadingScreen = document.getElementById('loading-screen');
      const startScreen = document.getElementById('start-screen');
      
      console.log('🔍 Loading screen element:', loadingScreen);
      console.log('🔍 Start screen element:', startScreen);
      
      if (loadingScreen) {
        console.log('🔍 Adding fade-out class to loading screen');
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          loadingScreen.classList.add('hidden');
          loadingScreen.classList.remove('fade-out');
          console.log('🔍 Loading screen hidden');
        }, 500);
      } else {
        console.error('🔍 Loading screen element not found!');
      }
      
      if (startScreen) {
        console.log('🔍 Showing start screen');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('fade-in');
      } else {
        console.error('🔍 Start screen element not found!');
      }
      
      console.log('🔍 Game ready to start!');
    }, 500);
  }
  
  addThrusterGlow() {
    // Check if player and player mesh exist
    if (!this.player || !this.player.mesh) {
      console.warn('Cannot add thruster glow: Player or player mesh is not initialized');
      return;
    }
    
    // Create a single, efficient thruster glow effect
    // Use instanced mesh for better performance if you have multiple thrusters
    
    // Create a glow for the thruster
    const thrusterGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 12);
    const thrusterMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending // Use additive blending for better glow effect
    });
    
    const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
    thruster.position.set(0, 0, -0.7); // Position at the back of the ship
    thruster.rotation.x = Math.PI / 2;
    thruster.name = 'thruster'; // Name it for easier reference later
    
    // Add thruster to player mesh
    this.player.mesh.add(thruster);
    
    // Add point light for the thruster
    const thrusterLight = new THREE.PointLight(0x00ffff, 1, 3);
    thrusterLight.position.copy(thruster.position);
    thrusterLight.name = 'thrusterLight';
    
    // Store references for animation
    this.thruster = thruster;
    this.thrusterLight = thrusterLight;
    
    // Create a subtle, animated glow effect with proper initialization
    this.thrusterPulse = { 
      value: 0,
      phase: 0 
    };
    
    // Add to ship model
    if (this.shipModel) {
      this.shipModel.add(thruster);
      this.shipModel.add(thrusterLight);
    }
  }
  
  createFloor() {
    console.log('Creating floor with Terrain.glb model');
    
    // Create a placeholder floor initially - this will be visible until the model loads
    const tempFloorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);
    const tempFloorMaterial = new THREE.MeshBasicMaterial({
      color: 0x000022,
      transparent: true,
      opacity: 0.2,
    });
    
    this.floor = new THREE.Mesh(tempFloorGeometry, tempFloorMaterial);
    this.floor.rotation.x = -Math.PI / 2;
    this.floor.position.y = -0.01;
    this.scene.add(this.floor);
    
    // Also create an invisible raycasting plane that will always work for targeting
    // This ensures mouse input works consistently regardless of the visual floor model
    this.raycastFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        transparent: true, 
        opacity: 0.05, // Very slight visibility for debugging
        side: THREE.DoubleSide
      })
    );
    this.raycastFloor.rotation.x = -Math.PI / 2;
    this.raycastFloor.position.y = 0.1; // Position higher above terrain
    this.scene.add(this.raycastFloor);
    
    // Add debug logging
    console.log('Raycast floor created at height:', this.raycastFloor.position.y, 'and size:', 1000);
    
    // Load texture first
    const textureLoader = new THREE.TextureLoader();
    const texturePromise = new Promise((resolve, reject) => {
      textureLoader.load(
        'assets/models/textures/Colors3.png', 
        texture => {
          console.log('Terrain texture (Colors3.png) loaded successfully');
          // Configure texture 
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(8, 8); // Repeat the texture more times for better detail
          resolve(texture);
        },
        undefined,
        error => {
          console.error('Error loading Colors3.png texture:', error);
          // Try fallback texture
          textureLoader.load(
            'assets/models/textures/tex.png', 
            fallbackTexture => {
              console.log('Fallback texture loaded');
              fallbackTexture.wrapS = THREE.RepeatWrapping;
              fallbackTexture.wrapT = THREE.RepeatWrapping;
              fallbackTexture.repeat.set(5, 5);
              resolve(fallbackTexture);
            },
            undefined,
            fallbackError => {
              console.error('Error loading fallback texture:', fallbackError);
              resolve(null); // Resolve with null to continue without texture
            }
          );
        }
      );
    });
    
    // When texture is loaded (or failed), get the terrain model from AssetLoader
    texturePromise.then(texture => {
      // Get terrain model from AssetLoader
      const terrain = this.assetLoader.getModel('terrain/Terrain.glb');
      
      if (terrain) {
        console.log('Using terrain model from AssetLoader');
        
        // Remove the temporary floor
        if (this.floor) {
          this.scene.remove(this.floor);
          this.floor.geometry.dispose();
          this.floor.material.dispose();
        }
        
        // Clone the model to avoid modifying the original
        const terrainClone = terrain.clone();
        
        // Scale the terrain appropriately
        const terrainScale = 100; // Adjust this value to change the overall size
        terrainClone.scale.set(terrainScale, terrainScale * 0.5, terrainScale);
        
        // Position terrain at center and slightly below zero to avoid z-fighting
        terrainClone.position.set(0, -0.2, 0);
        
        // Apply texture if available
        if (texture) {
          terrainClone.traverse((node) => {
            if (node.isMesh) {
              node.material = node.material.clone(); // Clone material to avoid affecting other instances
              node.material.map = texture;
              node.material.needsUpdate = true;
              
              // Enable shadows
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
        }
        
        // Add to scene
        this.scene.add(terrainClone);
        this.terrain = terrainClone;
        
        console.log('Terrain model added to scene');
        
        // Add a circular highlight around the player's position
        this.createPlayerHighlight();
      } else {
        console.warn('Terrain model not found in AssetLoader, using fallback grid');
        
        // Create a grid as fallback
        const grid = new THREE.GridHelper(100, 100, 0x0000ff, 0x000044);
        grid.position.y = 0;
        this.scene.add(grid);
        this.terrain = grid;
        
        // Add player highlight anyway
        this.createPlayerHighlight();
      }
    });
  }

  // Separate method for player highlight to avoid code duplication
  createPlayerHighlight() {
    // Add a circular highlight around the player's position
    const highlightGeometry = new THREE.CircleGeometry(5, 32);
    const highlightMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
    });
    
    this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    this.playerHighlight.rotation.x = -Math.PI / 2;
    this.playerHighlight.position.y = 0.02; // Slightly above the floor
    this.scene.add(this.playerHighlight);
  }
  
  createBoundaryMarkers() {
    const boundarySize = 25; // Should match constrainToBounds boundary
    const markerSize = 1;
    const markerHeight = 1;
    const numMarkers = 10; // Number of markers per side
    
    const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
    const markerMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0x600000,
      transparent: true,
      opacity: 0.7
    });
    
    const markers = new THREE.Group();
    
    // Create boundary markers along the perimeter
    for (let i = 0; i < numMarkers; i++) {
      const t = (i / (numMarkers - 1)) * 2 - 1; // -1 to 1
      const position = boundarySize * t;
      
      // North edge
      const northMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      northMarker.position.set(position, markerHeight / 2, -boundarySize);
      markers.add(northMarker);
      
      // South edge
      const southMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      southMarker.position.set(position, markerHeight / 2, boundarySize);
      markers.add(southMarker);
      
      // East edge
      const eastMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      eastMarker.position.set(boundarySize, markerHeight / 2, position);
      markers.add(eastMarker);
      
      // West edge
      const westMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      westMarker.position.set(-boundarySize, markerHeight / 2, position);
      markers.add(westMarker);
    }
    
    this.scene.add(markers);
  }
  
  createObstacles() {
    // Create obstacle arrays
    this.obstacles = [];
    
    console.log('🚧 Creating immersive landscape with pathways and scattered crystals');
    
    // Define model categories and paths, with a focus on variety and character
    const obstacleCategories = {
      // Small to medium rocks
      rocks: [
        'SP_Rock01.glb', 
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      // Expanded flora selection
      flora: [
        'Grass_01.glb',
        'Mushrooms.glb',
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SmalRoots_01.glb',
        'Tenticles_01.glb',
        'BigPlant_06.glb'
      ],
      // Expanded ground features for creating pathways
      groundFeatures: [
        'objects/SP_Ground02.glb',
        'objects/SP_Ground03.glb',
        'objects/SP_Ground04.glb',
        'objects/SP_Ground05.glb'
      ],
      // Crystal clusters for interest points
      crystals: [
        'objects/SP_Crystal01.glb',
        'objects/SP_Stone01.glb'
      ],
      // Mountains for landscape borders and key landmarks
      mountains: [
        'objects/SP_Mountain01.glb',
        'objects/SP_Mountain02.glb',
        'objects/SP_Mountain03.glb'
      ]
    };
    
    // Enhanced distribution for a more detailed landscape
    const distribution = {
      rocks: 8,
      flora: 10,
      groundFeatures: 18,  // Increased from 12 to 18
      crystals: 9,
      mountains: 12  // Increased from 4 to 12
    };
    
    // Define some pre-made templates for object groupings
    const templates = [
      // Rock garden template
      {
        position: new THREE.Vector3(25, 0, 15),
        rotation: Math.PI / 6,
        elements: [
          { category: 'rocks', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 2.0, rotation: 0 },
          { category: 'rocks', modelIndex: 2, offset: new THREE.Vector3(3, 0, 1), scale: 1.3, rotation: Math.PI/3 },
          { category: 'rocks', modelIndex: 1, offset: new THREE.Vector3(-2, 0, 2), scale: 1.5, rotation: Math.PI/5 },
          { category: 'flora', modelIndex: 1, offset: new THREE.Vector3(2, 0, 3), scale: 1.2, rotation: 0 }
        ]
      },
      // Flora cluster template
      {
        position: new THREE.Vector3(-20, 0, -18),
        rotation: Math.PI / 4,
        elements: [
          { category: 'flora', modelIndex: 4, offset: new THREE.Vector3(0, 0, 0), scale: 1.8, rotation: 0 },
          { category: 'flora', modelIndex: 0, offset: new THREE.Vector3(2, 0, 2), scale: 1.4, rotation: Math.PI/2 },
          { category: 'flora', modelIndex: 3, offset: new THREE.Vector3(-1.5, 0, 1), scale: 1.2, rotation: Math.PI/6 },
          { category: 'rocks', modelIndex: 3, offset: new THREE.Vector3(1, 0, -2), scale: 1.0, rotation: 0 }
        ]
      },
      // Crystal formation template
      {
        position: new THREE.Vector3(-15, 0, 30),
        rotation: -Math.PI / 3,
        elements: [
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 1.5, rotation: 0 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(1.5, 0, 1), scale: 1.0, rotation: Math.PI/2 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(-1, 0, 1.5), scale: 0.8, rotation: Math.PI/4 },
          { category: 'groundFeatures', modelIndex: 2, offset: new THREE.Vector3(0, -0.2, 0), scale: 1.8, rotation: 0 }
        ]
      }
    ];
    
    // Create main pathways (4 paths coming from center, like a cross)
    const pathways = [
      { direction: new THREE.Vector3(1, 0, 0), width: 5 },   // East
      { direction: new THREE.Vector3(-1, 0, 0), width: 5 },  // West
      { direction: new THREE.Vector3(0, 0, 1), width: 5 },   // North
      { direction: new THREE.Vector3(0, 0, -1), width: 5 }   // South
    ];
    
    // Add some curved pathways to make it more interesting
    pathways.push(
      { 
        direction: new THREE.Vector3(0.7, 0, 0.7), 
        width: 4,
        curve: 0.8 // Will curve around
      },
      { 
        direction: new THREE.Vector3(-0.7, 0, -0.7), 
        width: 4,
        curve: -0.5 // Will curve the other way
      }
    );
    
    // Create some crystal gardens (clusters of crystals)
    const crystalGardens = [
      { x: 30, z: 30, radius: 8, count: 4 },
      { x: -25, z: 20, radius: 6, count: 3 },
      { x: 15, z: -35, radius: 10, count: 5 }
    ];
    
    // Function to check if a position is near a pathway
    const isNearPathway = (x, z, pathWidth) => {
      for (const path of pathways) {
        // Create a vector from center to this position
        const posVector = new THREE.Vector3(x, 0, z);
        const length = posVector.length();
        
        // Normalize the vector to compare direction
        if (length > 0) posVector.divideScalar(length);
        
        // Check if this aligns with any pathway
        const dot = posVector.dot(path.direction);
        
        // If aligned with path direction and not too close to center
        if (dot > 0.7 && length > 15 && length < 40) {
          // Calculate perpendicular distance to path
          const perpFactor = Math.sqrt(1 - dot * dot) * length;
          if (perpFactor < (path.width || pathWidth)) {
            return true;
          }
          
          // For curved paths
          if (path.curve) {
            // Check if in a curved region
            if (length > 20) {
              // Apply curvature - this is simplified but creates a nice effect
              const curveFactor = (length - 20) * path.curve * 0.1;
              const curvePerp = Math.abs(perpFactor - curveFactor);
              if (curvePerp < (path.width || pathWidth)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    
    // Function to check if position is in a crystal garden
    const isInCrystalGarden = (x, z) => {
      for (const garden of crystalGardens) {
        const dx = x - garden.x;
        const dz = z - garden.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance < garden.radius) {
          return garden;
        }
      }
      return null;
    };
    
    // Load and place models as obstacles
    for (const [category, models] of Object.entries(obstacleCategories)) {
      const count = distribution[category];
      
      for (let i = 0; i < count; i++) {
        // Select a random model from this category
        const modelPath = models[Math.floor(Math.random() * models.length)];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Create position based on category
        let x, z;
        let attempts = 0;
        let isValid = false;
        let inGarden = null;
        
        while (!isValid && attempts < 30) {
          attempts++;
          
          if (category === 'groundFeatures') {
            // Ground features go along pathways or in open areas
            if (Math.random() < 0.7) {
              // 70% along pathways
              const angle = Math.random() * Math.PI * 2;
              const distance = 15 + Math.random() * 25; // Between 15-40 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
              
              // If not near a pathway, try again
              if (!isNearPathway(x, z, 6)) continue;
            } else {
              // 30% randomly placed
              x = (Math.random() * 80) - 40;
              z = (Math.random() * 80) - 40;
            }
          } else if (category === 'crystals') {
            // Try to place in crystal gardens
            if (Math.random() < 0.7) {
              // 70% in crystal gardens
              const garden = crystalGardens[Math.floor(Math.random() * crystalGardens.length)];
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * garden.radius;
              x = garden.x + Math.cos(angle) * distance;
              z = garden.z + Math.sin(angle) * distance;
              inGarden = garden;
            } else {
              // 30% scattered elsewhere, avoiding pathways
              x = (Math.random() * 70) - 35;
              z = (Math.random() * 70) - 35;
              
              // If near a pathway, try again
              if (isNearPathway(x, z, 6)) continue;
            }
          } else if (category === 'mountains') {
            // Mountains go on the periphery with more diverse placement
            if (i < 4) {
              // Place 4 mountains at the far corners of the map
              const angle = (Math.PI/4) + (i * Math.PI/2); // Place at 45°, 135°, 225°, 315°
              const distance = 40 + Math.random() * 5; // Between 40-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else if (i < 8) {
              // Place 4 mountains at cardinal directions, but further out
              const angle = (i - 4) * Math.PI/2; // Place at 0°, 90°, 180°, 270°
              const distance = 42 + Math.random() * 8; // Between 42-50 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else {
              // Place remaining mountains randomly but still on periphery
              const angle = Math.random() * Math.PI * 2;
              const distance = 35 + Math.random() * 10; // Between 35-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            }
            
            // If near a pathway, try again (want mountains to border but not block paths)
            if (isNearPathway(x, z, 8)) continue;
          } else {
            // Rocks and flora go anywhere but not on paths
            x = (Math.random() * 80) - 40;
            z = (Math.random() * 80) - 40;
            
            // Avoid pathways for these obstacles
            if (isNearPathway(x, z, 5)) continue;
          }
          
          // Keep all objects away from center spawn
          if (Math.sqrt(x * x + z * z) < 15) continue;
          
          // Position is valid
          isValid = true;
        }
        
        if (!isValid) continue; // Skip if couldn't find valid position
        
        // Scale factors tailored by category and context
        let scale;
        if (category === 'rocks') {
          scale = 1.5 + Math.random() * 1.0; // Larger rocks (1.5-2.5)
        } else if (category === 'flora') {
          scale = 1.2 + Math.random() * 0.8; // Taller flora (1.2-2.0)
        } else if (category === 'groundFeatures') {
          if (isNearPathway(x, z, 6)) {
            // Ground features along pathways have more consistent size
            scale = 1.2 + Math.random() * 0.6; // Medium-sized ground (1.2-1.8)
          } else {
            // Ground features away from pathways can vary more
            scale = 0.8 + Math.random() * 1.4; // Variable ground features (0.8-2.2)
          }
        } else if (category === 'crystals') {
          if (inGarden) {
            // Varied crystal sizes in gardens
            scale = 0.5 + Math.random() * 1.4; // Variety of sizes (0.5-1.9)
          } else {
            // Scattered crystals are smaller
            scale = 0.7 + Math.random() * 0.6; // Smaller scattered (0.7-1.3)
          }
        } else if (category === 'mountains') {
          // More diverse mountain scales based on position
          if (i < 4) {
            // Corner mountains are largest
            scale = 2.2 + Math.random() * 1.3; // Largest mountains (2.2-3.5)
          } else if (i < 8) {
            // Cardinal direction mountains are medium-large
            scale = 1.8 + Math.random() * 1.0; // Medium-large mountains (1.8-2.8)
          } else {
            // Random mountains have varied sizes
            scale = 1.4 + Math.random() * 1.6; // Variable mountains (1.4-3.0)
          }
        }
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale and position
            model.scale.set(scale, scale, scale);
            model.position.set(x, 0, z); // Will adjust y based on model size
            
            // Add randomized rotation, except for ground features on pathways
            if (category === 'groundFeatures' && isNearPathway(x, z, 6)) {
              // Align with nearest pathway for ground features
              const alignAngle = Math.atan2(z, x);
              model.rotation.y = alignAngle + (Math.random() * 0.5 - 0.25); // Slight variation
            } else {
              model.rotation.y = Math.random() * Math.PI * 2;
            }
            
            // Enable shadows with optimization
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Optimize materials while keeping visual quality
                if (node.material) {
                  // Add category-specific visual enhancements
                  if (category === 'crystals' && modelPath.includes('Crystal')) {
                    // Make crystals glow with random colors
                    const crystalColors = [
                      new THREE.Color(0x00ffff), // cyan
                      new THREE.Color(0xff00ff), // magenta
                      new THREE.Color(0x88bbff), // light blue
                      new THREE.Color(0xffaa00)  // orange
                    ];
                    
                    // Random crystal color
                    const crystalColor = crystalColors[Math.floor(Math.random() * crystalColors.length)];
                    node.material.emissive = crystalColor;
                    node.material.emissiveIntensity = 0.3 + Math.random() * 0.3; // 0.3-0.6
                  } else if (category === 'mountains') {
                    // Give mountains a slight purple/blue tint
                    node.material.color = new THREE.Color(0x9090b0);
                  } else if (category === 'groundFeatures') {
                    // Give ground features varied earthy tones
                    const groundColors = [
                      new THREE.Color(0x908070), // tan
                      new THREE.Color(0x807060), // brown
                      new THREE.Color(0x708060), // olive
                      new THREE.Color(0x606070)  // slate
                    ];
                    node.material.color = groundColors[Math.floor(Math.random() * groundColors.length)];
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // IMPROVED COLLISION DETECTION: Use oriented bounding box for more accurate collisions
            // First, compute an accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use the improved ground placement calculation
            const groundY = this.calculateGroundOffset(model, category, scale);
            model.position.y = groundY;
            
            // Generate compound collision shapes for more accurate collision detection
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, scale);
            
            // Create better collision data with compound shapes
            const obstacleData = {
              mesh: model,
              type: category,
              // Advanced collision data
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              // Keep bounding box for broad-phase checks
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * scale / 2),
                  model.position.y - (size.y * scale / 2),
                  model.position.z - (size.z * scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * scale / 2),
                  model.position.y + (size.y * scale / 2),
                  model.position.z + (size.z * scale / 2)
                ),
                size: size.clone().multiplyScalar(scale),
                rotation: model.rotation.y
              },
              // Also keep a simple radius for quick distance checks
              size: Math.max(size.x, size.z) * scale * 0.5,
              position: model.position.clone()
            };
            
            this.obstacles.push(obstacleData);
            
            // Log first few obstacles for debugging
            if (this.obstacles.length <= 3) {
              console.log(`Created ${category} obstacle from ${modelPath}: width=${size.x * scale}, height=${size.y * scale}, depth=${size.z * scale} at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
            }
          },
          undefined, // Progress callback
          (error) => {
            console.error(`Error loading obstacle model ${fullPath}:`, error);
          }
        );
      }
    }
    
    // Create a special centerpiece crystal formation
    this.createCenterpiece();
    
    // Create template-based object groupings for more cohesive landscape
    this.createTemplateGroupings(templates, obstacleCategories);
    
    console.log(`Started loading ${Object.values(distribution).reduce((a, b) => a + b, 0)} obstacles with pathways and crystal gardens`);
  }
  
  /**
   * Create template-based object groupings
   */
  createTemplateGroupings(templates, categoryModels) {
    console.log('Creating template-based object groupings');
    
    templates.forEach((template, templateIndex) => {
      const templatePosition = template.position;
      const templateRotation = template.rotation;
      
      // Process each element in the template
      template.elements.forEach(element => {
        const category = element.category;
        
        // Get the model list for this category
        const models = categoryModels[category];
        if (!models || models.length === 0) return;
        
        // Select model by index or randomly if index is out of bounds
        const modelIndex = element.modelIndex < models.length ? element.modelIndex : Math.floor(Math.random() * models.length);
        const modelPath = models[modelIndex];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Calculate final position with rotation applied to offset
        const offset = element.offset.clone();
        
        // Apply template rotation to the offset
        if (templateRotation) {
          // Create rotation matrix
          const rotMatrix = new THREE.Matrix4().makeRotationY(templateRotation);
          offset.applyMatrix4(rotMatrix);
        }
        
        // Final position combines template position and rotated offset
        const finalPosition = new THREE.Vector3(
          templatePosition.x + offset.x,
          templatePosition.y + offset.y,
          templatePosition.z + offset.z
        );
        
        // Final rotation combines template rotation and element rotation
        const finalRotation = templateRotation + element.rotation;
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale
            model.scale.set(element.scale, element.scale, element.scale);
            
            // Set initial position 
            model.position.copy(finalPosition);
            
            // Apply rotation
            model.rotation.y = finalRotation;
            
            // Enable shadows with appropriate material enhancements
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Apply category-specific visual effects
                if (node.material) {
                  if (category === 'crystals') {
                    // Crystal glow effect
                    node.material.emissive = new THREE.Color(0x88bbff);
                    node.material.emissiveIntensity = 0.3;
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // Compute accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use improved ground placement
            const groundY = this.calculateGroundOffset(model, category, element.scale);
            model.position.y = groundY + element.offset.y; // Apply any intentional Y offset
            
            // Generate compound collision shapes
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, element.scale);
            
            // Add to obstacles array with collision data
            this.obstacles.push({
              mesh: model,
              type: category,
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * element.scale / 2),
                  model.position.y - (size.y * element.scale / 2),
                  model.position.z - (size.z * element.scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * element.scale / 2),
                  model.position.y + (size.y * element.scale / 2),
                  model.position.z + (size.z * element.scale / 2)
                ),
                size: size.clone().multiplyScalar(element.scale),
                rotation: model.rotation.y
              },
              size: Math.max(size.x, size.z) * element.scale * 0.5,
              position: model.position.clone()
            });
            
            console.log(`Template ${templateIndex+1}: Added ${category} model at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
          },
          undefined,
          (error) => {
            console.error(`Error loading template model ${fullPath}:`, error);
          }
        );
      });
    });
  }
  
  setupControls() {
    // Store active keys for visual feedback
    this.activeKeys = new Set();
    
    // Add visual indicators for controls
    this.createControlIndicators();
    
    // Detect if we're on a touch device
    this.isTouchDevice = 'ontouchstart' in window;
    
    // Keyboard controls
    document.addEventListener('keydown', this.boundHandleKeyDown);
    document.addEventListener('keyup', this.boundHandleKeyUp);
    
    // Mouse controls - attach to the canvas for better precision
    const canvas = this.renderer.domElement;
    canvas.addEventListener('click', this.boundHandleClick);
    canvas.addEventListener('mousemove', this.boundHandleMouseMove);
    
    // Setup touch controls for mobile devices
    if (this.isTouchDevice) {
      this.setupTouchControls();
    }
  }
  
  createControlIndicators() {
    console.log('Creating control indicators');
    // Create container if it doesn't exist
    if (!this.controlsContainer) {
        this.controlsContainer = document.createElement('div');
        this.controlsContainer.id = 'controls';
        this.controlsContainer.className = 'control-indicators';
        document.body.appendChild(this.controlsContainer);
        console.log('Control container created');
    }

    // Clear existing indicators
    this.controlsContainer.innerHTML = '';
    
    // Create the movement controls grid
    const movementControls = document.createElement('div');
    movementControls.className = 'movement-controls control-group';
    
    // Create the weapon controls section
    const weaponControls = document.createElement('div');
    weaponControls.className = 'weapon-controls control-group';
    
    // Define the key indicators for movement
    const movementKeys = [
        { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward', gridArea: 'forward' },
        { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward', gridArea: 'backward' },
        { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left', gridArea: 'left' },
        { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right', gridArea: 'right' },
        { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left', gridArea: 'strafeLeft' },
        { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right', gridArea: 'strafeRight' },
        { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon', gridArea: 'fire' }
    ];
    
    // Define the key indicators for weapons
    const weaponKeys = [
        { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser', className: 'weapon-key' },
        { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade', className: 'weapon-key' },
        { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser', className: 'weapon-key' },
        { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon', className: 'weapon-key' }
    ];
    
    // Create movement indicators
    movementKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        movementControls.appendChild(indicator);
    });
    
    // Create weapon indicators
    weaponKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        weaponControls.appendChild(indicator);
    });
    
    // Add a controls hint
    const hint = document.createElement('div');
    hint.className = 'controls-hint';
    hint.textContent = 'Press C to toggle controls visibility';
    
    // Add all elements to controls container
    this.controlsContainer.appendChild(movementControls);
    this.controlsContainer.appendChild(weaponControls);
    this.controlsContainer.appendChild(hint);
    
    console.log('Control indicators created with updated structure');
  }
  
  updateControlIndicators() {
    // Skip if control indicators aren't created yet
    if (!this.controlsContainer) return;
    
    // Update movement keys
    this.updateIndicatorState('forward', this.keys.forward);
    this.updateIndicatorState('backward', this.keys.backward);
    this.updateIndicatorState('left', this.keys.left);
    this.updateIndicatorState('right', this.keys.right);
    this.updateIndicatorState('strafeLeft', this.keys.strafeLeft);
    this.updateIndicatorState('strafeRight', this.keys.strafeRight);
    
    // Update fire state
    this.updateIndicatorState('fire', this.keys.fire);
    
    // Update weapon selection
    this.updateIndicatorState('selectLaser', this.currentWeapon === 'LASER');
    this.updateIndicatorState('selectGrenade', this.currentWeapon === 'GRENADE');
    this.updateIndicatorState('selectBounce', this.currentWeapon === 'BOUNCE');
  }
  
  updateIndicatorState(id, isActive) {
    const indicator = this.controlsContainer?.querySelector(`#indicator-${id}`);
    if (indicator) {
      if (isActive) {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }
  }
  
  handleResize(event) {
    // Debounce resize events
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    
    this.resizeTimer = setTimeout(() => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.resizeTimer = null;
    }, 100);
  }
  
  handleKeyDown(event) {
    // Handle escape key for in-game menu
    if (event.code === 'Escape') {
        this.showInGameMenu();
        return;
    }
    
    // Handle 'C' key to toggle controls visibility
    if (event.code === 'KeyC') {
        console.log('C key pressed - toggling controls');
        this.toggleControls();
        return;
    }
    
    // Handle 'M' key to toggle mini-map
    if (event.code === 'KeyM') {
        this.toggleMiniMap();
        return;
    }

    // Get control action from key mapping
    const action = ControlUtils.getActionForKey(event.code);
    
    // Skip if key isn't mapped or event is repeated
    if (!action || event.repeat) return;
    
    // Handle weapon selection
    if (action.category === 'WEAPONS') {
        if (action.action === 'SWITCH_WEAPON') {
            this.cycleWeapon();
            return;
        } else if (action.action === 'SELECT_LASER') {
            this.selectWeapon('LASER');
            return;
        } else if (action.action === 'SELECT_GRENADE') {
            this.selectWeapon('GRENADE');
            return;
        } else if (action.action === 'SELECT_BOUNCE') {
            this.selectWeapon('BOUNCE');
            return;
        }
    }
    
    // Handle UI controls
    if (action.category === 'UI') {
        if (action.action === 'TOGGLE_MAP') {
            this.toggleMiniMap();
            return;
        } else if (action.action === 'TOGGLE_CONTROLS') {
            this.toggleControls();
            return;
        }
    }
    
    // Set key state to active
    if (action.category === 'MOVEMENT') {
        this.keys[action.action.toLowerCase()] = true;
    }
    
    // Store active key for visual feedback
    this.activeKeys.add(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
    
    // Prevent default browser behavior for game controls
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'Tab', 'KeyM'].includes(event.code)) {
        event.preventDefault();
    }
}
  
  handleKeyUp(event) {
    const action = ControlUtils.getActionForKey(event.code);
    if (!action) return;
    
    // Skip weapon selection keys on keyup
    if (action.category === 'WEAPONS' && action.action.startsWith('SELECT_')) {
      return;
    }
    
    // Set key state to inactive
    if (action.category === 'MOVEMENT') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'WEAPONS') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'UI') {
      this.keys[action.action.toLowerCase()] = false;
    }
    
    // Remove from active keys
    this.activeKeys.delete(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
  }
  
  handleClick(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault) {
        event.preventDefault();
    }
    
    // Prevent rapid-fire clicking
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
        return;
    }
    
    // Get click coordinates relative to canvas
    const rect = this.renderer.domElement.getBoundingClientRect();
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid click coordinates');
        return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Convert to normalized device coordinates
    const mouse = new THREE.Vector2(
        (x / this.renderer.domElement.clientWidth) * 2 - 1,
        -(y / this.renderer.domElement.clientHeight) * 2 + 1
    );
    
    // Handle weapon-specific targeting
    if (this.currentWeapon === 'GRENADE') {
        this.handleGrenadeTargeting({ 
            clientX, 
            clientY,
            preventDefault: () => {} // Add dummy preventDefault for consistency
        });
    } else {
        this.handleDirectionalFiring({ clientX, clientY });
    }
  }
  
  handleMouseMove(event) {
    // Skip if we're moving too frequently (throttle)
    if (this.mouseMoveTimer) {
        return;
    }
    
    // Use requestAnimationFrame for smoother updates
    this.mouseMoveTimer = requestAnimationFrame(() => {
        // Get mouse coordinates relative to canvas
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update targeting indicators for any weapon type
        this.updateTargetingIndicator({
            clientX: event.clientX,
            clientY: event.clientY
        });
        
        // Additional targeting for grenade if that's the current weapon
        if (this.currentWeapon === 'GRENADE') {
            this.updateGrenadeTargetingIndicator({
                clientX: event.clientX,
                clientY: event.clientY
            });
        }
        
        this.mouseMoveTimer = null;
    });
}
  
  handleFireAction() {
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
      return;
    }
    
    // Set cooldown based on weapon type
    const cooldownTime = this.currentWeapon === 'GRENADE' ? 1000 :
                        this.currentWeapon === 'BOUNCE' ? 500 :
                        200;
    
    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);
    this.fireCurrentWeapon();
  }
  
  setupTouchControls() {
    // Create touch control container
    const touchControls = document.createElement('div');
    touchControls.className = 'touch-controls';
    document.body.appendChild(touchControls);
    
    // Create virtual joystick for movement
    const joystickContainer = document.createElement('div');
    joystickContainer.className = 'joystick-container';
    touchControls.appendChild(joystickContainer);
    
    const joystick = document.createElement('div');
    joystick.className = 'joystick';
    joystickContainer.appendChild(joystick);
    
    const joystickKnob = document.createElement('div');
    joystickKnob.className = 'joystick-knob';
    joystick.appendChild(joystickKnob);
    
    // Create fire button
    const fireButton = document.createElement('div');
    fireButton.className = 'touch-button fire-button';
    fireButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.ACTIONS.find(a => a.id === 'fire').label;
    touchControls.appendChild(fireButton);
    
    // Create weapon switch button
    const weaponButton = document.createElement('div');
    weaponButton.className = 'touch-button weapon-button';
    weaponButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.WEAPONS.find(w => w.id === 'switchWeapon').label;
    touchControls.appendChild(weaponButton);
    
    // Joystick handling
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickOrigin.x = rect.left + rect.width / 2;
      joystickOrigin.y = rect.top + rect.height / 2;
      handleJoystickMove(touch);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (joystickActive) {
        const touch = e.touches[0];
        handleJoystickMove(touch);
        e.preventDefault();
      }
    });
    
    document.addEventListener('touchend', (e) => {
      if (joystickActive) {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Reset movement keys using DEFAULT_CONTROL_STATE
        Object.keys(DEFAULT_CONTROL_STATE).forEach(key => {
          if (key.startsWith('forward') || key.startsWith('backward') || 
              key.startsWith('left') || key.startsWith('right') || 
              key.startsWith('strafe')) {
            this.keys[key] = DEFAULT_CONTROL_STATE[key];
          }
        });
        
        this.updateControlIndicators();
      }
    });
    
    const handleJoystickMove = (touch) => {
      const maxDistance = CONTROL_SETTINGS.TOUCH.JOYSTICK_MAX_DISTANCE;
      const deadZone = CONTROL_SETTINGS.TOUCH.JOYSTICK_DEAD_ZONE;
      
      // Calculate distance from center
      const dx = touch.clientX - joystickOrigin.x;
      const dy = touch.clientY - joystickOrigin.y;
      
      // Limit distance to maxDistance
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
      const angle = Math.atan2(dy, dx);
      
      // Move joystick knob
      const knobX = distance * Math.cos(angle);
      const knobY = distance * Math.sin(angle);
      joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
      
      // Convert joystick position to key presses using deadzone
      this.keys.forward = dy < -deadZone;
      this.keys.backward = dy > deadZone;
      this.keys.left = dx < -deadZone;
      this.keys.right = dx > deadZone;
      
      this.updateControlIndicators();
    };
    
    // Fire button handling with weapon cooldown
    let lastFireTime = 0;
    fireButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      const cooldown = CONTROL_SETTINGS.WEAPON_COOLDOWNS[this.currentWeapon];
      
      if (now - lastFireTime >= cooldown) {
        this.keys.fire = true;
        this.fireCurrentWeapon();
        lastFireTime = now;
      }
      
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    fireButton.addEventListener('touchend', (e) => {
      this.keys.fire = false;
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    // Weapon switch button handling with cooldown
    let lastWeaponSwitchTime = 0;
    weaponButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastWeaponSwitchTime >= 200) { // 200ms cooldown for weapon switching
        this.cycleWeapon();
        lastWeaponSwitchTime = now;
      }
      e.preventDefault();
    });
    
    // Enable directional fire on game area tap
    const gameArea = document.querySelector('canvas');
    if (gameArea) {
      let lastTapTime = 0;
      
      gameArea.addEventListener('touchstart', (e) => {
        // Ignore if touch is in control areas
        const touch = e.touches[0];
        const isInControlArea = 
          touchControls.contains(document.elementFromPoint(touch.clientX, touch.clientY));
          
        if (!isInControlArea && this.playerShip) {
          const now = Date.now();
          const doubleTapDelay = CONTROL_SETTINGS.TOUCH.DOUBLE_TAP_DELAY;
          
          // Check for double tap
          if (now - lastTapTime < doubleTapDelay) {
            // Handle double tap action (e.g., special weapon)
            this.cycleWeapon();
          } else {
            // Handle single tap (directional firing)
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // Handle directional firing similarly to mouse
            const touchPoint = new THREE.Vector2(
              (touchX / window.innerWidth) * 2 - 1,
              -(touchY / window.innerHeight) * 2 + 1
            );
            
            // Use raycasting to determine the point in 3D space
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touchPoint, this.camera);
            
            // Check for intersection with the floor
            const intersects = raycaster.intersectObject(this.floor);
            
            if (intersects.length > 0) {
              const targetPoint = intersects[0].point;
              
              // Calculate the direction from the player to the target point
              const shipPosition = this.playerShip.position.clone();
              const direction = targetPoint.clone().sub(shipPosition).normalize();
              
              // Only care about horizontal direction (ignore y component)
              direction.y = 0;
              direction.normalize();
              
              // Store the original rotation
              const originalRotation = this.playerShip.rotation.clone();
              
              // Temporarily rotate the ship to face the target
              this.playerShip.lookAt(shipPosition.clone().add(direction));
              
              // Fire the weapon in that direction
              if (this.currentWeapon === 'GRENADE') {
                // For grenades, we simulate a tap at the target location
                const targetEvent = {
                  clientX: touchX,
                  clientY: touchY,
                  preventDefault: () => {}
                };
                this.handleGrenadeTargeting(targetEvent);
              } else {
                // For lasers and bounce, fire in the direction
                this.fireCurrentWeapon(direction);
              }
              
              // Restore the original rotation
              this.playerShip.rotation.copy(originalRotation);
            }
          }
          
          lastTapTime = now;
          e.preventDefault();
        }
      });
    }
  }
  
  toggleControls() {
    // Clear any existing timeout
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
    
    // Also clear any auto-fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (!this.controlsContainer) {
      this.createControlIndicators();
    }
    
    if (this.controlsContainer.classList.contains('visible')) {
      this.fadeOutControls();
    } else {
      this.fadeInControls();
    }
  }
  
  fadeInControls() {
    console.log('Fading in controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // Remove any classes that might hide the controls
        this.controlsContainer.classList.remove('hidden', 'fading');
        // Add the visible class
        this.controlsContainer.classList.add('visible');
        console.log('Controls should now be visible with class: visible');
        
        // Set a timeout to automatically fade out the controls after 5 seconds
        // (but only if we're in the game and not in a menu)
        if (this.isRunning) {
            this.controlsFadeTimeout = setTimeout(() => {
              console.log('Auto-hiding controls after timeout');
              this.fadeOutControls();
            }, 5000);
        }
    } else {
        console.warn('Control container not found during fade in');
        // Try to create controls if they don't exist
        this.createControlIndicators();
        // And then try to show them
        if (this.controlsContainer) {
            this.controlsContainer.classList.add('visible');
            
            // Also set the auto-fade timeout for the newly created controls
            // (but only if we're in the game and not in a menu)
            if (this.isRunning) {
                this.controlsFadeTimeout = setTimeout(() => {
                  console.log('Auto-hiding newly created controls after timeout');
                  this.fadeOutControls();
                }, 5000);
            }
        }
    }
  }
  
  fadeOutControls() {
    console.log('Fading out controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // First add the fading class for the transition
        this.controlsContainer.classList.add('fading');
        this.controlsContainer.classList.remove('visible');
        
        // After the transition completes, add the hidden class
        setTimeout(() => {
            if (this.controlsContainer) {
                this.controlsContainer.classList.add('hidden');
            }
        }, 500); // Match the transition time from CSS
    } else {
        console.warn('Control container not found during fade out');
    }
  }
  
  updateWeaponUI() {
    // Update UI to reflect weapon change
    if (this.ui) {
        this.ui.updateWeapon(this.currentWeapon);
        
        // Update targeting indicator color if it exists
        if (this.targetingIndicator) {
            const colors = {
                'LASER': new THREE.Color(0x00ffff),
                'GRENADE': new THREE.Color(0xff4500),
                'BOUNCE': new THREE.Color(0x00ff99)
            };
            const color = colors[this.currentWeapon] || colors['LASER'];
            
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
        }
    }
    
    // Log weapon change
    console.log('Weapon updated:', this.currentWeapon);
}

selectWeapon(weaponType) {
    console.log('Selecting specific weapon:', weaponType);
    const index = this.availableWeapons.indexOf(weaponType);
    if (index !== -1) {
        this.weaponIndex = index;
        this.currentWeapon = weaponType;
        console.log('Weapon selection successful');
        
        // Update UI to reflect weapon change
        this.updateWeaponUI();
        
        // Play weapon switch sound if available
        this.playSound('weapon-switch');
    } else {
        console.warn('Attempted to select unavailable weapon:', weaponType);
    }
}
  
  cycleWeapon() {
    console.log('Cycling weapon from:', this.currentWeapon);
    this.weaponIndex = (this.weaponIndex + 1) % this.availableWeapons.length;
    this.currentWeapon = this.availableWeapons[this.weaponIndex];
    console.log('New weapon selected:', this.currentWeapon);
    
    // Update UI to reflect weapon change
    this.updateWeaponUI();
    
    // Play weapon switch sound
    this.playSound('weapon-switch');
}
  
  fireGrenade() {
    console.log("Grenade weapon selected - click to target");
  }
  
  animate() {
    // Call animationFrame with this instance as context
    requestAnimationFrame(this.animate.bind(this));
    
    try {
      // Calculate delta time
      const now = performance.now();
      const deltaTime = (now - this.lastTime) / 1000; // in seconds
      this.lastTime = now;
      
      // Update frame counter
      this.frameCount++;
      
      // Limit update rate
      if (this.frameCount % 2 === 0) { // Reduce update frequency
        // Only update gameplay if the player ship exists
        if (this.playerShip) {
          // Update player
          if (typeof this.updatePlayer === 'function') {
            this.updatePlayer(deltaTime);
          }
          
          // Update other elements - only if they exist
          if (typeof this.updateLasers === 'function') {
            this.updateLasers();
          }
          
          if (typeof this.updateEnergy === 'function') {
            this.updateEnergy(deltaTime);
          }
          
          if (typeof this.updateCamera === 'function') {
            this.updateCamera();
          }
          
          // Update collision detection
          if (typeof this.checkObstacleCollisions === 'function') {
            this.checkObstacleCollisions();
          }
          
          // Update thruster effects
          if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
          }
          
          // Check if boost is active and update energy consumption
          if (this.keys && this.keys.boost && this.energy > 0) {
            this.energy = Math.max(0, this.energy - 30 * deltaTime); // Boost drains energy
            if (this.ui) {
              this.ui.updateEnergy(this.energy, this.maxEnergy);
            }
          }
        }
        
        // Update bounceLasers if they exist
        if (this.bouncingLasers && this.bouncingLasers.length > 0 && 
            typeof this.updateBouncingLasers === 'function') {
          this.updateBouncingLasers();
        }
        
        // Update grenades if they exist
        if (this.grenades && this.grenades.length > 0 && 
            typeof this.updateGrenades === 'function') {
          this.updateGrenades();
        }
        
        // Update multiplayer
        if (this.multiplayerEnabled && this.networkManager) {
          // Send our position and rotation to server
          if (this.playerShip) {
            this.networkManager.sendPlayerUpdate({
              position: {
                x: this.playerShip.position.x,
                y: this.playerShip.position.y,
                z: this.playerShip.position.z
              },
              rotation: this.playerShip.rotation.y,
              name: this.playerName,
              shipType: this.currentShipType || 'default'
            });
          }
          
          // Update other players
          if (typeof this.updateOtherPlayers === 'function') {
            this.updateOtherPlayers();
          }
        }
      }
      
      // Render the scene
      if (this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        
        // Render CSS2D elements if renderer exists
        if (this.labelRenderer) {
          this.labelRenderer.render(this.scene, this.camera);
        }
      }
    } catch (error) {
      console.error("Error in animate loop:", error);
      // Don't rethrow, we want to keep the animation loop running
    }
  }
  
  updatePlayer(deltaTime) {
    if (!this.playerShip) return;
    
    // Save original position in case we need to revert due to collision
    const originalPosition = this.playerShip.position.clone();
    
    // ORIGINAL SHIP MOVEMENT PHYSICS
    const moveSpeed = 10; // Base movement speed
    const rotateSpeed = 2.5; // Base rotation speed
    
    let moved = false; // Track if the ship moved
    
    // Handle forward/backward movement
    if (this.keys.forward) {
        // Move forward
        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(forwardDir, moveSpeed * deltaTime);
        moved = true;
    }
    else if (this.keys.backward) {
        // Move backward
        const backwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(backwardDir, moveSpeed * deltaTime);
        moved = true;
    }

    // Handle left/right rotation
    if (this.keys.left) {
        // Rotate left
        this.playerShip.rotation.y += rotateSpeed * deltaTime;
        moved = true;
    }
    else if (this.keys.right) {
        // Rotate right
        this.playerShip.rotation.y -= rotateSpeed * deltaTime;
        moved = true;
    }
    
    // Update player highlight to follow the player ship
    if (this.playerHighlight) {
        this.playerHighlight.position.x = this.playerShip.position.x;
        this.playerHighlight.position.z = this.playerShip.position.z;
        
        // Add a subtle pulsing effect to the highlight
        const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
        this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
    }
    
    // Check for collisions after movement
    if (moved) {
        this.checkObstacleCollisions();
        
        // If no collisions, update thruster effects
        if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
        }
        
        // Send position update to server if multiplayer is enabled
        if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
            this.sendPlayerPositionUpdate();
        }
    }
  }
  
  updateLasers() {
    if (!this.lasers) return;
    
    for (let i = this.lasers.length - 1; i >= 0; i--) {
      const laser = this.lasers[i];
      
      // Move laser
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update trail effect
      laser.trailPoints.push(laser.mesh.position.clone());
      if (laser.trailPoints.length > 8) { // Reduced trail length for better performance
        laser.trailPoints.shift();
      }
      
      // Update trail geometry
      const positions = new Float32Array(laser.trailPoints.length * 3);
      for (let j = 0; j < laser.trailPoints.length; j++) {
        positions[j * 3] = laser.trailPoints[j].x;
        positions[j * 3 + 1] = laser.trailPoints[j].y;
        positions[j * 3 + 2] = laser.trailPoints[j].z;
      }
      laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Pulse effect
      laser.pulsePhase += 0.3;
      const pulse = Math.sin(laser.pulsePhase) * 0.2 + 0.8;
      laser.mesh.material.opacity = pulse;
      const light = laser.mesh.children[0];
      if (light) {
        light.intensity = pulse * 2;
      }
      
      // Increment lifetime
      laser.lifeTime++;
      
      // Remove old lasers
      if (laser.lifeTime > laser.maxLifeTime) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.lasers.splice(i, 1);
        continue;
      }
      
      // Check for collisions with obstacles
      for (let j = 0; j < this.obstacles.length; j++) {
        const obstacle = this.obstacles[j];
        
        // Simple distance check
        if (laser.mesh.position.distanceTo(obstacle.position) < 1.5) {
          // Create enhanced hit effect
          this.createEnhancedHitEffect(laser.mesh.position.clone(), laser.direction.clone());
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  createEnhancedHitEffect(position, direction) {
    // Create a burst of particles
    const particleCount = 15;
    const particles = [];
    
    // Create particle material
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity based on impact direction
      const spread = Math.PI / 2; // 90 degree spread
      const angle = Math.random() * spread - spread/2;
      const speed = 0.2 + Math.random() * 0.3;
      
      // Calculate velocity
      const velocity = direction.clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle)
        .multiplyScalar(speed);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0; // Full life
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.3, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(position.clone().add(direction));
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }
  
  checkObstacleCollisions() {
    if (!this.playerShip || !this.infiniteMap) {
      console.log('Skipping collision check - player ship or infinite map not available');
      return;
    }
    
    // Get player collision info
    const playerRadius = this.playerShip.userData.collisionRadius || 0.35;
    const playerPos = this.playerShip.position.clone();
    
    // Create player sphere for collision checks
    const playerSphere = {
      center: playerPos,
      radius: playerRadius
    };
    
    // Check collisions with infinite map objects first
    const mapCollision = this.infiniteMap.checkCollisions(playerPos, playerRadius);
    
    if (mapCollision.collided) {
      // Handle collision from infinite map
      this.handleObjectCollision(playerPos, mapCollision.object.position, mapCollision.object.type || 'terrain');
      return; // Stop checking after handling one collision
    }
    
    // Check local obstacles with more accurate collision detection
    for (const obstacle of this.obstacles) {
      if (!obstacle.mesh) continue;
      
      // First, do a quick broad-phase check with spheres for efficiency
      const obstaclePos = obstacle.position.clone();
      const distance = playerPos.distanceTo(obstaclePos);
      const quickCheckDistance = playerRadius + obstacle.size;
      
      // Skip detailed check if clearly not colliding
      if (distance > quickCheckDistance * 1.5) continue;
      
      // Determine if collision happened based on shape type
      let collision = false;
      
      if (obstacle.collisionShape === 'compound' && obstacle.compoundShapes) {
        // Use compound shape collision detection for complex objects
        collision = this.checkCompoundCollision(playerSphere, obstacle.compoundShapes);
      } else if (obstacle.collisionShape === 'complex' && obstacle.boundingBox) {
        // Fall back to oriented bounding box if compound shapes not available
        collision = this.checkBoxCollision(
          playerPos, playerRadius,
          obstacle.boundingBox, 
          obstacle.boundingBox.rotation
        );
      } else {
        // Simplest case: sphere-based collision for backward compatibility
        collision = distance < quickCheckDistance;
      }
      
      if (collision) {
        // Handle the collision
        this.handleObjectCollision(playerPos, obstaclePos, obstacle.type);
        break; // Only handle one collision at a time
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (compound shapes)
   */
  checkCompoundCollision(playerSphere, compoundShapes) {
    // Check collision against each shape in the compound
    for (const shape of compoundShapes) {
      let collision = false;
      
      if (shape.type === 'box') {
        // Box vs sphere collision
        collision = this.checkBoxSphereCollision(
          shape.center,
          shape.halfExtents,
          shape.worldRotation || 0,
          playerSphere
        );
      } else if (shape.type === 'sphere') {
        // Sphere vs sphere collision (simpler case)
        const distance = playerSphere.center.distanceTo(shape.center);
        collision = distance < (playerSphere.radius + shape.radius);
      }
      
      if (collision) {
        return true; // Collision with any part means collision with the compound
      }
    }
    
    return false; // No collision with any part
  }
  
  /**
   * Check collision between a rotated box and a sphere
   */
  checkBoxSphereCollision(boxCenter, boxHalfExtents, boxRotation, sphere) {
    // Transform sphere center to box space (accounting for rotation)
    const toSphere = new THREE.Vector3().subVectors(sphere.center, boxCenter);
    
    // Apply inverse rotation to get into box space
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(-boxRotation);
      toSphere.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on box to sphere in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-boxHalfExtents.x, Math.min(boxHalfExtents.x, toSphere.x)),
      Math.max(-boxHalfExtents.y, Math.min(boxHalfExtents.y, toSphere.y)),
      Math.max(-boxHalfExtents.z, Math.min(boxHalfExtents.z, toSphere.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(boxRotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to sphere center (for efficiency)
    const squaredDistance = sphere.center.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than sphere radius squared
    return squaredDistance < (sphere.radius * sphere.radius);
  }

  /**
   * Handle collision with any object
   */
  handleObjectCollision(playerPos, objectPos, objectType) {
    console.log(`COLLISION DETECTED with ${objectType}: Pushing ship back`);
    
    // Push player away from obstacle
    const pushDir = new THREE.Vector3()
      .subVectors(playerPos, objectPos)
      .normalize();
      
    // Adjust push force based on object type
    let pushForce = 0.7; // Default push force
    let damageAmount = 5; // Default damage
    
    // Customize collision response based on type
    switch(objectType) {
      case 'rocks':
        pushForce = 0.85; // Rocks push strongly
        damageAmount = 8;
        break;
      case 'specialObjects':
      case 'groundFeatures':
        pushForce = 0.75; // Ground features push medium
        damageAmount = 6;
        break;
      case 'mountains':
        pushForce = 1.0; // Mountains push very strongly
        damageAmount = 10;
        break;
      case 'crystals':
        pushForce = 0.7; // Crystals push medium but with special effect
        damageAmount = 7;
        
        // Add special crystal collision effect
        this.createCrystalCollisionEffect(objectPos);
        break;
      case 'centerpiece':
        pushForce = 0.9; // Centerpiece pushes strongly
        damageAmount = 9;
        
        // Add special centerpiece collision effect
        this.createCrystalCollisionEffect(objectPos, true);
        break;
      case 'flora':
        pushForce = 0.6; // Flora pushes gently
        damageAmount = 3;
        break;
      default:
        // Use default values
        break;
    }
    
    // Apply the push force
    this.playerShip.position.addScaledVector(pushDir, pushForce);
    
    // Flash collision warning
    this.flashCollisionWarning();
    
    // Apply damage if the function exists
    if (typeof this.applyDamage === 'function') {
      this.applyDamage(damageAmount);
    }
    
    // Play appropriate collision sound based on object type
    let soundToPlay = 'collision';
    
    if (objectType === 'specialObjects') {
      // Crystal-like sounds for special objects
      soundToPlay = 'crystalHit';
    } else if (objectType === 'mountains') {
      // Heavy impact for mountains
      soundToPlay = 'heavyImpact';
    }
    
    // Play the sound if it exists, otherwise fall back to default collision
    if (this.playSound) {
      try {
        this.playSound(soundToPlay);
      } catch (e) {
        // Fall back to default if sound doesn't exist
        try {
          this.playSound('collision');
        } catch (e2) {
          // No sound available
        }
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (oriented box)
   */
  checkBoxCollision(playerPos, playerRadius, box, rotation) {
    // Get box center
    const boxCenter = new THREE.Vector3(
      (box.min.x + box.max.x) / 2,
      (box.min.y + box.max.y) / 2,
      (box.min.z + box.max.z) / 2
    );
    
    // Calculate half extents of box
    const halfExtents = new THREE.Vector3(
      (box.max.x - box.min.x) / 2,
      (box.max.y - box.min.y) / 2,
      (box.max.z - box.min.z) / 2
    );
    
    // Vector from box center to player
    const toPlayer = new THREE.Vector3().subVectors(playerPos, boxCenter);
    
    // If we have rotation, apply inverse rotation to convert to box space
    if (rotation) {
      // Create rotation matrix for the box (negative rotation to invert)
      const rotMatrix = new THREE.Matrix4().makeRotationY(-rotation);
      toPlayer.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on the box to the player in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-halfExtents.x, Math.min(halfExtents.x, toPlayer.x)),
      Math.max(-halfExtents.y, Math.min(halfExtents.y, toPlayer.y)),
      Math.max(-halfExtents.z, Math.min(halfExtents.z, toPlayer.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (rotation) {
      // Create rotation matrix for the box
      const rotMatrix = new THREE.Matrix4().makeRotationY(rotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to player center
    const squaredDistance = playerPos.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than player radius squared
    return squaredDistance < (playerRadius * playerRadius);
  }
  
  updateCamera() {
    // Check if cameraTargetPosition is initialized
    if (!this.cameraTargetPosition) {
      this.cameraTargetPosition = new THREE.Vector3();
      this.cameraTargetLookAt = new THREE.Vector3();
      this.cameraSmoothingFactor = 0.05;
    }
    
    // If playerShip doesn't exist, early return
    if (!this.playerShip) return;
    
    // Define the camera offset from the player
    const offsetY = 18; // Height above the player
    const offsetZ = -16; // Distance behind the player (adjusted for larger ship)
    
    // Get the player's forward direction vector (simplified)
    const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
    
    // Calculate camera target position (directly above and slightly behind player)
    this.cameraTargetPosition.copy(this.playerShip.position);
    this.cameraTargetPosition.y += offsetY;
    
    // Move camera back based on player's orientation
    const backOffset = forwardDir.clone().multiplyScalar(offsetZ);
    this.cameraTargetPosition.add(backOffset);
    
    // Smoothly move camera toward target position
    this.camera.position.lerp(this.cameraTargetPosition, this.cameraSmoothingFactor);
    
    // Make camera look at the player
    this.cameraTargetLookAt.copy(this.playerShip.position);
    this.camera.lookAt(this.cameraTargetLookAt);
  }
  
  updateThrusterEffects() {
    // Skip if ship model isn't loaded
    if (!this.shipModel || !this.thruster || !this.thrusterLight) return;
    
    // Use stored references instead of finding children each time
    const { thruster, thrusterLight } = this;
    
    // Base thruster scale and opacity on movement
    const isMovingForward = this.keys.forward;
    const isMovingBackward = this.keys.backward;
    
    // Update thruster pulse for ambient animation
    this.thrusterPulse.value = (this.thrusterPulse.value + 0.1) % (Math.PI * 2);
    const pulseEffect = Math.sin(this.thrusterPulse.value) * 0.1;
    
    if (isMovingForward) {
      // Full thruster when moving forward
      const randomScale = 1 + Math.random() * 0.2 + pulseEffect;
      thruster.scale.set(1, 1, randomScale);
      thruster.material.opacity = 0.7 + Math.random() * 0.3;
      thrusterLight.intensity = 1.2 + Math.random() * 0.3 + pulseEffect;
      
      // Add color variation for a more dynamic effect
      const hue = (Date.now() % 1000) / 1000; // Cycle through colors over time
      thruster.material.color.setHSL(hue, 1, 0.5);
      thrusterLight.color.setHSL(hue, 1, 0.5);
    } else if (isMovingBackward) {
      // Reduced thruster when moving backward
      const randomScale = 0.3 + Math.random() * 0.1 + pulseEffect * 0.5;
      thruster.scale.set(0.5, 0.5, randomScale);
      thruster.material.opacity = 0.4 + Math.random() * 0.2;
      thrusterLight.intensity = 0.6 + Math.random() * 0.2 + pulseEffect * 0.5;
      
      // Cooler color for reverse thrust
      thruster.material.color.setHSL(0.6, 1, 0.5); // Blue-ish
      thrusterLight.color.setHSL(0.6, 1, 0.5);
    } else {
      // Idle state with subtle pulsing
      const idleScale = 0.3 + pulseEffect;
      thruster.scale.set(0.3, 0.3, idleScale);
      thruster.material.opacity = 0.3 + pulseEffect;
      thrusterLight.intensity = 0.4 + pulseEffect;
      
      // Neutral color for idle
      thruster.material.color.setHSL(0.5, 0.7, 0.5); // Cyan-ish
      thrusterLight.color.setHSL(0.5, 0.7, 0.5);
    }
    
    // Performance optimization: only update material if it's visible
    if (thruster.material.opacity < 0.01) {
      thruster.visible = false;
      thrusterLight.visible = false;
    } else {
      thruster.visible = true;
      thrusterLight.visible = true;
    }
  }
  
  flashCollisionWarning() {
    // Create a full-screen flash effect for collision
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'collision-flash';
    document.body.appendChild(flashOverlay);
    
    // Remove after animation completes
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, 150);
  }
  
  updateEnergy(deltaTime) {
    // Validate parameters
    if (typeof deltaTime !== 'number' || deltaTime < 0) {
        console.warn('Invalid deltaTime in updateEnergy:', deltaTime);
        return;
    }

    // Initialize energy values if undefined
    if (typeof this.energy !== 'number') this.energy = 0;
    if (typeof this.maxEnergy !== 'number') this.maxEnergy = 100;
    if (typeof this.energyRechargeRate !== 'number') this.energyRechargeRate = 20;

    // Store old energy for change detection
    const oldEnergy = this.energy;

    // Calculate recharge amount
    const rechargeAmount = this.energyRechargeRate * deltaTime;
    
    // Apply recharge with bounds checking
    this.energy = Math.min(this.maxEnergy, this.energy + rechargeAmount);

    // Update UI only if energy changed
    if (this.energy !== oldEnergy) {
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        }

        // Play charging sound when energy is low (under 10%)
        if (this.energy < (this.maxEnergy * 0.1)) {
            this.playSound('weapon-charging');
        }

        // Log significant energy changes (more than 1 unit) for debugging
        if (Math.abs(this.energy - oldEnergy) > 1) {
            console.log(`Energy updated: ${oldEnergy.toFixed(1)} -> ${this.energy.toFixed(1)} (Δ${deltaTime.toFixed(3)}s)`);
        }
    }
  }
  
  updateGrenades() {
    if (!this.grenades || this.grenades.length === 0) return;
    
    for (let i = this.grenades.length - 1; i >= 0; i--) {
      const grenade = this.grenades[i];
      
      // If the grenade has exploded, handle explosion effects
      if (grenade.exploded) {
        // Increase the explosion radius until maximum
        grenade.explosionMesh.scale.addScalar(0.2);
        grenade.explosionLight.intensity -= 0.1;
        
        // Remove explosion after it's done
        if (grenade.explosionLight.intensity <= 0) {
          this.scene.remove(grenade.explosionMesh);
          this.scene.remove(grenade.trail);
          this.grenades.splice(i, 1);
        }
        continue;
      }
      
      // Update the grenade position along the arc
      grenade.progress += 0.02;
      
      if (grenade.progress >= 1) {
        // Explode when reaching the target
        this.explodeGrenade(grenade, i);
      } else {
        // Move along a quadratic bezier curve for arcing trajectory
        const p0 = grenade.startPos;
        const p1 = grenade.midPos;
        const p2 = grenade.endPos;
        
        // Quadratic bezier formula: p = (1-t)^2 * p0 + 2(1-t)t * p1 + t^2 * p2
        const t = grenade.progress;
        const oneMinusT = 1 - t;
        
        grenade.mesh.position.x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
        grenade.mesh.position.y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
        grenade.mesh.position.z = oneMinusT * oneMinusT * p0.z + 2 * oneMinusT * t * p1.z + t * t * p2.z;
        
        // Add trail effect
        const point = grenade.mesh.position.clone();
        grenade.trailPoints.push(point);
        
        // Keep only the last 20 trail points
        if (grenade.trailPoints.length > 20) {
          grenade.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(grenade.trailPoints.length * 3);
        for (let j = 0; j < grenade.trailPoints.length; j++) {
          positions[j * 3] = grenade.trailPoints[j].x;
          positions[j * 3 + 1] = grenade.trailPoints[j].y;
          positions[j * 3 + 2] = grenade.trailPoints[j].z;
        }
        
        grenade.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        grenade.trail.geometry.attributes.position.needsUpdate = true;
      }
    }
  }
  
  explodeGrenade(grenade, index) {
    // Remove the grenade mesh
    this.scene.remove(grenade.mesh);
    
    // Create explosion geometry
    const explosionGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const explosionMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8
    });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(grenade.mesh.position);
    
    // Add to scene
    this.scene.add(explosionMesh);
    
    // Add explosion light
    const explosionLight = new THREE.PointLight(0xff6600, 3, 10);
    explosionMesh.add(explosionLight);
    
    // Mark as exploded
    grenade.exploded = true;
    grenade.explosionMesh = explosionMesh;
    grenade.explosionLight = explosionLight;
    
    // Calculate damage radius
    const explosionCenter = grenade.mesh.position.clone();
    const maxDamage = 50; // Maximum damage at center - 50% of health
    const damageRadius = grenade.explosionRadius || 4; // Default radius of 4 units
    
    // Check for obstacle hits in explosion radius
    for (const obstacle of this.obstacles) {
      const distance = obstacle.position.distanceTo(explosionCenter);
      if (distance < damageRadius) {
        // Calculate damage based on distance (linear falloff)
        const damagePercent = 1 - (distance / damageRadius);
        const hitPoint = obstacle.position.clone().add(
          explosionCenter.clone().sub(obstacle.position).normalize().multiplyScalar(distance * 0.8)
        );
        this.createHitEffect(hitPoint);
      }
    }
    
    // Check for player damage
    const playerPosition = this.playerShip.position.clone();
    playerPosition.y = 0; // Project to ground plane
    const grenadePosition = explosionCenter.clone();
    grenadePosition.y = 0; // Project to ground plane
    
    const playerDistance = playerPosition.distanceTo(grenadePosition);
    if (playerDistance < damageRadius) {
      // Calculate damage with distance falloff
      const damagePercent = 1 - (playerDistance / damageRadius);
      const damage = Math.floor(maxDamage * damagePercent);
      
      // Apply damage to player
      this.health = Math.max(0, this.health - damage);
      
      // Update UI
      if (this.ui) {
        this.ui.updateHealth(this.health, this.maxHealth);
      }
      
      // Visual feedback
      this.flashCollisionWarning();
      this.createHitEffect(playerPosition);
    }
  }
  
  updateBouncingLasers() {
    if (!this.bouncingLasers || this.bouncingLasers.length === 0) return;
    
    const playerPos = this.playerShip ? this.playerShip.position.clone() : null;
    
    // Update each laser
    for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
      const laser = this.bouncingLasers[i];
      
      // Skip invalid lasers
      if (!laser || !laser.mesh) continue;
      
      // Update laser position
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update the trail
      if (laser.trail) {
        // Add current position to trail points
        laser.trailPoints.push(laser.mesh.position.clone());
        
        // Limit the number of trail points
        if (laser.trailPoints.length > 20) {
          laser.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(laser.trailPoints.length * 3);
        for (let j = 0; j < laser.trailPoints.length; j++) {
          positions[j * 3] = laser.trailPoints[j].x;
          positions[j * 3 + 1] = laser.trailPoints[j].y;
          positions[j * 3 + 2] = laser.trailPoints[j].z;
        }
        
        // Update geometry
        laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        laser.trail.geometry.attributes.position.needsUpdate = true;
      }
      
      // Check for collisions with obstacles
      let collision = false;
      let closestPoint = null;
      let closestDistance = Infinity;
      let closestNormal = null;
      
      // Check for collision with each obstacle
      for (const obstacle of this.obstacles) {
        if (!obstacle.geometry) continue;
        
        let intersection = null;
        let normal = null;
        
        if (obstacle.geometry instanceof THREE.SphereGeometry) {
          const radius = obstacle.geometry.parameters.radius;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else if (obstacle.geometry instanceof THREE.CylinderGeometry) {
          const radius = obstacle.geometry.parameters.radiusTop;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else {
          // For boxes, use bounding sphere as approximation
          const boundingSphere = obstacle.geometry.boundingSphere;
          if (!boundingSphere) {
            obstacle.geometry.computeBoundingSphere();
          }
          const sphere = new THREE.Sphere(
            obstacle.position,
            obstacle.geometry.boundingSphere.radius
          );
          intersection = tempRay.intersectSphere(sphere, tempVector);
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        }
        
        if (intersection) {
          const dist = laser.mesh.position.distanceTo(intersection);
          if (dist < closestDist && dist < laser.speed * 1.2) {
            closestDist = dist;
            closestPoint = intersection;
            closestNormal = normal;
          }
        }
      }
      
      // Handle bounce if collision found
      if (closestPoint && closestNormal) {
        // Position at intersection point
        laser.mesh.position.copy(closestPoint);
        
        // Calculate reflection direction
        const dot = laser.direction.dot(closestNormal);
        const reflection = laser.direction.clone()
          .sub(closestNormal.multiplyScalar(2 * dot))
          .normalize();
        
        // Update direction with some randomness for more interesting bounces
        const randomAngle = (Math.random() - 0.5) * 0.2; // Small random angle
        reflection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
        laser.direction.copy(reflection);
        
        // Increment bounce count
        laser.bounces++;
        
        // Create bounce effect
        this.createBounceEffect(closestPoint.clone(), closestNormal.clone());
        
        // Play bounce sound
        this.playSound('bounce');
        
        // Enable player collision after first bounce
        laser.canHitPlayer = true;
        
        // Increase speed slightly with each bounce
        laser.speed *= 1.1;
        
        bounced = true;
      }
      
      // If no bounce, move normally
      if (!bounced) {
        laser.mesh.position.copy(nextPosition);
      }
      
      // Check for enemy collisions - new code
      if (this.enemyManager && this.enemyManager.enemies.length > 0) {
        for (let j = this.enemyManager.enemies.length - 1; j >= 0; j--) {
          const enemy = this.enemyManager.enemies[j];
          if (!enemy.isActive) continue;
          
          const enemyPos = enemy.mesh.position.clone();
          enemyPos.y = 0.5; // Adjust to match laser height
          
          // Check if the laser hit the enemy
          const hitDistance = 0.7; // Collision distance for enemy hits
          if (laser.mesh.position.distanceTo(enemyPos) < hitDistance) {
            // Enemy hit
            enemy.takeDamage(10); // Damage the enemy
            
            // Create hit effect
            this.createHitEffect(enemyPos);
            
            // Play hit sound
            this.playSound('weapon-armor-hit');
            
            // Remove laser
            this.scene.remove(laser.mesh);
            this.scene.remove(laser.trail);
            this.bouncingLasers.splice(i, 1);
            break; // Exit the enemy loop
          }
        }
      }
      
      // Check for player collision
      if (laser.canHitPlayer) {
        const playerPos = this.playerShip.position.clone();
        playerPos.y = 0.5;
        
        if (laser.mesh.position.distanceTo(playerPos) < 1) {
          // Player hit
          this.health -= 10;
          if (this.health < 0) this.health = 0;
          
          // Update UI
          this.ui.updateHealth(this.health, this.maxHealth);
          
          // Visual feedback
          this.flashCollisionWarning();
          this.createBounceEffect(playerPos, new THREE.Vector3(0, 1, 0));
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.bouncingLasers.splice(i, 1);
          continue;
        }
      }
      
      // Update lifetime
      laser.lifeTime++;
      
      // Remove if too old or too many bounces
      if (laser.lifeTime > laser.maxLifeTime || laser.bounces >= laser.maxBounces) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.bouncingLasers.splice(i, 1);
      }
    }
  }
  
  // Create a special effect for laser bounces
  createBounceEffect(position, normal) {
    // Create a particle burst effect at the bounce point
    const particleCount = 20;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    // Add a flash of light at bounce point
    const bounceLight = new THREE.PointLight(0x00ffcc, 3, 5);
    bounceLight.position.copy(position);
    this.scene.add(bounceLight);
    
    // Create a ring effect at bounce point
    const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(position);
    
    // Orient the ring according to the normal
    if (Math.abs(normal.y) > 0.99) { // If normal is pointing mainly up/down
      ring.rotation.x = Math.PI / 2; // Rotate to lie flat
    } else {
      // Point the ring along the normal
      const rotationAxis = new THREE.Vector3(0, 1, 0).cross(normal).normalize();
      const angle = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0)));
      ring.setRotationFromAxisAngle(rotationAxis, angle);
    }
    
    this.scene.add(ring);
    
    // Create particles around bounce point
    for (let i = 0; i < particleCount; i++) {
      // Random direction from bounce point
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(2)).normalize();
      
      // Starting at bounce point
      const startPoint = position.clone();
      particlePositions[i * 3] = startPoint.x;
      particlePositions[i * 3 + 1] = startPoint.y;
      particlePositions[i * 3 + 2] = startPoint.z;
      
      // Random sizes for particles
      particleSizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.1,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Store particle velocities
    const particleVelocities = [];
    for (let i = 0; i < particleCount; i++) {
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1, 
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(1.5)).normalize();
      
      // Random speed
      const speed = Math.random() * 0.1 + 0.05;
      particleVelocities.push(direction.multiplyScalar(speed));
    }
    
    // Animate particles and effects
    let frameCount = 0;
    const maxFrames = 30;
    
    const animate = () => {
      frameCount++;
      
      // Update particles
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x;
        positions[i * 3 + 1] += particleVelocities[i].y;
        positions[i * 3 + 2] += particleVelocities[i].z;
        
        // Slow down particles over time
        particleVelocities[i].multiplyScalar(0.95);
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Fade the light
      bounceLight.intensity *= 0.85;
      
      // Expand and fade the ring
      ring.scale.addScalar(0.15);
      ring.material.opacity *= 0.9;
      
      // Fade the particles
      particles.material.opacity *= 0.92;
      
      if (frameCount < maxFrames) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(bounceLight);
        this.scene.remove(ring);
        this.scene.remove(particles);
      }
    };
    
    // Start animation
    animate();
  }
  
  // Now add new methods to handle grenade targeting
  updateGrenadeTargetingIndicator(event) {
    // Create targeting indicator if it doesn't exist
    if (!this.grenadeTargetIndicator) {
      // Create targeting indicator
      const targetGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
      const targetMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, 
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      this.grenadeTargetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
      this.grenadeTargetIndicator.rotation.x = Math.PI / 2; // Make it horizontal
      
      // Add pulsing animation
      this.grenadeTargetIndicator.pulse = 0;
      
      // Add to scene
      this.scene.add(this.grenadeTargetIndicator);
    }
    
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // Update indicator color based on range
        if (distance > maxRange) {
          this.grenadeTargetIndicator.material.color.set(0xff0000); // Red for out of range
        } else {
          this.grenadeTargetIndicator.material.color.set(0x00ff00); // Green for valid
        }
        
        // Position the targeting indicator
        this.grenadeTargetIndicator.position.copy(targetPoint);
        this.grenadeTargetIndicator.position.y = 0.1; // Slightly above floor
        
        // Pulse animation
        this.grenadeTargetIndicator.pulse += 0.1;
        const scale = 1 + 0.2 * Math.sin(this.grenadeTargetIndicator.pulse);
        this.grenadeTargetIndicator.scale.set(scale, scale, scale);
        
        // Store target point for launching
        this.grenadeTargetPoint = targetPoint.clone();
    }
  }
  
  handleGrenadeTargeting(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Validate energy before proceeding
    if (!this.energy || !this.maxEnergy) {
        console.warn('Energy values invalid:', { energy: this.energy, maxEnergy: this.maxEnergy });
        return;
    }
    
    // Check if we have enough energy - now requires FULL energy
    if (this.energy < this.maxEnergy) {
        console.log("Not enough energy for grenade");
        return;
    }
    
    // Validate event coordinates
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid grenade target coordinates');
        return;
    }
    
    // Get the position where to throw the grenade
    const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // If beyond max range, limit to max range
        if (distance > maxRange) {
            toTarget.normalize().multiplyScalar(maxRange);
            targetPoint.copy(shipPosition).add(toTarget);
        }
        
        // Consume full energy
        this.energy = 0;
        
        // Update UI with energy change
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        } else {
            console.warn('UI energy update failed');
        }
        
        // Create and launch the grenade
        this.launchGrenade(targetPoint);
    }
  }
  
  launchGrenade(targetPoint) {
    // Create grenade mesh
    const grenadeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const grenadeMaterial = new THREE.MeshPhongMaterial({
      color: 0xff4500,
      emissive: 0xff2000,
      emissiveIntensity: 0.5
    });
    const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial);
    
    // Position at the ship
    grenade.position.copy(this.playerShip.position);
    grenade.position.y = 0.5; // Slightly above floor
    
    // Add to scene
    this.scene.add(grenade);
    
    // Add grenade trail effect
    const trail = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({
        color: 0xff4500,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      })
    );
    this.scene.add(trail);
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(0xff4500, 1, 3);
    grenade.add(light);
    
    // Store grenade data for animation
    if (!this.grenades) {
      this.grenades = [];
    }
    
    // Calculate the arc of the grenade
    const startPos = grenade.position.clone();
    const endPos = targetPoint.clone();
    const midPos = startPos.clone().add(endPos.clone().sub(startPos).multiplyScalar(0.5));
    midPos.y += 5; // Arc height
    
    this.grenades.push({
      mesh: grenade,
      trail: trail,
      startPos: startPos,
      midPos: midPos,
      endPos: endPos,
      progress: 0,
      exploded: false,
      explosionRadius: 4,
      trailPoints: []
    });

    // Play grenade launch sound
    this.playSound('grenade-laser');
  }
  
  // Add a method to show targeting indicator for all weapons
  updateTargetingIndicator(event) {
    // Skip if indicator was recently updated
    if (this.lastIndicatorUpdate && Date.now() - this.lastIndicatorUpdate < 16) {
        return;
    }
    this.lastIndicatorUpdate = Date.now();

    // Get the mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Log the normalized mouse position occasionally
    if (Math.random() < 0.01) {
      console.log('Mouse normalized position:', mouse);
    }
    
    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Check for intersection with the raycastFloor
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    // Log raycasting results occasionally for debugging
    if (Math.random() < 0.01) {
      console.log('Raycast results:', { 
        intersections: intersects.length, 
        raycastFloorExists: !!this.raycastFloor,
        raycastFloorPosition: this.raycastFloor ? this.raycastFloor.position.y : 'N/A'
      });
    }
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Create or update targeting indicator
        if (!this.targetingIndicator) {
            console.log('Creating new targeting indicator');
            // Create a more efficient indicator using a single geometry
            const geometry = new THREE.Group();
            
            // Outer ring with fewer segments - MAKE LARGER
            const outerRing = new THREE.RingGeometry(0.8, 1.0, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8, // Increased opacity
                side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerRing, material);
            
            // Inner ring with fewer segments - MAKE LARGER
            const innerRing = new THREE.RingGeometry(0.2, 0.4, 16);
            const inner = new THREE.Mesh(innerRing, material.clone());
            
            // Simplified crosshair - MAKE LARGER
            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = new Float32Array([
                -0.6, 0, 0,
                0.6, 0, 0,
                0, -0.6, 0,
                0, 0.6, 0
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));
            const lines = new THREE.LineSegments(lineGeometry, material.clone());
            
            geometry.add(outer);
            geometry.add(inner);
            geometry.add(lines);
            
            this.targetingIndicator = geometry;
            this.targetingIndicator.rotation.x = Math.PI / 2;
            this.scene.add(this.targetingIndicator);
        }
        
        // Update position - INCREASE HEIGHT
        this.targetingIndicator.position.copy(targetPoint);
        this.targetingIndicator.position.y = 0.5; // Much higher above the terrain
        
        // Update color based on weapon type
        const colors = {
            'LASER': new THREE.Color(0x00ffff),
            'GRENADE': new THREE.Color(0xff4500),
            'BOUNCE': new THREE.Color(0x00ff99)
        };
        const color = colors[this.currentWeapon] || colors['LASER'];
        
        // Only update colors if they've changed
        if (!this.lastWeaponColor || this.lastWeaponColor !== this.currentWeapon) {
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
            this.lastWeaponColor = this.currentWeapon;
        }
        
        // Simplified pulse animation
        if (!this.targetingIndicator.pulse) {
            this.targetingIndicator.pulse = 0;
        }
        this.targetingIndicator.pulse = (this.targetingIndicator.pulse + 0.1) % (Math.PI * 2);
        const pulseScale = 1.0 + 0.1 * Math.sin(this.targetingIndicator.pulse);
        this.targetingIndicator.scale.setScalar(pulseScale);
        
        // Show indicator
        this.targetingIndicator.visible = true;
        
        // Reset fade timeout
        if (this.targetingTimeout) {
            clearTimeout(this.targetingTimeout);
        }
        this.targetingTimeout = setTimeout(() => {
            if (this.targetingIndicator && this.targetingIndicator.visible) {
                this.targetingIndicator.visible = false;
            }
        }, 1000);
        
        // Extract target direction for firing
        const direction = new THREE.Vector3()
            .subVectors(targetPoint, this.playerShip.position)
            .normalize();
        
        // Store direction for firing
        this.targetDirection = direction;
    }
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggleMiniMap() {
    if (this.miniMap) {
      this.miniMap.toggle();
    }
  }
  
  // Add cleanup method
  cleanup() {
    // Stop and remove all sounds
    this.soundPools.forEach(pool => {
      pool.forEach(wrapper => {
        if (wrapper.sound.isPlaying) {
          wrapper.sound.stop();
        }
        wrapper.sound.buffer = null;
      });
    });
    
    // Clear sound pools and loaded sounds
    this.soundPools.clear();
    this.loadedSounds.clear();
    this.soundLoadPromises.clear();
    
    // Remove audio listener from camera
    if (this.audioListener) {
      this.camera.remove(this.audioListener);
      this.audioListener = null;
    }
    
    // Remove event listeners
    window.removeEventListener('resize', this.boundHandleResize);
    document.removeEventListener('keydown', this.boundHandleKeyDown);
    document.removeEventListener('keyup', this.boundHandleKeyUp);
    document.removeEventListener('click', this.boundHandleClick);
    document.removeEventListener('mousemove', this.boundHandleMouseMove);
    
    // Clear timers
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = null;
    }
    
    if (this.mouseMoveTimer) {
      clearTimeout(this.mouseMoveTimer);
      this.mouseMoveTimer = null;
    }
    
    // Clear weapon cooldowns
    this.weaponCooldowns.clear();
    
    // Clear key states
    Object.keys(this.keys).forEach(key => {
      this.keys[key] = false;
    });
    this.activeKeys.clear();
  }

  startGame() {
    console.log("Starting game...");
    
    // Get player name from input
    const playerNameInput = document.getElementById('player-name');
    this.playerName = playerNameInput.value.trim() || 'Pilot-' + Math.floor(Math.random() * 1000);
    
    // Hide start screen
    const startScreen = document.getElementById('start-screen');
    startScreen.classList.add('hidden');
    
    // Enable multiplayer mode by default
    this.multiplayerEnabled = true;
    
    // Connect to server
    if (this.networkManager) {
      this.networkManager.connect();
      
      // Show multiplayer info UI
      const multiplayerInfo = document.getElementById('multiplayer-info');
      if (multiplayerInfo) {
        multiplayerInfo.classList.remove('hidden');
      }
      
      // Update player info on server
      this.networkManager.updatePlayerInfo(this.playerName, this.currentShipType || 'default');
    }
    
    // Show ship selection screen
    this.showShipSelection();
  }

  showShipSelection() {
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
      console.error('Game container not found');
      return;
    }

    // Initialize ship selection if not already done
    if (!this.shipSelection) {
      this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
          this.shipSelection.hide();
          this.startGameplay(selection);
        }
      });
    }
    this.shipSelection.show();
  }

  startGameplay(shipSelection) {
    console.log('🔍 Starting gameplay with ship selection:', shipSelection);
    
    // First apply the ship selection
    this.applyShipSelection(shipSelection);
    
    // Set game as running (if this property exists)
    this.isRunning = true;
    
    // Show game UI (using either method)
    if (typeof this.ui !== 'undefined' && typeof this.ui.show === 'function') {
        this.ui.show();
    } else {
        // Show game UI directly
        const gameUI = document.querySelector('.game-ui');
        if (gameUI) {
            gameUI.classList.remove('hidden');
        }
    }
    
    // Show mini-map if it exists
    if (this.miniMap && typeof this.miniMap.show === 'function') {
        this.miniMap.show();
    }
    
    // Create and show controls if not already created
    if (!this.controlsContainer && typeof this.createControlIndicators === 'function') {
        this.createControlIndicators();
    }
    this.fadeInControls();
    
    // IMPORTANT: Double-check that the player ship has a proper collision radius
    if (this.playerShip) {
        this.playerShip.userData.collisionRadius = 0.35; // Use the same reduced value as defined earlier
        console.log('🛡️ Verified player ship collision radius:', this.playerShip.userData.collisionRadius);
    } else {
        console.error('⚠️ Player ship not available when starting gameplay!');
    }
    
    // Manually check for collisions once to make sure it's working
    setTimeout(() => {
        console.log('🔍 Running initial collision check...');
        this.checkObstacleCollisions();
    }, 500);

    // Start animation loop
    this.animate();
    
    console.log('✅ Game started successfully!');
  }

  applyShipSelection(selection) {
    console.log('🔍 Applying ship selection:', selection);
    
    // Clear existing ship model
    if (this.playerShip) {
        // Remove all children (previous ship model)
        while (this.playerShip.children.length > 0) {
            const child = this.playerShip.children[0];
            this.playerShip.remove(child);
        }
    }
    
    // Set ship model based on selection
    const type = selection.type.toUpperCase(); // Make sure it's uppercase for consistency
    this.setShipModel(type);
    this.currentShipType = type;
    
    // Position ship at a random location in the playing area
    // Avoid spawning too close to the center (where other players might spawn)
    const spawnRadius = 30; // Radius from center for spawning
    const randomAngle = Math.random() * Math.PI * 2; // Random angle
    const randomDistance = spawnRadius * (0.5 + Math.random() * 0.5); // Between 50% and 100% of spawn radius
    
    // Calculate position
    const spawnX = Math.cos(randomAngle) * randomDistance;
    const spawnZ = Math.sin(randomAngle) * randomDistance;
    
    // Set player ship position
    if (this.playerShip) {
        this.playerShip.position.set(spawnX, this.playerShip.position.y, spawnZ);
        
        // Set random rotation
        this.playerShip.rotation.y = Math.random() * Math.PI * 2;
        
        console.log(`Player spawned at position: [${spawnX.toFixed(2)}, ${spawnZ.toFixed(2)}], rotation: ${this.playerShip.rotation.y.toFixed(2)}`);
    }
    
    // Apply ship color if specified
    if (selection.color && this.playerShip) {
        const color = new THREE.Color(selection.color);
        
        // Apply color to all meshes in the ship model
        this.playerShip.traverse(child => {
            if (child.isMesh && child.material) {
                try {
                    // Clone the material to avoid affecting other instances
                    if (!child.material._isCloned) {
                        child.material = child.material.clone();
                        child.material._isCloned = true;
                    }
                    
                    // Update material color properties with safety checks
                    if (child.material.color) {
                        child.material.color.set(color);
                    }
                    
                    if (child.material.emissive) {
                        child.material.emissive.set(color);
                        child.material.emissiveIntensity = 0.3;
                    }
                    
                    // Update the material
                    child.material.needsUpdate = true;
                } catch (error) {
                    console.warn('Error setting material properties:', error);
                }
            }
        });
    }
    
    console.log('✅ Ship configuration applied successfully');
    
    // Verify collision detection is working
    console.log('🔍 Verifying collision detection is working');
}

exitToMainMenu() {
    // Stop animation loop
    this.isRunning = false;

    // Hide in-game menu if it exists
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
      menuContainer.classList.add('hidden');
    }

    // Hide game UI
    this.ui.hide();
    if (this.miniMap) {
      this.miniMap.hide();
    }
    this.fadeOutControls();

    // Clean up ship selection if it exists
    if (this.shipSelection) {
      this.shipSelection.hide();
    }

    // Show start screen
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
      startScreen.classList.add('fade-in');
    }

    // Reset game state
    this.resetGameState();
  }

  resetGameState() {
    console.log('🔄 Resetting game state...');
    
    // Reset player position
    if (this.playerShip) {
        this.playerShip.position.set(0, 0.5, 0);
        this.playerShip.rotation.set(0, 0, 0);
    }
    
    // Reset camera to original position
    if (this.camera) {
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);
    }
    
    // Reset player stats
    this.health = this.maxHealth || 100;
    this.energy = this.maxEnergy || 100;
    
    // Update UI - use existing methods if available
    if (typeof this.updateUI === 'function') {
        this.updateUI();
    } else {
        // Update health bar
        const healthBar = document.querySelector('.health-bar .bar-inner');
        if (healthBar) {
            healthBar.style.width = '100%';
        }
        
        // Update energy bar
        const energyBar = document.querySelector('.energy-bar .bar-inner');
        if (energyBar) {
            energyBar.style.width = '100%';
        }
    }
    
    // Original way of clearing lasers
    if (this.lasers) {
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            const laser = this.lasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.lasers = [];
    }
    
    // Clear bouncing lasers
    if (this.bouncingLasers) {
        for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
            const laser = this.bouncingLasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.bouncingLasers = [];
    }
    
    // Clear grenades
    if (this.grenades) {
        for (let i = this.grenades.length - 1; i >= 0; i--) {
            const grenade = this.grenades[i];
            if (grenade.mesh && grenade.mesh.parent) {
                grenade.mesh.parent.remove(grenade.mesh);
            }
        }
        this.grenades = [];
    }
    
    // Reset movement keys
    this.keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        strafeLeft: false,
        strafeRight: false
    };
    
    // Reset weapon state to original
    this.currentWeapon = 'laser';
    this.weaponCooldown = 0;
    this.grenadeTargeting = false;
    
    // Make sure the player exists
    if (!this.playerShip) {
        this.createDefaultShip();
    }
    
    // Reset player velocity (original behavior)
    this.playerVelocity = new THREE.Vector3();
    this.playerRotation = new THREE.Vector3();
    
    // Update weapon UI - use existing method if available
    if (typeof this.updateWeaponUI === 'function') {
        this.updateWeaponUI();
    }
    
    // Update control indicators - use existing method if available
    if (typeof this.updateControlIndicators === 'function') {
        this.updateControlIndicators();
    }
    
    console.log('✅ Game state reset complete');
  }

  handleDirectionalFiring(event) {
    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);

    // Check for intersection with an invisible plane at ship's height
    const planeNormal = new THREE.Vector3(0, 1, 0);
    const shipHeight = this.playerShip.position.y;
    const plane = new THREE.Plane(planeNormal, -shipHeight);
    
    const targetPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, targetPoint);

    if (targetPoint) {
        // Calculate direction from ship to target
        const direction = targetPoint.clone().sub(this.playerShip.position).normalize();
        direction.y = 0; // Keep shots parallel to ground

        // Get the ship's current forward direction
        const shipForward = new THREE.Vector3(0, 0, 1);
        shipForward.applyQuaternion(this.playerShip.quaternion);
        shipForward.y = 0;
        shipForward.normalize();

        // Calculate the angle between ship's forward direction and target direction
        const angle = shipForward.angleTo(direction);
        
        // Only fire if the target is within a reasonable angle (e.g., 60 degrees) from ship's forward direction
        const maxFiringAngle = Math.PI / 3; // 60 degrees
        
        if (angle <= maxFiringAngle) {
            // Fire weapon in the calculated direction
            this.fireCurrentWeapon(direction);
        }
    }
  }

  fireCurrentWeapon(direction) {
    // Check weapon cooldown
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;

    if (now < weaponCooldown) {
        return;
    }

    // Define energy costs for each weapon from GAME_CONFIG
    const energyCosts = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.ENERGY_COST,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.ENERGY_COST,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.ENERGY_COST
    };

    // Check if we have enough energy
    const energyCost = energyCosts[this.currentWeapon];
    if (this.energy < energyCost) {
        console.log(`Not enough energy for ${this.currentWeapon}`);
        return;
    }

    // Set cooldown based on weapon type from GAME_CONFIG
    const cooldowns = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.COOLDOWN,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.COOLDOWN,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.COOLDOWN
    };
    const cooldownTime = cooldowns[this.currentWeapon];

    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);

    // Consume energy
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Update UI with energy change
    if (this.ui && typeof this.ui.updateEnergy === 'function') {
        this.ui.updateEnergy(this.energy, this.maxEnergy);
    }

    // Use target direction if available, otherwise use ship orientation
    let firingDirection;
    
    // If we have a targetDirection from mouse, use that instead of ship orientation
    if (this.targetDirection && (this.currentWeapon === 'LASER' || this.currentWeapon === 'BOUNCE')) {
        firingDirection = this.targetDirection.clone();
        console.log('Using mouse targeting direction:', firingDirection);
    } else {
        // Fall back to ship orientation if no target direction
        firingDirection = direction || new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        console.log('Using ship orientation direction:', firingDirection);
    }
    
    // Ensure direction is normalized
    firingDirection.normalize();
    
    // Get firing position (slightly in front of ship)
    const position = this.playerShip.position.clone().add(firingDirection.clone().multiplyScalar(1.5));
    position.y = 0.5; // Set height

    // Create weapon effect based on type
    switch (this.currentWeapon) {
        case 'LASER':
            this.fireLaser(position, firingDirection);
            this.playSound('laser');
            
            // Send laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection
                });
            }
            break;
        case 'BOUNCE':
            this.fireBouncingLaser(position, firingDirection);
            this.playSound('laser-bounce');
            
            // Send bounce laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection,
                    type: 'bounce'
                });
            }
            break;
        case 'GRENADE':
            // Grenades are handled separately through handleGrenadeTargeting
            break;
    }

    // Visual feedback for firing
    this.createMuzzleFlash(position, firingDirection);

    // Log energy state for debugging
    console.log(`Weapon fired: ${this.currentWeapon}, Energy remaining: ${this.energy}/${this.maxEnergy}`);
}

createMuzzleFlash(position, direction) {
  // Create a quick flash effect at the firing position
  const flashGeometry = new THREE.CircleGeometry(0.3, 16);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
  });
  
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position flash at the weapon position, oriented to face the camera
  flash.position.copy(position);
  flash.position.y += 0.1; // Slightly above ship
  
  // Update flash to always face camera
  flash.lookAt(this.camera.position);
  
  // Add to scene
  this.scene.add(flash);
  
  // Create flash animation with subtle scaling
  let scale = 1;
  const animate = () => {
    scale += 0.2;
    flash.scale.set(scale, scale, scale);
    
    // Reduce opacity as flash grows
    if (flash.material) {
      flash.material.opacity = Math.max(0, 1 - (scale - 1) / 2);
      
      // Remove when fully transparent
      if (flash.material.opacity <= 0) {
        this.scene.remove(flash);
        if (flash.material) flash.material.dispose();
        if (flash.geometry) flash.geometry.dispose();
        return;
      }
    }
    
    // Continue animation
    requestAnimationFrame(animate);
  };
  animate();
}

  fireLaser(position, direction) {
    // Create laser geometry - make it longer and thinner for better visual
    const geometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
    geometry.rotateX(-Math.PI / 2); // Changed rotation to negative to flip direction

    // Create glowing material with better visual effects
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Orient laser along direction - using lookAt for more accurate direction
    const targetPos = position.clone().add(direction.clone().multiplyScalar(10));
    laser.lookAt(targetPos);

    // Add to scene
    this.scene.add(laser);

    // Add point light for glow effect with better parameters
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.set(0, 0, 0); // Center of the laser
    laser.add(light);

    // Add a trail effect
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    this.scene.add(trail);

    // Initialize lasers array if it doesn't exist
    if (!this.lasers) {
      this.lasers = [];
    }

    // Store laser data with enhanced properties
    this.lasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 1.2, // Slightly increased speed for better feel
      lifeTime: 0,
      maxLifeTime: 40,
      trailPoints: [],
      pulsePhase: 0
    });
  }

  fireBouncingLaser(position, direction) {
    // Create bouncing laser geometry - using a smaller sphere for better visuals
    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff99,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Add point light for glow effect
    const light = new THREE.PointLight(0x00ff99, 2, 3);
    laser.add(light);

    // Create enhanced trail effect
    const trail = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({
        color: 0x00ff99,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      })
    );

    // Add to scene
    this.scene.add(laser);
    this.scene.add(trail);

    // Initialize bouncing lasers array if it doesn't exist
    if (!this.bouncingLasers) {
      this.bouncingLasers = [];
    }

    // Store bouncing laser data with improved parameters
    this.bouncingLasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 0.8, // Increased speed for better feel
      bounces: 0,
      maxBounces: 3,
      lifeTime: 0,
      maxLifeTime: 120,
      canHitPlayer: false,
      bounceTimeout: 15, // Reduced timeout for better gameplay
      trailPoints: [],
      pulsePhase: 0
    });
  }

  createHitEffect(position) {
    // Create particle burst effect
    const particleCount = 15;
    const particles = [];
    
    // Create particle material with orange/red color for explosion
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.2, 0.2);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity in all directions
      const velocity = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0;
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.5, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(this.camera.position);
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0xff6600, 3, 6);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles and effects
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }

  showInGameMenu() {
    // Pause the game
    this.isRunning = false;
    
    // Create or reuse the menu element
    let menuContainer = document.getElementById('in-game-menu');
    if (!menuContainer) {
      menuContainer = document.createElement('div');
      menuContainer.id = 'in-game-menu';
      menuContainer.className = 'menu-container';
      document.getElementById('game-container').appendChild(menuContainer);
      
      // Style the menu
      menuContainer.style.position = 'absolute';
      menuContainer.style.top = '50%';
      menuContainer.style.left = '50%';
      menuContainer.style.transform = 'translate(-50%, -50%)';
      menuContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      menuContainer.style.padding = '20px';
      menuContainer.style.borderRadius = '10px';
      menuContainer.style.color = '#fff';
      menuContainer.style.textAlign = 'center';
      menuContainer.style.zIndex = '1000';
      menuContainer.style.border = '2px solid #00ffff';
      menuContainer.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
      menuContainer.style.minWidth = '300px';
    }
    
    // Create menu content
    menuContainer.innerHTML = `
      <h2 style="color: #00ffff; margin-top: 0;">Game Menu</h2>
      <div class="menu-options">
        <button id="resume-button" class="menu-button">Resume Game</button>
        <button id="change-ship-button" class="menu-button">Change Ship</button>
        <button id="exit-button" class="menu-button">Exit to Main Menu</button>
      </div>
    `;
    
    // Style buttons
    const buttons = menuContainer.querySelectorAll('.menu-button');
    buttons.forEach(button => {
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.padding = '10px';
      button.style.margin = '10px 0';
      button.style.backgroundColor = '#001a33';
      button.style.color = '#00ffff';
      button.style.border = '1px solid #00ffff';
      button.style.borderRadius = '5px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '16px';
      button.style.transition = 'all 0.2s';
      
      // Hover effect
      button.onmouseenter = () => {
        button.style.backgroundColor = '#00ffff';
        button.style.color = '#001a33';
      };
      button.onmouseleave = () => {
        button.style.backgroundColor = '#001a33';
        button.style.color = '#00ffff';
      };
    });
    
    // Add event listeners
    document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
    document.getElementById('change-ship-button').addEventListener('click', () => this.showShipChangeScreen());
    document.getElementById('exit-button').addEventListener('click', () => this.exitToMainMenu());
    
    // Show the menu
    menuContainer.classList.remove('hidden');
  }
  
  resumeGame() {
    console.log('Hiding menus');
    
    // Hide ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
    }
    
    // Hide menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
  }
  
  showShipChangeScreen() {
    // Hide the menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
    
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
        console.error('Game container not found');
        return;
    }
    
    // Clean up existing ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
        
        // Safely remove the element from DOM if it exists and has a parent
        if (this.shipSelection.element && this.shipSelection.element.parentNode) {
            this.shipSelection.element.parentNode.removeChild(this.shipSelection.element);
        }
        
        this.shipSelection = null;
    }
    
    // Create new ship selection instance
    this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
            this.shipSelection.hide();
            this.applyShipSelection(selection);
        }
    });
    
    // Show the ship selection UI
    this.shipSelection.show();
  }

  /**
   * Calculate proper ground offset for an object based on its type and geometry
   */
  calculateGroundOffset(model, category, scale) {
    // Get the bounding box
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Calculate the distance from the object's pivot to its bottom
    const pivotToBottom = bbox.min.y;
    
    // The base offset is the distance needed to move the object so its bottom touches the ground
    let groundOffset = -pivotToBottom;
    
    // Add category-specific adjustments with more refined values
    switch(category) {
      case 'rocks':
        // Rocks typically need to be slightly embedded in the ground
        groundOffset += size.y * 0.08;
        break;
      case 'flora':
        // Flora should be firmly planted in the ground
        groundOffset += size.y * 0.03;
        break;
      case 'groundFeatures':
        // Ground features should be partially embedded, varying by model
        if (model.name && model.name.includes('Ground02')) {
          groundOffset += size.y * 0.15; // SP_Ground02 needs more embedding
        } else if (model.name && model.name.includes('Ground05')) {
          groundOffset += size.y * 0.05; // SP_Ground05 needs less embedding
        } else {
          groundOffset += size.y * 0.1; // Default for other ground features
        }
        break;
      case 'crystals':
        // Crystals should appear to be growing from the ground
        groundOffset += size.y * 0.15;
        break;
      case 'mountains':
        // Mountains need to be firmly embedded with varying depths
        const mountainDepth = 0.08 + (Math.random() * 0.05); // Random depth between 8-13%
        groundOffset += size.y * mountainDepth;
        break;
      case 'centerpiece':
        // Centerpiece gets special treatment
        groundOffset += size.y * 0.12;
        break;
      default:
        // Default adjustment for unknown types
        groundOffset += 0;
    }
    
    // Scale the offset according to the object's scale
    // Add a small global offset to prevent z-fighting
    return (groundOffset * scale) + 0.01;
  }

  /**
   * Create a special centerpiece for the landscape
   */
  createCenterpiece() {
    // Create a special formation at a designated spot
    const centerpiece = {
      position: new THREE.Vector3(0, 0, -35), // Prominent position
      models: [
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 2.5, offset: new THREE.Vector3(0, 0, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.8, offset: new THREE.Vector3(2, 0, 1), rotation: Math.PI/4 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.6, offset: new THREE.Vector3(-1.5, 0, -1), rotation: -Math.PI/5 },
        { path: 'assets/models/objects/SP_Ground05.glb', scale: 2.0, offset: new THREE.Vector3(0, -0.5, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Stone01.glb', scale: 1.2, offset: new THREE.Vector3(2.5, 0, -1.5), rotation: Math.PI/3 }
      ]
    };
    
    // Load each model in the centerpiece
    centerpiece.models.forEach((model, index) => {
      const loader = new GLTFLoader();
      loader.load(
        model.path,
        (gltf) => {
          const object = gltf.scene;
          
          // Apply scale
          object.scale.set(model.scale, model.scale, model.scale);
          
          // Position relative to centerpiece
          object.position.copy(centerpiece.position.clone().add(model.offset));
          
          // Apply rotation
          object.rotation.y = model.rotation;
          
          // Add special glow effect for crystals
          if (model.path.includes('Crystal')) {
            object.traverse(node => {
              if (node.isMesh && node.material) {
                node.material.emissive = new THREE.Color(0xff00ff);
                node.material.emissiveIntensity = 0.5;
                
                // Add a point light for extra effect
                const light = new THREE.PointLight(0xff00ff, 2, 10);
                light.position.set(0, 2 * model.scale, 0);
                object.add(light);
              }
            });
          }
          
          // Add to scene
          this.scene.add(object);
          
          // Create collision data
          const bbox = new THREE.Box3().setFromObject(object);
          const size = bbox.getSize(new THREE.Vector3());
          
          // Use improved ground placement
          const groundY = this.calculateGroundOffset(object, 'centerpiece', model.scale);
          object.position.y = groundY + model.offset.y; // Add the intentional offset for composition
          
          // Generate compound collision shapes
          const collisionShapes = this.generateCompoundCollisionShapes(object, 'centerpiece', model.scale);
          
          // Add to obstacles
          this.obstacles.push({
            mesh: object,
            type: 'centerpiece',
            collisionShape: 'compound',
            compoundShapes: collisionShapes.map(shape => {
              // Transform shape centers to world coordinates
              const worldCenter = shape.center.clone();
              worldCenter.add(object.position);
              
              return {
                ...shape,
                center: worldCenter,
                worldRotation: object.rotation.y + (shape.rotation || 0)
              };
            }),
            boundingBox: {
              min: new THREE.Vector3(
                object.position.x - (size.x * model.scale / 2),
                object.position.y - (size.y * model.scale / 2),
                object.position.z - (size.z * model.scale / 2)
              ),
              max: new THREE.Vector3(
                object.position.x + (size.x * model.scale / 2),
                object.position.y + (size.y * model.scale / 2),
                object.position.z + (size.z * model.scale / 2)
              ),
              size: size.clone().multiplyScalar(model.scale),
              rotation: object.rotation.y
            },
            size: Math.max(size.x, size.z) * model.scale * 0.5,
            position: object.position.clone()
          });
          
          console.log(`Centerpiece: Added ${model.path.split('/').pop()} at position [${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)}]`);
        },
        undefined,
        (error) => {
          console.error(`Error loading centerpiece model ${model.path}:`, error);
        }
      );
    });
  }

  /**
   * Create a special effect when colliding with crystals
   */
  createCrystalCollisionEffect(position, isSpecial = false) {
    // Create particles for crystal collision
    const particleCount = isSpecial ? 30 : 15;
    const color = isSpecial ? 0xff00ff : 0x00ffff;
    
    for (let i = 0; i < particleCount; i++) {
      // Create a small glowing cube
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      
      // Position at collision point
      particle.position.copy(position);
      
      // Add small random offset
      particle.position.x += (Math.random() - 0.5) * 2;
      particle.position.y += Math.random() * 3;
      particle.position.z += (Math.random() - 0.5) * 2;
      
      // Add to scene
      this.scene.add(particle);
      
      // Create velocity for particle
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.2 + 0.1,
        (Math.random() - 0.5) * 0.2
      );
      
      // Animate the particle
      const startTime = Date.now();
      const duration = 1000 + Math.random() * 1000; // 1-2 seconds
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Remove particle when animation completes
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return;
        }
        
        // Update position
        particle.position.add(velocity);
        
        // Slow down over time
        velocity.multiplyScalar(0.98);
        
        // Fade out
        particle.material.opacity = 0.8 * (1 - progress);
        
        // Continue animation
        requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
    }
  }

  /**
   * Generate compound collision shapes for more accurate collision detection
   */
  generateCompoundCollisionShapes(model, category, scale) {
    // Generate a compound collision shape based on model geometry and category
    const shapes = [];
    const bbox = new THREE.Box3().setFromObject(model);
    
    // Helper function to add a box shape
    const addBoxShape = (center, size, rotation = 0) => {
      shapes.push({
        type: 'box',
        center: center.clone(),
        halfExtents: size.clone().multiplyScalar(0.5),
        rotation: rotation
      });
    };
    
    // Helper function to add a sphere shape
    const addSphereShape = (center, radius) => {
      shapes.push({
        type: 'sphere',
        center: center.clone(),
        radius: radius
      });
    };
    
    // Different collision shape strategies based on category
    switch(category) {
      case 'rocks':
        // For rocks, use 1-3 overlapping boxes based on size
        const rockSize = bbox.getSize(new THREE.Vector3());
        const rockCenter = new THREE.Vector3();
        bbox.getCenter(rockCenter);
        
        // Main box
        addBoxShape(rockCenter, rockSize);
        
        // For larger rocks, add 1-2 more boxes at slight offsets for better shape approximation
        if (rockSize.x > 1.5 * scale || rockSize.z > 1.5 * scale) {
          // Add a second box, slightly offset and rotated
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3 * rockSize.x,
            0,
            (Math.random() - 0.5) * 0.3 * rockSize.z
          );
          
          const secondSize = new THREE.Vector3(
            rockSize.x * (0.7 + Math.random() * 0.3),
            rockSize.y * 0.9,
            rockSize.z * (0.7 + Math.random() * 0.3)
          );
          
          addBoxShape(rockCenter.clone().add(offset), secondSize, Math.PI * 0.25);
          
          // For very large rocks, add a third box
          if (rockSize.x > 2.5 * scale || rockSize.z > 2.5 * scale) {
            const thirdOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4 * rockSize.x,
              rockSize.y * 0.2,
              (Math.random() - 0.5) * 0.4 * rockSize.z
            );
            
            const thirdSize = new THREE.Vector3(
              rockSize.x * (0.6 + Math.random() * 0.2),
              rockSize.y * 0.7,
              rockSize.z * (0.6 + Math.random() * 0.2)
            );
            
            addBoxShape(rockCenter.clone().add(thirdOffset), thirdSize, Math.PI * 0.125);
          }
        }
        break;
        
      case 'flora':
        // For flora, use a smaller box for the base and a sphere for the top
        const floraSize = bbox.getSize(new THREE.Vector3());
        const floraCenter = new THREE.Vector3();
        bbox.getCenter(floraCenter);
        
        // Box for the base/stem
        const stemSize = new THREE.Vector3(
          floraSize.x * 0.2,
          floraSize.y * 0.6,
          floraSize.z * 0.2
        );
        
        const stemCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (stemSize.y / 2),
          floraCenter.z
        );
        
        addBoxShape(stemCenter, stemSize);
        
        // Sphere for the top/foliage
        const foliageCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (floraSize.y * 0.7),
          floraCenter.z
        );
        
        const foliageRadius = Math.max(floraSize.x, floraSize.z) * 0.5;
        addSphereShape(foliageCenter, foliageRadius);
        break;
        
      case 'mountains':
        // For mountains, use a pyramid-like composition of boxes
        const mountainSize = bbox.getSize(new THREE.Vector3());
        const mountainCenter = new THREE.Vector3();
        bbox.getCenter(mountainCenter);
        
        // Base box (wider)
        const baseSize = new THREE.Vector3(
          mountainSize.x,
          mountainSize.y * 0.3,
          mountainSize.z
        );
        
        const baseCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + (baseSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(baseCenter, baseSize);
        
        // Middle box (narrower)
        const middleSize = new THREE.Vector3(
          mountainSize.x * 0.8,
          mountainSize.y * 0.4,
          mountainSize.z * 0.8
        );
        
        const middleCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + (middleSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(middleCenter, middleSize);
        
        // Top box (narrowest)
        const topSize = new THREE.Vector3(
          mountainSize.x * 0.5,
          mountainSize.y * 0.3,
          mountainSize.z * 0.5
        );
        
        const topCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + middleSize.y + (topSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(topCenter, topSize);
        break;
        
      case 'crystals':
        // For crystals, use a combination of boxes at different angles
        const crystalSize = bbox.getSize(new THREE.Vector3());
        const crystalCenter = new THREE.Vector3();
        bbox.getCenter(crystalCenter);
        
        // Calculate a better fitting box size (narrower)
        const mainCrystalSize = new THREE.Vector3(
          crystalSize.x * 0.7,
          crystalSize.y,
          crystalSize.z * 0.7
        );
        
        // Add the main crystal shape
        addBoxShape(crystalCenter, mainCrystalSize, model.rotation.y);
        
        // For larger crystals, add some angled shards
        if (crystalSize.y > 1.0 * scale) {
          // Add up to 3 additional shards
          const shardCount = 1 + Math.floor(Math.random() * 3);
          
          for (let i = 0; i < shardCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = crystalSize.x * 0.3;
            
            const offset = new THREE.Vector3(
              Math.cos(angle) * distance,
              crystalSize.y * (Math.random() * 0.2),
              Math.sin(angle) * distance
            );
            
            const shardSize = new THREE.Vector3(
              crystalSize.x * (0.2 + Math.random() * 0.3),
              crystalSize.y * (0.4 + Math.random() * 0.4),
              crystalSize.z * (0.2 + Math.random() * 0.3)
            );
            
            const shardRotation = Math.random() * Math.PI;
            addBoxShape(crystalCenter.clone().add(offset), shardSize, shardRotation);
          }
        }
        break;
        
      case 'groundFeatures':
        // For ground features, use a more accurate horizontal shape with the right height
        const groundSize = bbox.getSize(new THREE.Vector3());
        const groundCenter = new THREE.Vector3();
        bbox.getCenter(groundCenter);
        
        // Just use a single box but with better proportions
        const adjustedSize = new THREE.Vector3(
          groundSize.x,
          groundSize.y * 0.7, // Lower height to prevent floating
          groundSize.z
        );
        
        // Center it properly on the ground
        const adjustedCenter = new THREE.Vector3(
          groundCenter.x,
          bbox.min.y + (adjustedSize.y / 2),
          groundCenter.z
        );
        
        addBoxShape(adjustedCenter, adjustedSize, model.rotation.y);
        break;
        
      case 'centerpiece':
        // For centerpiece, create a custom multi-part shape
        const centerpieceSize = bbox.getSize(new THREE.Vector3());
        const centerpieceCenter = new THREE.Vector3();
        bbox.getCenter(centerpieceCenter);
        
        // Main box
        addBoxShape(centerpieceCenter, centerpieceSize);
        
        // Add a sphere on top for the crystal parts
        const sphereCenter = new THREE.Vector3(
          centerpieceCenter.x,
          centerpieceCenter.y + (centerpieceSize.y * 0.2),
          centerpieceCenter.z
        );
        
        const sphereRadius = Math.max(centerpieceSize.x, centerpieceSize.z) * 0.6;
        addSphereShape(sphereCenter, sphereRadius);
        break;
        
      default:
        // Default: just use a box based on the bounding box
        const size = bbox.getSize(new THREE.Vector3());
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        addBoxShape(center, size);
        break;
    }
    
    return shapes;
  }

  updateOtherPlayers() {
    if (!this.networkManager || !this.multiplayerEnabled || !this.assetLoader) return;
  
    const otherPlayers = this.networkManager.getOtherPlayers();
    if (!this.otherPlayerObjects) this.otherPlayerObjects = {};
  
    otherPlayers.forEach(playerData => {
      let playerObject = this.otherPlayerObjects[playerData.id];
  
      if (!playerObject) {
        console.log('Creating new player representation for:', playerData.id);
        const shipType = (playerData.shipType || 'STANDARD').toUpperCase();
        const shipModel = this.assetLoader.getOpponentShipModel(shipType);
  
        if (!shipModel) {
          console.warn(`No model found for ship type: ${shipType}, falling back to default`);
          // Fallback geometry if model fails
          const geometry = new THREE.ConeGeometry(0.5, 1.0, 8);
          geometry.rotateX(Math.PI / 2);
          const material = new THREE.MeshPhongMaterial({ 
            color: playerData.teamColor || 0x00ffff,
            emissive: playerData.teamColor || 0x00ffff,
            emissiveIntensity: 0.5
          });
          const ship = new THREE.Mesh(geometry, material);
          this.scene.add(ship);
          playerObject = { ship, lastUpdate: Date.now() };
        } else {
          // Scale the model consistently (matching player ship scaling)
          shipModel.scale.set(0.45, 0.45, 0.45);
          this.scene.add(shipModel);
          playerObject = { ship: shipModel, lastUpdate: Date.now() };
        }
  
        // Add engine glow
        const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
        engineGlow.position.set(0, 0, -0.7);
        playerObject.ship.add(engineGlow);
        playerObject.engineGlow = engineGlow;
  
        // Add name label
        const nameDiv = document.createElement('div');
        nameDiv.className = 'player-label';
        nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
        const nameLabel = new CSS2DObject(nameDiv);
        nameLabel.position.set(0, 1.8, 0);
        playerObject.ship.add(nameLabel);
        playerObject.nameLabel = nameLabel;
  
        this.otherPlayerObjects[playerData.id] = playerObject;
      }
  
      // Update position and rotation
      if (playerData.position) {
        playerObject.ship.position.lerp(
          new THREE.Vector3(playerData.position.x, playerData.position.y || 0.5, playerData.position.z),
          0.3
        );
      }
      if (playerData.rotation !== undefined) {
        const targetY = playerData.rotation;
        let rotDiff = targetY - playerObject.ship.rotation.y;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerObject.ship.rotation.y += rotDiff * 0.3;
      }
  
      playerObject.lastUpdate = Date.now();
    });
  
    // Clean up disconnected players
    const now = Date.now();
    Object.keys(this.otherPlayerObjects).forEach(id => {
      const playerObj = this.otherPlayerObjects[id];
      if (now - playerObj.lastUpdate > 10000) {
        console.log('Removing disconnected player:', id);
        this.scene.remove(playerObj.ship);
        delete this.otherPlayerObjects[id];
        this.updatePlayerCount();
      }
    });
  }

  // Helper method to send player position and rotation to the server
  sendPlayerPositionUpdate() {
    if (!this.playerShip || !this.networkManager || !this.networkManager.isConnected()) return;
    
    // Create a simple data object with player information
    const playerData = {
      position: {
        x: this.playerShip.position.x,
        y: this.playerShip.position.y,
        z: this.playerShip.position.z
      },
      rotation: this.playerShip.rotation.y,
      shipType: this.currentShipType || 'STANDARD',
      name: this.playerName
    };
    
    // Send the update to the network manager
    this.networkManager.sendPlayerUpdate(playerData);
  }

  // Add the missing setShipModel function
  setShipModel(type) {
    console.log('🔍 Setting ship model:', type);
    
    // Get the ship model from assets
    let model = this.assetLoader.getShipModel(type);
    
    // If model is null or undefined, create fallback model
    if (!model) {
      console.warn('⚠️ Using fallback ship model for type:', type);
      
      // Create a simple geometric shape as fallback
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, 
        specular: 0x111111, 
        shininess: 30 
      });
      model = new THREE.Mesh(geometry, material);
    }
    
    // Clear existing player ship if it exists
    if (this.playerShip) {
      if (this.scene) {
        this.scene.remove(this.playerShip);
      }
      this.playerShip = null;
    }
    
    // Set the new ship model
    this.playerShip = model;
    
    // Position the ship appropriately
    if (this.playerShip && this.scene) {
      this.playerShip.position.set(0, 0.5, 0);
      this.scene.add(this.playerShip);
    }
    
    return this.playerShip;
  }

  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.soundManager) {
      console.log(`Playing sound: ${name}`);
      this.soundManager.playSound(name, position);
    } else {
      console.warn(`Cannot play sound '${name}': SoundManager not initialized`);
    }
  }

  /**
   * Update a remote player's position and rotation
   * @param {string} id - Player ID
   * @param {Object} position - Position coordinates
   * @param {Object} rotation - Rotation coordinates
   */
  updateRemotePlayer(id, position, rotation) {
    // Get existing player or create a new one
    let player = this.remotePlayers.get(id);
    
    if (!player) {
      // Create a new player mesh if this is the first update
      player = this.createRemotePlayerMesh();
      this.remotePlayers.set(id, player);
      this.scene.add(player);
      console.log(`Created new remote player: ${id}`);
    }
    
    // Update player position and rotation
    if (position) {
      player.position.set(position.x, position.y, position.z);
    }
    
    if (rotation) {
      player.rotation.set(rotation.x, rotation.y, rotation.z);
    }
  }
  
  /**
   * Create a mesh for a remote player
   * @returns {THREE.Object3D} Player mesh
   */
  createRemotePlayerMesh() {
    // For simplicity, we'll use a simple colored box for remote players
    const geometry = new THREE.BoxGeometry(1, 1, 2);
    const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red for other players
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'player-label';
    nameLabel.textContent = 'Player';
    
    const playerLabel = new CSS2DObject(nameLabel);
    playerLabel.position.set(0, 1.5, 0);
    mesh.add(playerLabel);
    
    return mesh;
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize game
  const game = new SimpleGame();
  
  // Add start button event listener
  document.getElementById('start-button').addEventListener('click', () => {
    // Get the player name from the input field
    const playerNameInput = document.getElementById('player-name');
    if (playerNameInput && playerNameInput.value.trim() !== '') {
      // Store the player name
      game.playerName = playerNameInput.value.trim();
      console.log(`Player name set to: ${game.playerName}`);
    } else {
      console.log('Using default player name: ' + game.playerName);
    }
    
    // Start the game
    game.startGame();
  });
}); 
### ./index.js END ###

### ./codebase.md BEGIN ###
### DIRECTORY . FOLDER STRUCTURE ###
./
    index.html
    flatten.py
    index.js
    codebase.md
    ui/
        ShipSelectionUI.js
        GameRoom.js
        GameUI.js
        MiniMap.js
    scenes/
        TeamDemo.js
    core/
        Game.js
        TeamManager.js
        Scene.js
        GameEngine.js
        Engine.js
        NetworkManager.js
        InfiniteMap.js
    config/
        ShipConfig.js
        Controls.js
        GameConfig.js
    constants/
    utils/
    styles/
        main.css
        controls.css
    effects/
    assets/
        ModelLoader.js
        SoundManager.js
        .DS_Store
        AssetLoader.js
        textures/
        images/
        models/
            .DS_Store
            textures/
                tex.png
                Colors3.png
            ships/
                ALTSPACE2.glb
                ALTSPACE1.glb
            flora/
                Grass_01.glb
                .DS_Store
                SmalRoots_01.glb
                BigPlant_06.glb
                SP_Plant08.glb
                SP_Plant07.glb
                Mushrooms.glb
                SP_Tree04.glb
                SP_Tree02.glb
                SP_Tree03.glb
                SP_Tree01.glb
                Tenticles_01.glb
            objects/
                .DS_Store
                SP_Stone01.glb
                SP_Mountain03.glb
                SP_Mountain02.glb
                SP_Mountain01.glb
                SP_Ground03.glb
                SP_Ground02.glb
                SP_Ground05.glb
                SP_Ground04.glb
            terrain/
                .DS_Store
                Water.glb
                Terrain.glb
            rocks/
                SP_Rock01.glb
                SP_Rock03.glb
                SP_Rock02.glb
                SP_Rock06.glb
                .DS_Store
                SP_Rock07.glb
                SP_Rock05.glb
                SP_Rock04.glb
                SP_Rock09.glb
                SP_Rock08.glb
        sounds/
            weapon-switch.mp3
            laser.mp3
            bounce.mp3
            weapon-charging.mp3
            grenade-laser.mp3
            laser-bounce.mp3
            weapon-armor-hit.mp3
    entities/
        Ship.js
        obstacles/
        weapons/
            RegularLaser.js
            WeaponSystem.js
            Laser.js
        enemies/
            EnemyManager.js
            Enemy.js
        player/
            Player.js
### DIRECTORY . FOLDER STRUCTURE ###

### DIRECTORY . FLATTENED CONTENT ###
### ./index.html BEGIN ###
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/main.css">
    <link rel="stylesheet" href="./styles/controls.css">
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="loader"></div>
            <p>Loading the quantum realm...</p>
        </div>
    </div>
    
    <div id="start-screen" class="hidden">
        <div class="start-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="player-input">
                <input type="text" id="player-name" maxlength="15" placeholder="Enter your pilot name" />
                <p class="input-info">Your name will be visible to other players</p>
            </div>
            <button id="start-button" class="glow-button">START GAME</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>
    
    <!-- Multiplayer Info -->
    <div id="multiplayer-info" class="hidden">
        <div class="connection-indicator">
            <span>Connection: </span>
            <span id="connection-status">Disconnected</span>
        </div>
        <div class="players-indicator">
            <span>Players: </span>
            <span id="players-count">0</span>
        </div>
    </div>
    
    <!-- Simple HUD for controls info -->
    <div class="controls-info hidden">
        <p>W/↑: Forward | S/↓: Backward</p>
        <p>A/← D/→: Rotate Ship</p>
        <p>Q/E: Strafe Left/Right</p>
        <p>Space: Fire Laser</p>
        <p>Avoid the colored obstacles!</p>
    </div>
</body>
<script type="module" src="./index.js"></script>
</html> 
### ./index.html END ###

### ./flatten.py BEGIN ###
import os
import argparse

def printFolderStructure(directory, output_file):
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n")
    for root, directories, files in os.walk(directory):
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write('{}{}/\n'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            output_file.write('{}{}\n'.format(subindent, f))
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n\n")

def walkFolderTree(folder):
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            yield os.path.join(dirpath, filename)

def main():
    parser = argparse.ArgumentParser(description='Flattens a codebase.')
    parser.add_argument('--folders', nargs='*', help='Base folders to process')
    parser.add_argument('--system_instructions', action='store_true', help='Print system instructions')

    system_instructions = """## System Instructions for Language Model Assistance in Code Debugging

### Role Definition:
- **Act as a software engineer** tasked with assisting in debugging code.
- Provide insights, explanations, and solutions based on the provided codebase information.

### Codebase Markdown File Structure:
- The codebase markdown file represents the actual codebase structure and content.
- It begins with a directory tree representation:
  ```
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  (file tree representation)
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  ```
- Following the directory tree, the contents of each file are displayed:
  ```
  ### path/to/file1 BEGIN ###
  (content of file1)
  ### path/to/file1 END ###
  
  ### path/to/file2 BEGIN ###
  (content of file2)
  ### path/to/file2 END ###
  ```

### Guidelines for Interaction:
- Respond to queries based on the explicit content provided within the markdown file.
- Avoid making assumptions about the code without clear evidence presented in the file content.
- When seeking specific implementation details, refer to the corresponding section in the markdown file, for example:
  ```
  ### folder1/folder2/myfile.ts BEGIN ###
  (specific implementation details)
  ### folder1/folder2/myfile.ts END ###
  ```

### Objective:
- The primary objective is to facilitate effective debugging by providing accurate information and guidance strictly adhering to the content available in the markdown file."""

    args = parser.parse_args()

    if args.system_instructions:
        print(system_instructions)

        if not args.folders:
            return

    if args.folders:
        base_folders = args.folders
        with open('codebase.md', 'w') as output_file:
            for base_folder in base_folders:
                printFolderStructure(base_folder, output_file)
                
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
                for filepath in walkFolderTree(base_folder):
                    content = f"### {filepath} BEGIN ###\n"
                    
                    try:
                        with open(filepath, "r") as f:
                            content += f.read()
                        content += f"\n### {filepath} END ###\n\n"
                    except:
                        continue
                    
                    output_file.write(content)
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
    else:
        print("usage: main.py [-h] --folders FOLDERS [FOLDERS ...] [--system_instructions]")
        print("Error: the following arguments are required: --folders")

if __name__ == "__main__":
    main()
### ./flatten.py END ###

### ./index.js BEGIN ###
import * as THREE from 'three';
import { OrbitControls } from '@three/examples/controls/OrbitControls';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import './styles/main.css';
import { GameUI } from './ui/GameUI';
import { MiniMap } from './ui/MiniMap';
import { CONTROL_SETTINGS, CONTROL_FEEDBACK, DEFAULT_CONTROL_STATE, ControlUtils } from './config/Controls';
import { ShipSelectionUI } from './ui/ShipSelectionUI';
import AssetLoader from './assets/AssetLoader';
import { InfiniteMap } from './core/InfiniteMap';
import { NetworkManager } from './core/NetworkManager';
import { CSS2DRenderer, CSS2DObject } from '@three/examples/renderers/CSS2DRenderer';
import { GAME_CONFIG } from './config/GameConfig';
import { Player } from './entities/player/Player';
import { SoundManager } from './assets/SoundManager';

// Basic Three.js game with a ship
class SimpleGame {
  constructor() {
    // Initialize all properties first
    // Player information
    this.playerName = 'Pilot';  // Default player name
    
    // Create the asset loader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => this.updateLoadingUI(message),
      (type, error) => this.handleLoadError(type, error)
    );
    
    // Initialize SoundManager
    this.soundManager = new SoundManager();
    
    // Asset loading state
    this.loadingState = {
      started: false,
      completed: false,
      errors: []
    };
    
    // Track assets loading
    this.assetsLoaded = false;
    this.shipModelLoaded = false;
    
    // Initialize control state
    this.keys = { ...DEFAULT_CONTROL_STATE };
    
    // Setup animation timing
    this.clock = new THREE.Clock();
    this.lastTime = Date.now();
    
    // Event handling - bind methods
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    
    // Debounce timers
    this.mouseMoveTimer = null;
    this.resizeTimer = null;
    this.weaponCooldowns = new Map();
    this.lastWeaponSwitch = 0;

    // Setup basic Three.js scene
    this.setupScene();
    
    // Create game UI
    this.ui = new GameUI();
    
    // Create player after scene setup (as specified in Task 8)
    this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
      type: 'PLAYER',
      shipModel: 'STANDARD',
      teamColor: 0x00ffff
    });
    this.scene.add(this.player.mesh);
    
    // For backward compatibility with existing code
    this.playerShip = this.player.mesh;
    
    // Game properties
    this.boundarySize = 100; // Size of the playable area
    
    // Initialize player state
    this.health = 100;
    this.maxHealth = 100;
    this.energy = 100;
    this.maxEnergy = 100;
    this.energyRechargeRate = 20; // Units per second
    this.currentWeapon = 'LASER';
    
    // Initialize available weapons
    this.availableWeapons = ['LASER', 'GRENADE', 'BOUNCE'];
    this.weaponIndex = 0; // Start with LASER
    
    // Load assets
    this.loadAssets();
    
    // Setup controls
    this.setupControls();
    
    // Initialize infinite map after scene setup
    this.infiniteMap = new InfiniteMap(this);
    
    // Create mini-map (after scene setup) but keep it hidden initially
    this.miniMap = new MiniMap(this);
    this.miniMap.hide(); // Make sure it starts hidden
    
    // Handle window resize
    window.addEventListener('resize', this.boundHandleResize);
    
    console.log('Simple game initialized!');

    // Add frame counter
    this.frameCount = 0;
    
    // Initialize NetworkManager
    this.networkManager = new NetworkManager();
    
    // Initialize remotePlayers map for multiplayer
    this.remotePlayers = new Map();
    
    this.networkManager.on('connected', () => {
      console.log('Connected to game server!');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from game server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      // Update player count
      this.updatePlayerCount();
    });
    
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      // Remove player mesh if it exists
      const player = this.remotePlayers.get(id);
      if (player) {
        this.scene.remove(player);
        this.remotePlayers.delete(id);
        console.log(`Removed remote player: ${id}`);
      }
      // Update player count
      this.updatePlayerCount();
    });
    
    // Add player update handling
    this.networkManager.on('player_update', (data) => {
      this.updateRemotePlayer(data.id, data.position, data.rotation);
    });
    
    // Add laser shot handling
    this.networkManager.on('laser_shot', (shotData) => {
      console.log('Received laser shot from network:', shotData);
      const position = new THREE.Vector3(shotData.origin.x, shotData.origin.y, shotData.origin.z);
      const direction = new THREE.Vector3(shotData.direction.x, shotData.direction.y, shotData.direction.z);

      if (shotData.type === 'bounce') {
        this.fireBouncingLaser(position, direction);
      } else {
        this.fireLaser(position, direction);
      }
    });
    
    // Add helper method to update player count
    this.updatePlayerCount = () => {
      const count = this.networkManager.getOtherPlayers().length + 1; // +1 for self
      document.getElementById('players-count').textContent = count;
    };
    
    this.multiplayerEnabled = false;
  }
  
  setupScene() {
    // Create Three.js Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a1f); // Dark blue background
    
    // Setup WebGL renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(this.renderer.domElement);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near
      1000 // Far
    );
    
    // Position camera
    this.camera.position.set(0, 7, 15); // Slightly above and behind player
    this.camera.lookAt(0, 0, 0);
    
    // Attach audio listener to camera
    if (this.soundManager) {
      this.camera.add(this.soundManager.getListener());
      console.log('Audio listener attached to camera');
    }
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);
    
    // Create a simple grid floor
    this.createFloor();
    
    // Create some obstacles
    this.createObstacles();
  }
  
  async loadAssets() {
    if (this.loadingState.started) {
        console.warn('🔍 Asset loading already in progress');
        return;
    }
    
    this.updateLoadingUI('Loading game assets...');
    
    try {
        // Create initial player with default ship
        if (!this.player) {
            this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
                type: 'PLAYER',
                shipModel: 'STANDARD',
                teamColor: 0x00ffff
            });
            this.playerShip = this.player.mesh; // For backward compatibility
        }
        
        // Load all assets through AssetLoader
        await this.assetLoader.loadAll();
        this.assetsLoaded = true;
        this.shipModelLoaded = true;
        
        console.log('✅ All assets loaded successfully');
        this.checkLoadingProgress();
    } catch (error) {
        console.error('🔍 Critical error loading assets:', error);
        this.handleLoadError('critical', error);
    }
  }
  
  handleLoadError(assetType, error) {
    console.error(`Error loading ${assetType}:`, error);
    this.loadingState.errors.push({ type: assetType, error: error.message });
    
    // Update UI with error
    this.updateLoadingUI(`Error loading ${assetType}. ${this.loadingState.errors.length} errors total.`);
    
    // If critical error, show error screen
    if (assetType === 'critical') {
      this.showErrorScreen('Failed to load game assets. Please refresh the page.');
    }
  }
  
  updateLoadingUI(message) {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const messageElement = loadingScreen.querySelector('.loading-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  }
  
  showErrorScreen(message) {
    // Create error screen if it doesn't exist
    let errorScreen = document.getElementById('error-screen');
    if (!errorScreen) {
      errorScreen = document.createElement('div');
      errorScreen.id = 'error-screen';
      errorScreen.className = 'error-screen';
      
      const errorMessage = document.createElement('div');
      errorMessage.className = 'error-message';
      errorScreen.appendChild(errorMessage);
      
      const retryButton = document.createElement('button');
      retryButton.textContent = 'Retry';
      retryButton.onclick = () => {
        errorScreen.remove();
        this.loadingState = {
          started: false,
          completed: false,
          errors: []
        };
        this.loadAssets();
      };
      errorScreen.appendChild(retryButton);
      
      document.body.appendChild(errorScreen);
    }
    
    // Update error message
    const messageElement = errorScreen.querySelector('.error-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
  }
  
  checkLoadingProgress() {
    console.log('🔍 Checking loading progress...');
    
    // Log loading state
    console.log('Loading state:', JSON.stringify(this.loadingState, null, 2));
    
    // Define what's required for a fully loaded game
    const requiredAssets = {
      shipModel: this.shipModelLoaded,
      assetsLoaded: this.assetLoader.loadingState.completed
    };
    
    // Check if all required assets are loaded
    const allAssetsLoaded = Object.entries(requiredAssets).every(([key, loaded]) => {
      console.log(`🔍 ${key}: ${loaded ? '✅' : '❌'}`);
      return loaded;
    });
    
    if (allAssetsLoaded) {
      console.log('✅ All required assets loaded!');
      this.loadingState.completed = true;
      this.showStartScreen();
    } else {
      // Log which assets are still pending
      const pendingAssets = Object.entries(requiredAssets)
        .filter(([_, loaded]) => !loaded)
        .map(([key]) => key);
      console.log('⏳ Still waiting for:', pendingAssets);
      
      // Update loading UI
      this.updateLoadingUI(`Loading... (${pendingAssets.join(', ')})`);
      
      // Check again after a delay
      setTimeout(() => this.checkLoadingProgress(), 1000);
    }
  }
  
  showStartScreen() {
    console.log('🔍 Attempting to show start screen');
    
    // Timeout to ensure UI has time to update
    setTimeout(() => {
      // Hide loading screen and show start screen
      const loadingScreen = document.getElementById('loading-screen');
      const startScreen = document.getElementById('start-screen');
      
      console.log('🔍 Loading screen element:', loadingScreen);
      console.log('🔍 Start screen element:', startScreen);
      
      if (loadingScreen) {
        console.log('🔍 Adding fade-out class to loading screen');
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          loadingScreen.classList.add('hidden');
          loadingScreen.classList.remove('fade-out');
          console.log('🔍 Loading screen hidden');
        }, 500);
      } else {
        console.error('🔍 Loading screen element not found!');
      }
      
      if (startScreen) {
        console.log('🔍 Showing start screen');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('fade-in');
      } else {
        console.error('🔍 Start screen element not found!');
      }
      
      console.log('🔍 Game ready to start!');
    }, 500);
  }
  
  addThrusterGlow() {
    // Check if player and player mesh exist
    if (!this.player || !this.player.mesh) {
      console.warn('Cannot add thruster glow: Player or player mesh is not initialized');
      return;
    }
    
    // Create a single, efficient thruster glow effect
    // Use instanced mesh for better performance if you have multiple thrusters
    
    // Create a glow for the thruster
    const thrusterGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 12);
    const thrusterMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending // Use additive blending for better glow effect
    });
    
    const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
    thruster.position.set(0, 0, -0.7); // Position at the back of the ship
    thruster.rotation.x = Math.PI / 2;
    thruster.name = 'thruster'; // Name it for easier reference later
    
    // Add thruster to player mesh
    this.player.mesh.add(thruster);
    
    // Add point light for the thruster
    const thrusterLight = new THREE.PointLight(0x00ffff, 1, 3);
    thrusterLight.position.copy(thruster.position);
    thrusterLight.name = 'thrusterLight';
    
    // Store references for animation
    this.thruster = thruster;
    this.thrusterLight = thrusterLight;
    
    // Create a subtle, animated glow effect with proper initialization
    this.thrusterPulse = { 
      value: 0,
      phase: 0 
    };
    
    // Add to ship model
    if (this.shipModel) {
      this.shipModel.add(thruster);
      this.shipModel.add(thrusterLight);
    }
  }
  
  createFloor() {
    console.log('Creating floor with Terrain.glb model');
    
    // Create a placeholder floor initially - this will be visible until the model loads
    const tempFloorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);
    const tempFloorMaterial = new THREE.MeshBasicMaterial({
      color: 0x000022,
      transparent: true,
      opacity: 0.2,
    });
    
    this.floor = new THREE.Mesh(tempFloorGeometry, tempFloorMaterial);
    this.floor.rotation.x = -Math.PI / 2;
    this.floor.position.y = -0.01;
    this.scene.add(this.floor);
    
    // Also create an invisible raycasting plane that will always work for targeting
    // This ensures mouse input works consistently regardless of the visual floor model
    this.raycastFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        transparent: true, 
        opacity: 0.05, // Very slight visibility for debugging
        side: THREE.DoubleSide
      })
    );
    this.raycastFloor.rotation.x = -Math.PI / 2;
    this.raycastFloor.position.y = 0.1; // Position higher above terrain
    this.scene.add(this.raycastFloor);
    
    // Add debug logging
    console.log('Raycast floor created at height:', this.raycastFloor.position.y, 'and size:', 1000);
    
    // Load texture first
    const textureLoader = new THREE.TextureLoader();
    const texturePromise = new Promise((resolve, reject) => {
      textureLoader.load(
        'assets/models/textures/Colors3.png', 
        texture => {
          console.log('Terrain texture (Colors3.png) loaded successfully');
          // Configure texture 
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(8, 8); // Repeat the texture more times for better detail
          resolve(texture);
        },
        undefined,
        error => {
          console.error('Error loading Colors3.png texture:', error);
          // Try fallback texture
          textureLoader.load(
            'assets/models/textures/tex.png', 
            fallbackTexture => {
              console.log('Fallback texture loaded');
              fallbackTexture.wrapS = THREE.RepeatWrapping;
              fallbackTexture.wrapT = THREE.RepeatWrapping;
              fallbackTexture.repeat.set(5, 5);
              resolve(fallbackTexture);
            },
            undefined,
            fallbackError => {
              console.error('Error loading fallback texture:', fallbackError);
              resolve(null); // Resolve with null to continue without texture
            }
          );
        }
      );
    });
    
    // When texture is loaded (or failed), get the terrain model from AssetLoader
    texturePromise.then(texture => {
      // Get terrain model from AssetLoader
      const terrain = this.assetLoader.getModel('terrain/Terrain.glb');
      
      if (terrain) {
        console.log('Using terrain model from AssetLoader');
        
        // Remove the temporary floor
        if (this.floor) {
          this.scene.remove(this.floor);
          this.floor.geometry.dispose();
          this.floor.material.dispose();
        }
        
        // Clone the model to avoid modifying the original
        const terrainClone = terrain.clone();
        
        // Scale the terrain appropriately
        const terrainScale = 100; // Adjust this value to change the overall size
        terrainClone.scale.set(terrainScale, terrainScale * 0.5, terrainScale);
        
        // Position terrain at center and slightly below zero to avoid z-fighting
        terrainClone.position.set(0, -0.2, 0);
        
        // Apply texture if available
        if (texture) {
          terrainClone.traverse((node) => {
            if (node.isMesh) {
              node.material = node.material.clone(); // Clone material to avoid affecting other instances
              node.material.map = texture;
              node.material.needsUpdate = true;
              
              // Enable shadows
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
        }
        
        // Add to scene
        this.scene.add(terrainClone);
        this.terrain = terrainClone;
        
        console.log('Terrain model added to scene');
        
        // Add a circular highlight around the player's position
        this.createPlayerHighlight();
      } else {
        console.warn('Terrain model not found in AssetLoader, using fallback grid');
        
        // Create a grid as fallback
        const grid = new THREE.GridHelper(100, 100, 0x0000ff, 0x000044);
        grid.position.y = 0;
        this.scene.add(grid);
        this.terrain = grid;
        
        // Add player highlight anyway
        this.createPlayerHighlight();
      }
    });
  }

  // Separate method for player highlight to avoid code duplication
  createPlayerHighlight() {
    // Add a circular highlight around the player's position
    const highlightGeometry = new THREE.CircleGeometry(5, 32);
    const highlightMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
    });
    
    this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    this.playerHighlight.rotation.x = -Math.PI / 2;
    this.playerHighlight.position.y = 0.02; // Slightly above the floor
    this.scene.add(this.playerHighlight);
  }
  
  createBoundaryMarkers() {
    const boundarySize = 25; // Should match constrainToBounds boundary
    const markerSize = 1;
    const markerHeight = 1;
    const numMarkers = 10; // Number of markers per side
    
    const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
    const markerMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0x600000,
      transparent: true,
      opacity: 0.7
    });
    
    const markers = new THREE.Group();
    
    // Create boundary markers along the perimeter
    for (let i = 0; i < numMarkers; i++) {
      const t = (i / (numMarkers - 1)) * 2 - 1; // -1 to 1
      const position = boundarySize * t;
      
      // North edge
      const northMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      northMarker.position.set(position, markerHeight / 2, -boundarySize);
      markers.add(northMarker);
      
      // South edge
      const southMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      southMarker.position.set(position, markerHeight / 2, boundarySize);
      markers.add(southMarker);
      
      // East edge
      const eastMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      eastMarker.position.set(boundarySize, markerHeight / 2, position);
      markers.add(eastMarker);
      
      // West edge
      const westMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      westMarker.position.set(-boundarySize, markerHeight / 2, position);
      markers.add(westMarker);
    }
    
    this.scene.add(markers);
  }
  
  createObstacles() {
    // Create obstacle arrays
    this.obstacles = [];
    
    console.log('🚧 Creating immersive landscape with pathways and scattered crystals');
    
    // Define model categories and paths, with a focus on variety and character
    const obstacleCategories = {
      // Small to medium rocks
      rocks: [
        'SP_Rock01.glb', 
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      // Expanded flora selection
      flora: [
        'Grass_01.glb',
        'Mushrooms.glb',
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SmalRoots_01.glb',
        'Tenticles_01.glb',
        'BigPlant_06.glb'
      ],
      // Expanded ground features for creating pathways
      groundFeatures: [
        'objects/SP_Ground02.glb',
        'objects/SP_Ground03.glb',
        'objects/SP_Ground04.glb',
        'objects/SP_Ground05.glb'
      ],
      // Crystal clusters for interest points
      crystals: [
        'objects/SP_Crystal01.glb',
        'objects/SP_Stone01.glb'
      ],
      // Mountains for landscape borders and key landmarks
      mountains: [
        'objects/SP_Mountain01.glb',
        'objects/SP_Mountain02.glb',
        'objects/SP_Mountain03.glb'
      ]
    };
    
    // Enhanced distribution for a more detailed landscape
    const distribution = {
      rocks: 8,
      flora: 10,
      groundFeatures: 18,  // Increased from 12 to 18
      crystals: 9,
      mountains: 12  // Increased from 4 to 12
    };
    
    // Define some pre-made templates for object groupings
    const templates = [
      // Rock garden template
      {
        position: new THREE.Vector3(25, 0, 15),
        rotation: Math.PI / 6,
        elements: [
          { category: 'rocks', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 2.0, rotation: 0 },
          { category: 'rocks', modelIndex: 2, offset: new THREE.Vector3(3, 0, 1), scale: 1.3, rotation: Math.PI/3 },
          { category: 'rocks', modelIndex: 1, offset: new THREE.Vector3(-2, 0, 2), scale: 1.5, rotation: Math.PI/5 },
          { category: 'flora', modelIndex: 1, offset: new THREE.Vector3(2, 0, 3), scale: 1.2, rotation: 0 }
        ]
      },
      // Flora cluster template
      {
        position: new THREE.Vector3(-20, 0, -18),
        rotation: Math.PI / 4,
        elements: [
          { category: 'flora', modelIndex: 4, offset: new THREE.Vector3(0, 0, 0), scale: 1.8, rotation: 0 },
          { category: 'flora', modelIndex: 0, offset: new THREE.Vector3(2, 0, 2), scale: 1.4, rotation: Math.PI/2 },
          { category: 'flora', modelIndex: 3, offset: new THREE.Vector3(-1.5, 0, 1), scale: 1.2, rotation: Math.PI/6 },
          { category: 'rocks', modelIndex: 3, offset: new THREE.Vector3(1, 0, -2), scale: 1.0, rotation: 0 }
        ]
      },
      // Crystal formation template
      {
        position: new THREE.Vector3(-15, 0, 30),
        rotation: -Math.PI / 3,
        elements: [
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 1.5, rotation: 0 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(1.5, 0, 1), scale: 1.0, rotation: Math.PI/2 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(-1, 0, 1.5), scale: 0.8, rotation: Math.PI/4 },
          { category: 'groundFeatures', modelIndex: 2, offset: new THREE.Vector3(0, -0.2, 0), scale: 1.8, rotation: 0 }
        ]
      }
    ];
    
    // Create main pathways (4 paths coming from center, like a cross)
    const pathways = [
      { direction: new THREE.Vector3(1, 0, 0), width: 5 },   // East
      { direction: new THREE.Vector3(-1, 0, 0), width: 5 },  // West
      { direction: new THREE.Vector3(0, 0, 1), width: 5 },   // North
      { direction: new THREE.Vector3(0, 0, -1), width: 5 }   // South
    ];
    
    // Add some curved pathways to make it more interesting
    pathways.push(
      { 
        direction: new THREE.Vector3(0.7, 0, 0.7), 
        width: 4,
        curve: 0.8 // Will curve around
      },
      { 
        direction: new THREE.Vector3(-0.7, 0, -0.7), 
        width: 4,
        curve: -0.5 // Will curve the other way
      }
    );
    
    // Create some crystal gardens (clusters of crystals)
    const crystalGardens = [
      { x: 30, z: 30, radius: 8, count: 4 },
      { x: -25, z: 20, radius: 6, count: 3 },
      { x: 15, z: -35, radius: 10, count: 5 }
    ];
    
    // Function to check if a position is near a pathway
    const isNearPathway = (x, z, pathWidth) => {
      for (const path of pathways) {
        // Create a vector from center to this position
        const posVector = new THREE.Vector3(x, 0, z);
        const length = posVector.length();
        
        // Normalize the vector to compare direction
        if (length > 0) posVector.divideScalar(length);
        
        // Check if this aligns with any pathway
        const dot = posVector.dot(path.direction);
        
        // If aligned with path direction and not too close to center
        if (dot > 0.7 && length > 15 && length < 40) {
          // Calculate perpendicular distance to path
          const perpFactor = Math.sqrt(1 - dot * dot) * length;
          if (perpFactor < (path.width || pathWidth)) {
            return true;
          }
          
          // For curved paths
          if (path.curve) {
            // Check if in a curved region
            if (length > 20) {
              // Apply curvature - this is simplified but creates a nice effect
              const curveFactor = (length - 20) * path.curve * 0.1;
              const curvePerp = Math.abs(perpFactor - curveFactor);
              if (curvePerp < (path.width || pathWidth)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    
    // Function to check if position is in a crystal garden
    const isInCrystalGarden = (x, z) => {
      for (const garden of crystalGardens) {
        const dx = x - garden.x;
        const dz = z - garden.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance < garden.radius) {
          return garden;
        }
      }
      return null;
    };
    
    // Load and place models as obstacles
    for (const [category, models] of Object.entries(obstacleCategories)) {
      const count = distribution[category];
      
      for (let i = 0; i < count; i++) {
        // Select a random model from this category
        const modelPath = models[Math.floor(Math.random() * models.length)];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Create position based on category
        let x, z;
        let attempts = 0;
        let isValid = false;
        let inGarden = null;
        
        while (!isValid && attempts < 30) {
          attempts++;
          
          if (category === 'groundFeatures') {
            // Ground features go along pathways or in open areas
            if (Math.random() < 0.7) {
              // 70% along pathways
              const angle = Math.random() * Math.PI * 2;
              const distance = 15 + Math.random() * 25; // Between 15-40 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
              
              // If not near a pathway, try again
              if (!isNearPathway(x, z, 6)) continue;
            } else {
              // 30% randomly placed
              x = (Math.random() * 80) - 40;
              z = (Math.random() * 80) - 40;
            }
          } else if (category === 'crystals') {
            // Try to place in crystal gardens
            if (Math.random() < 0.7) {
              // 70% in crystal gardens
              const garden = crystalGardens[Math.floor(Math.random() * crystalGardens.length)];
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * garden.radius;
              x = garden.x + Math.cos(angle) * distance;
              z = garden.z + Math.sin(angle) * distance;
              inGarden = garden;
            } else {
              // 30% scattered elsewhere, avoiding pathways
              x = (Math.random() * 70) - 35;
              z = (Math.random() * 70) - 35;
              
              // If near a pathway, try again
              if (isNearPathway(x, z, 6)) continue;
            }
          } else if (category === 'mountains') {
            // Mountains go on the periphery with more diverse placement
            if (i < 4) {
              // Place 4 mountains at the far corners of the map
              const angle = (Math.PI/4) + (i * Math.PI/2); // Place at 45°, 135°, 225°, 315°
              const distance = 40 + Math.random() * 5; // Between 40-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else if (i < 8) {
              // Place 4 mountains at cardinal directions, but further out
              const angle = (i - 4) * Math.PI/2; // Place at 0°, 90°, 180°, 270°
              const distance = 42 + Math.random() * 8; // Between 42-50 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else {
              // Place remaining mountains randomly but still on periphery
              const angle = Math.random() * Math.PI * 2;
              const distance = 35 + Math.random() * 10; // Between 35-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            }
            
            // If near a pathway, try again (want mountains to border but not block paths)
            if (isNearPathway(x, z, 8)) continue;
          } else {
            // Rocks and flora go anywhere but not on paths
            x = (Math.random() * 80) - 40;
            z = (Math.random() * 80) - 40;
            
            // Avoid pathways for these obstacles
            if (isNearPathway(x, z, 5)) continue;
          }
          
          // Keep all objects away from center spawn
          if (Math.sqrt(x * x + z * z) < 15) continue;
          
          // Position is valid
          isValid = true;
        }
        
        if (!isValid) continue; // Skip if couldn't find valid position
        
        // Scale factors tailored by category and context
        let scale;
        if (category === 'rocks') {
          scale = 1.5 + Math.random() * 1.0; // Larger rocks (1.5-2.5)
        } else if (category === 'flora') {
          scale = 1.2 + Math.random() * 0.8; // Taller flora (1.2-2.0)
        } else if (category === 'groundFeatures') {
          if (isNearPathway(x, z, 6)) {
            // Ground features along pathways have more consistent size
            scale = 1.2 + Math.random() * 0.6; // Medium-sized ground (1.2-1.8)
          } else {
            // Ground features away from pathways can vary more
            scale = 0.8 + Math.random() * 1.4; // Variable ground features (0.8-2.2)
          }
        } else if (category === 'crystals') {
          if (inGarden) {
            // Varied crystal sizes in gardens
            scale = 0.5 + Math.random() * 1.4; // Variety of sizes (0.5-1.9)
          } else {
            // Scattered crystals are smaller
            scale = 0.7 + Math.random() * 0.6; // Smaller scattered (0.7-1.3)
          }
        } else if (category === 'mountains') {
          // More diverse mountain scales based on position
          if (i < 4) {
            // Corner mountains are largest
            scale = 2.2 + Math.random() * 1.3; // Largest mountains (2.2-3.5)
          } else if (i < 8) {
            // Cardinal direction mountains are medium-large
            scale = 1.8 + Math.random() * 1.0; // Medium-large mountains (1.8-2.8)
          } else {
            // Random mountains have varied sizes
            scale = 1.4 + Math.random() * 1.6; // Variable mountains (1.4-3.0)
          }
        }
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale and position
            model.scale.set(scale, scale, scale);
            model.position.set(x, 0, z); // Will adjust y based on model size
            
            // Add randomized rotation, except for ground features on pathways
            if (category === 'groundFeatures' && isNearPathway(x, z, 6)) {
              // Align with nearest pathway for ground features
              const alignAngle = Math.atan2(z, x);
              model.rotation.y = alignAngle + (Math.random() * 0.5 - 0.25); // Slight variation
            } else {
              model.rotation.y = Math.random() * Math.PI * 2;
            }
            
            // Enable shadows with optimization
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Optimize materials while keeping visual quality
                if (node.material) {
                  // Add category-specific visual enhancements
                  if (category === 'crystals' && modelPath.includes('Crystal')) {
                    // Make crystals glow with random colors
                    const crystalColors = [
                      new THREE.Color(0x00ffff), // cyan
                      new THREE.Color(0xff00ff), // magenta
                      new THREE.Color(0x88bbff), // light blue
                      new THREE.Color(0xffaa00)  // orange
                    ];
                    
                    // Random crystal color
                    const crystalColor = crystalColors[Math.floor(Math.random() * crystalColors.length)];
                    node.material.emissive = crystalColor;
                    node.material.emissiveIntensity = 0.3 + Math.random() * 0.3; // 0.3-0.6
                  } else if (category === 'mountains') {
                    // Give mountains a slight purple/blue tint
                    node.material.color = new THREE.Color(0x9090b0);
                  } else if (category === 'groundFeatures') {
                    // Give ground features varied earthy tones
                    const groundColors = [
                      new THREE.Color(0x908070), // tan
                      new THREE.Color(0x807060), // brown
                      new THREE.Color(0x708060), // olive
                      new THREE.Color(0x606070)  // slate
                    ];
                    node.material.color = groundColors[Math.floor(Math.random() * groundColors.length)];
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // IMPROVED COLLISION DETECTION: Use oriented bounding box for more accurate collisions
            // First, compute an accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use the improved ground placement calculation
            const groundY = this.calculateGroundOffset(model, category, scale);
            model.position.y = groundY;
            
            // Generate compound collision shapes for more accurate collision detection
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, scale);
            
            // Create better collision data with compound shapes
            const obstacleData = {
              mesh: model,
              type: category,
              // Advanced collision data
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              // Keep bounding box for broad-phase checks
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * scale / 2),
                  model.position.y - (size.y * scale / 2),
                  model.position.z - (size.z * scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * scale / 2),
                  model.position.y + (size.y * scale / 2),
                  model.position.z + (size.z * scale / 2)
                ),
                size: size.clone().multiplyScalar(scale),
                rotation: model.rotation.y
              },
              // Also keep a simple radius for quick distance checks
              size: Math.max(size.x, size.z) * scale * 0.5,
              position: model.position.clone()
            };
            
            this.obstacles.push(obstacleData);
            
            // Log first few obstacles for debugging
            if (this.obstacles.length <= 3) {
              console.log(`Created ${category} obstacle from ${modelPath}: width=${size.x * scale}, height=${size.y * scale}, depth=${size.z * scale} at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
            }
          },
          undefined, // Progress callback
          (error) => {
            console.error(`Error loading obstacle model ${fullPath}:`, error);
          }
        );
      }
    }
    
    // Create a special centerpiece crystal formation
    this.createCenterpiece();
    
    // Create template-based object groupings for more cohesive landscape
    this.createTemplateGroupings(templates, obstacleCategories);
    
    console.log(`Started loading ${Object.values(distribution).reduce((a, b) => a + b, 0)} obstacles with pathways and crystal gardens`);
  }
  
  /**
   * Create template-based object groupings
   */
  createTemplateGroupings(templates, categoryModels) {
    console.log('Creating template-based object groupings');
    
    templates.forEach((template, templateIndex) => {
      const templatePosition = template.position;
      const templateRotation = template.rotation;
      
      // Process each element in the template
      template.elements.forEach(element => {
        const category = element.category;
        
        // Get the model list for this category
        const models = categoryModels[category];
        if (!models || models.length === 0) return;
        
        // Select model by index or randomly if index is out of bounds
        const modelIndex = element.modelIndex < models.length ? element.modelIndex : Math.floor(Math.random() * models.length);
        const modelPath = models[modelIndex];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Calculate final position with rotation applied to offset
        const offset = element.offset.clone();
        
        // Apply template rotation to the offset
        if (templateRotation) {
          // Create rotation matrix
          const rotMatrix = new THREE.Matrix4().makeRotationY(templateRotation);
          offset.applyMatrix4(rotMatrix);
        }
        
        // Final position combines template position and rotated offset
        const finalPosition = new THREE.Vector3(
          templatePosition.x + offset.x,
          templatePosition.y + offset.y,
          templatePosition.z + offset.z
        );
        
        // Final rotation combines template rotation and element rotation
        const finalRotation = templateRotation + element.rotation;
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale
            model.scale.set(element.scale, element.scale, element.scale);
            
            // Set initial position 
            model.position.copy(finalPosition);
            
            // Apply rotation
            model.rotation.y = finalRotation;
            
            // Enable shadows with appropriate material enhancements
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Apply category-specific visual effects
                if (node.material) {
                  if (category === 'crystals') {
                    // Crystal glow effect
                    node.material.emissive = new THREE.Color(0x88bbff);
                    node.material.emissiveIntensity = 0.3;
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // Compute accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use improved ground placement
            const groundY = this.calculateGroundOffset(model, category, element.scale);
            model.position.y = groundY + element.offset.y; // Apply any intentional Y offset
            
            // Generate compound collision shapes
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, element.scale);
            
            // Add to obstacles array with collision data
            this.obstacles.push({
              mesh: model,
              type: category,
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * element.scale / 2),
                  model.position.y - (size.y * element.scale / 2),
                  model.position.z - (size.z * element.scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * element.scale / 2),
                  model.position.y + (size.y * element.scale / 2),
                  model.position.z + (size.z * element.scale / 2)
                ),
                size: size.clone().multiplyScalar(element.scale),
                rotation: model.rotation.y
              },
              size: Math.max(size.x, size.z) * element.scale * 0.5,
              position: model.position.clone()
            });
            
            console.log(`Template ${templateIndex+1}: Added ${category} model at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
          },
          undefined,
          (error) => {
            console.error(`Error loading template model ${fullPath}:`, error);
          }
        );
      });
    });
  }
  
  setupControls() {
    // Store active keys for visual feedback
    this.activeKeys = new Set();
    
    // Add visual indicators for controls
    this.createControlIndicators();
    
    // Detect if we're on a touch device
    this.isTouchDevice = 'ontouchstart' in window;
    
    // Keyboard controls
    document.addEventListener('keydown', this.boundHandleKeyDown);
    document.addEventListener('keyup', this.boundHandleKeyUp);
    
    // Mouse controls - attach to the canvas for better precision
    const canvas = this.renderer.domElement;
    canvas.addEventListener('click', this.boundHandleClick);
    canvas.addEventListener('mousemove', this.boundHandleMouseMove);
    
    // Setup touch controls for mobile devices
    if (this.isTouchDevice) {
      this.setupTouchControls();
    }
  }
  
  createControlIndicators() {
    console.log('Creating control indicators');
    // Create container if it doesn't exist
    if (!this.controlsContainer) {
        this.controlsContainer = document.createElement('div');
        this.controlsContainer.id = 'controls';
        this.controlsContainer.className = 'control-indicators';
        document.body.appendChild(this.controlsContainer);
        console.log('Control container created');
    }

    // Clear existing indicators
    this.controlsContainer.innerHTML = '';
    
    // Create the movement controls grid
    const movementControls = document.createElement('div');
    movementControls.className = 'movement-controls control-group';
    
    // Create the weapon controls section
    const weaponControls = document.createElement('div');
    weaponControls.className = 'weapon-controls control-group';
    
    // Define the key indicators for movement
    const movementKeys = [
        { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward', gridArea: 'forward' },
        { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward', gridArea: 'backward' },
        { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left', gridArea: 'left' },
        { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right', gridArea: 'right' },
        { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left', gridArea: 'strafeLeft' },
        { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right', gridArea: 'strafeRight' },
        { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon', gridArea: 'fire' }
    ];
    
    // Define the key indicators for weapons
    const weaponKeys = [
        { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser', className: 'weapon-key' },
        { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade', className: 'weapon-key' },
        { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser', className: 'weapon-key' },
        { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon', className: 'weapon-key' }
    ];
    
    // Create movement indicators
    movementKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        movementControls.appendChild(indicator);
    });
    
    // Create weapon indicators
    weaponKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        weaponControls.appendChild(indicator);
    });
    
    // Add a controls hint
    const hint = document.createElement('div');
    hint.className = 'controls-hint';
    hint.textContent = 'Press C to toggle controls visibility';
    
    // Add all elements to controls container
    this.controlsContainer.appendChild(movementControls);
    this.controlsContainer.appendChild(weaponControls);
    this.controlsContainer.appendChild(hint);
    
    console.log('Control indicators created with updated structure');
  }
  
  updateControlIndicators() {
    // Skip if control indicators aren't created yet
    if (!this.controlsContainer) return;
    
    // Update movement keys
    this.updateIndicatorState('forward', this.keys.forward);
    this.updateIndicatorState('backward', this.keys.backward);
    this.updateIndicatorState('left', this.keys.left);
    this.updateIndicatorState('right', this.keys.right);
    this.updateIndicatorState('strafeLeft', this.keys.strafeLeft);
    this.updateIndicatorState('strafeRight', this.keys.strafeRight);
    
    // Update fire state
    this.updateIndicatorState('fire', this.keys.fire);
    
    // Update weapon selection
    this.updateIndicatorState('selectLaser', this.currentWeapon === 'LASER');
    this.updateIndicatorState('selectGrenade', this.currentWeapon === 'GRENADE');
    this.updateIndicatorState('selectBounce', this.currentWeapon === 'BOUNCE');
  }
  
  updateIndicatorState(id, isActive) {
    const indicator = this.controlsContainer?.querySelector(`#indicator-${id}`);
    if (indicator) {
      if (isActive) {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }
  }
  
  handleResize(event) {
    // Debounce resize events
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    
    this.resizeTimer = setTimeout(() => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.resizeTimer = null;
    }, 100);
  }
  
  handleKeyDown(event) {
    // Handle escape key for in-game menu
    if (event.code === 'Escape') {
        this.showInGameMenu();
        return;
    }
    
    // Handle 'C' key to toggle controls visibility
    if (event.code === 'KeyC') {
        console.log('C key pressed - toggling controls');
        this.toggleControls();
        return;
    }
    
    // Handle 'M' key to toggle mini-map
    if (event.code === 'KeyM') {
        this.toggleMiniMap();
        return;
    }

    // Get control action from key mapping
    const action = ControlUtils.getActionForKey(event.code);
    
    // Skip if key isn't mapped or event is repeated
    if (!action || event.repeat) return;
    
    // Handle weapon selection
    if (action.category === 'WEAPONS') {
        if (action.action === 'SWITCH_WEAPON') {
            this.cycleWeapon();
            return;
        } else if (action.action === 'SELECT_LASER') {
            this.selectWeapon('LASER');
            return;
        } else if (action.action === 'SELECT_GRENADE') {
            this.selectWeapon('GRENADE');
            return;
        } else if (action.action === 'SELECT_BOUNCE') {
            this.selectWeapon('BOUNCE');
            return;
        }
    }
    
    // Handle UI controls
    if (action.category === 'UI') {
        if (action.action === 'TOGGLE_MAP') {
            this.toggleMiniMap();
            return;
        } else if (action.action === 'TOGGLE_CONTROLS') {
            this.toggleControls();
            return;
        }
    }
    
    // Set key state to active
    if (action.category === 'MOVEMENT') {
        this.keys[action.action.toLowerCase()] = true;
    }
    
    // Store active key for visual feedback
    this.activeKeys.add(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
    
    // Prevent default browser behavior for game controls
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'Tab', 'KeyM'].includes(event.code)) {
        event.preventDefault();
    }
}
  
  handleKeyUp(event) {
    const action = ControlUtils.getActionForKey(event.code);
    if (!action) return;
    
    // Skip weapon selection keys on keyup
    if (action.category === 'WEAPONS' && action.action.startsWith('SELECT_')) {
      return;
    }
    
    // Set key state to inactive
    if (action.category === 'MOVEMENT') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'WEAPONS') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'UI') {
      this.keys[action.action.toLowerCase()] = false;
    }
    
    // Remove from active keys
    this.activeKeys.delete(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
  }
  
  handleClick(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault) {
        event.preventDefault();
    }
    
    // Prevent rapid-fire clicking
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
        return;
    }
    
    // Get click coordinates relative to canvas
    const rect = this.renderer.domElement.getBoundingClientRect();
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid click coordinates');
        return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Convert to normalized device coordinates
    const mouse = new THREE.Vector2(
        (x / this.renderer.domElement.clientWidth) * 2 - 1,
        -(y / this.renderer.domElement.clientHeight) * 2 + 1
    );
    
    // Handle weapon-specific targeting
    if (this.currentWeapon === 'GRENADE') {
        this.handleGrenadeTargeting({ 
            clientX, 
            clientY,
            preventDefault: () => {} // Add dummy preventDefault for consistency
        });
    } else {
        this.handleDirectionalFiring({ clientX, clientY });
    }
  }
  
  handleMouseMove(event) {
    // Skip if we're moving too frequently (throttle)
    if (this.mouseMoveTimer) {
        return;
    }
    
    // Use requestAnimationFrame for smoother updates
    this.mouseMoveTimer = requestAnimationFrame(() => {
        // Get mouse coordinates relative to canvas
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update targeting indicators for any weapon type
        this.updateTargetingIndicator({
            clientX: event.clientX,
            clientY: event.clientY
        });
        
        // Additional targeting for grenade if that's the current weapon
        if (this.currentWeapon === 'GRENADE') {
            this.updateGrenadeTargetingIndicator({
                clientX: event.clientX,
                clientY: event.clientY
            });
        }
        
        this.mouseMoveTimer = null;
    });
}
  
  handleFireAction() {
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
      return;
    }
    
    // Set cooldown based on weapon type
    const cooldownTime = this.currentWeapon === 'GRENADE' ? 1000 :
                        this.currentWeapon === 'BOUNCE' ? 500 :
                        200;
    
    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);
    this.fireCurrentWeapon();
  }
  
  setupTouchControls() {
    // Create touch control container
    const touchControls = document.createElement('div');
    touchControls.className = 'touch-controls';
    document.body.appendChild(touchControls);
    
    // Create virtual joystick for movement
    const joystickContainer = document.createElement('div');
    joystickContainer.className = 'joystick-container';
    touchControls.appendChild(joystickContainer);
    
    const joystick = document.createElement('div');
    joystick.className = 'joystick';
    joystickContainer.appendChild(joystick);
    
    const joystickKnob = document.createElement('div');
    joystickKnob.className = 'joystick-knob';
    joystick.appendChild(joystickKnob);
    
    // Create fire button
    const fireButton = document.createElement('div');
    fireButton.className = 'touch-button fire-button';
    fireButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.ACTIONS.find(a => a.id === 'fire').label;
    touchControls.appendChild(fireButton);
    
    // Create weapon switch button
    const weaponButton = document.createElement('div');
    weaponButton.className = 'touch-button weapon-button';
    weaponButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.WEAPONS.find(w => w.id === 'switchWeapon').label;
    touchControls.appendChild(weaponButton);
    
    // Joystick handling
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickOrigin.x = rect.left + rect.width / 2;
      joystickOrigin.y = rect.top + rect.height / 2;
      handleJoystickMove(touch);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (joystickActive) {
        const touch = e.touches[0];
        handleJoystickMove(touch);
        e.preventDefault();
      }
    });
    
    document.addEventListener('touchend', (e) => {
      if (joystickActive) {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Reset movement keys using DEFAULT_CONTROL_STATE
        Object.keys(DEFAULT_CONTROL_STATE).forEach(key => {
          if (key.startsWith('forward') || key.startsWith('backward') || 
              key.startsWith('left') || key.startsWith('right') || 
              key.startsWith('strafe')) {
            this.keys[key] = DEFAULT_CONTROL_STATE[key];
          }
        });
        
        this.updateControlIndicators();
      }
    });
    
    const handleJoystickMove = (touch) => {
      const maxDistance = CONTROL_SETTINGS.TOUCH.JOYSTICK_MAX_DISTANCE;
      const deadZone = CONTROL_SETTINGS.TOUCH.JOYSTICK_DEAD_ZONE;
      
      // Calculate distance from center
      const dx = touch.clientX - joystickOrigin.x;
      const dy = touch.clientY - joystickOrigin.y;
      
      // Limit distance to maxDistance
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
      const angle = Math.atan2(dy, dx);
      
      // Move joystick knob
      const knobX = distance * Math.cos(angle);
      const knobY = distance * Math.sin(angle);
      joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
      
      // Convert joystick position to key presses using deadzone
      this.keys.forward = dy < -deadZone;
      this.keys.backward = dy > deadZone;
      this.keys.left = dx < -deadZone;
      this.keys.right = dx > deadZone;
      
      this.updateControlIndicators();
    };
    
    // Fire button handling with weapon cooldown
    let lastFireTime = 0;
    fireButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      const cooldown = CONTROL_SETTINGS.WEAPON_COOLDOWNS[this.currentWeapon];
      
      if (now - lastFireTime >= cooldown) {
        this.keys.fire = true;
        this.fireCurrentWeapon();
        lastFireTime = now;
      }
      
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    fireButton.addEventListener('touchend', (e) => {
      this.keys.fire = false;
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    // Weapon switch button handling with cooldown
    let lastWeaponSwitchTime = 0;
    weaponButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastWeaponSwitchTime >= 200) { // 200ms cooldown for weapon switching
        this.cycleWeapon();
        lastWeaponSwitchTime = now;
      }
      e.preventDefault();
    });
    
    // Enable directional fire on game area tap
    const gameArea = document.querySelector('canvas');
    if (gameArea) {
      let lastTapTime = 0;
      
      gameArea.addEventListener('touchstart', (e) => {
        // Ignore if touch is in control areas
        const touch = e.touches[0];
        const isInControlArea = 
          touchControls.contains(document.elementFromPoint(touch.clientX, touch.clientY));
          
        if (!isInControlArea && this.playerShip) {
          const now = Date.now();
          const doubleTapDelay = CONTROL_SETTINGS.TOUCH.DOUBLE_TAP_DELAY;
          
          // Check for double tap
          if (now - lastTapTime < doubleTapDelay) {
            // Handle double tap action (e.g., special weapon)
            this.cycleWeapon();
          } else {
            // Handle single tap (directional firing)
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // Handle directional firing similarly to mouse
            const touchPoint = new THREE.Vector2(
              (touchX / window.innerWidth) * 2 - 1,
              -(touchY / window.innerHeight) * 2 + 1
            );
            
            // Use raycasting to determine the point in 3D space
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touchPoint, this.camera);
            
            // Check for intersection with the floor
            const intersects = raycaster.intersectObject(this.floor);
            
            if (intersects.length > 0) {
              const targetPoint = intersects[0].point;
              
              // Calculate the direction from the player to the target point
              const shipPosition = this.playerShip.position.clone();
              const direction = targetPoint.clone().sub(shipPosition).normalize();
              
              // Only care about horizontal direction (ignore y component)
              direction.y = 0;
              direction.normalize();
              
              // Store the original rotation
              const originalRotation = this.playerShip.rotation.clone();
              
              // Temporarily rotate the ship to face the target
              this.playerShip.lookAt(shipPosition.clone().add(direction));
              
              // Fire the weapon in that direction
              if (this.currentWeapon === 'GRENADE') {
                // For grenades, we simulate a tap at the target location
                const targetEvent = {
                  clientX: touchX,
                  clientY: touchY,
                  preventDefault: () => {}
                };
                this.handleGrenadeTargeting(targetEvent);
              } else {
                // For lasers and bounce, fire in the direction
                this.fireCurrentWeapon(direction);
              }
              
              // Restore the original rotation
              this.playerShip.rotation.copy(originalRotation);
            }
          }
          
          lastTapTime = now;
          e.preventDefault();
        }
      });
    }
  }
  
  toggleControls() {
    // Clear any existing timeout
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
    
    // Also clear any auto-fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (!this.controlsContainer) {
      this.createControlIndicators();
    }
    
    if (this.controlsContainer.classList.contains('visible')) {
      this.fadeOutControls();
    } else {
      this.fadeInControls();
    }
  }
  
  fadeInControls() {
    console.log('Fading in controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // Remove any classes that might hide the controls
        this.controlsContainer.classList.remove('hidden', 'fading');
        // Add the visible class
        this.controlsContainer.classList.add('visible');
        console.log('Controls should now be visible with class: visible');
        
        // Set a timeout to automatically fade out the controls after 5 seconds
        // (but only if we're in the game and not in a menu)
        if (this.isRunning) {
            this.controlsFadeTimeout = setTimeout(() => {
              console.log('Auto-hiding controls after timeout');
              this.fadeOutControls();
            }, 5000);
        }
    } else {
        console.warn('Control container not found during fade in');
        // Try to create controls if they don't exist
        this.createControlIndicators();
        // And then try to show them
        if (this.controlsContainer) {
            this.controlsContainer.classList.add('visible');
            
            // Also set the auto-fade timeout for the newly created controls
            // (but only if we're in the game and not in a menu)
            if (this.isRunning) {
                this.controlsFadeTimeout = setTimeout(() => {
                  console.log('Auto-hiding newly created controls after timeout');
                  this.fadeOutControls();
                }, 5000);
            }
        }
    }
  }
  
  fadeOutControls() {
    console.log('Fading out controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // First add the fading class for the transition
        this.controlsContainer.classList.add('fading');
        this.controlsContainer.classList.remove('visible');
        
        // After the transition completes, add the hidden class
        setTimeout(() => {
            if (this.controlsContainer) {
                this.controlsContainer.classList.add('hidden');
            }
        }, 500); // Match the transition time from CSS
    } else {
        console.warn('Control container not found during fade out');
    }
  }
  
  updateWeaponUI() {
    // Update UI to reflect weapon change
    if (this.ui) {
        this.ui.updateWeapon(this.currentWeapon);
        
        // Update targeting indicator color if it exists
        if (this.targetingIndicator) {
            const colors = {
                'LASER': new THREE.Color(0x00ffff),
                'GRENADE': new THREE.Color(0xff4500),
                'BOUNCE': new THREE.Color(0x00ff99)
            };
            const color = colors[this.currentWeapon] || colors['LASER'];
            
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
        }
    }
    
    // Log weapon change
    console.log('Weapon updated:', this.currentWeapon);
}

selectWeapon(weaponType) {
    console.log('Selecting specific weapon:', weaponType);
    const index = this.availableWeapons.indexOf(weaponType);
    if (index !== -1) {
        this.weaponIndex = index;
        this.currentWeapon = weaponType;
        console.log('Weapon selection successful');
        
        // Update UI to reflect weapon change
        this.updateWeaponUI();
        
        // Play weapon switch sound if available
        this.playSound('weapon-switch');
    } else {
        console.warn('Attempted to select unavailable weapon:', weaponType);
    }
}
  
  cycleWeapon() {
    console.log('Cycling weapon from:', this.currentWeapon);
    this.weaponIndex = (this.weaponIndex + 1) % this.availableWeapons.length;
    this.currentWeapon = this.availableWeapons[this.weaponIndex];
    console.log('New weapon selected:', this.currentWeapon);
    
    // Update UI to reflect weapon change
    this.updateWeaponUI();
    
    // Play weapon switch sound
    this.playSound('weapon-switch');
}
  
  fireGrenade() {
    console.log("Grenade weapon selected - click to target");
  }
  
  animate() {
    // Call animationFrame with this instance as context
    requestAnimationFrame(this.animate.bind(this));
    
    try {
      // Calculate delta time
      const now = performance.now();
      const deltaTime = (now - this.lastTime) / 1000; // in seconds
      this.lastTime = now;
      
      // Update frame counter
      this.frameCount++;
      
      // Limit update rate
      if (this.frameCount % 2 === 0) { // Reduce update frequency
        // Only update gameplay if the player ship exists
        if (this.playerShip) {
          // Update player
          if (typeof this.updatePlayer === 'function') {
            this.updatePlayer(deltaTime);
          }
          
          // Update other elements - only if they exist
          if (typeof this.updateLasers === 'function') {
            this.updateLasers();
          }
          
          if (typeof this.updateEnergy === 'function') {
            this.updateEnergy(deltaTime);
          }
          
          if (typeof this.updateCamera === 'function') {
            this.updateCamera();
          }
          
          // Update collision detection
          if (typeof this.checkObstacleCollisions === 'function') {
            this.checkObstacleCollisions();
          }
          
          // Update thruster effects
          if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
          }
          
          // Check if boost is active and update energy consumption
          if (this.keys && this.keys.boost && this.energy > 0) {
            this.energy = Math.max(0, this.energy - 30 * deltaTime); // Boost drains energy
            if (this.ui) {
              this.ui.updateEnergy(this.energy, this.maxEnergy);
            }
          }
        }
        
        // Update bounceLasers if they exist
        if (this.bouncingLasers && this.bouncingLasers.length > 0 && 
            typeof this.updateBouncingLasers === 'function') {
          this.updateBouncingLasers();
        }
        
        // Update grenades if they exist
        if (this.grenades && this.grenades.length > 0 && 
            typeof this.updateGrenades === 'function') {
          this.updateGrenades();
        }
        
        // Update multiplayer
        if (this.multiplayerEnabled && this.networkManager) {
          // Send our position and rotation to server
          if (this.playerShip) {
            this.networkManager.sendPlayerUpdate({
              position: {
                x: this.playerShip.position.x,
                y: this.playerShip.position.y,
                z: this.playerShip.position.z
              },
              rotation: this.playerShip.rotation.y,
              name: this.playerName,
              shipType: this.currentShipType || 'default'
            });
          }
          
          // Update other players
          if (typeof this.updateOtherPlayers === 'function') {
            this.updateOtherPlayers();
          }
        }
      }
      
      // Render the scene
      if (this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        
        // Render CSS2D elements if renderer exists
        if (this.labelRenderer) {
          this.labelRenderer.render(this.scene, this.camera);
        }
      }
    } catch (error) {
      console.error("Error in animate loop:", error);
      // Don't rethrow, we want to keep the animation loop running
    }
  }
  
  updatePlayer(deltaTime) {
    if (!this.playerShip) return;
    
    // Save original position in case we need to revert due to collision
    const originalPosition = this.playerShip.position.clone();
    
    // ORIGINAL SHIP MOVEMENT PHYSICS
    const moveSpeed = 10; // Base movement speed
    const rotateSpeed = 2.5; // Base rotation speed
    
    let moved = false; // Track if the ship moved
    
    // Handle forward/backward movement
    if (this.keys.forward) {
        // Move forward
        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(forwardDir, moveSpeed * deltaTime);
        moved = true;
    }
    else if (this.keys.backward) {
        // Move backward
        const backwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(backwardDir, moveSpeed * deltaTime);
        moved = true;
    }

    // Handle left/right rotation
    if (this.keys.left) {
        // Rotate left
        this.playerShip.rotation.y += rotateSpeed * deltaTime;
        moved = true;
    }
    else if (this.keys.right) {
        // Rotate right
        this.playerShip.rotation.y -= rotateSpeed * deltaTime;
        moved = true;
    }
    
    // Update player highlight to follow the player ship
    if (this.playerHighlight) {
        this.playerHighlight.position.x = this.playerShip.position.x;
        this.playerHighlight.position.z = this.playerShip.position.z;
        
        // Add a subtle pulsing effect to the highlight
        const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
        this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
    }
    
    // Check for collisions after movement
    if (moved) {
        this.checkObstacleCollisions();
        
        // If no collisions, update thruster effects
        if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
        }
        
        // Send position update to server if multiplayer is enabled
        if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
            this.sendPlayerPositionUpdate();
        }
    }
  }
  
  updateLasers() {
    if (!this.lasers) return;
    
    for (let i = this.lasers.length - 1; i >= 0; i--) {
      const laser = this.lasers[i];
      
      // Move laser
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update trail effect
      laser.trailPoints.push(laser.mesh.position.clone());
      if (laser.trailPoints.length > 8) { // Reduced trail length for better performance
        laser.trailPoints.shift();
      }
      
      // Update trail geometry
      const positions = new Float32Array(laser.trailPoints.length * 3);
      for (let j = 0; j < laser.trailPoints.length; j++) {
        positions[j * 3] = laser.trailPoints[j].x;
        positions[j * 3 + 1] = laser.trailPoints[j].y;
        positions[j * 3 + 2] = laser.trailPoints[j].z;
      }
      laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Pulse effect
      laser.pulsePhase += 0.3;
      const pulse = Math.sin(laser.pulsePhase) * 0.2 + 0.8;
      laser.mesh.material.opacity = pulse;
      const light = laser.mesh.children[0];
      if (light) {
        light.intensity = pulse * 2;
      }
      
      // Increment lifetime
      laser.lifeTime++;
      
      // Remove old lasers
      if (laser.lifeTime > laser.maxLifeTime) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.lasers.splice(i, 1);
        continue;
      }
      
      // Check for collisions with obstacles
      for (let j = 0; j < this.obstacles.length; j++) {
        const obstacle = this.obstacles[j];
        
        // Simple distance check
        if (laser.mesh.position.distanceTo(obstacle.position) < 1.5) {
          // Create enhanced hit effect
          this.createEnhancedHitEffect(laser.mesh.position.clone(), laser.direction.clone());
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  createEnhancedHitEffect(position, direction) {
    // Create a burst of particles
    const particleCount = 15;
    const particles = [];
    
    // Create particle material
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity based on impact direction
      const spread = Math.PI / 2; // 90 degree spread
      const angle = Math.random() * spread - spread/2;
      const speed = 0.2 + Math.random() * 0.3;
      
      // Calculate velocity
      const velocity = direction.clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle)
        .multiplyScalar(speed);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0; // Full life
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.3, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(position.clone().add(direction));
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }
  
  checkObstacleCollisions() {
    if (!this.playerShip || !this.infiniteMap) {
      console.log('Skipping collision check - player ship or infinite map not available');
      return;
    }
    
    // Get player collision info
    const playerRadius = this.playerShip.userData.collisionRadius || 0.35;
    const playerPos = this.playerShip.position.clone();
    
    // Create player sphere for collision checks
    const playerSphere = {
      center: playerPos,
      radius: playerRadius
    };
    
    // Check collisions with infinite map objects first
    const mapCollision = this.infiniteMap.checkCollisions(playerPos, playerRadius);
    
    if (mapCollision.collided) {
      // Handle collision from infinite map
      this.handleObjectCollision(playerPos, mapCollision.object.position, mapCollision.object.type || 'terrain');
      return; // Stop checking after handling one collision
    }
    
    // Check local obstacles with more accurate collision detection
    for (const obstacle of this.obstacles) {
      if (!obstacle.mesh) continue;
      
      // First, do a quick broad-phase check with spheres for efficiency
      const obstaclePos = obstacle.position.clone();
      const distance = playerPos.distanceTo(obstaclePos);
      const quickCheckDistance = playerRadius + obstacle.size;
      
      // Skip detailed check if clearly not colliding
      if (distance > quickCheckDistance * 1.5) continue;
      
      // Determine if collision happened based on shape type
      let collision = false;
      
      if (obstacle.collisionShape === 'compound' && obstacle.compoundShapes) {
        // Use compound shape collision detection for complex objects
        collision = this.checkCompoundCollision(playerSphere, obstacle.compoundShapes);
      } else if (obstacle.collisionShape === 'complex' && obstacle.boundingBox) {
        // Fall back to oriented bounding box if compound shapes not available
        collision = this.checkBoxCollision(
          playerPos, playerRadius,
          obstacle.boundingBox, 
          obstacle.boundingBox.rotation
        );
      } else {
        // Simplest case: sphere-based collision for backward compatibility
        collision = distance < quickCheckDistance;
      }
      
      if (collision) {
        // Handle the collision
        this.handleObjectCollision(playerPos, obstaclePos, obstacle.type);
        break; // Only handle one collision at a time
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (compound shapes)
   */
  checkCompoundCollision(playerSphere, compoundShapes) {
    // Check collision against each shape in the compound
    for (const shape of compoundShapes) {
      let collision = false;
      
      if (shape.type === 'box') {
        // Box vs sphere collision
        collision = this.checkBoxSphereCollision(
          shape.center,
          shape.halfExtents,
          shape.worldRotation || 0,
          playerSphere
        );
      } else if (shape.type === 'sphere') {
        // Sphere vs sphere collision (simpler case)
        const distance = playerSphere.center.distanceTo(shape.center);
        collision = distance < (playerSphere.radius + shape.radius);
      }
      
      if (collision) {
        return true; // Collision with any part means collision with the compound
      }
    }
    
    return false; // No collision with any part
  }
  
  /**
   * Check collision between a rotated box and a sphere
   */
  checkBoxSphereCollision(boxCenter, boxHalfExtents, boxRotation, sphere) {
    // Transform sphere center to box space (accounting for rotation)
    const toSphere = new THREE.Vector3().subVectors(sphere.center, boxCenter);
    
    // Apply inverse rotation to get into box space
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(-boxRotation);
      toSphere.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on box to sphere in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-boxHalfExtents.x, Math.min(boxHalfExtents.x, toSphere.x)),
      Math.max(-boxHalfExtents.y, Math.min(boxHalfExtents.y, toSphere.y)),
      Math.max(-boxHalfExtents.z, Math.min(boxHalfExtents.z, toSphere.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(boxRotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to sphere center (for efficiency)
    const squaredDistance = sphere.center.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than sphere radius squared
    return squaredDistance < (sphere.radius * sphere.radius);
  }

  /**
   * Handle collision with any object
   */
  handleObjectCollision(playerPos, objectPos, objectType) {
    console.log(`COLLISION DETECTED with ${objectType}: Pushing ship back`);
    
    // Push player away from obstacle
    const pushDir = new THREE.Vector3()
      .subVectors(playerPos, objectPos)
      .normalize();
      
    // Adjust push force based on object type
    let pushForce = 0.7; // Default push force
    let damageAmount = 5; // Default damage
    
    // Customize collision response based on type
    switch(objectType) {
      case 'rocks':
        pushForce = 0.85; // Rocks push strongly
        damageAmount = 8;
        break;
      case 'specialObjects':
      case 'groundFeatures':
        pushForce = 0.75; // Ground features push medium
        damageAmount = 6;
        break;
      case 'mountains':
        pushForce = 1.0; // Mountains push very strongly
        damageAmount = 10;
        break;
      case 'crystals':
        pushForce = 0.7; // Crystals push medium but with special effect
        damageAmount = 7;
        
        // Add special crystal collision effect
        this.createCrystalCollisionEffect(objectPos);
        break;
      case 'centerpiece':
        pushForce = 0.9; // Centerpiece pushes strongly
        damageAmount = 9;
        
        // Add special centerpiece collision effect
        this.createCrystalCollisionEffect(objectPos, true);
        break;
      case 'flora':
        pushForce = 0.6; // Flora pushes gently
        damageAmount = 3;
        break;
      default:
        // Use default values
        break;
    }
    
    // Apply the push force
    this.playerShip.position.addScaledVector(pushDir, pushForce);
    
    // Flash collision warning
    this.flashCollisionWarning();
    
    // Apply damage if the function exists
    if (typeof this.applyDamage === 'function') {
      this.applyDamage(damageAmount);
    }
    
    // Play appropriate collision sound based on object type
    let soundToPlay = 'collision';
    
    if (objectType === 'specialObjects') {
      // Crystal-like sounds for special objects
      soundToPlay = 'crystalHit';
    } else if (objectType === 'mountains') {
      // Heavy impact for mountains
      soundToPlay = 'heavyImpact';
    }
    
    // Play the sound if it exists, otherwise fall back to default collision
    if (this.playSound) {
      try {
        this.playSound(soundToPlay);
      } catch (e) {
        // Fall back to default if sound doesn't exist
        try {
          this.playSound('collision');
        } catch (e2) {
          // No sound available
        }
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (oriented box)
   */
  checkBoxCollision(playerPos, playerRadius, box, rotation) {
    // Get box center
    const boxCenter = new THREE.Vector3(
      (box.min.x + box.max.x) / 2,
      (box.min.y + box.max.y) / 2,
      (box.min.z + box.max.z) / 2
    );
    
    // Calculate half extents of box
    const halfExtents = new THREE.Vector3(
      (box.max.x - box.min.x) / 2,
      (box.max.y - box.min.y) / 2,
      (box.max.z - box.min.z) / 2
    );
    
    // Vector from box center to player
    const toPlayer = new THREE.Vector3().subVectors(playerPos, boxCenter);
    
    // If we have rotation, apply inverse rotation to convert to box space
    if (rotation) {
      // Create rotation matrix for the box (negative rotation to invert)
      const rotMatrix = new THREE.Matrix4().makeRotationY(-rotation);
      toPlayer.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on the box to the player in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-halfExtents.x, Math.min(halfExtents.x, toPlayer.x)),
      Math.max(-halfExtents.y, Math.min(halfExtents.y, toPlayer.y)),
      Math.max(-halfExtents.z, Math.min(halfExtents.z, toPlayer.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (rotation) {
      // Create rotation matrix for the box
      const rotMatrix = new THREE.Matrix4().makeRotationY(rotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to player center
    const squaredDistance = playerPos.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than player radius squared
    return squaredDistance < (playerRadius * playerRadius);
  }
  
  updateCamera() {
    // Check if cameraTargetPosition is initialized
    if (!this.cameraTargetPosition) {
      this.cameraTargetPosition = new THREE.Vector3();
      this.cameraTargetLookAt = new THREE.Vector3();
      this.cameraSmoothingFactor = 0.05;
    }
    
    // If playerShip doesn't exist, early return
    if (!this.playerShip) return;
    
    // Define the camera offset from the player
    const offsetY = 18; // Height above the player
    const offsetZ = -16; // Distance behind the player (adjusted for larger ship)
    
    // Get the player's forward direction vector (simplified)
    const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
    
    // Calculate camera target position (directly above and slightly behind player)
    this.cameraTargetPosition.copy(this.playerShip.position);
    this.cameraTargetPosition.y += offsetY;
    
    // Move camera back based on player's orientation
    const backOffset = forwardDir.clone().multiplyScalar(offsetZ);
    this.cameraTargetPosition.add(backOffset);
    
    // Smoothly move camera toward target position
    this.camera.position.lerp(this.cameraTargetPosition, this.cameraSmoothingFactor);
    
    // Make camera look at the player
    this.cameraTargetLookAt.copy(this.playerShip.position);
    this.camera.lookAt(this.cameraTargetLookAt);
  }
  
  updateThrusterEffects() {
    // Skip if ship model isn't loaded
    if (!this.shipModel || !this.thruster || !this.thrusterLight) return;
    
    // Use stored references instead of finding children each time
    const { thruster, thrusterLight } = this;
    
    // Base thruster scale and opacity on movement
    const isMovingForward = this.keys.forward;
    const isMovingBackward = this.keys.backward;
    
    // Update thruster pulse for ambient animation
    this.thrusterPulse.value = (this.thrusterPulse.value + 0.1) % (Math.PI * 2);
    const pulseEffect = Math.sin(this.thrusterPulse.value) * 0.1;
    
    if (isMovingForward) {
      // Full thruster when moving forward
      const randomScale = 1 + Math.random() * 0.2 + pulseEffect;
      thruster.scale.set(1, 1, randomScale);
      thruster.material.opacity = 0.7 + Math.random() * 0.3;
      thrusterLight.intensity = 1.2 + Math.random() * 0.3 + pulseEffect;
      
      // Add color variation for a more dynamic effect
      const hue = (Date.now() % 1000) / 1000; // Cycle through colors over time
      thruster.material.color.setHSL(hue, 1, 0.5);
      thrusterLight.color.setHSL(hue, 1, 0.5);
    } else if (isMovingBackward) {
      // Reduced thruster when moving backward
      const randomScale = 0.3 + Math.random() * 0.1 + pulseEffect * 0.5;
      thruster.scale.set(0.5, 0.5, randomScale);
      thruster.material.opacity = 0.4 + Math.random() * 0.2;
      thrusterLight.intensity = 0.6 + Math.random() * 0.2 + pulseEffect * 0.5;
      
      // Cooler color for reverse thrust
      thruster.material.color.setHSL(0.6, 1, 0.5); // Blue-ish
      thrusterLight.color.setHSL(0.6, 1, 0.5);
    } else {
      // Idle state with subtle pulsing
      const idleScale = 0.3 + pulseEffect;
      thruster.scale.set(0.3, 0.3, idleScale);
      thruster.material.opacity = 0.3 + pulseEffect;
      thrusterLight.intensity = 0.4 + pulseEffect;
      
      // Neutral color for idle
      thruster.material.color.setHSL(0.5, 0.7, 0.5); // Cyan-ish
      thrusterLight.color.setHSL(0.5, 0.7, 0.5);
    }
    
    // Performance optimization: only update material if it's visible
    if (thruster.material.opacity < 0.01) {
      thruster.visible = false;
      thrusterLight.visible = false;
    } else {
      thruster.visible = true;
      thrusterLight.visible = true;
    }
  }
  
  flashCollisionWarning() {
    // Create a full-screen flash effect for collision
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'collision-flash';
    document.body.appendChild(flashOverlay);
    
    // Remove after animation completes
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, 150);
  }
  
  updateEnergy(deltaTime) {
    // Validate parameters
    if (typeof deltaTime !== 'number' || deltaTime < 0) {
        console.warn('Invalid deltaTime in updateEnergy:', deltaTime);
        return;
    }

    // Initialize energy values if undefined
    if (typeof this.energy !== 'number') this.energy = 0;
    if (typeof this.maxEnergy !== 'number') this.maxEnergy = 100;
    if (typeof this.energyRechargeRate !== 'number') this.energyRechargeRate = 20;

    // Store old energy for change detection
    const oldEnergy = this.energy;

    // Calculate recharge amount
    const rechargeAmount = this.energyRechargeRate * deltaTime;
    
    // Apply recharge with bounds checking
    this.energy = Math.min(this.maxEnergy, this.energy + rechargeAmount);

    // Update UI only if energy changed
    if (this.energy !== oldEnergy) {
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        }

        // Play charging sound when energy is low (under 10%)
        if (this.energy < (this.maxEnergy * 0.1)) {
            this.playSound('weapon-charging');
        }

        // Log significant energy changes (more than 1 unit) for debugging
        if (Math.abs(this.energy - oldEnergy) > 1) {
            console.log(`Energy updated: ${oldEnergy.toFixed(1)} -> ${this.energy.toFixed(1)} (Δ${deltaTime.toFixed(3)}s)`);
        }
    }
  }
  
  updateGrenades() {
    if (!this.grenades || this.grenades.length === 0) return;
    
    for (let i = this.grenades.length - 1; i >= 0; i--) {
      const grenade = this.grenades[i];
      
      // If the grenade has exploded, handle explosion effects
      if (grenade.exploded) {
        // Increase the explosion radius until maximum
        grenade.explosionMesh.scale.addScalar(0.2);
        grenade.explosionLight.intensity -= 0.1;
        
        // Remove explosion after it's done
        if (grenade.explosionLight.intensity <= 0) {
          this.scene.remove(grenade.explosionMesh);
          this.scene.remove(grenade.trail);
          this.grenades.splice(i, 1);
        }
        continue;
      }
      
      // Update the grenade position along the arc
      grenade.progress += 0.02;
      
      if (grenade.progress >= 1) {
        // Explode when reaching the target
        this.explodeGrenade(grenade, i);
      } else {
        // Move along a quadratic bezier curve for arcing trajectory
        const p0 = grenade.startPos;
        const p1 = grenade.midPos;
        const p2 = grenade.endPos;
        
        // Quadratic bezier formula: p = (1-t)^2 * p0 + 2(1-t)t * p1 + t^2 * p2
        const t = grenade.progress;
        const oneMinusT = 1 - t;
        
        grenade.mesh.position.x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
        grenade.mesh.position.y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
        grenade.mesh.position.z = oneMinusT * oneMinusT * p0.z + 2 * oneMinusT * t * p1.z + t * t * p2.z;
        
        // Add trail effect
        const point = grenade.mesh.position.clone();
        grenade.trailPoints.push(point);
        
        // Keep only the last 20 trail points
        if (grenade.trailPoints.length > 20) {
          grenade.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(grenade.trailPoints.length * 3);
        for (let j = 0; j < grenade.trailPoints.length; j++) {
          positions[j * 3] = grenade.trailPoints[j].x;
          positions[j * 3 + 1] = grenade.trailPoints[j].y;
          positions[j * 3 + 2] = grenade.trailPoints[j].z;
        }
        
        grenade.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        grenade.trail.geometry.attributes.position.needsUpdate = true;
      }
    }
  }
  
  explodeGrenade(grenade, index) {
    // Remove the grenade mesh
    this.scene.remove(grenade.mesh);
    
    // Create explosion geometry
    const explosionGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const explosionMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8
    });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(grenade.mesh.position);
    
    // Add to scene
    this.scene.add(explosionMesh);
    
    // Add explosion light
    const explosionLight = new THREE.PointLight(0xff6600, 3, 10);
    explosionMesh.add(explosionLight);
    
    // Mark as exploded
    grenade.exploded = true;
    grenade.explosionMesh = explosionMesh;
    grenade.explosionLight = explosionLight;
    
    // Calculate damage radius
    const explosionCenter = grenade.mesh.position.clone();
    const maxDamage = 50; // Maximum damage at center - 50% of health
    const damageRadius = grenade.explosionRadius || 4; // Default radius of 4 units
    
    // Check for obstacle hits in explosion radius
    for (const obstacle of this.obstacles) {
      const distance = obstacle.position.distanceTo(explosionCenter);
      if (distance < damageRadius) {
        // Calculate damage based on distance (linear falloff)
        const damagePercent = 1 - (distance / damageRadius);
        const hitPoint = obstacle.position.clone().add(
          explosionCenter.clone().sub(obstacle.position).normalize().multiplyScalar(distance * 0.8)
        );
        this.createHitEffect(hitPoint);
      }
    }
    
    // Check for player damage
    const playerPosition = this.playerShip.position.clone();
    playerPosition.y = 0; // Project to ground plane
    const grenadePosition = explosionCenter.clone();
    grenadePosition.y = 0; // Project to ground plane
    
    const playerDistance = playerPosition.distanceTo(grenadePosition);
    if (playerDistance < damageRadius) {
      // Calculate damage with distance falloff
      const damagePercent = 1 - (playerDistance / damageRadius);
      const damage = Math.floor(maxDamage * damagePercent);
      
      // Apply damage to player
      this.health = Math.max(0, this.health - damage);
      
      // Update UI
      if (this.ui) {
        this.ui.updateHealth(this.health, this.maxHealth);
      }
      
      // Visual feedback
      this.flashCollisionWarning();
      this.createHitEffect(playerPosition);
    }
  }
  
  updateBouncingLasers() {
    if (!this.bouncingLasers || this.bouncingLasers.length === 0) return;
    
    const playerPos = this.playerShip ? this.playerShip.position.clone() : null;
    
    // Update each laser
    for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
      const laser = this.bouncingLasers[i];
      
      // Skip invalid lasers
      if (!laser || !laser.mesh) continue;
      
      // Update laser position
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update the trail
      if (laser.trail) {
        // Add current position to trail points
        laser.trailPoints.push(laser.mesh.position.clone());
        
        // Limit the number of trail points
        if (laser.trailPoints.length > 20) {
          laser.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(laser.trailPoints.length * 3);
        for (let j = 0; j < laser.trailPoints.length; j++) {
          positions[j * 3] = laser.trailPoints[j].x;
          positions[j * 3 + 1] = laser.trailPoints[j].y;
          positions[j * 3 + 2] = laser.trailPoints[j].z;
        }
        
        // Update geometry
        laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        laser.trail.geometry.attributes.position.needsUpdate = true;
      }
      
      // Check for collisions with obstacles
      let collision = false;
      let closestPoint = null;
      let closestDistance = Infinity;
      let closestNormal = null;
      
      // Check for collision with each obstacle
      for (const obstacle of this.obstacles) {
        if (!obstacle.geometry) continue;
        
        let intersection = null;
        let normal = null;
        
        if (obstacle.geometry instanceof THREE.SphereGeometry) {
          const radius = obstacle.geometry.parameters.radius;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else if (obstacle.geometry instanceof THREE.CylinderGeometry) {
          const radius = obstacle.geometry.parameters.radiusTop;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else {
          // For boxes, use bounding sphere as approximation
          const boundingSphere = obstacle.geometry.boundingSphere;
          if (!boundingSphere) {
            obstacle.geometry.computeBoundingSphere();
          }
          const sphere = new THREE.Sphere(
            obstacle.position,
            obstacle.geometry.boundingSphere.radius
          );
          intersection = tempRay.intersectSphere(sphere, tempVector);
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        }
        
        if (intersection) {
          const dist = laser.mesh.position.distanceTo(intersection);
          if (dist < closestDist && dist < laser.speed * 1.2) {
            closestDist = dist;
            closestPoint = intersection;
            closestNormal = normal;
          }
        }
      }
      
      // Handle bounce if collision found
      if (closestPoint && closestNormal) {
        // Position at intersection point
        laser.mesh.position.copy(closestPoint);
        
        // Calculate reflection direction
        const dot = laser.direction.dot(closestNormal);
        const reflection = laser.direction.clone()
          .sub(closestNormal.multiplyScalar(2 * dot))
          .normalize();
        
        // Update direction with some randomness for more interesting bounces
        const randomAngle = (Math.random() - 0.5) * 0.2; // Small random angle
        reflection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
        laser.direction.copy(reflection);
        
        // Increment bounce count
        laser.bounces++;
        
        // Create bounce effect
        this.createBounceEffect(closestPoint.clone(), closestNormal.clone());
        
        // Play bounce sound
        this.playSound('bounce');
        
        // Enable player collision after first bounce
        laser.canHitPlayer = true;
        
        // Increase speed slightly with each bounce
        laser.speed *= 1.1;
        
        bounced = true;
      }
      
      // If no bounce, move normally
      if (!bounced) {
        laser.mesh.position.copy(nextPosition);
      }
      
      // Check for enemy collisions - new code
      if (this.enemyManager && this.enemyManager.enemies.length > 0) {
        for (let j = this.enemyManager.enemies.length - 1; j >= 0; j--) {
          const enemy = this.enemyManager.enemies[j];
          if (!enemy.isActive) continue;
          
          const enemyPos = enemy.mesh.position.clone();
          enemyPos.y = 0.5; // Adjust to match laser height
          
          // Check if the laser hit the enemy
          const hitDistance = 0.7; // Collision distance for enemy hits
          if (laser.mesh.position.distanceTo(enemyPos) < hitDistance) {
            // Enemy hit
            enemy.takeDamage(10); // Damage the enemy
            
            // Create hit effect
            this.createHitEffect(enemyPos);
            
            // Play hit sound
            this.playSound('weapon-armor-hit');
            
            // Remove laser
            this.scene.remove(laser.mesh);
            this.scene.remove(laser.trail);
            this.bouncingLasers.splice(i, 1);
            break; // Exit the enemy loop
          }
        }
      }
      
      // Check for player collision
      if (laser.canHitPlayer) {
        const playerPos = this.playerShip.position.clone();
        playerPos.y = 0.5;
        
        if (laser.mesh.position.distanceTo(playerPos) < 1) {
          // Player hit
          this.health -= 10;
          if (this.health < 0) this.health = 0;
          
          // Update UI
          this.ui.updateHealth(this.health, this.maxHealth);
          
          // Visual feedback
          this.flashCollisionWarning();
          this.createBounceEffect(playerPos, new THREE.Vector3(0, 1, 0));
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.bouncingLasers.splice(i, 1);
          continue;
        }
      }
      
      // Update lifetime
      laser.lifeTime++;
      
      // Remove if too old or too many bounces
      if (laser.lifeTime > laser.maxLifeTime || laser.bounces >= laser.maxBounces) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.bouncingLasers.splice(i, 1);
      }
    }
  }
  
  // Create a special effect for laser bounces
  createBounceEffect(position, normal) {
    // Create a particle burst effect at the bounce point
    const particleCount = 20;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    // Add a flash of light at bounce point
    const bounceLight = new THREE.PointLight(0x00ffcc, 3, 5);
    bounceLight.position.copy(position);
    this.scene.add(bounceLight);
    
    // Create a ring effect at bounce point
    const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(position);
    
    // Orient the ring according to the normal
    if (Math.abs(normal.y) > 0.99) { // If normal is pointing mainly up/down
      ring.rotation.x = Math.PI / 2; // Rotate to lie flat
    } else {
      // Point the ring along the normal
      const rotationAxis = new THREE.Vector3(0, 1, 0).cross(normal).normalize();
      const angle = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0)));
      ring.setRotationFromAxisAngle(rotationAxis, angle);
    }
    
    this.scene.add(ring);
    
    // Create particles around bounce point
    for (let i = 0; i < particleCount; i++) {
      // Random direction from bounce point
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(2)).normalize();
      
      // Starting at bounce point
      const startPoint = position.clone();
      particlePositions[i * 3] = startPoint.x;
      particlePositions[i * 3 + 1] = startPoint.y;
      particlePositions[i * 3 + 2] = startPoint.z;
      
      // Random sizes for particles
      particleSizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.1,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Store particle velocities
    const particleVelocities = [];
    for (let i = 0; i < particleCount; i++) {
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1, 
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(1.5)).normalize();
      
      // Random speed
      const speed = Math.random() * 0.1 + 0.05;
      particleVelocities.push(direction.multiplyScalar(speed));
    }
    
    // Animate particles and effects
    let frameCount = 0;
    const maxFrames = 30;
    
    const animate = () => {
      frameCount++;
      
      // Update particles
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x;
        positions[i * 3 + 1] += particleVelocities[i].y;
        positions[i * 3 + 2] += particleVelocities[i].z;
        
        // Slow down particles over time
        particleVelocities[i].multiplyScalar(0.95);
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Fade the light
      bounceLight.intensity *= 0.85;
      
      // Expand and fade the ring
      ring.scale.addScalar(0.15);
      ring.material.opacity *= 0.9;
      
      // Fade the particles
      particles.material.opacity *= 0.92;
      
      if (frameCount < maxFrames) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(bounceLight);
        this.scene.remove(ring);
        this.scene.remove(particles);
      }
    };
    
    // Start animation
    animate();
  }
  
  // Now add new methods to handle grenade targeting
  updateGrenadeTargetingIndicator(event) {
    // Create targeting indicator if it doesn't exist
    if (!this.grenadeTargetIndicator) {
      // Create targeting indicator
      const targetGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
      const targetMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, 
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      this.grenadeTargetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
      this.grenadeTargetIndicator.rotation.x = Math.PI / 2; // Make it horizontal
      
      // Add pulsing animation
      this.grenadeTargetIndicator.pulse = 0;
      
      // Add to scene
      this.scene.add(this.grenadeTargetIndicator);
    }
    
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // Update indicator color based on range
        if (distance > maxRange) {
          this.grenadeTargetIndicator.material.color.set(0xff0000); // Red for out of range
        } else {
          this.grenadeTargetIndicator.material.color.set(0x00ff00); // Green for valid
        }
        
        // Position the targeting indicator
        this.grenadeTargetIndicator.position.copy(targetPoint);
        this.grenadeTargetIndicator.position.y = 0.1; // Slightly above floor
        
        // Pulse animation
        this.grenadeTargetIndicator.pulse += 0.1;
        const scale = 1 + 0.2 * Math.sin(this.grenadeTargetIndicator.pulse);
        this.grenadeTargetIndicator.scale.set(scale, scale, scale);
        
        // Store target point for launching
        this.grenadeTargetPoint = targetPoint.clone();
    }
  }
  
  handleGrenadeTargeting(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Validate energy before proceeding
    if (!this.energy || !this.maxEnergy) {
        console.warn('Energy values invalid:', { energy: this.energy, maxEnergy: this.maxEnergy });
        return;
    }
    
    // Check if we have enough energy - now requires FULL energy
    if (this.energy < this.maxEnergy) {
        console.log("Not enough energy for grenade");
        return;
    }
    
    // Validate event coordinates
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid grenade target coordinates');
        return;
    }
    
    // Get the position where to throw the grenade
    const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // If beyond max range, limit to max range
        if (distance > maxRange) {
            toTarget.normalize().multiplyScalar(maxRange);
            targetPoint.copy(shipPosition).add(toTarget);
        }
        
        // Consume full energy
        this.energy = 0;
        
        // Update UI with energy change
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        } else {
            console.warn('UI energy update failed');
        }
        
        // Create and launch the grenade
        this.launchGrenade(targetPoint);
    }
  }
  
  launchGrenade(targetPoint) {
    // Create grenade mesh
    const grenadeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const grenadeMaterial = new THREE.MeshPhongMaterial({
      color: 0xff4500,
      emissive: 0xff2000,
      emissiveIntensity: 0.5
    });
    const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial);
    
    // Position at the ship
    grenade.position.copy(this.playerShip.position);
    grenade.position.y = 0.5; // Slightly above floor
    
    // Add to scene
    this.scene.add(grenade);
    
    // Add grenade trail effect
    const trail = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({
        color: 0xff4500,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      })
    );
    this.scene.add(trail);
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(0xff4500, 1, 3);
    grenade.add(light);
    
    // Store grenade data for animation
    if (!this.grenades) {
      this.grenades = [];
    }
    
    // Calculate the arc of the grenade
    const startPos = grenade.position.clone();
    const endPos = targetPoint.clone();
    const midPos = startPos.clone().add(endPos.clone().sub(startPos).multiplyScalar(0.5));
    midPos.y += 5; // Arc height
    
    this.grenades.push({
      mesh: grenade,
      trail: trail,
      startPos: startPos,
      midPos: midPos,
      endPos: endPos,
      progress: 0,
      exploded: false,
      explosionRadius: 4,
      trailPoints: []
    });

    // Play grenade launch sound
    this.playSound('grenade-laser');
  }
  
  // Add a method to show targeting indicator for all weapons
  updateTargetingIndicator(event) {
    // Skip if indicator was recently updated
    if (this.lastIndicatorUpdate && Date.now() - this.lastIndicatorUpdate < 16) {
        return;
    }
    this.lastIndicatorUpdate = Date.now();

    // Get the mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Log the normalized mouse position occasionally
    if (Math.random() < 0.01) {
      console.log('Mouse normalized position:', mouse);
    }
    
    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Check for intersection with the raycastFloor
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    // Log raycasting results occasionally for debugging
    if (Math.random() < 0.01) {
      console.log('Raycast results:', { 
        intersections: intersects.length, 
        raycastFloorExists: !!this.raycastFloor,
        raycastFloorPosition: this.raycastFloor ? this.raycastFloor.position.y : 'N/A'
      });
    }
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Create or update targeting indicator
        if (!this.targetingIndicator) {
            console.log('Creating new targeting indicator');
            // Create a more efficient indicator using a single geometry
            const geometry = new THREE.Group();
            
            // Outer ring with fewer segments - MAKE LARGER
            const outerRing = new THREE.RingGeometry(0.8, 1.0, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8, // Increased opacity
                side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerRing, material);
            
            // Inner ring with fewer segments - MAKE LARGER
            const innerRing = new THREE.RingGeometry(0.2, 0.4, 16);
            const inner = new THREE.Mesh(innerRing, material.clone());
            
            // Simplified crosshair - MAKE LARGER
            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = new Float32Array([
                -0.6, 0, 0,
                0.6, 0, 0,
                0, -0.6, 0,
                0, 0.6, 0
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));
            const lines = new THREE.LineSegments(lineGeometry, material.clone());
            
            geometry.add(outer);
            geometry.add(inner);
            geometry.add(lines);
            
            this.targetingIndicator = geometry;
            this.targetingIndicator.rotation.x = Math.PI / 2;
            this.scene.add(this.targetingIndicator);
        }
        
        // Update position - INCREASE HEIGHT
        this.targetingIndicator.position.copy(targetPoint);
        this.targetingIndicator.position.y = 0.5; // Much higher above the terrain
        
        // Update color based on weapon type
        const colors = {
            'LASER': new THREE.Color(0x00ffff),
            'GRENADE': new THREE.Color(0xff4500),
            'BOUNCE': new THREE.Color(0x00ff99)
        };
        const color = colors[this.currentWeapon] || colors['LASER'];
        
        // Only update colors if they've changed
        if (!this.lastWeaponColor || this.lastWeaponColor !== this.currentWeapon) {
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
            this.lastWeaponColor = this.currentWeapon;
        }
        
        // Simplified pulse animation
        if (!this.targetingIndicator.pulse) {
            this.targetingIndicator.pulse = 0;
        }
        this.targetingIndicator.pulse = (this.targetingIndicator.pulse + 0.1) % (Math.PI * 2);
        const pulseScale = 1.0 + 0.1 * Math.sin(this.targetingIndicator.pulse);
        this.targetingIndicator.scale.setScalar(pulseScale);
        
        // Show indicator
        this.targetingIndicator.visible = true;
        
        // Reset fade timeout
        if (this.targetingTimeout) {
            clearTimeout(this.targetingTimeout);
        }
        this.targetingTimeout = setTimeout(() => {
            if (this.targetingIndicator && this.targetingIndicator.visible) {
                this.targetingIndicator.visible = false;
            }
        }, 1000);
        
        // Extract target direction for firing
        const direction = new THREE.Vector3()
            .subVectors(targetPoint, this.playerShip.position)
            .normalize();
        
        // Store direction for firing
        this.targetDirection = direction;
    }
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggleMiniMap() {
    if (this.miniMap) {
      this.miniMap.toggle();
    }
  }
  
  // Add cleanup method
  cleanup() {
    // Stop and remove all sounds
    this.soundPools.forEach(pool => {
      pool.forEach(wrapper => {
        if (wrapper.sound.isPlaying) {
          wrapper.sound.stop();
        }
        wrapper.sound.buffer = null;
      });
    });
    
    // Clear sound pools and loaded sounds
    this.soundPools.clear();
    this.loadedSounds.clear();
    this.soundLoadPromises.clear();
    
    // Remove audio listener from camera
    if (this.audioListener) {
      this.camera.remove(this.audioListener);
      this.audioListener = null;
    }
    
    // Remove event listeners
    window.removeEventListener('resize', this.boundHandleResize);
    document.removeEventListener('keydown', this.boundHandleKeyDown);
    document.removeEventListener('keyup', this.boundHandleKeyUp);
    document.removeEventListener('click', this.boundHandleClick);
    document.removeEventListener('mousemove', this.boundHandleMouseMove);
    
    // Clear timers
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = null;
    }
    
    if (this.mouseMoveTimer) {
      clearTimeout(this.mouseMoveTimer);
      this.mouseMoveTimer = null;
    }
    
    // Clear weapon cooldowns
    this.weaponCooldowns.clear();
    
    // Clear key states
    Object.keys(this.keys).forEach(key => {
      this.keys[key] = false;
    });
    this.activeKeys.clear();
  }

  startGame() {
    console.log("Starting game...");
    
    // Get player name from input
    const playerNameInput = document.getElementById('player-name');
    this.playerName = playerNameInput.value.trim() || 'Pilot-' + Math.floor(Math.random() * 1000);
    
    // Hide start screen
    const startScreen = document.getElementById('start-screen');
    startScreen.classList.add('hidden');
    
    // Enable multiplayer mode by default
    this.multiplayerEnabled = true;
    
    // Connect to server
    if (this.networkManager) {
      this.networkManager.connect();
      
      // Show multiplayer info UI
      const multiplayerInfo = document.getElementById('multiplayer-info');
      if (multiplayerInfo) {
        multiplayerInfo.classList.remove('hidden');
      }
      
      // Update player info on server
      this.networkManager.updatePlayerInfo(this.playerName, this.currentShipType || 'default');
    }
    
    // Show ship selection screen
    this.showShipSelection();
  }

  showShipSelection() {
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
      console.error('Game container not found');
      return;
    }

    // Initialize ship selection if not already done
    if (!this.shipSelection) {
      this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
          this.shipSelection.hide();
          this.startGameplay(selection);
        }
      });
    }
    this.shipSelection.show();
  }

  startGameplay(shipSelection) {
    console.log('🔍 Starting gameplay with ship selection:', shipSelection);
    
    // First apply the ship selection
    this.applyShipSelection(shipSelection);
    
    // Set game as running (if this property exists)
    this.isRunning = true;
    
    // Show game UI (using either method)
    if (typeof this.ui !== 'undefined' && typeof this.ui.show === 'function') {
        this.ui.show();
    } else {
        // Show game UI directly
        const gameUI = document.querySelector('.game-ui');
        if (gameUI) {
            gameUI.classList.remove('hidden');
        }
    }
    
    // Show mini-map if it exists
    if (this.miniMap && typeof this.miniMap.show === 'function') {
        this.miniMap.show();
    }
    
    // Create and show controls if not already created
    if (!this.controlsContainer && typeof this.createControlIndicators === 'function') {
        this.createControlIndicators();
    }
    this.fadeInControls();
    
    // IMPORTANT: Double-check that the player ship has a proper collision radius
    if (this.playerShip) {
        this.playerShip.userData.collisionRadius = 0.35; // Use the same reduced value as defined earlier
        console.log('🛡️ Verified player ship collision radius:', this.playerShip.userData.collisionRadius);
    } else {
        console.error('⚠️ Player ship not available when starting gameplay!');
    }
    
    // Manually check for collisions once to make sure it's working
    setTimeout(() => {
        console.log('🔍 Running initial collision check...');
        this.checkObstacleCollisions();
    }, 500);

    // Start animation loop
    this.animate();
    
    console.log('✅ Game started successfully!');
  }

  applyShipSelection(selection) {
    console.log('🔍 Applying ship selection:', selection);
    
    // Clear existing ship model
    if (this.playerShip) {
        // Remove all children (previous ship model)
        while (this.playerShip.children.length > 0) {
            const child = this.playerShip.children[0];
            this.playerShip.remove(child);
        }
    }
    
    // Set ship model based on selection
    const type = selection.type.toUpperCase(); // Make sure it's uppercase for consistency
    this.setShipModel(type);
    this.currentShipType = type;
    
    // Position ship at a random location in the playing area
    // Avoid spawning too close to the center (where other players might spawn)
    const spawnRadius = 30; // Radius from center for spawning
    const randomAngle = Math.random() * Math.PI * 2; // Random angle
    const randomDistance = spawnRadius * (0.5 + Math.random() * 0.5); // Between 50% and 100% of spawn radius
    
    // Calculate position
    const spawnX = Math.cos(randomAngle) * randomDistance;
    const spawnZ = Math.sin(randomAngle) * randomDistance;
    
    // Set player ship position
    if (this.playerShip) {
        this.playerShip.position.set(spawnX, this.playerShip.position.y, spawnZ);
        
        // Set random rotation
        this.playerShip.rotation.y = Math.random() * Math.PI * 2;
        
        console.log(`Player spawned at position: [${spawnX.toFixed(2)}, ${spawnZ.toFixed(2)}], rotation: ${this.playerShip.rotation.y.toFixed(2)}`);
    }
    
    // Apply ship color if specified
    if (selection.color && this.playerShip) {
        const color = new THREE.Color(selection.color);
        
        // Apply color to all meshes in the ship model
        this.playerShip.traverse(child => {
            if (child.isMesh && child.material) {
                try {
                    // Clone the material to avoid affecting other instances
                    if (!child.material._isCloned) {
                        child.material = child.material.clone();
                        child.material._isCloned = true;
                    }
                    
                    // Update material color properties with safety checks
                    if (child.material.color) {
                        child.material.color.set(color);
                    }
                    
                    if (child.material.emissive) {
                        child.material.emissive.set(color);
                        child.material.emissiveIntensity = 0.3;
                    }
                    
                    // Update the material
                    child.material.needsUpdate = true;
                } catch (error) {
                    console.warn('Error setting material properties:', error);
                }
            }
        });
    }
    
    console.log('✅ Ship configuration applied successfully');
    
    // Verify collision detection is working
    console.log('🔍 Verifying collision detection is working');
}

exitToMainMenu() {
    // Stop animation loop
    this.isRunning = false;

    // Hide in-game menu if it exists
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
      menuContainer.classList.add('hidden');
    }

    // Hide game UI
    this.ui.hide();
    if (this.miniMap) {
      this.miniMap.hide();
    }
    this.fadeOutControls();

    // Clean up ship selection if it exists
    if (this.shipSelection) {
      this.shipSelection.hide();
    }

    // Show start screen
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
      startScreen.classList.add('fade-in');
    }

    // Reset game state
    this.resetGameState();
  }

  resetGameState() {
    console.log('🔄 Resetting game state...');
    
    // Reset player position
    if (this.playerShip) {
        this.playerShip.position.set(0, 0.5, 0);
        this.playerShip.rotation.set(0, 0, 0);
    }
    
    // Reset camera to original position
    if (this.camera) {
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);
    }
    
    // Reset player stats
    this.health = this.maxHealth || 100;
    this.energy = this.maxEnergy || 100;
    
    // Update UI - use existing methods if available
    if (typeof this.updateUI === 'function') {
        this.updateUI();
    } else {
        // Update health bar
        const healthBar = document.querySelector('.health-bar .bar-inner');
        if (healthBar) {
            healthBar.style.width = '100%';
        }
        
        // Update energy bar
        const energyBar = document.querySelector('.energy-bar .bar-inner');
        if (energyBar) {
            energyBar.style.width = '100%';
        }
    }
    
    // Original way of clearing lasers
    if (this.lasers) {
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            const laser = this.lasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.lasers = [];
    }
    
    // Clear bouncing lasers
    if (this.bouncingLasers) {
        for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
            const laser = this.bouncingLasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.bouncingLasers = [];
    }
    
    // Clear grenades
    if (this.grenades) {
        for (let i = this.grenades.length - 1; i >= 0; i--) {
            const grenade = this.grenades[i];
            if (grenade.mesh && grenade.mesh.parent) {
                grenade.mesh.parent.remove(grenade.mesh);
            }
        }
        this.grenades = [];
    }
    
    // Reset movement keys
    this.keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        strafeLeft: false,
        strafeRight: false
    };
    
    // Reset weapon state to original
    this.currentWeapon = 'laser';
    this.weaponCooldown = 0;
    this.grenadeTargeting = false;
    
    // Make sure the player exists
    if (!this.playerShip) {
        this.createDefaultShip();
    }
    
    // Reset player velocity (original behavior)
    this.playerVelocity = new THREE.Vector3();
    this.playerRotation = new THREE.Vector3();
    
    // Update weapon UI - use existing method if available
    if (typeof this.updateWeaponUI === 'function') {
        this.updateWeaponUI();
    }
    
    // Update control indicators - use existing method if available
    if (typeof this.updateControlIndicators === 'function') {
        this.updateControlIndicators();
    }
    
    console.log('✅ Game state reset complete');
  }

  handleDirectionalFiring(event) {
    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);

    // Check for intersection with an invisible plane at ship's height
    const planeNormal = new THREE.Vector3(0, 1, 0);
    const shipHeight = this.playerShip.position.y;
    const plane = new THREE.Plane(planeNormal, -shipHeight);
    
    const targetPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, targetPoint);

    if (targetPoint) {
        // Calculate direction from ship to target
        const direction = targetPoint.clone().sub(this.playerShip.position).normalize();
        direction.y = 0; // Keep shots parallel to ground

        // Get the ship's current forward direction
        const shipForward = new THREE.Vector3(0, 0, 1);
        shipForward.applyQuaternion(this.playerShip.quaternion);
        shipForward.y = 0;
        shipForward.normalize();

        // Calculate the angle between ship's forward direction and target direction
        const angle = shipForward.angleTo(direction);
        
        // Only fire if the target is within a reasonable angle (e.g., 60 degrees) from ship's forward direction
        const maxFiringAngle = Math.PI / 3; // 60 degrees
        
        if (angle <= maxFiringAngle) {
            // Fire weapon in the calculated direction
            this.fireCurrentWeapon(direction);
        }
    }
  }

  fireCurrentWeapon(direction) {
    // Check weapon cooldown
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;

    if (now < weaponCooldown) {
        return;
    }

    // Define energy costs for each weapon from GAME_CONFIG
    const energyCosts = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.ENERGY_COST,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.ENERGY_COST,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.ENERGY_COST
    };

    // Check if we have enough energy
    const energyCost = energyCosts[this.currentWeapon];
    if (this.energy < energyCost) {
        console.log(`Not enough energy for ${this.currentWeapon}`);
        return;
    }

    // Set cooldown based on weapon type from GAME_CONFIG
    const cooldowns = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.COOLDOWN,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.COOLDOWN,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.COOLDOWN
    };
    const cooldownTime = cooldowns[this.currentWeapon];

    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);

    // Consume energy
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Update UI with energy change
    if (this.ui && typeof this.ui.updateEnergy === 'function') {
        this.ui.updateEnergy(this.energy, this.maxEnergy);
    }

    // Use target direction if available, otherwise use ship orientation
    let firingDirection;
    
    // If we have a targetDirection from mouse, use that instead of ship orientation
    if (this.targetDirection && (this.currentWeapon === 'LASER' || this.currentWeapon === 'BOUNCE')) {
        firingDirection = this.targetDirection.clone();
        console.log('Using mouse targeting direction:', firingDirection);
    } else {
        // Fall back to ship orientation if no target direction
        firingDirection = direction || new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        console.log('Using ship orientation direction:', firingDirection);
    }
    
    // Ensure direction is normalized
    firingDirection.normalize();
    
    // Get firing position (slightly in front of ship)
    const position = this.playerShip.position.clone().add(firingDirection.clone().multiplyScalar(1.5));
    position.y = 0.5; // Set height

    // Create weapon effect based on type
    switch (this.currentWeapon) {
        case 'LASER':
            this.fireLaser(position, firingDirection);
            this.playSound('laser');
            
            // Send laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection
                });
            }
            break;
        case 'BOUNCE':
            this.fireBouncingLaser(position, firingDirection);
            this.playSound('laser-bounce');
            
            // Send bounce laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection,
                    type: 'bounce'
                });
            }
            break;
        case 'GRENADE':
            // Grenades are handled separately through handleGrenadeTargeting
            break;
    }

    // Visual feedback for firing
    this.createMuzzleFlash(position, firingDirection);

    // Log energy state for debugging
    console.log(`Weapon fired: ${this.currentWeapon}, Energy remaining: ${this.energy}/${this.maxEnergy}`);
}

createMuzzleFlash(position, direction) {
  // Create a quick flash effect at the firing position
  const flashGeometry = new THREE.CircleGeometry(0.3, 16);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
  });
  
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position flash at the weapon position, oriented to face the camera
  flash.position.copy(position);
  flash.position.y += 0.1; // Slightly above ship
  
  // Update flash to always face camera
  flash.lookAt(this.camera.position);
  
  // Add to scene
  this.scene.add(flash);
  
  // Create flash animation with subtle scaling
  let scale = 1;
  const animate = () => {
    scale += 0.2;
    flash.scale.set(scale, scale, scale);
    
    // Reduce opacity as flash grows
    if (flash.material) {
      flash.material.opacity = Math.max(0, 1 - (scale - 1) / 2);
      
      // Remove when fully transparent
      if (flash.material.opacity <= 0) {
        this.scene.remove(flash);
        if (flash.material) flash.material.dispose();
        if (flash.geometry) flash.geometry.dispose();
        return;
      }
    }
    
    // Continue animation
    requestAnimationFrame(animate);
  };
  animate();
}

  fireLaser(position, direction) {
    // Create laser geometry - make it longer and thinner for better visual
    const geometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
    geometry.rotateX(-Math.PI / 2); // Changed rotation to negative to flip direction

    // Create glowing material with better visual effects
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Orient laser along direction - using lookAt for more accurate direction
    const targetPos = position.clone().add(direction.clone().multiplyScalar(10));
    laser.lookAt(targetPos);

    // Add to scene
    this.scene.add(laser);

    // Add point light for glow effect with better parameters
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.set(0, 0, 0); // Center of the laser
    laser.add(light);

    // Add a trail effect
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    this.scene.add(trail);

    // Initialize lasers array if it doesn't exist
    if (!this.lasers) {
      this.lasers = [];
    }

    // Store laser data with enhanced properties
    this.lasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 1.2, // Slightly increased speed for better feel
      lifeTime: 0,
      maxLifeTime: 40,
      trailPoints: [],
      pulsePhase: 0
    });
  }

  fireBouncingLaser(position, direction) {
    // Create bouncing laser geometry - using a smaller sphere for better visuals
    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff99,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Add point light for glow effect
    const light = new THREE.PointLight(0x00ff99, 2, 3);
    laser.add(light);

    // Create enhanced trail effect
    const trail = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({
        color: 0x00ff99,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      })
    );

    // Add to scene
    this.scene.add(laser);
    this.scene.add(trail);

    // Initialize bouncing lasers array if it doesn't exist
    if (!this.bouncingLasers) {
      this.bouncingLasers = [];
    }

    // Store bouncing laser data with improved parameters
    this.bouncingLasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 0.8, // Increased speed for better feel
      bounces: 0,
      maxBounces: 3,
      lifeTime: 0,
      maxLifeTime: 120,
      canHitPlayer: false,
      bounceTimeout: 15, // Reduced timeout for better gameplay
      trailPoints: [],
      pulsePhase: 0
    });
  }

  createHitEffect(position) {
    // Create particle burst effect
    const particleCount = 15;
    const particles = [];
    
    // Create particle material with orange/red color for explosion
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.2, 0.2);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity in all directions
      const velocity = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0;
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.5, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(this.camera.position);
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0xff6600, 3, 6);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles and effects
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }

  showInGameMenu() {
    // Pause the game
    this.isRunning = false;
    
    // Create or reuse the menu element
    let menuContainer = document.getElementById('in-game-menu');
    if (!menuContainer) {
      menuContainer = document.createElement('div');
      menuContainer.id = 'in-game-menu';
      menuContainer.className = 'menu-container';
      document.getElementById('game-container').appendChild(menuContainer);
      
      // Style the menu
      menuContainer.style.position = 'absolute';
      menuContainer.style.top = '50%';
      menuContainer.style.left = '50%';
      menuContainer.style.transform = 'translate(-50%, -50%)';
      menuContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      menuContainer.style.padding = '20px';
      menuContainer.style.borderRadius = '10px';
      menuContainer.style.color = '#fff';
      menuContainer.style.textAlign = 'center';
      menuContainer.style.zIndex = '1000';
      menuContainer.style.border = '2px solid #00ffff';
      menuContainer.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
      menuContainer.style.minWidth = '300px';
    }
    
    // Create menu content
    menuContainer.innerHTML = `
      <h2 style="color: #00ffff; margin-top: 0;">Game Menu</h2>
      <div class="menu-options">
        <button id="resume-button" class="menu-button">Resume Game</button>
        <button id="change-ship-button" class="menu-button">Change Ship</button>
        <button id="exit-button" class="menu-button">Exit to Main Menu</button>
      </div>
    `;
    
    // Style buttons
    const buttons = menuContainer.querySelectorAll('.menu-button');
    buttons.forEach(button => {
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.padding = '10px';
      button.style.margin = '10px 0';
      button.style.backgroundColor = '#001a33';
      button.style.color = '#00ffff';
      button.style.border = '1px solid #00ffff';
      button.style.borderRadius = '5px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '16px';
      button.style.transition = 'all 0.2s';
      
      // Hover effect
      button.onmouseenter = () => {
        button.style.backgroundColor = '#00ffff';
        button.style.color = '#001a33';
      };
      button.onmouseleave = () => {
        button.style.backgroundColor = '#001a33';
        button.style.color = '#00ffff';
      };
    });
    
    // Add event listeners
    document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
    document.getElementById('change-ship-button').addEventListener('click', () => this.showShipChangeScreen());
    document.getElementById('exit-button').addEventListener('click', () => this.exitToMainMenu());
    
    // Show the menu
    menuContainer.classList.remove('hidden');
  }
  
  resumeGame() {
    console.log('Hiding menus');
    
    // Hide ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
    }
    
    // Hide menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
  }
  
  showShipChangeScreen() {
    // Hide the menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
    
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
        console.error('Game container not found');
        return;
    }
    
    // Clean up existing ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
        
        // Safely remove the element from DOM if it exists and has a parent
        if (this.shipSelection.element && this.shipSelection.element.parentNode) {
            this.shipSelection.element.parentNode.removeChild(this.shipSelection.element);
        }
        
        this.shipSelection = null;
    }
    
    // Create new ship selection instance
    this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
            this.shipSelection.hide();
            this.applyShipSelection(selection);
        }
    });
    
    // Show the ship selection UI
    this.shipSelection.show();
  }

  /**
   * Calculate proper ground offset for an object based on its type and geometry
   */
  calculateGroundOffset(model, category, scale) {
    // Get the bounding box
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Calculate the distance from the object's pivot to its bottom
    const pivotToBottom = bbox.min.y;
    
    // The base offset is the distance needed to move the object so its bottom touches the ground
    let groundOffset = -pivotToBottom;
    
    // Add category-specific adjustments with more refined values
    switch(category) {
      case 'rocks':
        // Rocks typically need to be slightly embedded in the ground
        groundOffset += size.y * 0.08;
        break;
      case 'flora':
        // Flora should be firmly planted in the ground
        groundOffset += size.y * 0.03;
        break;
      case 'groundFeatures':
        // Ground features should be partially embedded, varying by model
        if (model.name && model.name.includes('Ground02')) {
          groundOffset += size.y * 0.15; // SP_Ground02 needs more embedding
        } else if (model.name && model.name.includes('Ground05')) {
          groundOffset += size.y * 0.05; // SP_Ground05 needs less embedding
        } else {
          groundOffset += size.y * 0.1; // Default for other ground features
        }
        break;
      case 'crystals':
        // Crystals should appear to be growing from the ground
        groundOffset += size.y * 0.15;
        break;
      case 'mountains':
        // Mountains need to be firmly embedded with varying depths
        const mountainDepth = 0.08 + (Math.random() * 0.05); // Random depth between 8-13%
        groundOffset += size.y * mountainDepth;
        break;
      case 'centerpiece':
        // Centerpiece gets special treatment
        groundOffset += size.y * 0.12;
        break;
      default:
        // Default adjustment for unknown types
        groundOffset += 0;
    }
    
    // Scale the offset according to the object's scale
    // Add a small global offset to prevent z-fighting
    return (groundOffset * scale) + 0.01;
  }

  /**
   * Create a special centerpiece for the landscape
   */
  createCenterpiece() {
    // Create a special formation at a designated spot
    const centerpiece = {
      position: new THREE.Vector3(0, 0, -35), // Prominent position
      models: [
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 2.5, offset: new THREE.Vector3(0, 0, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.8, offset: new THREE.Vector3(2, 0, 1), rotation: Math.PI/4 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.6, offset: new THREE.Vector3(-1.5, 0, -1), rotation: -Math.PI/5 },
        { path: 'assets/models/objects/SP_Ground05.glb', scale: 2.0, offset: new THREE.Vector3(0, -0.5, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Stone01.glb', scale: 1.2, offset: new THREE.Vector3(2.5, 0, -1.5), rotation: Math.PI/3 }
      ]
    };
    
    // Load each model in the centerpiece
    centerpiece.models.forEach((model, index) => {
      const loader = new GLTFLoader();
      loader.load(
        model.path,
        (gltf) => {
          const object = gltf.scene;
          
          // Apply scale
          object.scale.set(model.scale, model.scale, model.scale);
          
          // Position relative to centerpiece
          object.position.copy(centerpiece.position.clone().add(model.offset));
          
          // Apply rotation
          object.rotation.y = model.rotation;
          
          // Add special glow effect for crystals
          if (model.path.includes('Crystal')) {
            object.traverse(node => {
              if (node.isMesh && node.material) {
                node.material.emissive = new THREE.Color(0xff00ff);
                node.material.emissiveIntensity = 0.5;
                
                // Add a point light for extra effect
                const light = new THREE.PointLight(0xff00ff, 2, 10);
                light.position.set(0, 2 * model.scale, 0);
                object.add(light);
              }
            });
          }
          
          // Add to scene
          this.scene.add(object);
          
          // Create collision data
          const bbox = new THREE.Box3().setFromObject(object);
          const size = bbox.getSize(new THREE.Vector3());
          
          // Use improved ground placement
          const groundY = this.calculateGroundOffset(object, 'centerpiece', model.scale);
          object.position.y = groundY + model.offset.y; // Add the intentional offset for composition
          
          // Generate compound collision shapes
          const collisionShapes = this.generateCompoundCollisionShapes(object, 'centerpiece', model.scale);
          
          // Add to obstacles
          this.obstacles.push({
            mesh: object,
            type: 'centerpiece',
            collisionShape: 'compound',
            compoundShapes: collisionShapes.map(shape => {
              // Transform shape centers to world coordinates
              const worldCenter = shape.center.clone();
              worldCenter.add(object.position);
              
              return {
                ...shape,
                center: worldCenter,
                worldRotation: object.rotation.y + (shape.rotation || 0)
              };
            }),
            boundingBox: {
              min: new THREE.Vector3(
                object.position.x - (size.x * model.scale / 2),
                object.position.y - (size.y * model.scale / 2),
                object.position.z - (size.z * model.scale / 2)
              ),
              max: new THREE.Vector3(
                object.position.x + (size.x * model.scale / 2),
                object.position.y + (size.y * model.scale / 2),
                object.position.z + (size.z * model.scale / 2)
              ),
              size: size.clone().multiplyScalar(model.scale),
              rotation: object.rotation.y
            },
            size: Math.max(size.x, size.z) * model.scale * 0.5,
            position: object.position.clone()
          });
          
          console.log(`Centerpiece: Added ${model.path.split('/').pop()} at position [${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)}]`);
        },
        undefined,
        (error) => {
          console.error(`Error loading centerpiece model ${model.path}:`, error);
        }
      );
    });
  }

  /**
   * Create a special effect when colliding with crystals
   */
  createCrystalCollisionEffect(position, isSpecial = false) {
    // Create particles for crystal collision
    const particleCount = isSpecial ? 30 : 15;
    const color = isSpecial ? 0xff00ff : 0x00ffff;
    
    for (let i = 0; i < particleCount; i++) {
      // Create a small glowing cube
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      
      // Position at collision point
      particle.position.copy(position);
      
      // Add small random offset
      particle.position.x += (Math.random() - 0.5) * 2;
      particle.position.y += Math.random() * 3;
      particle.position.z += (Math.random() - 0.5) * 2;
      
      // Add to scene
      this.scene.add(particle);
      
      // Create velocity for particle
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.2 + 0.1,
        (Math.random() - 0.5) * 0.2
      );
      
      // Animate the particle
      const startTime = Date.now();
      const duration = 1000 + Math.random() * 1000; // 1-2 seconds
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Remove particle when animation completes
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return;
        }
        
        // Update position
        particle.position.add(velocity);
        
        // Slow down over time
        velocity.multiplyScalar(0.98);
        
        // Fade out
        particle.material.opacity = 0.8 * (1 - progress);
        
        // Continue animation
        requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
    }
  }

  /**
   * Generate compound collision shapes for more accurate collision detection
   */
  generateCompoundCollisionShapes(model, category, scale) {
    // Generate a compound collision shape based on model geometry and category
    const shapes = [];
    const bbox = new THREE.Box3().setFromObject(model);
    
    // Helper function to add a box shape
    const addBoxShape = (center, size, rotation = 0) => {
      shapes.push({
        type: 'box',
        center: center.clone(),
        halfExtents: size.clone().multiplyScalar(0.5),
        rotation: rotation
      });
    };
    
    // Helper function to add a sphere shape
    const addSphereShape = (center, radius) => {
      shapes.push({
        type: 'sphere',
        center: center.clone(),
        radius: radius
      });
    };
    
    // Different collision shape strategies based on category
    switch(category) {
      case 'rocks':
        // For rocks, use 1-3 overlapping boxes based on size
        const rockSize = bbox.getSize(new THREE.Vector3());
        const rockCenter = new THREE.Vector3();
        bbox.getCenter(rockCenter);
        
        // Main box
        addBoxShape(rockCenter, rockSize);
        
        // For larger rocks, add 1-2 more boxes at slight offsets for better shape approximation
        if (rockSize.x > 1.5 * scale || rockSize.z > 1.5 * scale) {
          // Add a second box, slightly offset and rotated
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3 * rockSize.x,
            0,
            (Math.random() - 0.5) * 0.3 * rockSize.z
          );
          
          const secondSize = new THREE.Vector3(
            rockSize.x * (0.7 + Math.random() * 0.3),
            rockSize.y * 0.9,
            rockSize.z * (0.7 + Math.random() * 0.3)
          );
          
          addBoxShape(rockCenter.clone().add(offset), secondSize, Math.PI * 0.25);
          
          // For very large rocks, add a third box
          if (rockSize.x > 2.5 * scale || rockSize.z > 2.5 * scale) {
            const thirdOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4 * rockSize.x,
              rockSize.y * 0.2,
              (Math.random() - 0.5) * 0.4 * rockSize.z
            );
            
            const thirdSize = new THREE.Vector3(
              rockSize.x * (0.6 + Math.random() * 0.2),
              rockSize.y * 0.7,
              rockSize.z * (0.6 + Math.random() * 0.2)
            );
            
            addBoxShape(rockCenter.clone().add(thirdOffset), thirdSize, Math.PI * 0.125);
          }
        }
        break;
        
      case 'flora':
        // For flora, use a smaller box for the base and a sphere for the top
        const floraSize = bbox.getSize(new THREE.Vector3());
        const floraCenter = new THREE.Vector3();
        bbox.getCenter(floraCenter);
        
        // Box for the base/stem
        const stemSize = new THREE.Vector3(
          floraSize.x * 0.2,
          floraSize.y * 0.6,
          floraSize.z * 0.2
        );
        
        const stemCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (stemSize.y / 2),
          floraCenter.z
        );
        
        addBoxShape(stemCenter, stemSize);
        
        // Sphere for the top/foliage
        const foliageCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (floraSize.y * 0.7),
          floraCenter.z
        );
        
        const foliageRadius = Math.max(floraSize.x, floraSize.z) * 0.5;
        addSphereShape(foliageCenter, foliageRadius);
        break;
        
      case 'mountains':
        // For mountains, use a pyramid-like composition of boxes
        const mountainSize = bbox.getSize(new THREE.Vector3());
        const mountainCenter = new THREE.Vector3();
        bbox.getCenter(mountainCenter);
        
        // Base box (wider)
        const baseSize = new THREE.Vector3(
          mountainSize.x,
          mountainSize.y * 0.3,
          mountainSize.z
        );
        
        const baseCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + (baseSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(baseCenter, baseSize);
        
        // Middle box (narrower)
        const middleSize = new THREE.Vector3(
          mountainSize.x * 0.8,
          mountainSize.y * 0.4,
          mountainSize.z * 0.8
        );
        
        const middleCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + (middleSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(middleCenter, middleSize);
        
        // Top box (narrowest)
        const topSize = new THREE.Vector3(
          mountainSize.x * 0.5,
          mountainSize.y * 0.3,
          mountainSize.z * 0.5
        );
        
        const topCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + middleSize.y + (topSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(topCenter, topSize);
        break;
        
      case 'crystals':
        // For crystals, use a combination of boxes at different angles
        const crystalSize = bbox.getSize(new THREE.Vector3());
        const crystalCenter = new THREE.Vector3();
        bbox.getCenter(crystalCenter);
        
        // Calculate a better fitting box size (narrower)
        const mainCrystalSize = new THREE.Vector3(
          crystalSize.x * 0.7,
          crystalSize.y,
          crystalSize.z * 0.7
        );
        
        // Add the main crystal shape
        addBoxShape(crystalCenter, mainCrystalSize, model.rotation.y);
        
        // For larger crystals, add some angled shards
        if (crystalSize.y > 1.0 * scale) {
          // Add up to 3 additional shards
          const shardCount = 1 + Math.floor(Math.random() * 3);
          
          for (let i = 0; i < shardCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = crystalSize.x * 0.3;
            
            const offset = new THREE.Vector3(
              Math.cos(angle) * distance,
              crystalSize.y * (Math.random() * 0.2),
              Math.sin(angle) * distance
            );
            
            const shardSize = new THREE.Vector3(
              crystalSize.x * (0.2 + Math.random() * 0.3),
              crystalSize.y * (0.4 + Math.random() * 0.4),
              crystalSize.z * (0.2 + Math.random() * 0.3)
            );
            
            const shardRotation = Math.random() * Math.PI;
            addBoxShape(crystalCenter.clone().add(offset), shardSize, shardRotation);
          }
        }
        break;
        
      case 'groundFeatures':
        // For ground features, use a more accurate horizontal shape with the right height
        const groundSize = bbox.getSize(new THREE.Vector3());
        const groundCenter = new THREE.Vector3();
        bbox.getCenter(groundCenter);
        
        // Just use a single box but with better proportions
        const adjustedSize = new THREE.Vector3(
          groundSize.x,
          groundSize.y * 0.7, // Lower height to prevent floating
          groundSize.z
        );
        
        // Center it properly on the ground
        const adjustedCenter = new THREE.Vector3(
          groundCenter.x,
          bbox.min.y + (adjustedSize.y / 2),
          groundCenter.z
        );
        
        addBoxShape(adjustedCenter, adjustedSize, model.rotation.y);
        break;
        
      case 'centerpiece':
        // For centerpiece, create a custom multi-part shape
        const centerpieceSize = bbox.getSize(new THREE.Vector3());
        const centerpieceCenter = new THREE.Vector3();
        bbox.getCenter(centerpieceCenter);
        
        // Main box
        addBoxShape(centerpieceCenter, centerpieceSize);
        
        // Add a sphere on top for the crystal parts
        const sphereCenter = new THREE.Vector3(
          centerpieceCenter.x,
          centerpieceCenter.y + (centerpieceSize.y * 0.2),
          centerpieceCenter.z
        );
        
        const sphereRadius = Math.max(centerpieceSize.x, centerpieceSize.z) * 0.6;
        addSphereShape(sphereCenter, sphereRadius);
        break;
        
      default:
        // Default: just use a box based on the bounding box
        const size = bbox.getSize(new THREE.Vector3());
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        addBoxShape(center, size);
        break;
    }
    
    return shapes;
  }

  updateOtherPlayers() {
    if (!this.networkManager || !this.multiplayerEnabled || !this.assetLoader) return;
  
    const otherPlayers = this.networkManager.getOtherPlayers();
    if (!this.otherPlayerObjects) this.otherPlayerObjects = {};
  
    otherPlayers.forEach(playerData => {
      let playerObject = this.otherPlayerObjects[playerData.id];
  
      if (!playerObject) {
        console.log('Creating new player representation for:', playerData.id);
        const shipType = (playerData.shipType || 'STANDARD').toUpperCase();
        const shipModel = this.assetLoader.getOpponentShipModel(shipType);
  
        if (!shipModel) {
          console.warn(`No model found for ship type: ${shipType}, falling back to default`);
          // Fallback geometry if model fails
          const geometry = new THREE.ConeGeometry(0.5, 1.0, 8);
          geometry.rotateX(Math.PI / 2);
          const material = new THREE.MeshPhongMaterial({ 
            color: playerData.teamColor || 0x00ffff,
            emissive: playerData.teamColor || 0x00ffff,
            emissiveIntensity: 0.5
          });
          const ship = new THREE.Mesh(geometry, material);
          this.scene.add(ship);
          playerObject = { ship, lastUpdate: Date.now() };
        } else {
          // Scale the model consistently (matching player ship scaling)
          shipModel.scale.set(0.45, 0.45, 0.45);
          this.scene.add(shipModel);
          playerObject = { ship: shipModel, lastUpdate: Date.now() };
        }
  
        // Add engine glow
        const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
        engineGlow.position.set(0, 0, -0.7);
        playerObject.ship.add(engineGlow);
        playerObject.engineGlow = engineGlow;
  
        // Add name label
        const nameDiv = document.createElement('div');
        nameDiv.className = 'player-label';
        nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
        const nameLabel = new CSS2DObject(nameDiv);
        nameLabel.position.set(0, 1.8, 0);
        playerObject.ship.add(nameLabel);
        playerObject.nameLabel = nameLabel;
  
        this.otherPlayerObjects[playerData.id] = playerObject;
      }
  
      // Update position and rotation
      if (playerData.position) {
        playerObject.ship.position.lerp(
          new THREE.Vector3(playerData.position.x, playerData.position.y || 0.5, playerData.position.z),
          0.3
        );
      }
      if (playerData.rotation !== undefined) {
        const targetY = playerData.rotation;
        let rotDiff = targetY - playerObject.ship.rotation.y;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerObject.ship.rotation.y += rotDiff * 0.3;
      }
  
      playerObject.lastUpdate = Date.now();
    });
  
    // Clean up disconnected players
    const now = Date.now();
    Object.keys(this.otherPlayerObjects).forEach(id => {
      const playerObj = this.otherPlayerObjects[id];
      if (now - playerObj.lastUpdate > 10000) {
        console.log('Removing disconnected player:', id);
        this.scene.remove(playerObj.ship);
        delete this.otherPlayerObjects[id];
        this.updatePlayerCount();
      }
    });
  }

  // Helper method to send player position and rotation to the server
  sendPlayerPositionUpdate() {
    if (!this.playerShip || !this.networkManager || !this.networkManager.isConnected()) return;
    
    // Create a simple data object with player information
    const playerData = {
      position: {
        x: this.playerShip.position.x,
        y: this.playerShip.position.y,
        z: this.playerShip.position.z
      },
      rotation: this.playerShip.rotation.y,
      shipType: this.currentShipType || 'STANDARD',
      name: this.playerName
    };
    
    // Send the update to the network manager
    this.networkManager.sendPlayerUpdate(playerData);
  }

  // Add the missing setShipModel function
  setShipModel(type) {
    console.log('🔍 Setting ship model:', type);
    
    // Get the ship model from assets
    let model = this.assetLoader.getShipModel(type);
    
    // If model is null or undefined, create fallback model
    if (!model) {
      console.warn('⚠️ Using fallback ship model for type:', type);
      
      // Create a simple geometric shape as fallback
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, 
        specular: 0x111111, 
        shininess: 30 
      });
      model = new THREE.Mesh(geometry, material);
    }
    
    // Clear existing player ship if it exists
    if (this.playerShip) {
      if (this.scene) {
        this.scene.remove(this.playerShip);
      }
      this.playerShip = null;
    }
    
    // Set the new ship model
    this.playerShip = model;
    
    // Position the ship appropriately
    if (this.playerShip && this.scene) {
      this.playerShip.position.set(0, 0.5, 0);
      this.scene.add(this.playerShip);
    }
    
    return this.playerShip;
  }

  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.soundManager) {
      console.log(`Playing sound: ${name}`);
      this.soundManager.playSound(name, position);
    } else {
      console.warn(`Cannot play sound '${name}': SoundManager not initialized`);
    }
  }

  /**
   * Update a remote player's position and rotation
   * @param {string} id - Player ID
   * @param {Object} position - Position coordinates
   * @param {Object} rotation - Rotation coordinates
   */
  updateRemotePlayer(id, position, rotation) {
    // Get existing player or create a new one
    let player = this.remotePlayers.get(id);
    
    if (!player) {
      // Create a new player mesh if this is the first update
      player = this.createRemotePlayerMesh();
      this.remotePlayers.set(id, player);
      this.scene.add(player);
      console.log(`Created new remote player: ${id}`);
    }
    
    // Update player position and rotation
    if (position) {
      player.position.set(position.x, position.y, position.z);
    }
    
    if (rotation) {
      player.rotation.set(rotation.x, rotation.y, rotation.z);
    }
  }
  
  /**
   * Create a mesh for a remote player
   * @returns {THREE.Object3D} Player mesh
   */
  createRemotePlayerMesh() {
    // For simplicity, we'll use a simple colored box for remote players
    const geometry = new THREE.BoxGeometry(1, 1, 2);
    const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red for other players
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'player-label';
    nameLabel.textContent = 'Player';
    
    const playerLabel = new CSS2DObject(nameLabel);
    playerLabel.position.set(0, 1.5, 0);
    mesh.add(playerLabel);
    
    return mesh;
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize game
  const game = new SimpleGame();
  
  // Add start button event listener
  document.getElementById('start-button').addEventListener('click', () => {
    // Get the player name from the input field
    const playerNameInput = document.getElementById('player-name');
    if (playerNameInput && playerNameInput.value.trim() !== '') {
      // Store the player name
      game.playerName = playerNameInput.value.trim();
      console.log(`Player name set to: ${game.playerName}`);
    } else {
      console.log('Using default player name: ' + game.playerName);
    }
    
    // Start the game
    game.startGame();
  });
}); 
### ./index.js END ###

### ./codebase.md BEGIN ###
### DIRECTORY . FOLDER STRUCTURE ###
./
    index.html
    flatten.py
    index.js
    codebase.md
    ui/
        ShipSelectionUI.js
        GameRoom.js
        GameUI.js
        MiniMap.js
    scenes/
        TeamDemo.js
    core/
        Game.js
        TeamManager.js
        Scene.js
        GameEngine.js
        Engine.js
        NetworkManager.js
        InfiniteMap.js
    config/
        ShipConfig.js
        Controls.js
        GameConfig.js
    constants/
    utils/
    styles/
        main.css
        controls.css
    effects/
    assets/
        ModelLoader.js
        SoundManager.js
        .DS_Store
        AssetLoader.js
        textures/
        images/
        models/
            .DS_Store
            textures/
                tex.png
                Colors3.png
            ships/
                ALTSPACE2.glb
                ALTSPACE1.glb
            flora/
                Grass_01.glb
                .DS_Store
                SmalRoots_01.glb
                BigPlant_06.glb
                SP_Plant08.glb
                SP_Plant07.glb
                Mushrooms.glb
                SP_Tree04.glb
                SP_Tree02.glb
                SP_Tree03.glb
                SP_Tree01.glb
                Tenticles_01.glb
            objects/
                .DS_Store
                SP_Stone01.glb
                SP_Mountain03.glb
                SP_Mountain02.glb
                SP_Mountain01.glb
                SP_Ground03.glb
                SP_Ground02.glb
                SP_Ground05.glb
                SP_Ground04.glb
            terrain/
                .DS_Store
                Water.glb
                Terrain.glb
            rocks/
                SP_Rock01.glb
                SP_Rock03.glb
                SP_Rock02.glb
                SP_Rock06.glb
                .DS_Store
                SP_Rock07.glb
                SP_Rock05.glb
                SP_Rock04.glb
                SP_Rock09.glb
                SP_Rock08.glb
        sounds/
            weapon-switch.mp3
            laser.mp3
            bounce.mp3
            weapon-charging.mp3
            grenade-laser.mp3
            laser-bounce.mp3
            weapon-armor-hit.mp3
    entities/
        Ship.js
        obstacles/
        weapons/
            RegularLaser.js
            WeaponSystem.js
            Laser.js
        enemies/
            EnemyManager.js
            Enemy.js
        player/
            Player.js
### DIRECTORY . FOLDER STRUCTURE ###

### DIRECTORY . FLATTENED CONTENT ###
### ./index.html BEGIN ###
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/main.css">
    <link rel="stylesheet" href="./styles/controls.css">
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="loader"></div>
            <p>Loading the quantum realm...</p>
        </div>
    </div>
    
    <div id="start-screen" class="hidden">
        <div class="start-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="player-input">
                <input type="text" id="player-name" maxlength="15" placeholder="Enter your pilot name" />
                <p class="input-info">Your name will be visible to other players</p>
            </div>
            <button id="start-button" class="glow-button">START GAME</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>
    
    <!-- Multiplayer Info -->
    <div id="multiplayer-info" class="hidden">
        <div class="connection-indicator">
            <span>Connection: </span>
            <span id="connection-status">Disconnected</span>
        </div>
        <div class="players-indicator">
            <span>Players: </span>
            <span id="players-count">0</span>
        </div>
    </div>
    
    <!-- Simple HUD for controls info -->
    <div class="controls-info hidden">
        <p>W/↑: Forward | S/↓: Backward</p>
        <p>A/← D/→: Rotate Ship</p>
        <p>Q/E: Strafe Left/Right</p>
        <p>Space: Fire Laser</p>
        <p>Avoid the colored obstacles!</p>
    </div>
</body>
<script type="module" src="./index.js"></script>
</html> 
### ./index.html END ###

### ./flatten.py BEGIN ###
import os
import argparse

def printFolderStructure(directory, output_file):
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n")
    for root, directories, files in os.walk(directory):
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write('{}{}/\n'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            output_file.write('{}{}\n'.format(subindent, f))
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n\n")

def walkFolderTree(folder):
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            yield os.path.join(dirpath, filename)

def main():
    parser = argparse.ArgumentParser(description='Flattens a codebase.')
    parser.add_argument('--folders', nargs='*', help='Base folders to process')
    parser.add_argument('--system_instructions', action='store_true', help='Print system instructions')

    system_instructions = """## System Instructions for Language Model Assistance in Code Debugging

### Role Definition:
- **Act as a software engineer** tasked with assisting in debugging code.
- Provide insights, explanations, and solutions based on the provided codebase information.

### Codebase Markdown File Structure:
- The codebase markdown file represents the actual codebase structure and content.
- It begins with a directory tree representation:
  ```
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  (file tree representation)
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  ```
- Following the directory tree, the contents of each file are displayed:
  ```
  ### path/to/file1 BEGIN ###
  (content of file1)
  ### path/to/file1 END ###
  
  ### path/to/file2 BEGIN ###
  (content of file2)
  ### path/to/file2 END ###
  ```

### Guidelines for Interaction:
- Respond to queries based on the explicit content provided within the markdown file.
- Avoid making assumptions about the code without clear evidence presented in the file content.
- When seeking specific implementation details, refer to the corresponding section in the markdown file, for example:
  ```
  ### folder1/folder2/myfile.ts BEGIN ###
  (specific implementation details)
  ### folder1/folder2/myfile.ts END ###
  ```

### Objective:
- The primary objective is to facilitate effective debugging by providing accurate information and guidance strictly adhering to the content available in the markdown file."""

    args = parser.parse_args()

    if args.system_instructions:
        print(system_instructions)

        if not args.folders:
            return

    if args.folders:
        base_folders = args.folders
        with open('codebase.md', 'w') as output_file:
            for base_folder in base_folders:
                printFolderStructure(base_folder, output_file)
                
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
                for filepath in walkFolderTree(base_folder):
                    content = f"### {filepath} BEGIN ###\n"
                    
                    try:
                        with open(filepath, "r") as f:
                            content += f.read()
                        content += f"\n### {filepath} END ###\n\n"
                    except:
                        continue
                    
                    output_file.write(content)
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
    else:
        print("usage: main.py [-h] --folders FOLDERS [FOLDERS ...] [--system_instructions]")
        print("Error: the following arguments are required: --folders")

if __name__ == "__main__":
    main()
### ./flatten.py END ###

### ./index.js BEGIN ###
import * as THREE from 'three';
import { OrbitControls } from '@three/examples/controls/OrbitControls';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import './styles/main.css';
import { GameUI } from './ui/GameUI';
import { MiniMap } from './ui/MiniMap';
import { CONTROL_SETTINGS, CONTROL_FEEDBACK, DEFAULT_CONTROL_STATE, ControlUtils } from './config/Controls';
import { ShipSelectionUI } from './ui/ShipSelectionUI';
import AssetLoader from './assets/AssetLoader';
import { InfiniteMap } from './core/InfiniteMap';
import { NetworkManager } from './core/NetworkManager';
import { CSS2DRenderer, CSS2DObject } from '@three/examples/renderers/CSS2DRenderer';
import { GAME_CONFIG } from './config/GameConfig';
import { Player } from './entities/player/Player';
import { SoundManager } from './assets/SoundManager';

// Basic Three.js game with a ship
class SimpleGame {
  constructor() {
    // Initialize all properties first
    // Player information
    this.playerName = 'Pilot';  // Default player name
    
    // Create the asset loader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => this.updateLoadingUI(message),
      (type, error) => this.handleLoadError(type, error)
    );
    
    // Initialize SoundManager
    this.soundManager = new SoundManager();
    
    // Asset loading state
    this.loadingState = {
      started: false,
      completed: false,
      errors: []
    };
    
    // Track assets loading
    this.assetsLoaded = false;
    this.shipModelLoaded = false;
    
    // Initialize control state
    this.keys = { ...DEFAULT_CONTROL_STATE };
    
    // Setup animation timing
    this.clock = new THREE.Clock();
    this.lastTime = Date.now();
    
    // Event handling - bind methods
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    
    // Debounce timers
    this.mouseMoveTimer = null;
    this.resizeTimer = null;
    this.weaponCooldowns = new Map();
    this.lastWeaponSwitch = 0;

    // Setup basic Three.js scene
    this.setupScene();
    
    // Create game UI
    this.ui = new GameUI();
    
    // Create player after scene setup (as specified in Task 8)
    this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
      type: 'PLAYER',
      shipModel: 'STANDARD',
      teamColor: 0x00ffff
    });
    this.scene.add(this.player.mesh);
    
    // For backward compatibility with existing code
    this.playerShip = this.player.mesh;
    
    // Game properties
    this.boundarySize = 100; // Size of the playable area
    
    // Initialize player state
    this.health = 100;
    this.maxHealth = 100;
    this.energy = 100;
    this.maxEnergy = 100;
    this.energyRechargeRate = 20; // Units per second
    this.currentWeapon = 'LASER';
    
    // Initialize available weapons
    this.availableWeapons = ['LASER', 'GRENADE', 'BOUNCE'];
    this.weaponIndex = 0; // Start with LASER
    
    // Load assets
    this.loadAssets();
    
    // Setup controls
    this.setupControls();
    
    // Initialize infinite map after scene setup
    this.infiniteMap = new InfiniteMap(this);
    
    // Create mini-map (after scene setup) but keep it hidden initially
    this.miniMap = new MiniMap(this);
    this.miniMap.hide(); // Make sure it starts hidden
    
    // Handle window resize
    window.addEventListener('resize', this.boundHandleResize);
    
    console.log('Simple game initialized!');

    // Add frame counter
    this.frameCount = 0;
    
    // Initialize NetworkManager
    this.networkManager = new NetworkManager();
    
    // Initialize remotePlayers map for multiplayer
    this.remotePlayers = new Map();
    
    this.networkManager.on('connected', () => {
      console.log('Connected to game server!');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from game server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      // Update player count
      this.updatePlayerCount();
    });
    
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      // Remove player mesh if it exists
      const player = this.remotePlayers.get(id);
      if (player) {
        this.scene.remove(player);
        this.remotePlayers.delete(id);
        console.log(`Removed remote player: ${id}`);
      }
      // Update player count
      this.updatePlayerCount();
    });
    
    // Add player update handling
    this.networkManager.on('player_update', (data) => {
      this.updateRemotePlayer(data.id, data.position, data.rotation);
    });
    
    // Add laser shot handling
    this.networkManager.on('laser_shot', (shotData) => {
      console.log('Received laser shot from network:', shotData);
      const position = new THREE.Vector3(shotData.origin.x, shotData.origin.y, shotData.origin.z);
      const direction = new THREE.Vector3(shotData.direction.x, shotData.direction.y, shotData.direction.z);

      if (shotData.type === 'bounce') {
        this.fireBouncingLaser(position, direction);
      } else {
        this.fireLaser(position, direction);
      }
    });
    
    // Add helper method to update player count
    this.updatePlayerCount = () => {
      const count = this.networkManager.getOtherPlayers().length + 1; // +1 for self
      document.getElementById('players-count').textContent = count;
    };
    
    this.multiplayerEnabled = false;
  }
  
  setupScene() {
    // Create Three.js Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a1f); // Dark blue background
    
    // Setup WebGL renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(this.renderer.domElement);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near
      1000 // Far
    );
    
    // Position camera
    this.camera.position.set(0, 7, 15); // Slightly above and behind player
    this.camera.lookAt(0, 0, 0);
    
    // Attach audio listener to camera
    if (this.soundManager) {
      this.camera.add(this.soundManager.getListener());
      console.log('Audio listener attached to camera');
    }
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);
    
    // Create a simple grid floor
    this.createFloor();
    
    // Create some obstacles
    this.createObstacles();
  }
  
  async loadAssets() {
    if (this.loadingState.started) {
        console.warn('🔍 Asset loading already in progress');
        return;
    }
    
    this.updateLoadingUI('Loading game assets...');
    
    try {
        // Create initial player with default ship
        if (!this.player) {
            this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
                type: 'PLAYER',
                shipModel: 'STANDARD',
                teamColor: 0x00ffff
            });
            this.playerShip = this.player.mesh; // For backward compatibility
        }
        
        // Load all assets through AssetLoader
        await this.assetLoader.loadAll();
        this.assetsLoaded = true;
        this.shipModelLoaded = true;
        
        console.log('✅ All assets loaded successfully');
        this.checkLoadingProgress();
    } catch (error) {
        console.error('🔍 Critical error loading assets:', error);
        this.handleLoadError('critical', error);
    }
  }
  
  handleLoadError(assetType, error) {
    console.error(`Error loading ${assetType}:`, error);
    this.loadingState.errors.push({ type: assetType, error: error.message });
    
    // Update UI with error
    this.updateLoadingUI(`Error loading ${assetType}. ${this.loadingState.errors.length} errors total.`);
    
    // If critical error, show error screen
    if (assetType === 'critical') {
      this.showErrorScreen('Failed to load game assets. Please refresh the page.');
    }
  }
  
  updateLoadingUI(message) {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const messageElement = loadingScreen.querySelector('.loading-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  }
  
  showErrorScreen(message) {
    // Create error screen if it doesn't exist
    let errorScreen = document.getElementById('error-screen');
    if (!errorScreen) {
      errorScreen = document.createElement('div');
      errorScreen.id = 'error-screen';
      errorScreen.className = 'error-screen';
      
      const errorMessage = document.createElement('div');
      errorMessage.className = 'error-message';
      errorScreen.appendChild(errorMessage);
      
      const retryButton = document.createElement('button');
      retryButton.textContent = 'Retry';
      retryButton.onclick = () => {
        errorScreen.remove();
        this.loadingState = {
          started: false,
          completed: false,
          errors: []
        };
        this.loadAssets();
      };
      errorScreen.appendChild(retryButton);
      
      document.body.appendChild(errorScreen);
    }
    
    // Update error message
    const messageElement = errorScreen.querySelector('.error-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
  }
  
  checkLoadingProgress() {
    console.log('🔍 Checking loading progress...');
    
    // Log loading state
    console.log('Loading state:', JSON.stringify(this.loadingState, null, 2));
    
    // Define what's required for a fully loaded game
    const requiredAssets = {
      shipModel: this.shipModelLoaded,
      assetsLoaded: this.assetLoader.loadingState.completed
    };
    
    // Check if all required assets are loaded
    const allAssetsLoaded = Object.entries(requiredAssets).every(([key, loaded]) => {
      console.log(`🔍 ${key}: ${loaded ? '✅' : '❌'}`);
      return loaded;
    });
    
    if (allAssetsLoaded) {
      console.log('✅ All required assets loaded!');
      this.loadingState.completed = true;
      this.showStartScreen();
    } else {
      // Log which assets are still pending
      const pendingAssets = Object.entries(requiredAssets)
        .filter(([_, loaded]) => !loaded)
        .map(([key]) => key);
      console.log('⏳ Still waiting for:', pendingAssets);
      
      // Update loading UI
      this.updateLoadingUI(`Loading... (${pendingAssets.join(', ')})`);
      
      // Check again after a delay
      setTimeout(() => this.checkLoadingProgress(), 1000);
    }
  }
  
  showStartScreen() {
    console.log('🔍 Attempting to show start screen');
    
    // Timeout to ensure UI has time to update
    setTimeout(() => {
      // Hide loading screen and show start screen
      const loadingScreen = document.getElementById('loading-screen');
      const startScreen = document.getElementById('start-screen');
      
      console.log('🔍 Loading screen element:', loadingScreen);
      console.log('🔍 Start screen element:', startScreen);
      
      if (loadingScreen) {
        console.log('🔍 Adding fade-out class to loading screen');
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          loadingScreen.classList.add('hidden');
          loadingScreen.classList.remove('fade-out');
          console.log('🔍 Loading screen hidden');
        }, 500);
      } else {
        console.error('🔍 Loading screen element not found!');
      }
      
      if (startScreen) {
        console.log('🔍 Showing start screen');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('fade-in');
      } else {
        console.error('🔍 Start screen element not found!');
      }
      
      console.log('🔍 Game ready to start!');
    }, 500);
  }
  
  addThrusterGlow() {
    // Check if player and player mesh exist
    if (!this.player || !this.player.mesh) {
      console.warn('Cannot add thruster glow: Player or player mesh is not initialized');
      return;
    }
    
    // Create a single, efficient thruster glow effect
    // Use instanced mesh for better performance if you have multiple thrusters
    
    // Create a glow for the thruster
    const thrusterGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 12);
    const thrusterMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending // Use additive blending for better glow effect
    });
    
    const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
    thruster.position.set(0, 0, -0.7); // Position at the back of the ship
    thruster.rotation.x = Math.PI / 2;
    thruster.name = 'thruster'; // Name it for easier reference later
    
    // Add thruster to player mesh
    this.player.mesh.add(thruster);
    
    // Add point light for the thruster
    const thrusterLight = new THREE.PointLight(0x00ffff, 1, 3);
    thrusterLight.position.copy(thruster.position);
    thrusterLight.name = 'thrusterLight';
    
    // Store references for animation
    this.thruster = thruster;
    this.thrusterLight = thrusterLight;
    
    // Create a subtle, animated glow effect with proper initialization
    this.thrusterPulse = { 
      value: 0,
      phase: 0 
    };
    
    // Add to ship model
    if (this.shipModel) {
      this.shipModel.add(thruster);
      this.shipModel.add(thrusterLight);
    }
  }
  
  createFloor() {
    console.log('Creating floor with Terrain.glb model');
    
    // Create a placeholder floor initially - this will be visible until the model loads
    const tempFloorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);
    const tempFloorMaterial = new THREE.MeshBasicMaterial({
      color: 0x000022,
      transparent: true,
      opacity: 0.2,
    });
    
    this.floor = new THREE.Mesh(tempFloorGeometry, tempFloorMaterial);
    this.floor.rotation.x = -Math.PI / 2;
    this.floor.position.y = -0.01;
    this.scene.add(this.floor);
    
    // Also create an invisible raycasting plane that will always work for targeting
    // This ensures mouse input works consistently regardless of the visual floor model
    this.raycastFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        transparent: true, 
        opacity: 0.05, // Very slight visibility for debugging
        side: THREE.DoubleSide
      })
    );
    this.raycastFloor.rotation.x = -Math.PI / 2;
    this.raycastFloor.position.y = 0.1; // Position higher above terrain
    this.scene.add(this.raycastFloor);
    
    // Add debug logging
    console.log('Raycast floor created at height:', this.raycastFloor.position.y, 'and size:', 1000);
    
    // Load texture first
    const textureLoader = new THREE.TextureLoader();
    const texturePromise = new Promise((resolve, reject) => {
      textureLoader.load(
        'assets/models/textures/Colors3.png', 
        texture => {
          console.log('Terrain texture (Colors3.png) loaded successfully');
          // Configure texture 
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(8, 8); // Repeat the texture more times for better detail
          resolve(texture);
        },
        undefined,
        error => {
          console.error('Error loading Colors3.png texture:', error);
          // Try fallback texture
          textureLoader.load(
            'assets/models/textures/tex.png', 
            fallbackTexture => {
              console.log('Fallback texture loaded');
              fallbackTexture.wrapS = THREE.RepeatWrapping;
              fallbackTexture.wrapT = THREE.RepeatWrapping;
              fallbackTexture.repeat.set(5, 5);
              resolve(fallbackTexture);
            },
            undefined,
            fallbackError => {
              console.error('Error loading fallback texture:', fallbackError);
              resolve(null); // Resolve with null to continue without texture
            }
          );
        }
      );
    });
    
    // When texture is loaded (or failed), get the terrain model from AssetLoader
    texturePromise.then(texture => {
      // Get terrain model from AssetLoader
      const terrain = this.assetLoader.getModel('terrain/Terrain.glb');
      
      if (terrain) {
        console.log('Using terrain model from AssetLoader');
        
        // Remove the temporary floor
        if (this.floor) {
          this.scene.remove(this.floor);
          this.floor.geometry.dispose();
          this.floor.material.dispose();
        }
        
        // Clone the model to avoid modifying the original
        const terrainClone = terrain.clone();
        
        // Scale the terrain appropriately
        const terrainScale = 100; // Adjust this value to change the overall size
        terrainClone.scale.set(terrainScale, terrainScale * 0.5, terrainScale);
        
        // Position terrain at center and slightly below zero to avoid z-fighting
        terrainClone.position.set(0, -0.2, 0);
        
        // Apply texture if available
        if (texture) {
          terrainClone.traverse((node) => {
            if (node.isMesh) {
              node.material = node.material.clone(); // Clone material to avoid affecting other instances
              node.material.map = texture;
              node.material.needsUpdate = true;
              
              // Enable shadows
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
        }
        
        // Add to scene
        this.scene.add(terrainClone);
        this.terrain = terrainClone;
        
        console.log('Terrain model added to scene');
        
        // Add a circular highlight around the player's position
        this.createPlayerHighlight();
      } else {
        console.warn('Terrain model not found in AssetLoader, using fallback grid');
        
        // Create a grid as fallback
        const grid = new THREE.GridHelper(100, 100, 0x0000ff, 0x000044);
        grid.position.y = 0;
        this.scene.add(grid);
        this.terrain = grid;
        
        // Add player highlight anyway
        this.createPlayerHighlight();
      }
    });
  }

  // Separate method for player highlight to avoid code duplication
  createPlayerHighlight() {
    // Add a circular highlight around the player's position
    const highlightGeometry = new THREE.CircleGeometry(5, 32);
    const highlightMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
    });
    
    this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    this.playerHighlight.rotation.x = -Math.PI / 2;
    this.playerHighlight.position.y = 0.02; // Slightly above the floor
    this.scene.add(this.playerHighlight);
  }
  
  createBoundaryMarkers() {
    const boundarySize = 25; // Should match constrainToBounds boundary
    const markerSize = 1;
    const markerHeight = 1;
    const numMarkers = 10; // Number of markers per side
    
    const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
    const markerMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0x600000,
      transparent: true,
      opacity: 0.7
    });
    
    const markers = new THREE.Group();
    
    // Create boundary markers along the perimeter
    for (let i = 0; i < numMarkers; i++) {
      const t = (i / (numMarkers - 1)) * 2 - 1; // -1 to 1
      const position = boundarySize * t;
      
      // North edge
      const northMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      northMarker.position.set(position, markerHeight / 2, -boundarySize);
      markers.add(northMarker);
      
      // South edge
      const southMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      southMarker.position.set(position, markerHeight / 2, boundarySize);
      markers.add(southMarker);
      
      // East edge
      const eastMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      eastMarker.position.set(boundarySize, markerHeight / 2, position);
      markers.add(eastMarker);
      
      // West edge
      const westMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      westMarker.position.set(-boundarySize, markerHeight / 2, position);
      markers.add(westMarker);
    }
    
    this.scene.add(markers);
  }
  
  createObstacles() {
    // Create obstacle arrays
    this.obstacles = [];
    
    console.log('🚧 Creating immersive landscape with pathways and scattered crystals');
    
    // Define model categories and paths, with a focus on variety and character
    const obstacleCategories = {
      // Small to medium rocks
      rocks: [
        'SP_Rock01.glb', 
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      // Expanded flora selection
      flora: [
        'Grass_01.glb',
        'Mushrooms.glb',
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SmalRoots_01.glb',
        'Tenticles_01.glb',
        'BigPlant_06.glb'
      ],
      // Expanded ground features for creating pathways
      groundFeatures: [
        'objects/SP_Ground02.glb',
        'objects/SP_Ground03.glb',
        'objects/SP_Ground04.glb',
        'objects/SP_Ground05.glb'
      ],
      // Crystal clusters for interest points
      crystals: [
        'objects/SP_Crystal01.glb',
        'objects/SP_Stone01.glb'
      ],
      // Mountains for landscape borders and key landmarks
      mountains: [
        'objects/SP_Mountain01.glb',
        'objects/SP_Mountain02.glb',
        'objects/SP_Mountain03.glb'
      ]
    };
    
    // Enhanced distribution for a more detailed landscape
    const distribution = {
      rocks: 8,
      flora: 10,
      groundFeatures: 18,  // Increased from 12 to 18
      crystals: 9,
      mountains: 12  // Increased from 4 to 12
    };
    
    // Define some pre-made templates for object groupings
    const templates = [
      // Rock garden template
      {
        position: new THREE.Vector3(25, 0, 15),
        rotation: Math.PI / 6,
        elements: [
          { category: 'rocks', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 2.0, rotation: 0 },
          { category: 'rocks', modelIndex: 2, offset: new THREE.Vector3(3, 0, 1), scale: 1.3, rotation: Math.PI/3 },
          { category: 'rocks', modelIndex: 1, offset: new THREE.Vector3(-2, 0, 2), scale: 1.5, rotation: Math.PI/5 },
          { category: 'flora', modelIndex: 1, offset: new THREE.Vector3(2, 0, 3), scale: 1.2, rotation: 0 }
        ]
      },
      // Flora cluster template
      {
        position: new THREE.Vector3(-20, 0, -18),
        rotation: Math.PI / 4,
        elements: [
          { category: 'flora', modelIndex: 4, offset: new THREE.Vector3(0, 0, 0), scale: 1.8, rotation: 0 },
          { category: 'flora', modelIndex: 0, offset: new THREE.Vector3(2, 0, 2), scale: 1.4, rotation: Math.PI/2 },
          { category: 'flora', modelIndex: 3, offset: new THREE.Vector3(-1.5, 0, 1), scale: 1.2, rotation: Math.PI/6 },
          { category: 'rocks', modelIndex: 3, offset: new THREE.Vector3(1, 0, -2), scale: 1.0, rotation: 0 }
        ]
      },
      // Crystal formation template
      {
        position: new THREE.Vector3(-15, 0, 30),
        rotation: -Math.PI / 3,
        elements: [
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 1.5, rotation: 0 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(1.5, 0, 1), scale: 1.0, rotation: Math.PI/2 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(-1, 0, 1.5), scale: 0.8, rotation: Math.PI/4 },
          { category: 'groundFeatures', modelIndex: 2, offset: new THREE.Vector3(0, -0.2, 0), scale: 1.8, rotation: 0 }
        ]
      }
    ];
    
    // Create main pathways (4 paths coming from center, like a cross)
    const pathways = [
      { direction: new THREE.Vector3(1, 0, 0), width: 5 },   // East
      { direction: new THREE.Vector3(-1, 0, 0), width: 5 },  // West
      { direction: new THREE.Vector3(0, 0, 1), width: 5 },   // North
      { direction: new THREE.Vector3(0, 0, -1), width: 5 }   // South
    ];
    
    // Add some curved pathways to make it more interesting
    pathways.push(
      { 
        direction: new THREE.Vector3(0.7, 0, 0.7), 
        width: 4,
        curve: 0.8 // Will curve around
      },
      { 
        direction: new THREE.Vector3(-0.7, 0, -0.7), 
        width: 4,
        curve: -0.5 // Will curve the other way
      }
    );
    
    // Create some crystal gardens (clusters of crystals)
    const crystalGardens = [
      { x: 30, z: 30, radius: 8, count: 4 },
      { x: -25, z: 20, radius: 6, count: 3 },
      { x: 15, z: -35, radius: 10, count: 5 }
    ];
    
    // Function to check if a position is near a pathway
    const isNearPathway = (x, z, pathWidth) => {
      for (const path of pathways) {
        // Create a vector from center to this position
        const posVector = new THREE.Vector3(x, 0, z);
        const length = posVector.length();
        
        // Normalize the vector to compare direction
        if (length > 0) posVector.divideScalar(length);
        
        // Check if this aligns with any pathway
        const dot = posVector.dot(path.direction);
        
        // If aligned with path direction and not too close to center
        if (dot > 0.7 && length > 15 && length < 40) {
          // Calculate perpendicular distance to path
          const perpFactor = Math.sqrt(1 - dot * dot) * length;
          if (perpFactor < (path.width || pathWidth)) {
            return true;
          }
          
          // For curved paths
          if (path.curve) {
            // Check if in a curved region
            if (length > 20) {
              // Apply curvature - this is simplified but creates a nice effect
              const curveFactor = (length - 20) * path.curve * 0.1;
              const curvePerp = Math.abs(perpFactor - curveFactor);
              if (curvePerp < (path.width || pathWidth)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    
    // Function to check if position is in a crystal garden
    const isInCrystalGarden = (x, z) => {
      for (const garden of crystalGardens) {
        const dx = x - garden.x;
        const dz = z - garden.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance < garden.radius) {
          return garden;
        }
      }
      return null;
    };
    
    // Load and place models as obstacles
    for (const [category, models] of Object.entries(obstacleCategories)) {
      const count = distribution[category];
      
      for (let i = 0; i < count; i++) {
        // Select a random model from this category
        const modelPath = models[Math.floor(Math.random() * models.length)];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Create position based on category
        let x, z;
        let attempts = 0;
        let isValid = false;
        let inGarden = null;
        
        while (!isValid && attempts < 30) {
          attempts++;
          
          if (category === 'groundFeatures') {
            // Ground features go along pathways or in open areas
            if (Math.random() < 0.7) {
              // 70% along pathways
              const angle = Math.random() * Math.PI * 2;
              const distance = 15 + Math.random() * 25; // Between 15-40 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
              
              // If not near a pathway, try again
              if (!isNearPathway(x, z, 6)) continue;
            } else {
              // 30% randomly placed
              x = (Math.random() * 80) - 40;
              z = (Math.random() * 80) - 40;
            }
          } else if (category === 'crystals') {
            // Try to place in crystal gardens
            if (Math.random() < 0.7) {
              // 70% in crystal gardens
              const garden = crystalGardens[Math.floor(Math.random() * crystalGardens.length)];
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * garden.radius;
              x = garden.x + Math.cos(angle) * distance;
              z = garden.z + Math.sin(angle) * distance;
              inGarden = garden;
            } else {
              // 30% scattered elsewhere, avoiding pathways
              x = (Math.random() * 70) - 35;
              z = (Math.random() * 70) - 35;
              
              // If near a pathway, try again
              if (isNearPathway(x, z, 6)) continue;
            }
          } else if (category === 'mountains') {
            // Mountains go on the periphery with more diverse placement
            if (i < 4) {
              // Place 4 mountains at the far corners of the map
              const angle = (Math.PI/4) + (i * Math.PI/2); // Place at 45°, 135°, 225°, 315°
              const distance = 40 + Math.random() * 5; // Between 40-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else if (i < 8) {
              // Place 4 mountains at cardinal directions, but further out
              const angle = (i - 4) * Math.PI/2; // Place at 0°, 90°, 180°, 270°
              const distance = 42 + Math.random() * 8; // Between 42-50 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else {
              // Place remaining mountains randomly but still on periphery
              const angle = Math.random() * Math.PI * 2;
              const distance = 35 + Math.random() * 10; // Between 35-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            }
            
            // If near a pathway, try again (want mountains to border but not block paths)
            if (isNearPathway(x, z, 8)) continue;
          } else {
            // Rocks and flora go anywhere but not on paths
            x = (Math.random() * 80) - 40;
            z = (Math.random() * 80) - 40;
            
            // Avoid pathways for these obstacles
            if (isNearPathway(x, z, 5)) continue;
          }
          
          // Keep all objects away from center spawn
          if (Math.sqrt(x * x + z * z) < 15) continue;
          
          // Position is valid
          isValid = true;
        }
        
        if (!isValid) continue; // Skip if couldn't find valid position
        
        // Scale factors tailored by category and context
        let scale;
        if (category === 'rocks') {
          scale = 1.5 + Math.random() * 1.0; // Larger rocks (1.5-2.5)
        } else if (category === 'flora') {
          scale = 1.2 + Math.random() * 0.8; // Taller flora (1.2-2.0)
        } else if (category === 'groundFeatures') {
          if (isNearPathway(x, z, 6)) {
            // Ground features along pathways have more consistent size
            scale = 1.2 + Math.random() * 0.6; // Medium-sized ground (1.2-1.8)
          } else {
            // Ground features away from pathways can vary more
            scale = 0.8 + Math.random() * 1.4; // Variable ground features (0.8-2.2)
          }
        } else if (category === 'crystals') {
          if (inGarden) {
            // Varied crystal sizes in gardens
            scale = 0.5 + Math.random() * 1.4; // Variety of sizes (0.5-1.9)
          } else {
            // Scattered crystals are smaller
            scale = 0.7 + Math.random() * 0.6; // Smaller scattered (0.7-1.3)
          }
        } else if (category === 'mountains') {
          // More diverse mountain scales based on position
          if (i < 4) {
            // Corner mountains are largest
            scale = 2.2 + Math.random() * 1.3; // Largest mountains (2.2-3.5)
          } else if (i < 8) {
            // Cardinal direction mountains are medium-large
            scale = 1.8 + Math.random() * 1.0; // Medium-large mountains (1.8-2.8)
          } else {
            // Random mountains have varied sizes
            scale = 1.4 + Math.random() * 1.6; // Variable mountains (1.4-3.0)
          }
        }
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale and position
            model.scale.set(scale, scale, scale);
            model.position.set(x, 0, z); // Will adjust y based on model size
            
            // Add randomized rotation, except for ground features on pathways
            if (category === 'groundFeatures' && isNearPathway(x, z, 6)) {
              // Align with nearest pathway for ground features
              const alignAngle = Math.atan2(z, x);
              model.rotation.y = alignAngle + (Math.random() * 0.5 - 0.25); // Slight variation
            } else {
              model.rotation.y = Math.random() * Math.PI * 2;
            }
            
            // Enable shadows with optimization
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Optimize materials while keeping visual quality
                if (node.material) {
                  // Add category-specific visual enhancements
                  if (category === 'crystals' && modelPath.includes('Crystal')) {
                    // Make crystals glow with random colors
                    const crystalColors = [
                      new THREE.Color(0x00ffff), // cyan
                      new THREE.Color(0xff00ff), // magenta
                      new THREE.Color(0x88bbff), // light blue
                      new THREE.Color(0xffaa00)  // orange
                    ];
                    
                    // Random crystal color
                    const crystalColor = crystalColors[Math.floor(Math.random() * crystalColors.length)];
                    node.material.emissive = crystalColor;
                    node.material.emissiveIntensity = 0.3 + Math.random() * 0.3; // 0.3-0.6
                  } else if (category === 'mountains') {
                    // Give mountains a slight purple/blue tint
                    node.material.color = new THREE.Color(0x9090b0);
                  } else if (category === 'groundFeatures') {
                    // Give ground features varied earthy tones
                    const groundColors = [
                      new THREE.Color(0x908070), // tan
                      new THREE.Color(0x807060), // brown
                      new THREE.Color(0x708060), // olive
                      new THREE.Color(0x606070)  // slate
                    ];
                    node.material.color = groundColors[Math.floor(Math.random() * groundColors.length)];
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // IMPROVED COLLISION DETECTION: Use oriented bounding box for more accurate collisions
            // First, compute an accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use the improved ground placement calculation
            const groundY = this.calculateGroundOffset(model, category, scale);
            model.position.y = groundY;
            
            // Generate compound collision shapes for more accurate collision detection
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, scale);
            
            // Create better collision data with compound shapes
            const obstacleData = {
              mesh: model,
              type: category,
              // Advanced collision data
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              // Keep bounding box for broad-phase checks
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * scale / 2),
                  model.position.y - (size.y * scale / 2),
                  model.position.z - (size.z * scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * scale / 2),
                  model.position.y + (size.y * scale / 2),
                  model.position.z + (size.z * scale / 2)
                ),
                size: size.clone().multiplyScalar(scale),
                rotation: model.rotation.y
              },
              // Also keep a simple radius for quick distance checks
              size: Math.max(size.x, size.z) * scale * 0.5,
              position: model.position.clone()
            };
            
            this.obstacles.push(obstacleData);
            
            // Log first few obstacles for debugging
            if (this.obstacles.length <= 3) {
              console.log(`Created ${category} obstacle from ${modelPath}: width=${size.x * scale}, height=${size.y * scale}, depth=${size.z * scale} at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
            }
          },
          undefined, // Progress callback
          (error) => {
            console.error(`Error loading obstacle model ${fullPath}:`, error);
          }
        );
      }
    }
    
    // Create a special centerpiece crystal formation
    this.createCenterpiece();
    
    // Create template-based object groupings for more cohesive landscape
    this.createTemplateGroupings(templates, obstacleCategories);
    
    console.log(`Started loading ${Object.values(distribution).reduce((a, b) => a + b, 0)} obstacles with pathways and crystal gardens`);
  }
  
  /**
   * Create template-based object groupings
   */
  createTemplateGroupings(templates, categoryModels) {
    console.log('Creating template-based object groupings');
    
    templates.forEach((template, templateIndex) => {
      const templatePosition = template.position;
      const templateRotation = template.rotation;
      
      // Process each element in the template
      template.elements.forEach(element => {
        const category = element.category;
        
        // Get the model list for this category
        const models = categoryModels[category];
        if (!models || models.length === 0) return;
        
        // Select model by index or randomly if index is out of bounds
        const modelIndex = element.modelIndex < models.length ? element.modelIndex : Math.floor(Math.random() * models.length);
        const modelPath = models[modelIndex];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Calculate final position with rotation applied to offset
        const offset = element.offset.clone();
        
        // Apply template rotation to the offset
        if (templateRotation) {
          // Create rotation matrix
          const rotMatrix = new THREE.Matrix4().makeRotationY(templateRotation);
          offset.applyMatrix4(rotMatrix);
        }
        
        // Final position combines template position and rotated offset
        const finalPosition = new THREE.Vector3(
          templatePosition.x + offset.x,
          templatePosition.y + offset.y,
          templatePosition.z + offset.z
        );
        
        // Final rotation combines template rotation and element rotation
        const finalRotation = templateRotation + element.rotation;
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale
            model.scale.set(element.scale, element.scale, element.scale);
            
            // Set initial position 
            model.position.copy(finalPosition);
            
            // Apply rotation
            model.rotation.y = finalRotation;
            
            // Enable shadows with appropriate material enhancements
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Apply category-specific visual effects
                if (node.material) {
                  if (category === 'crystals') {
                    // Crystal glow effect
                    node.material.emissive = new THREE.Color(0x88bbff);
                    node.material.emissiveIntensity = 0.3;
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // Compute accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use improved ground placement
            const groundY = this.calculateGroundOffset(model, category, element.scale);
            model.position.y = groundY + element.offset.y; // Apply any intentional Y offset
            
            // Generate compound collision shapes
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, element.scale);
            
            // Add to obstacles array with collision data
            this.obstacles.push({
              mesh: model,
              type: category,
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * element.scale / 2),
                  model.position.y - (size.y * element.scale / 2),
                  model.position.z - (size.z * element.scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * element.scale / 2),
                  model.position.y + (size.y * element.scale / 2),
                  model.position.z + (size.z * element.scale / 2)
                ),
                size: size.clone().multiplyScalar(element.scale),
                rotation: model.rotation.y
              },
              size: Math.max(size.x, size.z) * element.scale * 0.5,
              position: model.position.clone()
            });
            
            console.log(`Template ${templateIndex+1}: Added ${category} model at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
          },
          undefined,
          (error) => {
            console.error(`Error loading template model ${fullPath}:`, error);
          }
        );
      });
    });
  }
  
  setupControls() {
    // Store active keys for visual feedback
    this.activeKeys = new Set();
    
    // Add visual indicators for controls
    this.createControlIndicators();
    
    // Detect if we're on a touch device
    this.isTouchDevice = 'ontouchstart' in window;
    
    // Keyboard controls
    document.addEventListener('keydown', this.boundHandleKeyDown);
    document.addEventListener('keyup', this.boundHandleKeyUp);
    
    // Mouse controls - attach to the canvas for better precision
    const canvas = this.renderer.domElement;
    canvas.addEventListener('click', this.boundHandleClick);
    canvas.addEventListener('mousemove', this.boundHandleMouseMove);
    
    // Setup touch controls for mobile devices
    if (this.isTouchDevice) {
      this.setupTouchControls();
    }
  }
  
  createControlIndicators() {
    console.log('Creating control indicators');
    // Create container if it doesn't exist
    if (!this.controlsContainer) {
        this.controlsContainer = document.createElement('div');
        this.controlsContainer.id = 'controls';
        this.controlsContainer.className = 'control-indicators';
        document.body.appendChild(this.controlsContainer);
        console.log('Control container created');
    }

    // Clear existing indicators
    this.controlsContainer.innerHTML = '';
    
    // Create the movement controls grid
    const movementControls = document.createElement('div');
    movementControls.className = 'movement-controls control-group';
    
    // Create the weapon controls section
    const weaponControls = document.createElement('div');
    weaponControls.className = 'weapon-controls control-group';
    
    // Define the key indicators for movement
    const movementKeys = [
        { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward', gridArea: 'forward' },
        { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward', gridArea: 'backward' },
        { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left', gridArea: 'left' },
        { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right', gridArea: 'right' },
        { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left', gridArea: 'strafeLeft' },
        { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right', gridArea: 'strafeRight' },
        { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon', gridArea: 'fire' }
    ];
    
    // Define the key indicators for weapons
    const weaponKeys = [
        { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser', className: 'weapon-key' },
        { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade', className: 'weapon-key' },
        { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser', className: 'weapon-key' },
        { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon', className: 'weapon-key' }
    ];
    
    // Create movement indicators
    movementKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        movementControls.appendChild(indicator);
    });
    
    // Create weapon indicators
    weaponKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        weaponControls.appendChild(indicator);
    });
    
    // Add a controls hint
    const hint = document.createElement('div');
    hint.className = 'controls-hint';
    hint.textContent = 'Press C to toggle controls visibility';
    
    // Add all elements to controls container
    this.controlsContainer.appendChild(movementControls);
    this.controlsContainer.appendChild(weaponControls);
    this.controlsContainer.appendChild(hint);
    
    console.log('Control indicators created with updated structure');
  }
  
  updateControlIndicators() {
    // Skip if control indicators aren't created yet
    if (!this.controlsContainer) return;
    
    // Update movement keys
    this.updateIndicatorState('forward', this.keys.forward);
    this.updateIndicatorState('backward', this.keys.backward);
    this.updateIndicatorState('left', this.keys.left);
    this.updateIndicatorState('right', this.keys.right);
    this.updateIndicatorState('strafeLeft', this.keys.strafeLeft);
    this.updateIndicatorState('strafeRight', this.keys.strafeRight);
    
    // Update fire state
    this.updateIndicatorState('fire', this.keys.fire);
    
    // Update weapon selection
    this.updateIndicatorState('selectLaser', this.currentWeapon === 'LASER');
    this.updateIndicatorState('selectGrenade', this.currentWeapon === 'GRENADE');
    this.updateIndicatorState('selectBounce', this.currentWeapon === 'BOUNCE');
  }
  
  updateIndicatorState(id, isActive) {
    const indicator = this.controlsContainer?.querySelector(`#indicator-${id}`);
    if (indicator) {
      if (isActive) {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }
  }
  
  handleResize(event) {
    // Debounce resize events
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    
    this.resizeTimer = setTimeout(() => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.resizeTimer = null;
    }, 100);
  }
  
  handleKeyDown(event) {
    // Handle escape key for in-game menu
    if (event.code === 'Escape') {
        this.showInGameMenu();
        return;
    }
    
    // Handle 'C' key to toggle controls visibility
    if (event.code === 'KeyC') {
        console.log('C key pressed - toggling controls');
        this.toggleControls();
        return;
    }
    
    // Handle 'M' key to toggle mini-map
    if (event.code === 'KeyM') {
        this.toggleMiniMap();
        return;
    }

    // Get control action from key mapping
    const action = ControlUtils.getActionForKey(event.code);
    
    // Skip if key isn't mapped or event is repeated
    if (!action || event.repeat) return;
    
    // Handle weapon selection
    if (action.category === 'WEAPONS') {
        if (action.action === 'SWITCH_WEAPON') {
            this.cycleWeapon();
            return;
        } else if (action.action === 'SELECT_LASER') {
            this.selectWeapon('LASER');
            return;
        } else if (action.action === 'SELECT_GRENADE') {
            this.selectWeapon('GRENADE');
            return;
        } else if (action.action === 'SELECT_BOUNCE') {
            this.selectWeapon('BOUNCE');
            return;
        }
    }
    
    // Handle UI controls
    if (action.category === 'UI') {
        if (action.action === 'TOGGLE_MAP') {
            this.toggleMiniMap();
            return;
        } else if (action.action === 'TOGGLE_CONTROLS') {
            this.toggleControls();
            return;
        }
    }
    
    // Set key state to active
    if (action.category === 'MOVEMENT') {
        this.keys[action.action.toLowerCase()] = true;
    }
    
    // Store active key for visual feedback
    this.activeKeys.add(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
    
    // Prevent default browser behavior for game controls
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'Tab', 'KeyM'].includes(event.code)) {
        event.preventDefault();
    }
}
  
  handleKeyUp(event) {
    const action = ControlUtils.getActionForKey(event.code);
    if (!action) return;
    
    // Skip weapon selection keys on keyup
    if (action.category === 'WEAPONS' && action.action.startsWith('SELECT_')) {
      return;
    }
    
    // Set key state to inactive
    if (action.category === 'MOVEMENT') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'WEAPONS') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'UI') {
      this.keys[action.action.toLowerCase()] = false;
    }
    
    // Remove from active keys
    this.activeKeys.delete(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
  }
  
  handleClick(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault) {
        event.preventDefault();
    }
    
    // Prevent rapid-fire clicking
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
        return;
    }
    
    // Get click coordinates relative to canvas
    const rect = this.renderer.domElement.getBoundingClientRect();
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid click coordinates');
        return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Convert to normalized device coordinates
    const mouse = new THREE.Vector2(
        (x / this.renderer.domElement.clientWidth) * 2 - 1,
        -(y / this.renderer.domElement.clientHeight) * 2 + 1
    );
    
    // Handle weapon-specific targeting
    if (this.currentWeapon === 'GRENADE') {
        this.handleGrenadeTargeting({ 
            clientX, 
            clientY,
            preventDefault: () => {} // Add dummy preventDefault for consistency
        });
    } else {
        this.handleDirectionalFiring({ clientX, clientY });
    }
  }
  
  handleMouseMove(event) {
    // Skip if we're moving too frequently (throttle)
    if (this.mouseMoveTimer) {
        return;
    }
    
    // Use requestAnimationFrame for smoother updates
    this.mouseMoveTimer = requestAnimationFrame(() => {
        // Get mouse coordinates relative to canvas
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update targeting indicators for any weapon type
        this.updateTargetingIndicator({
            clientX: event.clientX,
            clientY: event.clientY
        });
        
        // Additional targeting for grenade if that's the current weapon
        if (this.currentWeapon === 'GRENADE') {
            this.updateGrenadeTargetingIndicator({
                clientX: event.clientX,
                clientY: event.clientY
            });
        }
        
        this.mouseMoveTimer = null;
    });
}
  
  handleFireAction() {
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
      return;
    }
    
    // Set cooldown based on weapon type
    const cooldownTime = this.currentWeapon === 'GRENADE' ? 1000 :
                        this.currentWeapon === 'BOUNCE' ? 500 :
                        200;
    
    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);
    this.fireCurrentWeapon();
  }
  
  setupTouchControls() {
    // Create touch control container
    const touchControls = document.createElement('div');
    touchControls.className = 'touch-controls';
    document.body.appendChild(touchControls);
    
    // Create virtual joystick for movement
    const joystickContainer = document.createElement('div');
    joystickContainer.className = 'joystick-container';
    touchControls.appendChild(joystickContainer);
    
    const joystick = document.createElement('div');
    joystick.className = 'joystick';
    joystickContainer.appendChild(joystick);
    
    const joystickKnob = document.createElement('div');
    joystickKnob.className = 'joystick-knob';
    joystick.appendChild(joystickKnob);
    
    // Create fire button
    const fireButton = document.createElement('div');
    fireButton.className = 'touch-button fire-button';
    fireButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.ACTIONS.find(a => a.id === 'fire').label;
    touchControls.appendChild(fireButton);
    
    // Create weapon switch button
    const weaponButton = document.createElement('div');
    weaponButton.className = 'touch-button weapon-button';
    weaponButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.WEAPONS.find(w => w.id === 'switchWeapon').label;
    touchControls.appendChild(weaponButton);
    
    // Joystick handling
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickOrigin.x = rect.left + rect.width / 2;
      joystickOrigin.y = rect.top + rect.height / 2;
      handleJoystickMove(touch);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (joystickActive) {
        const touch = e.touches[0];
        handleJoystickMove(touch);
        e.preventDefault();
      }
    });
    
    document.addEventListener('touchend', (e) => {
      if (joystickActive) {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Reset movement keys using DEFAULT_CONTROL_STATE
        Object.keys(DEFAULT_CONTROL_STATE).forEach(key => {
          if (key.startsWith('forward') || key.startsWith('backward') || 
              key.startsWith('left') || key.startsWith('right') || 
              key.startsWith('strafe')) {
            this.keys[key] = DEFAULT_CONTROL_STATE[key];
          }
        });
        
        this.updateControlIndicators();
      }
    });
    
    const handleJoystickMove = (touch) => {
      const maxDistance = CONTROL_SETTINGS.TOUCH.JOYSTICK_MAX_DISTANCE;
      const deadZone = CONTROL_SETTINGS.TOUCH.JOYSTICK_DEAD_ZONE;
      
      // Calculate distance from center
      const dx = touch.clientX - joystickOrigin.x;
      const dy = touch.clientY - joystickOrigin.y;
      
      // Limit distance to maxDistance
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
      const angle = Math.atan2(dy, dx);
      
      // Move joystick knob
      const knobX = distance * Math.cos(angle);
      const knobY = distance * Math.sin(angle);
      joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
      
      // Convert joystick position to key presses using deadzone
      this.keys.forward = dy < -deadZone;
      this.keys.backward = dy > deadZone;
      this.keys.left = dx < -deadZone;
      this.keys.right = dx > deadZone;
      
      this.updateControlIndicators();
    };
    
    // Fire button handling with weapon cooldown
    let lastFireTime = 0;
    fireButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      const cooldown = CONTROL_SETTINGS.WEAPON_COOLDOWNS[this.currentWeapon];
      
      if (now - lastFireTime >= cooldown) {
        this.keys.fire = true;
        this.fireCurrentWeapon();
        lastFireTime = now;
      }
      
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    fireButton.addEventListener('touchend', (e) => {
      this.keys.fire = false;
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    // Weapon switch button handling with cooldown
    let lastWeaponSwitchTime = 0;
    weaponButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastWeaponSwitchTime >= 200) { // 200ms cooldown for weapon switching
        this.cycleWeapon();
        lastWeaponSwitchTime = now;
      }
      e.preventDefault();
    });
    
    // Enable directional fire on game area tap
    const gameArea = document.querySelector('canvas');
    if (gameArea) {
      let lastTapTime = 0;
      
      gameArea.addEventListener('touchstart', (e) => {
        // Ignore if touch is in control areas
        const touch = e.touches[0];
        const isInControlArea = 
          touchControls.contains(document.elementFromPoint(touch.clientX, touch.clientY));
          
        if (!isInControlArea && this.playerShip) {
          const now = Date.now();
          const doubleTapDelay = CONTROL_SETTINGS.TOUCH.DOUBLE_TAP_DELAY;
          
          // Check for double tap
          if (now - lastTapTime < doubleTapDelay) {
            // Handle double tap action (e.g., special weapon)
            this.cycleWeapon();
          } else {
            // Handle single tap (directional firing)
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // Handle directional firing similarly to mouse
            const touchPoint = new THREE.Vector2(
              (touchX / window.innerWidth) * 2 - 1,
              -(touchY / window.innerHeight) * 2 + 1
            );
            
            // Use raycasting to determine the point in 3D space
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touchPoint, this.camera);
            
            // Check for intersection with the floor
            const intersects = raycaster.intersectObject(this.floor);
            
            if (intersects.length > 0) {
              const targetPoint = intersects[0].point;
              
              // Calculate the direction from the player to the target point
              const shipPosition = this.playerShip.position.clone();
              const direction = targetPoint.clone().sub(shipPosition).normalize();
              
              // Only care about horizontal direction (ignore y component)
              direction.y = 0;
              direction.normalize();
              
              // Store the original rotation
              const originalRotation = this.playerShip.rotation.clone();
              
              // Temporarily rotate the ship to face the target
              this.playerShip.lookAt(shipPosition.clone().add(direction));
              
              // Fire the weapon in that direction
              if (this.currentWeapon === 'GRENADE') {
                // For grenades, we simulate a tap at the target location
                const targetEvent = {
                  clientX: touchX,
                  clientY: touchY,
                  preventDefault: () => {}
                };
                this.handleGrenadeTargeting(targetEvent);
              } else {
                // For lasers and bounce, fire in the direction
                this.fireCurrentWeapon(direction);
              }
              
              // Restore the original rotation
              this.playerShip.rotation.copy(originalRotation);
            }
          }
          
          lastTapTime = now;
          e.preventDefault();
        }
      });
    }
  }
  
  toggleControls() {
    // Clear any existing timeout
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
    
    // Also clear any auto-fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (!this.controlsContainer) {
      this.createControlIndicators();
    }
    
    if (this.controlsContainer.classList.contains('visible')) {
      this.fadeOutControls();
    } else {
      this.fadeInControls();
    }
  }
  
  fadeInControls() {
    console.log('Fading in controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // Remove any classes that might hide the controls
        this.controlsContainer.classList.remove('hidden', 'fading');
        // Add the visible class
        this.controlsContainer.classList.add('visible');
        console.log('Controls should now be visible with class: visible');
        
        // Set a timeout to automatically fade out the controls after 5 seconds
        // (but only if we're in the game and not in a menu)
        if (this.isRunning) {
            this.controlsFadeTimeout = setTimeout(() => {
              console.log('Auto-hiding controls after timeout');
              this.fadeOutControls();
            }, 5000);
        }
    } else {
        console.warn('Control container not found during fade in');
        // Try to create controls if they don't exist
        this.createControlIndicators();
        // And then try to show them
        if (this.controlsContainer) {
            this.controlsContainer.classList.add('visible');
            
            // Also set the auto-fade timeout for the newly created controls
            // (but only if we're in the game and not in a menu)
            if (this.isRunning) {
                this.controlsFadeTimeout = setTimeout(() => {
                  console.log('Auto-hiding newly created controls after timeout');
                  this.fadeOutControls();
                }, 5000);
            }
        }
    }
  }
  
  fadeOutControls() {
    console.log('Fading out controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // First add the fading class for the transition
        this.controlsContainer.classList.add('fading');
        this.controlsContainer.classList.remove('visible');
        
        // After the transition completes, add the hidden class
        setTimeout(() => {
            if (this.controlsContainer) {
                this.controlsContainer.classList.add('hidden');
            }
        }, 500); // Match the transition time from CSS
    } else {
        console.warn('Control container not found during fade out');
    }
  }
  
  updateWeaponUI() {
    // Update UI to reflect weapon change
    if (this.ui) {
        this.ui.updateWeapon(this.currentWeapon);
        
        // Update targeting indicator color if it exists
        if (this.targetingIndicator) {
            const colors = {
                'LASER': new THREE.Color(0x00ffff),
                'GRENADE': new THREE.Color(0xff4500),
                'BOUNCE': new THREE.Color(0x00ff99)
            };
            const color = colors[this.currentWeapon] || colors['LASER'];
            
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
        }
    }
    
    // Log weapon change
    console.log('Weapon updated:', this.currentWeapon);
}

selectWeapon(weaponType) {
    console.log('Selecting specific weapon:', weaponType);
    const index = this.availableWeapons.indexOf(weaponType);
    if (index !== -1) {
        this.weaponIndex = index;
        this.currentWeapon = weaponType;
        console.log('Weapon selection successful');
        
        // Update UI to reflect weapon change
        this.updateWeaponUI();
        
        // Play weapon switch sound if available
        this.playSound('weapon-switch');
    } else {
        console.warn('Attempted to select unavailable weapon:', weaponType);
    }
}
  
  cycleWeapon() {
    console.log('Cycling weapon from:', this.currentWeapon);
    this.weaponIndex = (this.weaponIndex + 1) % this.availableWeapons.length;
    this.currentWeapon = this.availableWeapons[this.weaponIndex];
    console.log('New weapon selected:', this.currentWeapon);
    
    // Update UI to reflect weapon change
    this.updateWeaponUI();
    
    // Play weapon switch sound
    this.playSound('weapon-switch');
}
  
  fireGrenade() {
    console.log("Grenade weapon selected - click to target");
  }
  
  animate() {
    // Call animationFrame with this instance as context
    requestAnimationFrame(this.animate.bind(this));
    
    try {
      // Calculate delta time
      const now = performance.now();
      const deltaTime = (now - this.lastTime) / 1000; // in seconds
      this.lastTime = now;
      
      // Update frame counter
      this.frameCount++;
      
      // Limit update rate
      if (this.frameCount % 2 === 0) { // Reduce update frequency
        // Only update gameplay if the player ship exists
        if (this.playerShip) {
          // Update player
          if (typeof this.updatePlayer === 'function') {
            this.updatePlayer(deltaTime);
          }
          
          // Update other elements - only if they exist
          if (typeof this.updateLasers === 'function') {
            this.updateLasers();
          }
          
          if (typeof this.updateEnergy === 'function') {
            this.updateEnergy(deltaTime);
          }
          
          if (typeof this.updateCamera === 'function') {
            this.updateCamera();
          }
          
          // Update collision detection
          if (typeof this.checkObstacleCollisions === 'function') {
            this.checkObstacleCollisions();
          }
          
          // Update thruster effects
          if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
          }
          
          // Check if boost is active and update energy consumption
          if (this.keys && this.keys.boost && this.energy > 0) {
            this.energy = Math.max(0, this.energy - 30 * deltaTime); // Boost drains energy
            if (this.ui) {
              this.ui.updateEnergy(this.energy, this.maxEnergy);
            }
          }
        }
        
        // Update bounceLasers if they exist
        if (this.bouncingLasers && this.bouncingLasers.length > 0 && 
            typeof this.updateBouncingLasers === 'function') {
          this.updateBouncingLasers();
        }
        
        // Update grenades if they exist
        if (this.grenades && this.grenades.length > 0 && 
            typeof this.updateGrenades === 'function') {
          this.updateGrenades();
        }
        
        // Update multiplayer
        if (this.multiplayerEnabled && this.networkManager) {
          // Send our position and rotation to server
          if (this.playerShip) {
            this.networkManager.sendPlayerUpdate({
              position: {
                x: this.playerShip.position.x,
                y: this.playerShip.position.y,
                z: this.playerShip.position.z
              },
              rotation: this.playerShip.rotation.y,
              name: this.playerName,
              shipType: this.currentShipType || 'default'
            });
          }
          
          // Update other players
          if (typeof this.updateOtherPlayers === 'function') {
            this.updateOtherPlayers();
          }
        }
      }
      
      // Render the scene
      if (this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        
        // Render CSS2D elements if renderer exists
        if (this.labelRenderer) {
          this.labelRenderer.render(this.scene, this.camera);
        }
      }
    } catch (error) {
      console.error("Error in animate loop:", error);
      // Don't rethrow, we want to keep the animation loop running
    }
  }
  
  updatePlayer(deltaTime) {
    if (!this.playerShip) return;
    
    // Save original position in case we need to revert due to collision
    const originalPosition = this.playerShip.position.clone();
    
    // ORIGINAL SHIP MOVEMENT PHYSICS
    const moveSpeed = 10; // Base movement speed
    const rotateSpeed = 2.5; // Base rotation speed
    
    let moved = false; // Track if the ship moved
    
    // Handle forward/backward movement
    if (this.keys.forward) {
        // Move forward
        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(forwardDir, moveSpeed * deltaTime);
        moved = true;
    }
    else if (this.keys.backward) {
        // Move backward
        const backwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(backwardDir, moveSpeed * deltaTime);
        moved = true;
    }

    // Handle left/right rotation
    if (this.keys.left) {
        // Rotate left
        this.playerShip.rotation.y += rotateSpeed * deltaTime;
        moved = true;
    }
    else if (this.keys.right) {
        // Rotate right
        this.playerShip.rotation.y -= rotateSpeed * deltaTime;
        moved = true;
    }
    
    // Update player highlight to follow the player ship
    if (this.playerHighlight) {
        this.playerHighlight.position.x = this.playerShip.position.x;
        this.playerHighlight.position.z = this.playerShip.position.z;
        
        // Add a subtle pulsing effect to the highlight
        const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
        this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
    }
    
    // Check for collisions after movement
    if (moved) {
        this.checkObstacleCollisions();
        
        // If no collisions, update thruster effects
        if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
        }
        
        // Send position update to server if multiplayer is enabled
        if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
            this.sendPlayerPositionUpdate();
        }
    }
  }
  
  updateLasers() {
    if (!this.lasers) return;
    
    for (let i = this.lasers.length - 1; i >= 0; i--) {
      const laser = this.lasers[i];
      
      // Move laser
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update trail effect
      laser.trailPoints.push(laser.mesh.position.clone());
      if (laser.trailPoints.length > 8) { // Reduced trail length for better performance
        laser.trailPoints.shift();
      }
      
      // Update trail geometry
      const positions = new Float32Array(laser.trailPoints.length * 3);
      for (let j = 0; j < laser.trailPoints.length; j++) {
        positions[j * 3] = laser.trailPoints[j].x;
        positions[j * 3 + 1] = laser.trailPoints[j].y;
        positions[j * 3 + 2] = laser.trailPoints[j].z;
      }
      laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Pulse effect
      laser.pulsePhase += 0.3;
      const pulse = Math.sin(laser.pulsePhase) * 0.2 + 0.8;
      laser.mesh.material.opacity = pulse;
      const light = laser.mesh.children[0];
      if (light) {
        light.intensity = pulse * 2;
      }
      
      // Increment lifetime
      laser.lifeTime++;
      
      // Remove old lasers
      if (laser.lifeTime > laser.maxLifeTime) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.lasers.splice(i, 1);
        continue;
      }
      
      // Check for collisions with obstacles
      for (let j = 0; j < this.obstacles.length; j++) {
        const obstacle = this.obstacles[j];
        
        // Simple distance check
        if (laser.mesh.position.distanceTo(obstacle.position) < 1.5) {
          // Create enhanced hit effect
          this.createEnhancedHitEffect(laser.mesh.position.clone(), laser.direction.clone());
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  createEnhancedHitEffect(position, direction) {
    // Create a burst of particles
    const particleCount = 15;
    const particles = [];
    
    // Create particle material
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity based on impact direction
      const spread = Math.PI / 2; // 90 degree spread
      const angle = Math.random() * spread - spread/2;
      const speed = 0.2 + Math.random() * 0.3;
      
      // Calculate velocity
      const velocity = direction.clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle)
        .multiplyScalar(speed);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0; // Full life
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.3, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(position.clone().add(direction));
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }
  
  checkObstacleCollisions() {
    if (!this.playerShip || !this.infiniteMap) {
      console.log('Skipping collision check - player ship or infinite map not available');
      return;
    }
    
    // Get player collision info
    const playerRadius = this.playerShip.userData.collisionRadius || 0.35;
    const playerPos = this.playerShip.position.clone();
    
    // Create player sphere for collision checks
    const playerSphere = {
      center: playerPos,
      radius: playerRadius
    };
    
    // Check collisions with infinite map objects first
    const mapCollision = this.infiniteMap.checkCollisions(playerPos, playerRadius);
    
    if (mapCollision.collided) {
      // Handle collision from infinite map
      this.handleObjectCollision(playerPos, mapCollision.object.position, mapCollision.object.type || 'terrain');
      return; // Stop checking after handling one collision
    }
    
    // Check local obstacles with more accurate collision detection
    for (const obstacle of this.obstacles) {
      if (!obstacle.mesh) continue;
      
      // First, do a quick broad-phase check with spheres for efficiency
      const obstaclePos = obstacle.position.clone();
      const distance = playerPos.distanceTo(obstaclePos);
      const quickCheckDistance = playerRadius + obstacle.size;
      
      // Skip detailed check if clearly not colliding
      if (distance > quickCheckDistance * 1.5) continue;
      
      // Determine if collision happened based on shape type
      let collision = false;
      
      if (obstacle.collisionShape === 'compound' && obstacle.compoundShapes) {
        // Use compound shape collision detection for complex objects
        collision = this.checkCompoundCollision(playerSphere, obstacle.compoundShapes);
      } else if (obstacle.collisionShape === 'complex' && obstacle.boundingBox) {
        // Fall back to oriented bounding box if compound shapes not available
        collision = this.checkBoxCollision(
          playerPos, playerRadius,
          obstacle.boundingBox, 
          obstacle.boundingBox.rotation
        );
      } else {
        // Simplest case: sphere-based collision for backward compatibility
        collision = distance < quickCheckDistance;
      }
      
      if (collision) {
        // Handle the collision
        this.handleObjectCollision(playerPos, obstaclePos, obstacle.type);
        break; // Only handle one collision at a time
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (compound shapes)
   */
  checkCompoundCollision(playerSphere, compoundShapes) {
    // Check collision against each shape in the compound
    for (const shape of compoundShapes) {
      let collision = false;
      
      if (shape.type === 'box') {
        // Box vs sphere collision
        collision = this.checkBoxSphereCollision(
          shape.center,
          shape.halfExtents,
          shape.worldRotation || 0,
          playerSphere
        );
      } else if (shape.type === 'sphere') {
        // Sphere vs sphere collision (simpler case)
        const distance = playerSphere.center.distanceTo(shape.center);
        collision = distance < (playerSphere.radius + shape.radius);
      }
      
      if (collision) {
        return true; // Collision with any part means collision with the compound
      }
    }
    
    return false; // No collision with any part
  }
  
  /**
   * Check collision between a rotated box and a sphere
   */
  checkBoxSphereCollision(boxCenter, boxHalfExtents, boxRotation, sphere) {
    // Transform sphere center to box space (accounting for rotation)
    const toSphere = new THREE.Vector3().subVectors(sphere.center, boxCenter);
    
    // Apply inverse rotation to get into box space
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(-boxRotation);
      toSphere.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on box to sphere in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-boxHalfExtents.x, Math.min(boxHalfExtents.x, toSphere.x)),
      Math.max(-boxHalfExtents.y, Math.min(boxHalfExtents.y, toSphere.y)),
      Math.max(-boxHalfExtents.z, Math.min(boxHalfExtents.z, toSphere.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(boxRotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to sphere center (for efficiency)
    const squaredDistance = sphere.center.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than sphere radius squared
    return squaredDistance < (sphere.radius * sphere.radius);
  }

  /**
   * Handle collision with any object
   */
  handleObjectCollision(playerPos, objectPos, objectType) {
    console.log(`COLLISION DETECTED with ${objectType}: Pushing ship back`);
    
    // Push player away from obstacle
    const pushDir = new THREE.Vector3()
      .subVectors(playerPos, objectPos)
      .normalize();
      
    // Adjust push force based on object type
    let pushForce = 0.7; // Default push force
    let damageAmount = 5; // Default damage
    
    // Customize collision response based on type
    switch(objectType) {
      case 'rocks':
        pushForce = 0.85; // Rocks push strongly
        damageAmount = 8;
        break;
      case 'specialObjects':
      case 'groundFeatures':
        pushForce = 0.75; // Ground features push medium
        damageAmount = 6;
        break;
      case 'mountains':
        pushForce = 1.0; // Mountains push very strongly
        damageAmount = 10;
        break;
      case 'crystals':
        pushForce = 0.7; // Crystals push medium but with special effect
        damageAmount = 7;
        
        // Add special crystal collision effect
        this.createCrystalCollisionEffect(objectPos);
        break;
      case 'centerpiece':
        pushForce = 0.9; // Centerpiece pushes strongly
        damageAmount = 9;
        
        // Add special centerpiece collision effect
        this.createCrystalCollisionEffect(objectPos, true);
        break;
      case 'flora':
        pushForce = 0.6; // Flora pushes gently
        damageAmount = 3;
        break;
      default:
        // Use default values
        break;
    }
    
    // Apply the push force
    this.playerShip.position.addScaledVector(pushDir, pushForce);
    
    // Flash collision warning
    this.flashCollisionWarning();
    
    // Apply damage if the function exists
    if (typeof this.applyDamage === 'function') {
      this.applyDamage(damageAmount);
    }
    
    // Play appropriate collision sound based on object type
    let soundToPlay = 'collision';
    
    if (objectType === 'specialObjects') {
      // Crystal-like sounds for special objects
      soundToPlay = 'crystalHit';
    } else if (objectType === 'mountains') {
      // Heavy impact for mountains
      soundToPlay = 'heavyImpact';
    }
    
    // Play the sound if it exists, otherwise fall back to default collision
    if (this.playSound) {
      try {
        this.playSound(soundToPlay);
      } catch (e) {
        // Fall back to default if sound doesn't exist
        try {
          this.playSound('collision');
        } catch (e2) {
          // No sound available
        }
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (oriented box)
   */
  checkBoxCollision(playerPos, playerRadius, box, rotation) {
    // Get box center
    const boxCenter = new THREE.Vector3(
      (box.min.x + box.max.x) / 2,
      (box.min.y + box.max.y) / 2,
      (box.min.z + box.max.z) / 2
    );
    
    // Calculate half extents of box
    const halfExtents = new THREE.Vector3(
      (box.max.x - box.min.x) / 2,
      (box.max.y - box.min.y) / 2,
      (box.max.z - box.min.z) / 2
    );
    
    // Vector from box center to player
    const toPlayer = new THREE.Vector3().subVectors(playerPos, boxCenter);
    
    // If we have rotation, apply inverse rotation to convert to box space
    if (rotation) {
      // Create rotation matrix for the box (negative rotation to invert)
      const rotMatrix = new THREE.Matrix4().makeRotationY(-rotation);
      toPlayer.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on the box to the player in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-halfExtents.x, Math.min(halfExtents.x, toPlayer.x)),
      Math.max(-halfExtents.y, Math.min(halfExtents.y, toPlayer.y)),
      Math.max(-halfExtents.z, Math.min(halfExtents.z, toPlayer.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (rotation) {
      // Create rotation matrix for the box
      const rotMatrix = new THREE.Matrix4().makeRotationY(rotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to player center
    const squaredDistance = playerPos.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than player radius squared
    return squaredDistance < (playerRadius * playerRadius);
  }
  
  updateCamera() {
    // Check if cameraTargetPosition is initialized
    if (!this.cameraTargetPosition) {
      this.cameraTargetPosition = new THREE.Vector3();
      this.cameraTargetLookAt = new THREE.Vector3();
      this.cameraSmoothingFactor = 0.05;
    }
    
    // If playerShip doesn't exist, early return
    if (!this.playerShip) return;
    
    // Define the camera offset from the player
    const offsetY = 18; // Height above the player
    const offsetZ = -16; // Distance behind the player (adjusted for larger ship)
    
    // Get the player's forward direction vector (simplified)
    const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
    
    // Calculate camera target position (directly above and slightly behind player)
    this.cameraTargetPosition.copy(this.playerShip.position);
    this.cameraTargetPosition.y += offsetY;
    
    // Move camera back based on player's orientation
    const backOffset = forwardDir.clone().multiplyScalar(offsetZ);
    this.cameraTargetPosition.add(backOffset);
    
    // Smoothly move camera toward target position
    this.camera.position.lerp(this.cameraTargetPosition, this.cameraSmoothingFactor);
    
    // Make camera look at the player
    this.cameraTargetLookAt.copy(this.playerShip.position);
    this.camera.lookAt(this.cameraTargetLookAt);
  }
  
  updateThrusterEffects() {
    // Skip if ship model isn't loaded
    if (!this.shipModel || !this.thruster || !this.thrusterLight) return;
    
    // Use stored references instead of finding children each time
    const { thruster, thrusterLight } = this;
    
    // Base thruster scale and opacity on movement
    const isMovingForward = this.keys.forward;
    const isMovingBackward = this.keys.backward;
    
    // Update thruster pulse for ambient animation
    this.thrusterPulse.value = (this.thrusterPulse.value + 0.1) % (Math.PI * 2);
    const pulseEffect = Math.sin(this.thrusterPulse.value) * 0.1;
    
    if (isMovingForward) {
      // Full thruster when moving forward
      const randomScale = 1 + Math.random() * 0.2 + pulseEffect;
      thruster.scale.set(1, 1, randomScale);
      thruster.material.opacity = 0.7 + Math.random() * 0.3;
      thrusterLight.intensity = 1.2 + Math.random() * 0.3 + pulseEffect;
      
      // Add color variation for a more dynamic effect
      const hue = (Date.now() % 1000) / 1000; // Cycle through colors over time
      thruster.material.color.setHSL(hue, 1, 0.5);
      thrusterLight.color.setHSL(hue, 1, 0.5);
    } else if (isMovingBackward) {
      // Reduced thruster when moving backward
      const randomScale = 0.3 + Math.random() * 0.1 + pulseEffect * 0.5;
      thruster.scale.set(0.5, 0.5, randomScale);
      thruster.material.opacity = 0.4 + Math.random() * 0.2;
      thrusterLight.intensity = 0.6 + Math.random() * 0.2 + pulseEffect * 0.5;
      
      // Cooler color for reverse thrust
      thruster.material.color.setHSL(0.6, 1, 0.5); // Blue-ish
      thrusterLight.color.setHSL(0.6, 1, 0.5);
    } else {
      // Idle state with subtle pulsing
      const idleScale = 0.3 + pulseEffect;
      thruster.scale.set(0.3, 0.3, idleScale);
      thruster.material.opacity = 0.3 + pulseEffect;
      thrusterLight.intensity = 0.4 + pulseEffect;
      
      // Neutral color for idle
      thruster.material.color.setHSL(0.5, 0.7, 0.5); // Cyan-ish
      thrusterLight.color.setHSL(0.5, 0.7, 0.5);
    }
    
    // Performance optimization: only update material if it's visible
    if (thruster.material.opacity < 0.01) {
      thruster.visible = false;
      thrusterLight.visible = false;
    } else {
      thruster.visible = true;
      thrusterLight.visible = true;
    }
  }
  
  flashCollisionWarning() {
    // Create a full-screen flash effect for collision
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'collision-flash';
    document.body.appendChild(flashOverlay);
    
    // Remove after animation completes
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, 150);
  }
  
  updateEnergy(deltaTime) {
    // Validate parameters
    if (typeof deltaTime !== 'number' || deltaTime < 0) {
        console.warn('Invalid deltaTime in updateEnergy:', deltaTime);
        return;
    }

    // Initialize energy values if undefined
    if (typeof this.energy !== 'number') this.energy = 0;
    if (typeof this.maxEnergy !== 'number') this.maxEnergy = 100;
    if (typeof this.energyRechargeRate !== 'number') this.energyRechargeRate = 20;

    // Store old energy for change detection
    const oldEnergy = this.energy;

    // Calculate recharge amount
    const rechargeAmount = this.energyRechargeRate * deltaTime;
    
    // Apply recharge with bounds checking
    this.energy = Math.min(this.maxEnergy, this.energy + rechargeAmount);

    // Update UI only if energy changed
    if (this.energy !== oldEnergy) {
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        }

        // Play charging sound when energy is low (under 10%)
        if (this.energy < (this.maxEnergy * 0.1)) {
            this.playSound('weapon-charging');
        }

        // Log significant energy changes (more than 1 unit) for debugging
        if (Math.abs(this.energy - oldEnergy) > 1) {
            console.log(`Energy updated: ${oldEnergy.toFixed(1)} -> ${this.energy.toFixed(1)} (Δ${deltaTime.toFixed(3)}s)`);
        }
    }
  }
  
  updateGrenades() {
    if (!this.grenades || this.grenades.length === 0) return;
    
    for (let i = this.grenades.length - 1; i >= 0; i--) {
      const grenade = this.grenades[i];
      
      // If the grenade has exploded, handle explosion effects
      if (grenade.exploded) {
        // Increase the explosion radius until maximum
        grenade.explosionMesh.scale.addScalar(0.2);
        grenade.explosionLight.intensity -= 0.1;
        
        // Remove explosion after it's done
        if (grenade.explosionLight.intensity <= 0) {
          this.scene.remove(grenade.explosionMesh);
          this.scene.remove(grenade.trail);
          this.grenades.splice(i, 1);
        }
        continue;
      }
      
      // Update the grenade position along the arc
      grenade.progress += 0.02;
      
      if (grenade.progress >= 1) {
        // Explode when reaching the target
        this.explodeGrenade(grenade, i);
      } else {
        // Move along a quadratic bezier curve for arcing trajectory
        const p0 = grenade.startPos;
        const p1 = grenade.midPos;
        const p2 = grenade.endPos;
        
        // Quadratic bezier formula: p = (1-t)^2 * p0 + 2(1-t)t * p1 + t^2 * p2
        const t = grenade.progress;
        const oneMinusT = 1 - t;
        
        grenade.mesh.position.x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
        grenade.mesh.position.y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
        grenade.mesh.position.z = oneMinusT * oneMinusT * p0.z + 2 * oneMinusT * t * p1.z + t * t * p2.z;
        
        // Add trail effect
        const point = grenade.mesh.position.clone();
        grenade.trailPoints.push(point);
        
        // Keep only the last 20 trail points
        if (grenade.trailPoints.length > 20) {
          grenade.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(grenade.trailPoints.length * 3);
        for (let j = 0; j < grenade.trailPoints.length; j++) {
          positions[j * 3] = grenade.trailPoints[j].x;
          positions[j * 3 + 1] = grenade.trailPoints[j].y;
          positions[j * 3 + 2] = grenade.trailPoints[j].z;
        }
        
        grenade.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        grenade.trail.geometry.attributes.position.needsUpdate = true;
      }
    }
  }
  
  explodeGrenade(grenade, index) {
    // Remove the grenade mesh
    this.scene.remove(grenade.mesh);
    
    // Create explosion geometry
    const explosionGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const explosionMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8
    });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(grenade.mesh.position);
    
    // Add to scene
    this.scene.add(explosionMesh);
    
    // Add explosion light
    const explosionLight = new THREE.PointLight(0xff6600, 3, 10);
    explosionMesh.add(explosionLight);
    
    // Mark as exploded
    grenade.exploded = true;
    grenade.explosionMesh = explosionMesh;
    grenade.explosionLight = explosionLight;
    
    // Calculate damage radius
    const explosionCenter = grenade.mesh.position.clone();
    const maxDamage = 50; // Maximum damage at center - 50% of health
    const damageRadius = grenade.explosionRadius || 4; // Default radius of 4 units
    
    // Check for obstacle hits in explosion radius
    for (const obstacle of this.obstacles) {
      const distance = obstacle.position.distanceTo(explosionCenter);
      if (distance < damageRadius) {
        // Calculate damage based on distance (linear falloff)
        const damagePercent = 1 - (distance / damageRadius);
        const hitPoint = obstacle.position.clone().add(
          explosionCenter.clone().sub(obstacle.position).normalize().multiplyScalar(distance * 0.8)
        );
        this.createHitEffect(hitPoint);
      }
    }
    
    // Check for player damage
    const playerPosition = this.playerShip.position.clone();
    playerPosition.y = 0; // Project to ground plane
    const grenadePosition = explosionCenter.clone();
    grenadePosition.y = 0; // Project to ground plane
    
    const playerDistance = playerPosition.distanceTo(grenadePosition);
    if (playerDistance < damageRadius) {
      // Calculate damage with distance falloff
      const damagePercent = 1 - (playerDistance / damageRadius);
      const damage = Math.floor(maxDamage * damagePercent);
      
      // Apply damage to player
      this.health = Math.max(0, this.health - damage);
      
      // Update UI
      if (this.ui) {
        this.ui.updateHealth(this.health, this.maxHealth);
      }
      
      // Visual feedback
      this.flashCollisionWarning();
      this.createHitEffect(playerPosition);
    }
  }
  
  updateBouncingLasers() {
    if (!this.bouncingLasers || this.bouncingLasers.length === 0) return;
    
    const playerPos = this.playerShip ? this.playerShip.position.clone() : null;
    
    // Update each laser
    for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
      const laser = this.bouncingLasers[i];
      
      // Skip invalid lasers
      if (!laser || !laser.mesh) continue;
      
      // Update laser position
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update the trail
      if (laser.trail) {
        // Add current position to trail points
        laser.trailPoints.push(laser.mesh.position.clone());
        
        // Limit the number of trail points
        if (laser.trailPoints.length > 20) {
          laser.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(laser.trailPoints.length * 3);
        for (let j = 0; j < laser.trailPoints.length; j++) {
          positions[j * 3] = laser.trailPoints[j].x;
          positions[j * 3 + 1] = laser.trailPoints[j].y;
          positions[j * 3 + 2] = laser.trailPoints[j].z;
        }
        
        // Update geometry
        laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        laser.trail.geometry.attributes.position.needsUpdate = true;
      }
      
      // Check for collisions with obstacles
      let collision = false;
      let closestPoint = null;
      let closestDistance = Infinity;
      let closestNormal = null;
      
      // Check for collision with each obstacle
      for (const obstacle of this.obstacles) {
        if (!obstacle.geometry) continue;
        
        let intersection = null;
        let normal = null;
        
        if (obstacle.geometry instanceof THREE.SphereGeometry) {
          const radius = obstacle.geometry.parameters.radius;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else if (obstacle.geometry instanceof THREE.CylinderGeometry) {
          const radius = obstacle.geometry.parameters.radiusTop;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else {
          // For boxes, use bounding sphere as approximation
          const boundingSphere = obstacle.geometry.boundingSphere;
          if (!boundingSphere) {
            obstacle.geometry.computeBoundingSphere();
          }
          const sphere = new THREE.Sphere(
            obstacle.position,
            obstacle.geometry.boundingSphere.radius
          );
          intersection = tempRay.intersectSphere(sphere, tempVector);
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        }
        
        if (intersection) {
          const dist = laser.mesh.position.distanceTo(intersection);
          if (dist < closestDist && dist < laser.speed * 1.2) {
            closestDist = dist;
            closestPoint = intersection;
            closestNormal = normal;
          }
        }
      }
      
      // Handle bounce if collision found
      if (closestPoint && closestNormal) {
        // Position at intersection point
        laser.mesh.position.copy(closestPoint);
        
        // Calculate reflection direction
        const dot = laser.direction.dot(closestNormal);
        const reflection = laser.direction.clone()
          .sub(closestNormal.multiplyScalar(2 * dot))
          .normalize();
        
        // Update direction with some randomness for more interesting bounces
        const randomAngle = (Math.random() - 0.5) * 0.2; // Small random angle
        reflection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
        laser.direction.copy(reflection);
        
        // Increment bounce count
        laser.bounces++;
        
        // Create bounce effect
        this.createBounceEffect(closestPoint.clone(), closestNormal.clone());
        
        // Play bounce sound
        this.playSound('bounce');
        
        // Enable player collision after first bounce
        laser.canHitPlayer = true;
        
        // Increase speed slightly with each bounce
        laser.speed *= 1.1;
        
        bounced = true;
      }
      
      // If no bounce, move normally
      if (!bounced) {
        laser.mesh.position.copy(nextPosition);
      }
      
      // Check for enemy collisions - new code
      if (this.enemyManager && this.enemyManager.enemies.length > 0) {
        for (let j = this.enemyManager.enemies.length - 1; j >= 0; j--) {
          const enemy = this.enemyManager.enemies[j];
          if (!enemy.isActive) continue;
          
          const enemyPos = enemy.mesh.position.clone();
          enemyPos.y = 0.5; // Adjust to match laser height
          
          // Check if the laser hit the enemy
          const hitDistance = 0.7; // Collision distance for enemy hits
          if (laser.mesh.position.distanceTo(enemyPos) < hitDistance) {
            // Enemy hit
            enemy.takeDamage(10); // Damage the enemy
            
            // Create hit effect
            this.createHitEffect(enemyPos);
            
            // Play hit sound
            this.playSound('weapon-armor-hit');
            
            // Remove laser
            this.scene.remove(laser.mesh);
            this.scene.remove(laser.trail);
            this.bouncingLasers.splice(i, 1);
            break; // Exit the enemy loop
          }
        }
      }
      
      // Check for player collision
      if (laser.canHitPlayer) {
        const playerPos = this.playerShip.position.clone();
        playerPos.y = 0.5;
        
        if (laser.mesh.position.distanceTo(playerPos) < 1) {
          // Player hit
          this.health -= 10;
          if (this.health < 0) this.health = 0;
          
          // Update UI
          this.ui.updateHealth(this.health, this.maxHealth);
          
          // Visual feedback
          this.flashCollisionWarning();
          this.createBounceEffect(playerPos, new THREE.Vector3(0, 1, 0));
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.bouncingLasers.splice(i, 1);
          continue;
        }
      }
      
      // Update lifetime
      laser.lifeTime++;
      
      // Remove if too old or too many bounces
      if (laser.lifeTime > laser.maxLifeTime || laser.bounces >= laser.maxBounces) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.bouncingLasers.splice(i, 1);
      }
    }
  }
  
  // Create a special effect for laser bounces
  createBounceEffect(position, normal) {
    // Create a particle burst effect at the bounce point
    const particleCount = 20;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    // Add a flash of light at bounce point
    const bounceLight = new THREE.PointLight(0x00ffcc, 3, 5);
    bounceLight.position.copy(position);
    this.scene.add(bounceLight);
    
    // Create a ring effect at bounce point
    const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(position);
    
    // Orient the ring according to the normal
    if (Math.abs(normal.y) > 0.99) { // If normal is pointing mainly up/down
      ring.rotation.x = Math.PI / 2; // Rotate to lie flat
    } else {
      // Point the ring along the normal
      const rotationAxis = new THREE.Vector3(0, 1, 0).cross(normal).normalize();
      const angle = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0)));
      ring.setRotationFromAxisAngle(rotationAxis, angle);
    }
    
    this.scene.add(ring);
    
    // Create particles around bounce point
    for (let i = 0; i < particleCount; i++) {
      // Random direction from bounce point
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(2)).normalize();
      
      // Starting at bounce point
      const startPoint = position.clone();
      particlePositions[i * 3] = startPoint.x;
      particlePositions[i * 3 + 1] = startPoint.y;
      particlePositions[i * 3 + 2] = startPoint.z;
      
      // Random sizes for particles
      particleSizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.1,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Store particle velocities
    const particleVelocities = [];
    for (let i = 0; i < particleCount; i++) {
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1, 
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(1.5)).normalize();
      
      // Random speed
      const speed = Math.random() * 0.1 + 0.05;
      particleVelocities.push(direction.multiplyScalar(speed));
    }
    
    // Animate particles and effects
    let frameCount = 0;
    const maxFrames = 30;
    
    const animate = () => {
      frameCount++;
      
      // Update particles
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x;
        positions[i * 3 + 1] += particleVelocities[i].y;
        positions[i * 3 + 2] += particleVelocities[i].z;
        
        // Slow down particles over time
        particleVelocities[i].multiplyScalar(0.95);
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Fade the light
      bounceLight.intensity *= 0.85;
      
      // Expand and fade the ring
      ring.scale.addScalar(0.15);
      ring.material.opacity *= 0.9;
      
      // Fade the particles
      particles.material.opacity *= 0.92;
      
      if (frameCount < maxFrames) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(bounceLight);
        this.scene.remove(ring);
        this.scene.remove(particles);
      }
    };
    
    // Start animation
    animate();
  }
  
  // Now add new methods to handle grenade targeting
  updateGrenadeTargetingIndicator(event) {
    // Create targeting indicator if it doesn't exist
    if (!this.grenadeTargetIndicator) {
      // Create targeting indicator
      const targetGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
      const targetMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, 
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      this.grenadeTargetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
      this.grenadeTargetIndicator.rotation.x = Math.PI / 2; // Make it horizontal
      
      // Add pulsing animation
      this.grenadeTargetIndicator.pulse = 0;
      
      // Add to scene
      this.scene.add(this.grenadeTargetIndicator);
    }
    
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // Update indicator color based on range
        if (distance > maxRange) {
          this.grenadeTargetIndicator.material.color.set(0xff0000); // Red for out of range
        } else {
          this.grenadeTargetIndicator.material.color.set(0x00ff00); // Green for valid
        }
        
        // Position the targeting indicator
        this.grenadeTargetIndicator.position.copy(targetPoint);
        this.grenadeTargetIndicator.position.y = 0.1; // Slightly above floor
        
        // Pulse animation
        this.grenadeTargetIndicator.pulse += 0.1;
        const scale = 1 + 0.2 * Math.sin(this.grenadeTargetIndicator.pulse);
        this.grenadeTargetIndicator.scale.set(scale, scale, scale);
        
        // Store target point for launching
        this.grenadeTargetPoint = targetPoint.clone();
    }
  }
  
  handleGrenadeTargeting(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Validate energy before proceeding
    if (!this.energy || !this.maxEnergy) {
        console.warn('Energy values invalid:', { energy: this.energy, maxEnergy: this.maxEnergy });
        return;
    }
    
    // Check if we have enough energy - now requires FULL energy
    if (this.energy < this.maxEnergy) {
        console.log("Not enough energy for grenade");
        return;
    }
    
    // Validate event coordinates
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid grenade target coordinates');
        return;
    }
    
    // Get the position where to throw the grenade
    const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // If beyond max range, limit to max range
        if (distance > maxRange) {
            toTarget.normalize().multiplyScalar(maxRange);
            targetPoint.copy(shipPosition).add(toTarget);
        }
        
        // Consume full energy
        this.energy = 0;
        
        // Update UI with energy change
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        } else {
            console.warn('UI energy update failed');
        }
        
        // Create and launch the grenade
        this.launchGrenade(targetPoint);
    }
  }
  
  launchGrenade(targetPoint) {
    // Create grenade mesh
    const grenadeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const grenadeMaterial = new THREE.MeshPhongMaterial({
      color: 0xff4500,
      emissive: 0xff2000,
      emissiveIntensity: 0.5
    });
    const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial);
    
    // Position at the ship
    grenade.position.copy(this.playerShip.position);
    grenade.position.y = 0.5; // Slightly above floor
    
    // Add to scene
    this.scene.add(grenade);
    
    // Add grenade trail effect
    const trail = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({
        color: 0xff4500,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      })
    );
    this.scene.add(trail);
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(0xff4500, 1, 3);
    grenade.add(light);
    
    // Store grenade data for animation
    if (!this.grenades) {
      this.grenades = [];
    }
    
    // Calculate the arc of the grenade
    const startPos = grenade.position.clone();
    const endPos = targetPoint.clone();
    const midPos = startPos.clone().add(endPos.clone().sub(startPos).multiplyScalar(0.5));
    midPos.y += 5; // Arc height
    
    this.grenades.push({
      mesh: grenade,
      trail: trail,
      startPos: startPos,
      midPos: midPos,
      endPos: endPos,
      progress: 0,
      exploded: false,
      explosionRadius: 4,
      trailPoints: []
    });

    // Play grenade launch sound
    this.playSound('grenade-laser');
  }
  
  // Add a method to show targeting indicator for all weapons
  updateTargetingIndicator(event) {
    // Skip if indicator was recently updated
    if (this.lastIndicatorUpdate && Date.now() - this.lastIndicatorUpdate < 16) {
        return;
    }
    this.lastIndicatorUpdate = Date.now();

    // Get the mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Log the normalized mouse position occasionally
    if (Math.random() < 0.01) {
      console.log('Mouse normalized position:', mouse);
    }
    
    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Check for intersection with the raycastFloor
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    // Log raycasting results occasionally for debugging
    if (Math.random() < 0.01) {
      console.log('Raycast results:', { 
        intersections: intersects.length, 
        raycastFloorExists: !!this.raycastFloor,
        raycastFloorPosition: this.raycastFloor ? this.raycastFloor.position.y : 'N/A'
      });
    }
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Create or update targeting indicator
        if (!this.targetingIndicator) {
            console.log('Creating new targeting indicator');
            // Create a more efficient indicator using a single geometry
            const geometry = new THREE.Group();
            
            // Outer ring with fewer segments - MAKE LARGER
            const outerRing = new THREE.RingGeometry(0.8, 1.0, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8, // Increased opacity
                side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerRing, material);
            
            // Inner ring with fewer segments - MAKE LARGER
            const innerRing = new THREE.RingGeometry(0.2, 0.4, 16);
            const inner = new THREE.Mesh(innerRing, material.clone());
            
            // Simplified crosshair - MAKE LARGER
            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = new Float32Array([
                -0.6, 0, 0,
                0.6, 0, 0,
                0, -0.6, 0,
                0, 0.6, 0
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));
            const lines = new THREE.LineSegments(lineGeometry, material.clone());
            
            geometry.add(outer);
            geometry.add(inner);
            geometry.add(lines);
            
            this.targetingIndicator = geometry;
            this.targetingIndicator.rotation.x = Math.PI / 2;
            this.scene.add(this.targetingIndicator);
        }
        
        // Update position - INCREASE HEIGHT
        this.targetingIndicator.position.copy(targetPoint);
        this.targetingIndicator.position.y = 0.5; // Much higher above the terrain
        
        // Update color based on weapon type
        const colors = {
            'LASER': new THREE.Color(0x00ffff),
            'GRENADE': new THREE.Color(0xff4500),
            'BOUNCE': new THREE.Color(0x00ff99)
        };
        const color = colors[this.currentWeapon] || colors['LASER'];
        
        // Only update colors if they've changed
        if (!this.lastWeaponColor || this.lastWeaponColor !== this.currentWeapon) {
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
            this.lastWeaponColor = this.currentWeapon;
        }
        
        // Simplified pulse animation
        if (!this.targetingIndicator.pulse) {
            this.targetingIndicator.pulse = 0;
        }
        this.targetingIndicator.pulse = (this.targetingIndicator.pulse + 0.1) % (Math.PI * 2);
        const pulseScale = 1.0 + 0.1 * Math.sin(this.targetingIndicator.pulse);
        this.targetingIndicator.scale.setScalar(pulseScale);
        
        // Show indicator
        this.targetingIndicator.visible = true;
        
        // Reset fade timeout
        if (this.targetingTimeout) {
            clearTimeout(this.targetingTimeout);
        }
        this.targetingTimeout = setTimeout(() => {
            if (this.targetingIndicator && this.targetingIndicator.visible) {
                this.targetingIndicator.visible = false;
            }
        }, 1000);
        
        // Extract target direction for firing
        const direction = new THREE.Vector3()
            .subVectors(targetPoint, this.playerShip.position)
            .normalize();
        
        // Store direction for firing
        this.targetDirection = direction;
    }
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggleMiniMap() {
    if (this.miniMap) {
      this.miniMap.toggle();
    }
  }
  
  // Add cleanup method
  cleanup() {
    // Stop and remove all sounds
    this.soundPools.forEach(pool => {
      pool.forEach(wrapper => {
        if (wrapper.sound.isPlaying) {
          wrapper.sound.stop();
        }
        wrapper.sound.buffer = null;
      });
    });
    
    // Clear sound pools and loaded sounds
    this.soundPools.clear();
    this.loadedSounds.clear();
    this.soundLoadPromises.clear();
    
    // Remove audio listener from camera
    if (this.audioListener) {
      this.camera.remove(this.audioListener);
      this.audioListener = null;
    }
    
    // Remove event listeners
    window.removeEventListener('resize', this.boundHandleResize);
    document.removeEventListener('keydown', this.boundHandleKeyDown);
    document.removeEventListener('keyup', this.boundHandleKeyUp);
    document.removeEventListener('click', this.boundHandleClick);
    document.removeEventListener('mousemove', this.boundHandleMouseMove);
    
    // Clear timers
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = null;
    }
    
    if (this.mouseMoveTimer) {
      clearTimeout(this.mouseMoveTimer);
      this.mouseMoveTimer = null;
    }
    
    // Clear weapon cooldowns
    this.weaponCooldowns.clear();
    
    // Clear key states
    Object.keys(this.keys).forEach(key => {
      this.keys[key] = false;
    });
    this.activeKeys.clear();
  }

  startGame() {
    console.log("Starting game...");
    
    // Get player name from input
    const playerNameInput = document.getElementById('player-name');
    this.playerName = playerNameInput.value.trim() || 'Pilot-' + Math.floor(Math.random() * 1000);
    
    // Hide start screen
    const startScreen = document.getElementById('start-screen');
    startScreen.classList.add('hidden');
    
    // Enable multiplayer mode by default
    this.multiplayerEnabled = true;
    
    // Connect to server
    if (this.networkManager) {
      this.networkManager.connect();
      
      // Show multiplayer info UI
      const multiplayerInfo = document.getElementById('multiplayer-info');
      if (multiplayerInfo) {
        multiplayerInfo.classList.remove('hidden');
      }
      
      // Update player info on server
      this.networkManager.updatePlayerInfo(this.playerName, this.currentShipType || 'default');
    }
    
    // Show ship selection screen
    this.showShipSelection();
  }

  showShipSelection() {
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
      console.error('Game container not found');
      return;
    }

    // Initialize ship selection if not already done
    if (!this.shipSelection) {
      this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
          this.shipSelection.hide();
          this.startGameplay(selection);
        }
      });
    }
    this.shipSelection.show();
  }

  startGameplay(shipSelection) {
    console.log('🔍 Starting gameplay with ship selection:', shipSelection);
    
    // First apply the ship selection
    this.applyShipSelection(shipSelection);
    
    // Set game as running (if this property exists)
    this.isRunning = true;
    
    // Show game UI (using either method)
    if (typeof this.ui !== 'undefined' && typeof this.ui.show === 'function') {
        this.ui.show();
    } else {
        // Show game UI directly
        const gameUI = document.querySelector('.game-ui');
        if (gameUI) {
            gameUI.classList.remove('hidden');
        }
    }
    
    // Show mini-map if it exists
    if (this.miniMap && typeof this.miniMap.show === 'function') {
        this.miniMap.show();
    }
    
    // Create and show controls if not already created
    if (!this.controlsContainer && typeof this.createControlIndicators === 'function') {
        this.createControlIndicators();
    }
    this.fadeInControls();
    
    // IMPORTANT: Double-check that the player ship has a proper collision radius
    if (this.playerShip) {
        this.playerShip.userData.collisionRadius = 0.35; // Use the same reduced value as defined earlier
        console.log('🛡️ Verified player ship collision radius:', this.playerShip.userData.collisionRadius);
    } else {
        console.error('⚠️ Player ship not available when starting gameplay!');
    }
    
    // Manually check for collisions once to make sure it's working
    setTimeout(() => {
        console.log('🔍 Running initial collision check...');
        this.checkObstacleCollisions();
    }, 500);

    // Start animation loop
    this.animate();
    
    console.log('✅ Game started successfully!');
  }

  applyShipSelection(selection) {
    console.log('🔍 Applying ship selection:', selection);
    
    // Clear existing ship model
    if (this.playerShip) {
        // Remove all children (previous ship model)
        while (this.playerShip.children.length > 0) {
            const child = this.playerShip.children[0];
            this.playerShip.remove(child);
        }
    }
    
    // Set ship model based on selection
    const type = selection.type.toUpperCase(); // Make sure it's uppercase for consistency
    this.setShipModel(type);
    this.currentShipType = type;
    
    // Position ship at a random location in the playing area
    // Avoid spawning too close to the center (where other players might spawn)
    const spawnRadius = 30; // Radius from center for spawning
    const randomAngle = Math.random() * Math.PI * 2; // Random angle
    const randomDistance = spawnRadius * (0.5 + Math.random() * 0.5); // Between 50% and 100% of spawn radius
    
    // Calculate position
    const spawnX = Math.cos(randomAngle) * randomDistance;
    const spawnZ = Math.sin(randomAngle) * randomDistance;
    
    // Set player ship position
    if (this.playerShip) {
        this.playerShip.position.set(spawnX, this.playerShip.position.y, spawnZ);
        
        // Set random rotation
        this.playerShip.rotation.y = Math.random() * Math.PI * 2;
        
        console.log(`Player spawned at position: [${spawnX.toFixed(2)}, ${spawnZ.toFixed(2)}], rotation: ${this.playerShip.rotation.y.toFixed(2)}`);
    }
    
    // Apply ship color if specified
    if (selection.color && this.playerShip) {
        const color = new THREE.Color(selection.color);
        
        // Apply color to all meshes in the ship model
        this.playerShip.traverse(child => {
            if (child.isMesh && child.material) {
                try {
                    // Clone the material to avoid affecting other instances
                    if (!child.material._isCloned) {
                        child.material = child.material.clone();
                        child.material._isCloned = true;
                    }
                    
                    // Update material color properties with safety checks
                    if (child.material.color) {
                        child.material.color.set(color);
                    }
                    
                    if (child.material.emissive) {
                        child.material.emissive.set(color);
                        child.material.emissiveIntensity = 0.3;
                    }
                    
                    // Update the material
                    child.material.needsUpdate = true;
                } catch (error) {
                    console.warn('Error setting material properties:', error);
                }
            }
        });
    }
    
    console.log('✅ Ship configuration applied successfully');
    
    // Verify collision detection is working
    console.log('🔍 Verifying collision detection is working');
}

exitToMainMenu() {
    // Stop animation loop
    this.isRunning = false;

    // Hide in-game menu if it exists
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
      menuContainer.classList.add('hidden');
    }

    // Hide game UI
    this.ui.hide();
    if (this.miniMap) {
      this.miniMap.hide();
    }
    this.fadeOutControls();

    // Clean up ship selection if it exists
    if (this.shipSelection) {
      this.shipSelection.hide();
    }

    // Show start screen
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
      startScreen.classList.add('fade-in');
    }

    // Reset game state
    this.resetGameState();
  }

  resetGameState() {
    console.log('🔄 Resetting game state...');
    
    // Reset player position
    if (this.playerShip) {
        this.playerShip.position.set(0, 0.5, 0);
        this.playerShip.rotation.set(0, 0, 0);
    }
    
    // Reset camera to original position
    if (this.camera) {
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);
    }
    
    // Reset player stats
    this.health = this.maxHealth || 100;
    this.energy = this.maxEnergy || 100;
    
    // Update UI - use existing methods if available
    if (typeof this.updateUI === 'function') {
        this.updateUI();
    } else {
        // Update health bar
        const healthBar = document.querySelector('.health-bar .bar-inner');
        if (healthBar) {
            healthBar.style.width = '100%';
        }
        
        // Update energy bar
        const energyBar = document.querySelector('.energy-bar .bar-inner');
        if (energyBar) {
            energyBar.style.width = '100%';
        }
    }
    
    // Original way of clearing lasers
    if (this.lasers) {
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            const laser = this.lasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.lasers = [];
    }
    
    // Clear bouncing lasers
    if (this.bouncingLasers) {
        for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
            const laser = this.bouncingLasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.bouncingLasers = [];
    }
    
    // Clear grenades
    if (this.grenades) {
        for (let i = this.grenades.length - 1; i >= 0; i--) {
            const grenade = this.grenades[i];
            if (grenade.mesh && grenade.mesh.parent) {
                grenade.mesh.parent.remove(grenade.mesh);
            }
        }
        this.grenades = [];
    }
    
    // Reset movement keys
    this.keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        strafeLeft: false,
        strafeRight: false
    };
    
    // Reset weapon state to original
    this.currentWeapon = 'laser';
    this.weaponCooldown = 0;
    this.grenadeTargeting = false;
    
    // Make sure the player exists
    if (!this.playerShip) {
        this.createDefaultShip();
    }
    
    // Reset player velocity (original behavior)
    this.playerVelocity = new THREE.Vector3();
    this.playerRotation = new THREE.Vector3();
    
    // Update weapon UI - use existing method if available
    if (typeof this.updateWeaponUI === 'function') {
        this.updateWeaponUI();
    }
    
    // Update control indicators - use existing method if available
    if (typeof this.updateControlIndicators === 'function') {
        this.updateControlIndicators();
    }
    
    console.log('✅ Game state reset complete');
  }

  handleDirectionalFiring(event) {
    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);

    // Check for intersection with an invisible plane at ship's height
    const planeNormal = new THREE.Vector3(0, 1, 0);
    const shipHeight = this.playerShip.position.y;
    const plane = new THREE.Plane(planeNormal, -shipHeight);
    
    const targetPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, targetPoint);

    if (targetPoint) {
        // Calculate direction from ship to target
        const direction = targetPoint.clone().sub(this.playerShip.position).normalize();
        direction.y = 0; // Keep shots parallel to ground

        // Get the ship's current forward direction
        const shipForward = new THREE.Vector3(0, 0, 1);
        shipForward.applyQuaternion(this.playerShip.quaternion);
        shipForward.y = 0;
        shipForward.normalize();

        // Calculate the angle between ship's forward direction and target direction
        const angle = shipForward.angleTo(direction);
        
        // Only fire if the target is within a reasonable angle (e.g., 60 degrees) from ship's forward direction
        const maxFiringAngle = Math.PI / 3; // 60 degrees
        
        if (angle <= maxFiringAngle) {
            // Fire weapon in the calculated direction
            this.fireCurrentWeapon(direction);
        }
    }
  }

  fireCurrentWeapon(direction) {
    // Check weapon cooldown
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;

    if (now < weaponCooldown) {
        return;
    }

    // Define energy costs for each weapon from GAME_CONFIG
    const energyCosts = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.ENERGY_COST,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.ENERGY_COST,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.ENERGY_COST
    };

    // Check if we have enough energy
    const energyCost = energyCosts[this.currentWeapon];
    if (this.energy < energyCost) {
        console.log(`Not enough energy for ${this.currentWeapon}`);
        return;
    }

    // Set cooldown based on weapon type from GAME_CONFIG
    const cooldowns = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.COOLDOWN,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.COOLDOWN,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.COOLDOWN
    };
    const cooldownTime = cooldowns[this.currentWeapon];

    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);

    // Consume energy
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Update UI with energy change
    if (this.ui && typeof this.ui.updateEnergy === 'function') {
        this.ui.updateEnergy(this.energy, this.maxEnergy);
    }

    // Use target direction if available, otherwise use ship orientation
    let firingDirection;
    
    // If we have a targetDirection from mouse, use that instead of ship orientation
    if (this.targetDirection && (this.currentWeapon === 'LASER' || this.currentWeapon === 'BOUNCE')) {
        firingDirection = this.targetDirection.clone();
        console.log('Using mouse targeting direction:', firingDirection);
    } else {
        // Fall back to ship orientation if no target direction
        firingDirection = direction || new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        console.log('Using ship orientation direction:', firingDirection);
    }
    
    // Ensure direction is normalized
    firingDirection.normalize();
    
    // Get firing position (slightly in front of ship)
    const position = this.playerShip.position.clone().add(firingDirection.clone().multiplyScalar(1.5));
    position.y = 0.5; // Set height

    // Create weapon effect based on type
    switch (this.currentWeapon) {
        case 'LASER':
            this.fireLaser(position, firingDirection);
            this.playSound('laser');
            
            // Send laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection
                });
            }
            break;
        case 'BOUNCE':
            this.fireBouncingLaser(position, firingDirection);
            this.playSound('laser-bounce');
            
            // Send bounce laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection,
                    type: 'bounce'
                });
            }
            break;
        case 'GRENADE':
            // Grenades are handled separately through handleGrenadeTargeting
            break;
    }

    // Visual feedback for firing
    this.createMuzzleFlash(position, firingDirection);

    // Log energy state for debugging
    console.log(`Weapon fired: ${this.currentWeapon}, Energy remaining: ${this.energy}/${this.maxEnergy}`);
}

createMuzzleFlash(position, direction) {
  // Create a quick flash effect at the firing position
  const flashGeometry = new THREE.CircleGeometry(0.3, 16);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
  });
  
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position flash at the weapon position, oriented to face the camera
  flash.position.copy(position);
  flash.position.y += 0.1; // Slightly above ship
  
  // Update flash to always face camera
  flash.lookAt(this.camera.position);
  
  // Add to scene
  this.scene.add(flash);
  
  // Create flash animation with subtle scaling
  let scale = 1;
  const animate = () => {
    scale += 0.2;
    flash.scale.set(scale, scale, scale);
    
    // Reduce opacity as flash grows
    if (flash.material) {
      flash.material.opacity = Math.max(0, 1 - (scale - 1) / 2);
      
      // Remove when fully transparent
      if (flash.material.opacity <= 0) {
        this.scene.remove(flash);
        if (flash.material) flash.material.dispose();
        if (flash.geometry) flash.geometry.dispose();
        return;
      }
    }
    
    // Continue animation
    requestAnimationFrame(animate);
  };
  animate();
}

  fireLaser(position, direction) {
    // Create laser geometry - make it longer and thinner for better visual
    const geometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
    geometry.rotateX(-Math.PI / 2); // Changed rotation to negative to flip direction

    // Create glowing material with better visual effects
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Orient laser along direction - using lookAt for more accurate direction
    const targetPos = position.clone().add(direction.clone().multiplyScalar(10));
    laser.lookAt(targetPos);

    // Add to scene
    this.scene.add(laser);

    // Add point light for glow effect with better parameters
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.set(0, 0, 0); // Center of the laser
    laser.add(light);

    // Add a trail effect
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    this.scene.add(trail);

    // Initialize lasers array if it doesn't exist
    if (!this.lasers) {
      this.lasers = [];
    }

    // Store laser data with enhanced properties
    this.lasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 1.2, // Slightly increased speed for better feel
      lifeTime: 0,
      maxLifeTime: 40,
      trailPoints: [],
      pulsePhase: 0
    });
  }

  fireBouncingLaser(position, direction) {
    // Create bouncing laser geometry - using a smaller sphere for better visuals
    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff99,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Add point light for glow effect
    const light = new THREE.PointLight(0x00ff99, 2, 3);
    laser.add(light);

    // Create enhanced trail effect
    const trail = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({
        color: 0x00ff99,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      })
    );

    // Add to scene
    this.scene.add(laser);
    this.scene.add(trail);

    // Initialize bouncing lasers array if it doesn't exist
    if (!this.bouncingLasers) {
      this.bouncingLasers = [];
    }

    // Store bouncing laser data with improved parameters
    this.bouncingLasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 0.8, // Increased speed for better feel
      bounces: 0,
      maxBounces: 3,
      lifeTime: 0,
      maxLifeTime: 120,
      canHitPlayer: false,
      bounceTimeout: 15, // Reduced timeout for better gameplay
      trailPoints: [],
      pulsePhase: 0
    });
  }

  createHitEffect(position) {
    // Create particle burst effect
    const particleCount = 15;
    const particles = [];
    
    // Create particle material with orange/red color for explosion
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.2, 0.2);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity in all directions
      const velocity = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0;
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.5, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(this.camera.position);
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0xff6600, 3, 6);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles and effects
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }

  showInGameMenu() {
    // Pause the game
    this.isRunning = false;
    
    // Create or reuse the menu element
    let menuContainer = document.getElementById('in-game-menu');
    if (!menuContainer) {
      menuContainer = document.createElement('div');
      menuContainer.id = 'in-game-menu';
      menuContainer.className = 'menu-container';
      document.getElementById('game-container').appendChild(menuContainer);
      
      // Style the menu
      menuContainer.style.position = 'absolute';
      menuContainer.style.top = '50%';
      menuContainer.style.left = '50%';
      menuContainer.style.transform = 'translate(-50%, -50%)';
      menuContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      menuContainer.style.padding = '20px';
      menuContainer.style.borderRadius = '10px';
      menuContainer.style.color = '#fff';
      menuContainer.style.textAlign = 'center';
      menuContainer.style.zIndex = '1000';
      menuContainer.style.border = '2px solid #00ffff';
      menuContainer.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
      menuContainer.style.minWidth = '300px';
    }
    
    // Create menu content
    menuContainer.innerHTML = `
      <h2 style="color: #00ffff; margin-top: 0;">Game Menu</h2>
      <div class="menu-options">
        <button id="resume-button" class="menu-button">Resume Game</button>
        <button id="change-ship-button" class="menu-button">Change Ship</button>
        <button id="exit-button" class="menu-button">Exit to Main Menu</button>
      </div>
    `;
    
    // Style buttons
    const buttons = menuContainer.querySelectorAll('.menu-button');
    buttons.forEach(button => {
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.padding = '10px';
      button.style.margin = '10px 0';
      button.style.backgroundColor = '#001a33';
      button.style.color = '#00ffff';
      button.style.border = '1px solid #00ffff';
      button.style.borderRadius = '5px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '16px';
      button.style.transition = 'all 0.2s';
      
      // Hover effect
      button.onmouseenter = () => {
        button.style.backgroundColor = '#00ffff';
        button.style.color = '#001a33';
      };
      button.onmouseleave = () => {
        button.style.backgroundColor = '#001a33';
        button.style.color = '#00ffff';
      };
    });
    
    // Add event listeners
    document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
    document.getElementById('change-ship-button').addEventListener('click', () => this.showShipChangeScreen());
    document.getElementById('exit-button').addEventListener('click', () => this.exitToMainMenu());
    
    // Show the menu
    menuContainer.classList.remove('hidden');
  }
  
  resumeGame() {
    console.log('Hiding menus');
    
    // Hide ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
    }
    
    // Hide menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
  }
  
  showShipChangeScreen() {
    // Hide the menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
    
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
        console.error('Game container not found');
        return;
    }
    
    // Clean up existing ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
        
        // Safely remove the element from DOM if it exists and has a parent
        if (this.shipSelection.element && this.shipSelection.element.parentNode) {
            this.shipSelection.element.parentNode.removeChild(this.shipSelection.element);
        }
        
        this.shipSelection = null;
    }
    
    // Create new ship selection instance
    this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
            this.shipSelection.hide();
            this.applyShipSelection(selection);
        }
    });
    
    // Show the ship selection UI
    this.shipSelection.show();
  }

  /**
   * Calculate proper ground offset for an object based on its type and geometry
   */
  calculateGroundOffset(model, category, scale) {
    // Get the bounding box
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Calculate the distance from the object's pivot to its bottom
    const pivotToBottom = bbox.min.y;
    
    // The base offset is the distance needed to move the object so its bottom touches the ground
    let groundOffset = -pivotToBottom;
    
    // Add category-specific adjustments with more refined values
    switch(category) {
      case 'rocks':
        // Rocks typically need to be slightly embedded in the ground
        groundOffset += size.y * 0.08;
        break;
      case 'flora':
        // Flora should be firmly planted in the ground
        groundOffset += size.y * 0.03;
        break;
      case 'groundFeatures':
        // Ground features should be partially embedded, varying by model
        if (model.name && model.name.includes('Ground02')) {
          groundOffset += size.y * 0.15; // SP_Ground02 needs more embedding
        } else if (model.name && model.name.includes('Ground05')) {
          groundOffset += size.y * 0.05; // SP_Ground05 needs less embedding
        } else {
          groundOffset += size.y * 0.1; // Default for other ground features
        }
        break;
      case 'crystals':
        // Crystals should appear to be growing from the ground
        groundOffset += size.y * 0.15;
        break;
      case 'mountains':
        // Mountains need to be firmly embedded with varying depths
        const mountainDepth = 0.08 + (Math.random() * 0.05); // Random depth between 8-13%
        groundOffset += size.y * mountainDepth;
        break;
      case 'centerpiece':
        // Centerpiece gets special treatment
        groundOffset += size.y * 0.12;
        break;
      default:
        // Default adjustment for unknown types
        groundOffset += 0;
    }
    
    // Scale the offset according to the object's scale
    // Add a small global offset to prevent z-fighting
    return (groundOffset * scale) + 0.01;
  }

  /**
   * Create a special centerpiece for the landscape
   */
  createCenterpiece() {
    // Create a special formation at a designated spot
    const centerpiece = {
      position: new THREE.Vector3(0, 0, -35), // Prominent position
      models: [
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 2.5, offset: new THREE.Vector3(0, 0, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.8, offset: new THREE.Vector3(2, 0, 1), rotation: Math.PI/4 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.6, offset: new THREE.Vector3(-1.5, 0, -1), rotation: -Math.PI/5 },
        { path: 'assets/models/objects/SP_Ground05.glb', scale: 2.0, offset: new THREE.Vector3(0, -0.5, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Stone01.glb', scale: 1.2, offset: new THREE.Vector3(2.5, 0, -1.5), rotation: Math.PI/3 }
      ]
    };
    
    // Load each model in the centerpiece
    centerpiece.models.forEach((model, index) => {
      const loader = new GLTFLoader();
      loader.load(
        model.path,
        (gltf) => {
          const object = gltf.scene;
          
          // Apply scale
          object.scale.set(model.scale, model.scale, model.scale);
          
          // Position relative to centerpiece
          object.position.copy(centerpiece.position.clone().add(model.offset));
          
          // Apply rotation
          object.rotation.y = model.rotation;
          
          // Add special glow effect for crystals
          if (model.path.includes('Crystal')) {
            object.traverse(node => {
              if (node.isMesh && node.material) {
                node.material.emissive = new THREE.Color(0xff00ff);
                node.material.emissiveIntensity = 0.5;
                
                // Add a point light for extra effect
                const light = new THREE.PointLight(0xff00ff, 2, 10);
                light.position.set(0, 2 * model.scale, 0);
                object.add(light);
              }
            });
          }
          
          // Add to scene
          this.scene.add(object);
          
          // Create collision data
          const bbox = new THREE.Box3().setFromObject(object);
          const size = bbox.getSize(new THREE.Vector3());
          
          // Use improved ground placement
          const groundY = this.calculateGroundOffset(object, 'centerpiece', model.scale);
          object.position.y = groundY + model.offset.y; // Add the intentional offset for composition
          
          // Generate compound collision shapes
          const collisionShapes = this.generateCompoundCollisionShapes(object, 'centerpiece', model.scale);
          
          // Add to obstacles
          this.obstacles.push({
            mesh: object,
            type: 'centerpiece',
            collisionShape: 'compound',
            compoundShapes: collisionShapes.map(shape => {
              // Transform shape centers to world coordinates
              const worldCenter = shape.center.clone();
              worldCenter.add(object.position);
              
              return {
                ...shape,
                center: worldCenter,
                worldRotation: object.rotation.y + (shape.rotation || 0)
              };
            }),
            boundingBox: {
              min: new THREE.Vector3(
                object.position.x - (size.x * model.scale / 2),
                object.position.y - (size.y * model.scale / 2),
                object.position.z - (size.z * model.scale / 2)
              ),
              max: new THREE.Vector3(
                object.position.x + (size.x * model.scale / 2),
                object.position.y + (size.y * model.scale / 2),
                object.position.z + (size.z * model.scale / 2)
              ),
              size: size.clone().multiplyScalar(model.scale),
              rotation: object.rotation.y
            },
            size: Math.max(size.x, size.z) * model.scale * 0.5,
            position: object.position.clone()
          });
          
          console.log(`Centerpiece: Added ${model.path.split('/').pop()} at position [${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)}]`);
        },
        undefined,
        (error) => {
          console.error(`Error loading centerpiece model ${model.path}:`, error);
        }
      );
    });
  }

  /**
   * Create a special effect when colliding with crystals
   */
  createCrystalCollisionEffect(position, isSpecial = false) {
    // Create particles for crystal collision
    const particleCount = isSpecial ? 30 : 15;
    const color = isSpecial ? 0xff00ff : 0x00ffff;
    
    for (let i = 0; i < particleCount; i++) {
      // Create a small glowing cube
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      
      // Position at collision point
      particle.position.copy(position);
      
      // Add small random offset
      particle.position.x += (Math.random() - 0.5) * 2;
      particle.position.y += Math.random() * 3;
      particle.position.z += (Math.random() - 0.5) * 2;
      
      // Add to scene
      this.scene.add(particle);
      
      // Create velocity for particle
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.2 + 0.1,
        (Math.random() - 0.5) * 0.2
      );
      
      // Animate the particle
      const startTime = Date.now();
      const duration = 1000 + Math.random() * 1000; // 1-2 seconds
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Remove particle when animation completes
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return;
        }
        
        // Update position
        particle.position.add(velocity);
        
        // Slow down over time
        velocity.multiplyScalar(0.98);
        
        // Fade out
        particle.material.opacity = 0.8 * (1 - progress);
        
        // Continue animation
        requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
    }
  }

  /**
   * Generate compound collision shapes for more accurate collision detection
   */
  generateCompoundCollisionShapes(model, category, scale) {
    // Generate a compound collision shape based on model geometry and category
    const shapes = [];
    const bbox = new THREE.Box3().setFromObject(model);
    
    // Helper function to add a box shape
    const addBoxShape = (center, size, rotation = 0) => {
      shapes.push({
        type: 'box',
        center: center.clone(),
        halfExtents: size.clone().multiplyScalar(0.5),
        rotation: rotation
      });
    };
    
    // Helper function to add a sphere shape
    const addSphereShape = (center, radius) => {
      shapes.push({
        type: 'sphere',
        center: center.clone(),
        radius: radius
      });
    };
    
    // Different collision shape strategies based on category
    switch(category) {
      case 'rocks':
        // For rocks, use 1-3 overlapping boxes based on size
        const rockSize = bbox.getSize(new THREE.Vector3());
        const rockCenter = new THREE.Vector3();
        bbox.getCenter(rockCenter);
        
        // Main box
        addBoxShape(rockCenter, rockSize);
        
        // For larger rocks, add 1-2 more boxes at slight offsets for better shape approximation
        if (rockSize.x > 1.5 * scale || rockSize.z > 1.5 * scale) {
          // Add a second box, slightly offset and rotated
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3 * rockSize.x,
            0,
            (Math.random() - 0.5) * 0.3 * rockSize.z
          );
          
          const secondSize = new THREE.Vector3(
            rockSize.x * (0.7 + Math.random() * 0.3),
            rockSize.y * 0.9,
            rockSize.z * (0.7 + Math.random() * 0.3)
          );
          
          addBoxShape(rockCenter.clone().add(offset), secondSize, Math.PI * 0.25);
          
          // For very large rocks, add a third box
          if (rockSize.x > 2.5 * scale || rockSize.z > 2.5 * scale) {
            const thirdOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4 * rockSize.x,
              rockSize.y * 0.2,
              (Math.random() - 0.5) * 0.4 * rockSize.z
            );
            
            const thirdSize = new THREE.Vector3(
              rockSize.x * (0.6 + Math.random() * 0.2),
              rockSize.y * 0.7,
              rockSize.z * (0.6 + Math.random() * 0.2)
            );
            
            addBoxShape(rockCenter.clone().add(thirdOffset), thirdSize, Math.PI * 0.125);
          }
        }
        break;
        
      case 'flora':
        // For flora, use a smaller box for the base and a sphere for the top
        const floraSize = bbox.getSize(new THREE.Vector3());
        const floraCenter = new THREE.Vector3();
        bbox.getCenter(floraCenter);
        
        // Box for the base/stem
        const stemSize = new THREE.Vector3(
          floraSize.x * 0.2,
          floraSize.y * 0.6,
          floraSize.z * 0.2
        );
        
        const stemCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (stemSize.y / 2),
          floraCenter.z
        );
        
        addBoxShape(stemCenter, stemSize);
        
        // Sphere for the top/foliage
        const foliageCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (floraSize.y * 0.7),
          floraCenter.z
        );
        
        const foliageRadius = Math.max(floraSize.x, floraSize.z) * 0.5;
        addSphereShape(foliageCenter, foliageRadius);
        break;
        
      case 'mountains':
        // For mountains, use a pyramid-like composition of boxes
        const mountainSize = bbox.getSize(new THREE.Vector3());
        const mountainCenter = new THREE.Vector3();
        bbox.getCenter(mountainCenter);
        
        // Base box (wider)
        const baseSize = new THREE.Vector3(
          mountainSize.x,
          mountainSize.y * 0.3,
          mountainSize.z
        );
        
        const baseCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + (baseSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(baseCenter, baseSize);
        
        // Middle box (narrower)
        const middleSize = new THREE.Vector3(
          mountainSize.x * 0.8,
          mountainSize.y * 0.4,
          mountainSize.z * 0.8
        );
        
        const middleCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + (middleSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(middleCenter, middleSize);
        
        // Top box (narrowest)
        const topSize = new THREE.Vector3(
          mountainSize.x * 0.5,
          mountainSize.y * 0.3,
          mountainSize.z * 0.5
        );
        
        const topCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + middleSize.y + (topSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(topCenter, topSize);
        break;
        
      case 'crystals':
        // For crystals, use a combination of boxes at different angles
        const crystalSize = bbox.getSize(new THREE.Vector3());
        const crystalCenter = new THREE.Vector3();
        bbox.getCenter(crystalCenter);
        
        // Calculate a better fitting box size (narrower)
        const mainCrystalSize = new THREE.Vector3(
          crystalSize.x * 0.7,
          crystalSize.y,
          crystalSize.z * 0.7
        );
        
        // Add the main crystal shape
        addBoxShape(crystalCenter, mainCrystalSize, model.rotation.y);
        
        // For larger crystals, add some angled shards
        if (crystalSize.y > 1.0 * scale) {
          // Add up to 3 additional shards
          const shardCount = 1 + Math.floor(Math.random() * 3);
          
          for (let i = 0; i < shardCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = crystalSize.x * 0.3;
            
            const offset = new THREE.Vector3(
              Math.cos(angle) * distance,
              crystalSize.y * (Math.random() * 0.2),
              Math.sin(angle) * distance
            );
            
            const shardSize = new THREE.Vector3(
              crystalSize.x * (0.2 + Math.random() * 0.3),
              crystalSize.y * (0.4 + Math.random() * 0.4),
              crystalSize.z * (0.2 + Math.random() * 0.3)
            );
            
            const shardRotation = Math.random() * Math.PI;
            addBoxShape(crystalCenter.clone().add(offset), shardSize, shardRotation);
          }
        }
        break;
        
      case 'groundFeatures':
        // For ground features, use a more accurate horizontal shape with the right height
        const groundSize = bbox.getSize(new THREE.Vector3());
        const groundCenter = new THREE.Vector3();
        bbox.getCenter(groundCenter);
        
        // Just use a single box but with better proportions
        const adjustedSize = new THREE.Vector3(
          groundSize.x,
          groundSize.y * 0.7, // Lower height to prevent floating
          groundSize.z
        );
        
        // Center it properly on the ground
        const adjustedCenter = new THREE.Vector3(
          groundCenter.x,
          bbox.min.y + (adjustedSize.y / 2),
          groundCenter.z
        );
        
        addBoxShape(adjustedCenter, adjustedSize, model.rotation.y);
        break;
        
      case 'centerpiece':
        // For centerpiece, create a custom multi-part shape
        const centerpieceSize = bbox.getSize(new THREE.Vector3());
        const centerpieceCenter = new THREE.Vector3();
        bbox.getCenter(centerpieceCenter);
        
        // Main box
        addBoxShape(centerpieceCenter, centerpieceSize);
        
        // Add a sphere on top for the crystal parts
        const sphereCenter = new THREE.Vector3(
          centerpieceCenter.x,
          centerpieceCenter.y + (centerpieceSize.y * 0.2),
          centerpieceCenter.z
        );
        
        const sphereRadius = Math.max(centerpieceSize.x, centerpieceSize.z) * 0.6;
        addSphereShape(sphereCenter, sphereRadius);
        break;
        
      default:
        // Default: just use a box based on the bounding box
        const size = bbox.getSize(new THREE.Vector3());
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        addBoxShape(center, size);
        break;
    }
    
    return shapes;
  }

  updateOtherPlayers() {
    if (!this.networkManager || !this.multiplayerEnabled || !this.assetLoader) return;
  
    const otherPlayers = this.networkManager.getOtherPlayers();
    if (!this.otherPlayerObjects) this.otherPlayerObjects = {};
  
    otherPlayers.forEach(playerData => {
      let playerObject = this.otherPlayerObjects[playerData.id];
  
      if (!playerObject) {
        console.log('Creating new player representation for:', playerData.id);
        const shipType = (playerData.shipType || 'STANDARD').toUpperCase();
        const shipModel = this.assetLoader.getOpponentShipModel(shipType);
  
        if (!shipModel) {
          console.warn(`No model found for ship type: ${shipType}, falling back to default`);
          // Fallback geometry if model fails
          const geometry = new THREE.ConeGeometry(0.5, 1.0, 8);
          geometry.rotateX(Math.PI / 2);
          const material = new THREE.MeshPhongMaterial({ 
            color: playerData.teamColor || 0x00ffff,
            emissive: playerData.teamColor || 0x00ffff,
            emissiveIntensity: 0.5
          });
          const ship = new THREE.Mesh(geometry, material);
          this.scene.add(ship);
          playerObject = { ship, lastUpdate: Date.now() };
        } else {
          // Scale the model consistently (matching player ship scaling)
          shipModel.scale.set(0.45, 0.45, 0.45);
          this.scene.add(shipModel);
          playerObject = { ship: shipModel, lastUpdate: Date.now() };
        }
  
        // Add engine glow
        const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
        engineGlow.position.set(0, 0, -0.7);
        playerObject.ship.add(engineGlow);
        playerObject.engineGlow = engineGlow;
  
        // Add name label
        const nameDiv = document.createElement('div');
        nameDiv.className = 'player-label';
        nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
        const nameLabel = new CSS2DObject(nameDiv);
        nameLabel.position.set(0, 1.8, 0);
        playerObject.ship.add(nameLabel);
        playerObject.nameLabel = nameLabel;
  
        this.otherPlayerObjects[playerData.id] = playerObject;
      }
  
      // Update position and rotation
      if (playerData.position) {
        playerObject.ship.position.lerp(
          new THREE.Vector3(playerData.position.x, playerData.position.y || 0.5, playerData.position.z),
          0.3
        );
      }
      if (playerData.rotation !== undefined) {
        const targetY = playerData.rotation;
        let rotDiff = targetY - playerObject.ship.rotation.y;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerObject.ship.rotation.y += rotDiff * 0.3;
      }
  
      playerObject.lastUpdate = Date.now();
    });
  
    // Clean up disconnected players
    const now = Date.now();
    Object.keys(this.otherPlayerObjects).forEach(id => {
      const playerObj = this.otherPlayerObjects[id];
      if (now - playerObj.lastUpdate > 10000) {
        console.log('Removing disconnected player:', id);
        this.scene.remove(playerObj.ship);
        delete this.otherPlayerObjects[id];
        this.updatePlayerCount();
      }
    });
  }

  // Helper method to send player position and rotation to the server
  sendPlayerPositionUpdate() {
    if (!this.playerShip || !this.networkManager || !this.networkManager.isConnected()) return;
    
    // Create a simple data object with player information
    const playerData = {
      position: {
        x: this.playerShip.position.x,
        y: this.playerShip.position.y,
        z: this.playerShip.position.z
      },
      rotation: this.playerShip.rotation.y,
      shipType: this.currentShipType || 'STANDARD',
      name: this.playerName
    };
    
    // Send the update to the network manager
    this.networkManager.sendPlayerUpdate(playerData);
  }

  // Add the missing setShipModel function
  setShipModel(type) {
    console.log('🔍 Setting ship model:', type);
    
    // Get the ship model from assets
    let model = this.assetLoader.getShipModel(type);
    
    // If model is null or undefined, create fallback model
    if (!model) {
      console.warn('⚠️ Using fallback ship model for type:', type);
      
      // Create a simple geometric shape as fallback
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, 
        specular: 0x111111, 
        shininess: 30 
      });
      model = new THREE.Mesh(geometry, material);
    }
    
    // Clear existing player ship if it exists
    if (this.playerShip) {
      if (this.scene) {
        this.scene.remove(this.playerShip);
      }
      this.playerShip = null;
    }
    
    // Set the new ship model
    this.playerShip = model;
    
    // Position the ship appropriately
    if (this.playerShip && this.scene) {
      this.playerShip.position.set(0, 0.5, 0);
      this.scene.add(this.playerShip);
    }
    
    return this.playerShip;
  }

  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.soundManager) {
      console.log(`Playing sound: ${name}`);
      this.soundManager.playSound(name, position);
    } else {
      console.warn(`Cannot play sound '${name}': SoundManager not initialized`);
    }
  }

  /**
   * Update a remote player's position and rotation
   * @param {string} id - Player ID
   * @param {Object} position - Position coordinates
   * @param {Object} rotation - Rotation coordinates
   */
  updateRemotePlayer(id, position, rotation) {
    // Get existing player or create a new one
    let player = this.remotePlayers.get(id);
    
    if (!player) {
      // Create a new player mesh if this is the first update
      player = this.createRemotePlayerMesh();
      this.remotePlayers.set(id, player);
      this.scene.add(player);
      console.log(`Created new remote player: ${id}`);
    }
    
    // Update player position and rotation
    if (position) {
      player.position.set(position.x, position.y, position.z);
    }
    
    if (rotation) {
      player.rotation.set(rotation.x, rotation.y, rotation.z);
    }
  }
  
  /**
   * Create a mesh for a remote player
   * @returns {THREE.Object3D} Player mesh
   */
  createRemotePlayerMesh() {
    // For simplicity, we'll use a simple colored box for remote players
    const geometry = new THREE.BoxGeometry(1, 1, 2);
    const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red for other players
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'player-label';
    nameLabel.textContent = 'Player';
    
    const playerLabel = new CSS2DObject(nameLabel);
    playerLabel.position.set(0, 1.5, 0);
    mesh.add(playerLabel);
    
    return mesh;
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize game
  const game = new SimpleGame();
  
  // Add start button event listener
  document.getElementById('start-button').addEventListener('click', () => {
    // Get the player name from the input field
    const playerNameInput = document.getElementById('player-name');
    if (playerNameInput && playerNameInput.value.trim() !== '') {
      // Store the player name
      game.playerName = playerNameInput.value.trim();
      console.log(`Player name set to: ${game.playerName}`);
    } else {
      console.log('Using default player name: ' + game.playerName);
    }
    
    // Start the game
    game.startGame();
  });
}); 
### ./index.js END ###


### ./codebase.md END ###

### ./ui/ShipSelectionUI.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import { ShipSelector, SHIP_TYPES, SHIP_STATUS } from '../config/ShipConfig';
import { TEAM_COLORS } from '../core/TeamManager';
import AssetLoader from '../assets/AssetLoader';

export class ShipSelectionUI {
    constructor(container, options = {}) {
        this.container = container;
        if (!this.container) {
            console.error('Game container not found');
            return;
        }
        
        this.options = {
            onShipSelect: null,
            isPremium: false,
            ...options
        };

        this.selectedShip = 'scout';
        this.selectedColor = '#00ff00';
        this.previewScene = null;
        this.previewCamera = null;
        this.previewRenderer = null;
        this.currentModel = null;
        
        // Initialize the asset loader
        this.assetLoader = new AssetLoader().setCallbacks(
            (message) => console.log(`Ship Selection: ${message}`),
            (type, error) => console.error(`Ship Selection Error: ${type} - ${error}`)
        );
        
        this.createUI();
        // Add a small delay to ensure DOM is fully ready
        setTimeout(() => {
            this.setupPreview();
            this.loadShipModels();
        }, 100);
    }

    createUI() {
        // Create main container
        this.element = document.createElement('div');
        this.element.className = 'ship-selection';
        this.element.innerHTML = `
            <div class="ship-selection-header">
                <h2>Choose Your Quantum Ship</h2>
                <div class="color-picker">
                    <label>Ship Color:</label>
                    <input type="color" value="${this.selectedColor}">
                </div>
            </div>
            <div class="ships-container">
                <div class="ship-option selected" data-ship="scout">
                    <h3>Scout</h3>
                    <p>Fast and agile, but lightly armored</p>
                    <div class="stats">
                        <div class="stat">
                            <label>Health</label>
                            <div class="stat-bar"><div style="width: 53%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Speed</label>
                            <div class="stat-bar"><div style="width: 100%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Size</label>
                            <div class="stat-bar"><div style="width: 67%"></div></div>
                        </div>
                    </div>
                </div>
                <div class="ship-option" data-ship="interceptor">
                    <h3>Interceptor</h3>
                    <p>Balanced combat vessel</p>
                    <div class="stats">
                        <div class="stat">
                            <label>Health</label>
                            <div class="stat-bar"><div style="width: 80%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Speed</label>
                            <div class="stat-bar"><div style="width: 85%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Size</label>
                            <div class="stat-bar"><div style="width: 75%"></div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="preview-section">
                <h3>Ship Preview</h3>
                <div id="ship-preview"></div>
            </div>
            <div class="ship-details">
                <div class="ship-name">Scout</div>
                <p class="ship-description">Fast and agile, but lightly armored</p>
                
                <div class="ship-details-left">
                    <div class="stat">
                        <label>Health</label>
                        <div class="stat-bar"><div style="width: 53%"></div></div>
                        <span class="stat-value">53%</span>
                    </div>
                    <div class="stat">
                        <label>Speed</label>
                        <div class="stat-bar"><div style="width: 100%"></div></div>
                        <span class="stat-value">100%</span>
                    </div>
                    <div class="stat">
                        <label>Size</label>
                        <div class="stat-bar"><div style="width: 67%"></div></div>
                        <span class="stat-value">67%</span>
                    </div>
                </div>
                
                <div class="ship-details-right">
                    <div class="special-abilities">
                        <h4>Special Abilities</h4>
                        <div class="ability">Quick Boost</div>
                        <div class="ability">Stealth Mode</div>
                    </div>
                </div>
            </div>
            <button class="launch-button">Launch</button>
        `;

        // Add to container
        this.container.appendChild(this.element);

        // Add class to properly show the UI
        this.element.classList.add('visible');

        // Setup event listeners
        this.setupEventListeners();
    }

    setupPreview() {
        // Get preview container
        this.previewContainer = this.element.querySelector('#ship-preview');
        if (!this.previewContainer) {
            console.error('Preview container not found');
            return;
        }

        // Set initial dimensions
        this.previewContainer.style.width = '100%';
        this.previewContainer.style.height = '150px';

        // Create scene
        this.previewScene = new THREE.Scene();
        this.previewScene.background = new THREE.Color(0x000011);

        // Create camera
        this.previewCamera = new THREE.PerspectiveCamera(
            65,
            this.previewContainer.clientWidth / this.previewContainer.clientHeight,
            0.1,
            1000
        );
        this.previewCamera.position.set(0, 0.3, 2.5);
        this.previewCamera.lookAt(0, 0, 0);

        // Create renderer
        this.previewRenderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        this.previewRenderer.setSize(this.previewContainer.clientWidth, this.previewContainer.clientHeight);
        this.previewRenderer.setClearColor(0x000011);
        this.previewContainer.appendChild(this.previewRenderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        this.previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1, 1, 1).normalize();
        this.previewScene.add(directionalLight);

        // Add a grid to help with orientation
        const gridHelper = new THREE.GridHelper(8, 8, 0x333333, 0x222222);
        gridHelper.position.y = -0.5;
        this.previewScene.add(gridHelper);

        // Handle window resize
        window.addEventListener('resize', () => {
            if (this.previewContainer && this.previewCamera && this.previewRenderer) {
                this.previewCamera.aspect = this.previewContainer.clientWidth / this.previewContainer.clientHeight;
                this.previewCamera.updateProjectionMatrix();
                this.previewRenderer.setSize(this.previewContainer.clientWidth, this.previewContainer.clientHeight);
            }
        });

        // Start animation
        this.animate();
    }

    setupEventListeners() {
        // Store bound handlers for cleanup
        this.boundHandleShipSelection = this.handleShipSelection.bind(this);
        this.boundHandleLaunch = this.handleLaunch.bind(this);
        this.boundHandleColorChange = this.handleColorChange.bind(this);
        this.boundHandleResize = this.handleResize.bind(this);
        
        // Ship selection - make sure to use the right selector
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(option => {
            option.addEventListener('click', this.boundHandleShipSelection);
        });
        
        // Launch button
        const launchButton = this.element.querySelector('.launch-button');
        launchButton.addEventListener('click', this.boundHandleLaunch);
        
        // Color picker
        const colorPicker = this.element.querySelector('input[type="color"]');
        colorPicker.addEventListener('change', this.boundHandleColorChange);
        
        // Handle window resize for the preview
        window.addEventListener('resize', this.boundHandleResize);
    }

    selectShip(shipType) {
        this.selectedShip = shipType;
        
        // Update details section
        const details = this.element.querySelector('.ship-details');
        const shipName = details.querySelector('.ship-name');
        const shipDesc = details.querySelector('.ship-description');
        
        const config = this.getShipConfig();
        shipName.textContent = config.name;
        shipDesc.textContent = config.description;
        
        // Update the stats
        const leftSection = details.querySelector('.ship-details-left');
        leftSection.innerHTML = '';
        
        Object.entries(config.stats).forEach(([key, value]) => {
            const percentage = Math.round(value * 100);
            const statElement = document.createElement('div');
            statElement.className = 'stat';
            statElement.innerHTML = `
                <label>${key.charAt(0).toUpperCase() + key.slice(1)}</label>
                <div class="stat-bar"><div style="width: ${percentage}%"></div></div>
                <span class="stat-value">${percentage}%</span>
            `;
            leftSection.appendChild(statElement);
        });
        
        // Update abilities
        const abilitiesContainer = details.querySelector('.special-abilities');
        abilitiesContainer.innerHTML = '<h4>Special Abilities</h4>';
        config.abilities.forEach(ability => {
            const abilityEl = document.createElement('div');
            abilityEl.className = 'ability';
            abilityEl.textContent = ability;
            abilitiesContainer.appendChild(abilityEl);
        });
        
        // Update preview
        this.updatePreview();
    }

    async loadShipModels() {
        try {
            // Load ships using the central AssetLoader
            await this.assetLoader.loadModels();
            console.log('Ship models loaded successfully via AssetLoader');
            
            // Set initial preview
            this.updatePreview();
        } catch (error) {
            console.error('Error loading ship models:', error);
        }
    }

    updatePreview() {
        // Remove current model if it exists
        if (this.currentModel) {
            this.previewScene.remove(this.currentModel);
            this.currentModel = null;
        }

        // Convert selectedShip to the format expected by AssetLoader
        const modelKey = this.selectedShip.toUpperCase();
        
        // Get the model from AssetLoader and clone it
        const model = this.assetLoader.getShipModel(modelKey);
        
        if (model) {
            this.currentModel = model;
            
            // Update material color
            this.currentModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    try {
                        // Clone material to avoid affecting other instances
                        child.material = child.material.clone();
                        
                        // Apply color with safety checks
                        if (child.material.color) {
                            child.material.color = new THREE.Color(this.selectedColor);
                        }
                        
                        if (child.material.emissive) {
                            child.material.emissive = new THREE.Color(this.selectedColor).multiplyScalar(0.3);
                        }
                        
                        child.material.needsUpdate = true;
                    } catch (error) {
                        console.warn('Error setting preview material properties:', error);
                    }
                }
            });

            // Set preview-specific scale
            this.currentModel.scale.set(0.25, 0.25, 0.25);
            this.currentModel.position.set(0, 0, 0);
            this.currentModel.rotation.set(0, 0, 0);

            // Add to scene
            this.previewScene.add(this.currentModel);
        } else {
            console.log('Model not available for preview');
        }
    }

    animate = () => {
        if (!this.previewRenderer || !this.previewScene || !this.previewCamera) {
            return;
        }
        
        requestAnimationFrame(this.animate);

        // Rotate the model if it exists
        if (this.currentModel) {
            this.currentModel.rotation.y += 0.01;
        }

        this.previewRenderer.render(this.previewScene, this.previewCamera);
    }

    getShipConfig() {
        if (this.selectedShip === 'scout') {
            return {
                type: 'fighter',
                name: 'Scout',
                description: 'Fast and agile, but lightly armored',
                stats: {
                    health: 0.53,
                    speed: 1.0,
                    size: 0.67,
                    turnSpeed: 1.0,
                    acceleration: 1.0
                },
                abilities: ['Quick Boost', 'Stealth Mode']
            };
        } else {
            return {
                type: 'experimental',
                name: 'Interceptor',
                description: 'Balanced combat vessel',
                stats: {
                    health: 0.8,
                    speed: 0.85,
                    size: 0.75,
                    turnSpeed: 0.7,
                    acceleration: 0.9
                },
                abilities: ['Shield Generator', 'EMP Burst']
            };
        }
    }

    show() {
        this.element.classList.add('visible');
    }

    hide() {
        this.element.classList.add('hidden');
    }

    updateOptions(newOptions) {
        this.options = {
            ...this.options,
            ...newOptions
        };
    }

    cleanup() {
        // Stop animation loop
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        
        // Clean up event listeners using the stored bound handlers
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(option => {
            option.removeEventListener('click', this.boundHandleShipSelection);
        });
        
        const launchButton = this.element.querySelector('.launch-button');
        if (launchButton) {
            launchButton.removeEventListener('click', this.boundHandleLaunch);
        }
        
        const colorPicker = this.element.querySelector('input[type="color"]');
        if (colorPicker) {
            colorPicker.removeEventListener('change', this.boundHandleColorChange);
        }
        
        window.removeEventListener('resize', this.boundHandleResize);
        
        // Clean up THREE.js resources
        if (this.previewRenderer) {
            this.previewRenderer.dispose();
        }
        
        if (this.previewScene) {
            // Let Three.js handle most of the cleanup, but we should clear the scene
            this.previewScene = null;
        }
        
        // No need to explicitly dispose of models as they're managed by AssetLoader
        this.previewRenderer = null;
        this.previewCamera = null;
        this.currentModel = null;
    }

    handleShipSelection = (event) => {
        const option = event.currentTarget;
        const shipType = option.dataset.ship;
        console.log(`Selecting ship: ${shipType}`);
        this.selectShip(shipType);
        
        // Update UI to show selected
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(opt => {
            opt.classList.remove('selected');
        });
        option.classList.add('selected');
    }
    
    handleLaunch = () => {
        if (this.selectedShip && this.options.onShipSelect) {
            console.log(`Launching with ship: ${this.selectedShip}`);
            
            // Create selection data in the format the game expects
            const selectionData = {
                type: this.selectedShip.toUpperCase(),
                color: this.selectedColor,
                config: this.getShipConfig()
            };
            
            // Hide UI before calling the callback
            this.hide();
            
            // Clean up resources
            this.cleanup();
            
            // First remove the element from the DOM to prevent any interference
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            
            // Then call the callback with ship selection data
            this.options.onShipSelect(selectionData);
        }
    }
    
    handleColorChange = (event) => {
        this.selectedColor = event.target.value;
        this.updatePreview();
    }
    
    handleResize = () => {
        if (this.previewRenderer && this.previewCamera) {
            const container = this.previewContainer;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            this.previewCamera.aspect = width / height;
            this.previewCamera.updateProjectionMatrix();
            
            this.previewRenderer.setSize(width, height);
        }
    }
} 
### ./ui/ShipSelectionUI.js END ###

### ./ui/GameRoom.js BEGIN ###
import * as THREE from 'three';

export class GameRoom {
  constructor(scene, size = { width: 60, height: 60 }, theme = 'space-station') {
    this.scene = scene;
    this.size = size;
    this.theme = theme;
    
    // Room properties
    this.roomObjects = [];
    this.obstacles = [];
    this.spawnPoints = [];
    this.coverPoints = [];
    this.roomCenter = new THREE.Vector3(0, 0, 0);
    
    // Generate room
    this.generateRoom();
  }
  
  generateRoom() {
    // Create room floor
    this.createFloor();
    
    // Create room walls
    this.createWalls();
    
    // Add obstacles and cover points
    this.addObstacles();
    
    // Add spawn points
    this.addSpawnPoints();
    
    // Add decorative elements
    this.addDecorations();
  }
  
  createFloor() {
    // Create floor with grid texture
    const floorGeometry = new THREE.PlaneGeometry(this.size.width, this.size.height);
    
    // Create custom shader material for grid effect
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: this.getThemeColors().floor,
      roughness: 0.8,
      metalness: 0.2,
      emissive: this.getThemeColors().floorEmissive,
      emissiveIntensity: 0.1
    });
    
    // Create floor mesh
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(0, 0, 0);
    this.scene.add(floor);
    this.roomObjects.push(floor);
    
    // Add grid lines
    this.addGridLines();
  }
  
  addGridLines() {
    // Create grid material
    const gridMaterial = new THREE.LineBasicMaterial({ 
      color: this.getThemeColors().grid,
      transparent: true,
      opacity: 0.3
    });
    
    // Create horizontal grid lines
    const gridStep = 5;
    const halfWidth = this.size.width / 2;
    const halfHeight = this.size.height / 2;
    
    const gridHelper = new THREE.GridHelper(
      Math.max(this.size.width, this.size.height), 
      Math.max(this.size.width, this.size.height) / gridStep
    );
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    gridHelper.position.y = 0.02; // Slightly above floor to prevent z-fighting
    this.scene.add(gridHelper);
    this.roomObjects.push(gridHelper);
  }
  
  createWalls() {
    // Create walls around the room
    const wallHeight = 3;
    const wallThickness = 1;
    
    // Calculate positions
    const halfWidth = this.size.width / 2;
    const halfHeight = this.size.height / 2;
    
    // Get theme wall material
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: this.getThemeColors().wall,
      emissive: this.getThemeColors().wallEmissive,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.7
    });
    
    // North Wall
    const northWall = new THREE.Mesh(
      new THREE.BoxGeometry(this.size.width + wallThickness * 2, wallHeight, wallThickness),
      wallMaterial
    );
    northWall.position.set(0, wallHeight / 2, -halfHeight - wallThickness/2);
    this.scene.add(northWall);
    this.roomObjects.push(northWall);
    this.obstacles.push({
      type: 'wall',
      position: northWall.position.clone(),
      size: new THREE.Vector3(this.size.width + wallThickness*2, wallHeight, wallThickness)
    });
    
    // South Wall
    const southWall = new THREE.Mesh(
      new THREE.BoxGeometry(this.size.width + wallThickness * 2, wallHeight, wallThickness),
      wallMaterial
    );
    southWall.position.set(0, wallHeight / 2, halfHeight + wallThickness/2);
    this.scene.add(southWall);
    this.roomObjects.push(southWall);
    this.obstacles.push({
      type: 'wall',
      position: southWall.position.clone(),
      size: new THREE.Vector3(this.size.width + wallThickness*2, wallHeight, wallThickness)
    });
    
    // East Wall
    const eastWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, this.size.height + wallThickness * 2),
      wallMaterial
    );
    eastWall.position.set(halfWidth + wallThickness/2, wallHeight / 2, 0);
    this.scene.add(eastWall);
    this.roomObjects.push(eastWall);
    this.obstacles.push({
      type: 'wall',
      position: eastWall.position.clone(),
      size: new THREE.Vector3(wallThickness, wallHeight, this.size.height + wallThickness*2)
    });
    
    // West Wall
    const westWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, this.size.height + wallThickness * 2),
      wallMaterial
    );
    westWall.position.set(-halfWidth - wallThickness/2, wallHeight / 2, 0);
    this.scene.add(westWall);
    this.roomObjects.push(westWall);
    this.obstacles.push({
      type: 'wall',
      position: westWall.position.clone(),
      size: new THREE.Vector3(wallThickness, wallHeight, this.size.height + wallThickness*2)
    });
  }
  
  addObstacles() {
    // Add between 5-10 random obstacles in the room
    const obstacleCount = 5 + Math.floor(Math.random() * 6);
    
    for (let i = 0; i < obstacleCount; i++) {
      this.addRandomObstacle();
    }
  }
  
  addRandomObstacle() {
    // Types of obstacles: block, cylinder, barrier
    const types = ['block', 'cylinder', 'barrier'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random position in the room
    const halfWidth = this.size.width / 2 - 5; // Stay away from walls
    const halfHeight = this.size.height / 2 - 5;
    
    const x = (Math.random() * 2 - 1) * halfWidth;
    const z = (Math.random() * 2 - 1) * halfHeight;
    
    // Random size
    const width = 2 + Math.random() * 5;
    const height = 1 + Math.random() * 2;
    const depth = 2 + Math.random() * 5;
    
    // Create obstacle based on type
    let mesh;
    let obstacleData = {
      type: 'obstacle',
      position: new THREE.Vector3(x, height/2, z)
    };
    
    switch (type) {
      case 'block':
        const blockGeometry = new THREE.BoxGeometry(width, height, depth);
        const blockMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.5,
          metalness: 0.5
        });
        mesh = new THREE.Mesh(blockGeometry, blockMaterial);
        mesh.position.set(x, height/2, z);
        obstacleData.size = new THREE.Vector3(width, height, depth);
        break;
        
      case 'cylinder':
        const radius = width / 2;
        const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 16);
        const cylinderMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.5,
          metalness: 0.5
        });
        mesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        mesh.position.set(x, height/2, z);
        obstacleData.radius = radius;
        obstacleData.height = height;
        break;
        
      case 'barrier':
        const barrierGeometry = new THREE.BoxGeometry(width, height, 0.5);
        const barrierMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.4,
          roughness: 0.3,
          metalness: 0.7,
          transparent: true,
          opacity: 0.8
        });
        mesh = new THREE.Mesh(barrierGeometry, barrierMaterial);
        mesh.position.set(x, height/2, z);
        
        // Random rotation
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        obstacleData.size = new THREE.Vector3(width, height, 0.5);
        obstacleData.rotation = mesh.rotation.clone();
        break;
    }
    
    this.scene.add(mesh);
    this.roomObjects.push(mesh);
    this.obstacles.push(obstacleData);
    
    // Add a cover point near this obstacle
    this.coverPoints.push(new THREE.Vector3(
      x + (Math.random() - 0.5) * 3,
      0,
      z + (Math.random() - 0.5) * 3
    ));
  }
  
  addSpawnPoints() {
    // Add spawn points in the corners
    const halfWidth = this.size.width / 2 - 8;
    const halfHeight = this.size.height / 2 - 8;
    
    // Four corners
    this.spawnPoints.push(
      new THREE.Vector3(-halfWidth, 0, -halfHeight),
      new THREE.Vector3(halfWidth, 0, -halfHeight),
      new THREE.Vector3(-halfWidth, 0, halfHeight),
      new THREE.Vector3(halfWidth, 0, halfHeight)
    );
    
    // Add a few more random spawn points
    for (let i = 0; i < 4; i++) {
      const x = (Math.random() * 2 - 1) * halfWidth;
      const z = (Math.random() * 2 - 1) * halfHeight;
      this.spawnPoints.push(new THREE.Vector3(x, 0, z));
    }
  }
  
  addDecorations() {
    // Add decorative elements based on theme
    const decorationCount = 10 + Math.floor(Math.random() * 10);
    
    // Add lights around the room
    for (let i = 0; i < decorationCount; i++) {
      this.addRandomDecoration();
    }
    
    // Add room lights
    this.addRoomLights();
  }
  
  addRandomDecoration() {
    // Types of decorations: console, crate, panel
    const types = ['console', 'crate', 'panel'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random position near walls
    const halfWidth = this.size.width / 2 - 2;
    const halfHeight = this.size.height / 2 - 2;
    
    let x, z;
    const nearWall = Math.random() > 0.5;
    
    if (nearWall) {
      // Position near a wall
      if (Math.random() > 0.5) {
        // Near east/west wall
        x = (Math.random() > 0.5 ? 1 : -1) * halfWidth;
        z = (Math.random() * 2 - 1) * halfHeight;
      } else {
        // Near north/south wall
        x = (Math.random() * 2 - 1) * halfWidth;
        z = (Math.random() > 0.5 ? 1 : -1) * halfHeight;
      }
    } else {
      // Random position
      x = (Math.random() * 2 - 1) * halfWidth;
      z = (Math.random() * 2 - 1) * halfHeight;
    }
    
    // Create decoration based on type
    let mesh;
    
    switch (type) {
      case 'console':
        const consoleGeometry = new THREE.BoxGeometry(2, 1, 1);
        const consoleMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().console,
          emissive: this.getThemeColors().consoleEmissive,
          emissiveIntensity: 0.5,
          roughness: 0.3,
          metalness: 0.8
        });
        mesh = new THREE.Mesh(consoleGeometry, consoleMaterial);
        
        // Add a light on top
        const consoleLight = new THREE.PointLight(
          this.getThemeColors().consoleLight, 
          0.5, 
          5
        );
        consoleLight.position.set(0, 1, 0);
        mesh.add(consoleLight);
        break;
        
      case 'crate':
        const crateGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const crateMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().crate,
          roughness: 0.7,
          metalness: 0.2
        });
        mesh = new THREE.Mesh(crateGeometry, crateMaterial);
        break;
        
      case 'panel':
        const panelGeometry = new THREE.PlaneGeometry(2, 1.5);
        const panelMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().panel,
          emissive: this.getThemeColors().panelEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.4,
          metalness: 0.6,
          side: THREE.DoubleSide
        });
        mesh = new THREE.Mesh(panelGeometry, panelMaterial);
        
        // Orient towards center
        mesh.lookAt(this.roomCenter);
        // Adjust to be vertical
        mesh.rotation.x = 0;
        break;
    }
    
    mesh.position.set(x, 0.75, z);
    this.scene.add(mesh);
    this.roomObjects.push(mesh);
  }
  
  addRoomLights() {
    // Ambient light for the room
    const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
    this.scene.add(ambientLight);
    this.roomObjects.push(ambientLight);
    
    // Add main overhead light
    const mainLight = new THREE.PointLight(
      this.getThemeColors().mainLight, 
      1, 
      100
    );
    mainLight.position.set(0, 15, 0);
    this.scene.add(mainLight);
    this.roomObjects.push(mainLight);
    
    // Add accent lights in corners
    const cornerLightPositions = [
      new THREE.Vector3(-this.size.width / 3, 5, -this.size.height / 3),
      new THREE.Vector3(this.size.width / 3, 5, -this.size.height / 3),
      new THREE.Vector3(-this.size.width / 3, 5, this.size.height / 3),
      new THREE.Vector3(this.size.width / 3, 5, this.size.height / 3)
    ];
    
    for (const position of cornerLightPositions) {
      const cornerLight = new THREE.PointLight(
        this.getThemeColors().accentLight,
        0.6,
        30
      );
      cornerLight.position.copy(position);
      this.scene.add(cornerLight);
      this.roomObjects.push(cornerLight);
    }
  }
  
  getRandomSpawnPoint() {
    if (this.spawnPoints.length === 0) return new THREE.Vector3(0, 0, 0);
    return this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)].clone();
  }
  
  /**
   * Get all obstacles in the room, including walls and other objects
   * @returns {Array} Array of obstacles with position and size/radius information
   */
  getObstacles() {
    const obstacles = [];
    
    // Add walls
    if (this.walls && this.walls.length > 0) {
      obstacles.push(...this.walls.map(wall => ({
        type: 'wall',
        position: wall.position.clone(),
        size: wall.size ? { x: wall.size.x, y: wall.size.y, z: wall.size.z } : { x: 1, y: 1, z: 1 },
        rotation: wall.rotation ? wall.rotation.clone() : new THREE.Euler()
      })));
    }
    
    // Add other obstacles like pillars, etc.
    if (this.obstacles && this.obstacles.length > 0) {
      obstacles.push(...this.obstacles.map(obstacle => {
        if (obstacle.geometry && obstacle.geometry.type.includes('Cylinder')) {
          // Cylindrical obstacles
          return {
            type: 'cylinder',
            position: obstacle.position.clone(),
            radius: obstacle.geometry.parameters?.radiusTop || 1,
            height: obstacle.geometry.parameters?.height || 2
          };
        } else {
          // Box obstacles
          return {
            type: 'box',
            position: obstacle.position.clone(),
            size: {
              x: obstacle.scale.x,
              y: obstacle.scale.y,
              z: obstacle.scale.z
            },
            rotation: obstacle.rotation.clone()
          };
        }
      }));
    }
    
    // Add environmental hazards if they exist
    if (this.hazards && this.hazards.length > 0) {
      obstacles.push(...this.hazards.map(hazard => ({
        type: 'hazard',
        position: hazard.position.clone(),
        radius: hazard.radius || 1,
        damage: hazard.damage || 10
      })));
    }
    
    return obstacles;
  }
  
  cleanup() {
    // Remove all room objects from the scene
    for (const object of this.roomObjects) {
      this.scene.remove(object);
      
      // Dispose geometries and materials
      if (object.geometry) {
        object.geometry.dispose();
      }
      
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    }
    
    // Clear arrays
    this.roomObjects = [];
    this.obstacles = [];
    this.spawnPoints = [];
    this.coverPoints = [];
  }
  
  getThemeColors() {
    // Return colors based on room theme
    switch(this.theme) {
      case 'alien-hive':
        return {
          floor: 0x112211,
          floorEmissive: 0x224422,
          wall: 0x336633,
          wallEmissive: 0x44ff44,
          grid: 0x33ff33,
          obstacle: 0x225522,
          obstacleEmissive: 0x33ff33,
          console: 0x336633,
          consoleEmissive: 0x44ff66,
          consoleLight: 0x66ff66,
          crate: 0x225522,
          panel: 0x112211,
          panelEmissive: 0x33ff33,
          mainLight: 0x33ff33,
          accentLight: 0x66ff66
        };
      case 'neon-city':
        return {
          floor: 0x000011,
          floorEmissive: 0x000033,
          wall: 0x110022,
          wallEmissive: 0xff00ff,
          grid: 0x0088ff,
          obstacle: 0x220033,
          obstacleEmissive: 0xff00ff,
          console: 0x330044,
          consoleEmissive: 0xff00ff,
          consoleLight: 0xff00ff,
          crate: 0x110022,
          panel: 0x220044,
          panelEmissive: 0xff00aa,
          mainLight: 0xffffff,
          accentLight: 0xff00ff
        };
      case 'space-station':
      default:
        return {
          floor: 0x111122,
          floorEmissive: 0x0000ff,
          wall: 0x334455,
          wallEmissive: 0x0088ff,
          grid: 0x0088ff,
          obstacle: 0x334455,
          obstacleEmissive: 0x0088ff,
          console: 0x223344,
          consoleEmissive: 0x00ffff,
          consoleLight: 0x00ffff,
          crate: 0x445566,
          panel: 0x223344,
          panelEmissive: 0x0088ff,
          mainLight: 0xaaccff,
          accentLight: 0x0088ff
        };
    }
  }
} 
### ./ui/GameRoom.js END ###

### ./ui/GameUI.js BEGIN ###
/**
 * GameUI class for handling all game UI elements
 */
export class GameUI {
  constructor() {
    this.uiContainer = null;
    this.controlsInfo = null;
    this.healthBar = null;
    this.energyBar = null;
    this.weaponIndicator = null;

    this.createUI();
  }

  /**
   * Create all UI elements
   */
  createUI() {
    // Remove existing controls-info if it exists
    const oldControls = document.querySelector('.controls-info');
    if (oldControls) {
      oldControls.remove();
    }

    // Create main UI container
    this.uiContainer = document.createElement('div');
    this.uiContainer.className = 'game-ui';
    this.uiContainer.id = 'game-ui';
    document.body.appendChild(this.uiContainer);

    // Create status bars container
    const statusBars = document.createElement('div');
    statusBars.className = 'status-bars';
    this.uiContainer.appendChild(statusBars);

    // Create health bar
    const healthBarContainer = document.createElement('div');
    healthBarContainer.className = 'bar-container health-bar-container';
    statusBars.appendChild(healthBarContainer);

    const healthLabel = document.createElement('div');
    healthLabel.className = 'bar-label';
    healthLabel.innerHTML = '❤️'; // Heart emoji for health
    healthBarContainer.appendChild(healthLabel);

    const healthBarOuter = document.createElement('div');
    healthBarOuter.className = 'bar-outer';
    healthBarContainer.appendChild(healthBarOuter);

    this.healthBar = document.createElement('div');
    this.healthBar.className = 'bar-inner health-bar';
    healthBarOuter.appendChild(this.healthBar);

    // Create health percentage display
    this.healthPercentage = document.createElement('div');
    this.healthPercentage.className = 'bar-percentage';
    this.healthPercentage.textContent = '100%';
    healthBarContainer.appendChild(this.healthPercentage);

    // Create energy bar
    const energyBarContainer = document.createElement('div');
    energyBarContainer.className = 'bar-container energy-bar-container';
    statusBars.appendChild(energyBarContainer);

    const energyLabel = document.createElement('div');
    energyLabel.className = 'bar-label';
    energyLabel.innerHTML = '⚡'; // Lightning emoji for energy
    energyBarContainer.appendChild(energyLabel);

    const energyBarOuter = document.createElement('div');
    energyBarOuter.className = 'bar-outer';
    energyBarContainer.appendChild(energyBarOuter);

    this.energyBar = document.createElement('div');
    this.energyBar.className = 'bar-inner energy-bar';
    energyBarOuter.appendChild(this.energyBar);

    // Create energy percentage display
    this.energyPercentage = document.createElement('div');
    this.energyPercentage.className = 'bar-percentage';
    this.energyPercentage.textContent = '100%';
    energyBarContainer.appendChild(this.energyPercentage);

    // Create weapon indicator
    this.weaponIndicator = document.createElement('div');
    this.weaponIndicator.className = 'weapon-indicator';
    this.uiContainer.appendChild(this.weaponIndicator);

    const weaponLabel = document.createElement('div');
    weaponLabel.className = 'weapon-label';
    weaponLabel.textContent = '🔫';  // Weapon emoji
    this.weaponIndicator.appendChild(weaponLabel);

    this.weaponName = document.createElement('div');
    this.weaponName.className = 'weapon-name laser';
    this.weaponName.textContent = 'LASER';
    this.weaponIndicator.appendChild(this.weaponName);

    // Initially hide the UI
    this.uiContainer.classList.add('hidden');
  }

  /**
   * Show the UI
   */
  show() {
    if (this.uiContainer) {
      this.uiContainer.classList.remove('hidden');
      this.uiContainer.style.display = 'flex';
      this.uiContainer.style.opacity = '1';
    }
  }

  /**
   * Hide the UI
   */
  hide() {
    if (this.uiContainer) {
      this.uiContainer.classList.add('hidden');
      this.uiContainer.style.display = 'none';
      this.uiContainer.style.opacity = '0';
    }
  }

  /**
   * Update health bar
   * @param {number} health - Current health value
   * @param {number} maxHealth - Maximum health value
   */
  updateHealth(health, maxHealth) {
    const percentage = (health / maxHealth) * 100;
    this.healthBar.style.width = `${percentage}%`;

    // Change color based on health level
    if (percentage < 30) {
      this.healthBar.classList.add('critical');
    } else if (percentage < 60) {
      this.healthBar.classList.remove('critical');
      this.healthBar.classList.add('warning');
    } else {
      this.healthBar.classList.remove('critical', 'warning');
    }

    this.healthPercentage.textContent = `${percentage.toFixed(0)}%`;
  }

  /**
   * Update energy bar
   * @param {number} energy - Current energy value
   * @param {number} maxEnergy - Maximum energy value
   */
  updateEnergy(energy, maxEnergy) {
    const percentage = (energy / maxEnergy) * 100;
    this.energyBar.style.width = `${percentage}%`;

    // Change color based on energy level
    if (percentage < 30) {
      this.energyBar.classList.add('critical');
    } else if (percentage < 60) {
      this.energyBar.classList.remove('critical');
      this.energyBar.classList.add('warning');
    } else {
      this.energyBar.classList.remove('critical', 'warning');
    }

    this.energyPercentage.textContent = `${percentage.toFixed(0)}%`;
  }

  /**
   * Update weapon indicator
   * @param {string} weaponName - Name of the current weapon
   */
  updateWeapon(weaponName) {
    this.weaponName.textContent = weaponName;

    // Remove all weapon classes
    this.weaponName.classList.remove('laser', 'grenade', 'bounce');

    // Add the appropriate class for styling
    switch(weaponName.toLowerCase()) {
      case 'laser':
        this.weaponName.classList.add('laser');
        break;
      case 'grenade':
        this.weaponName.classList.add('grenade');
        break;
      case 'bounce':
        this.weaponName.classList.add('bounce');
        break;
    }
  }
} 
### ./ui/GameUI.js END ###

### ./ui/MiniMap.js BEGIN ###
/**
 * MiniMap class for displaying a top-down radar view of the game
 */
export class MiniMap {
  constructor(game) {
    this.game = game;
    this.visible = true;
    this.container = null;
    this.canvas = null;
    this.ctx = null;
    this.mapScale = 15; // Scale factor for map (pixels per world unit)
    
    // Scale factor for converting world coordinates to mini-map coordinates
    this.scale = 0.08;
    
    // Mini-map center offset in pixels
    this.offsetX = 0;
    this.offsetY = 0;
    
    this.createMiniMap();
  }
  
  /**
   * Create the mini-map UI
   */
  createMiniMap() {
    this.container = document.createElement('div');
    this.container.className = 'mini-map-container';
    document.body.appendChild(this.container);
    
    // Create mini-map area
    const miniMap = document.createElement('div');
    miniMap.className = 'mini-map';
    this.container.appendChild(miniMap);
    
    // Add subtle M key hint
    const hint = document.createElement('div');
    hint.className = 'mini-map-hint';
    hint.textContent = 'M';
    this.container.appendChild(hint);
    
    // Create canvas for drawing
    this.canvas = document.createElement('canvas');
    this.canvas.width = 300;
    this.canvas.height = 300;
    miniMap.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    
    // Calculate center offset
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
  }
  
  /**
   * Update the mini-map with current game state
   */
  update() {
    if (!this.visible || !this.ctx || !this.game.playerShip) return;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw background
    this.ctx.fillStyle = 'rgba(0, 20, 40, 0.2)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw grid lines
    this.drawGridLines();
    
    // Draw objects from infinite map
    this.drawObjects();
    
    // Draw player
    this.drawPlayer();
    
    // Draw enemies (if any exist)
    if (this.game.enemies) {
      this.drawEnemies();
    }
  }
  
  /**
   * Draw grid lines on mini-map
   */
  drawGridLines() {
    const gridSize = 10; // World units
    const gridLines = 20; // Number of grid lines in each direction
    
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
    this.ctx.lineWidth = 0.5;
    
    // Get player position
    const playerX = this.game.playerShip.position.x;
    const playerZ = this.game.playerShip.position.z;
    
    const startX = Math.floor(playerX / gridSize) * gridSize - (gridLines * gridSize / 2);
    const startZ = Math.floor(playerZ / gridSize) * gridSize - (gridLines * gridSize / 2);
    
    // Draw vertical lines
    for (let i = 0; i <= gridLines; i++) {
      const worldX = startX + i * gridSize;
      const mapX = this.worldToMapX(worldX);
      
      this.ctx.beginPath();
      this.ctx.moveTo(mapX, 0);
      this.ctx.lineTo(mapX, this.canvas.height);
      this.ctx.stroke();
    }
    
    // Draw horizontal lines
    for (let i = 0; i <= gridLines; i++) {
      const worldZ = startZ + i * gridSize;
      const mapY = this.worldToMapY(worldZ);
      
      this.ctx.beginPath();
      this.ctx.moveTo(0, mapY);
      this.ctx.lineTo(this.canvas.width, mapY);
      this.ctx.stroke();
    }
  }
  
  /**
   * Draw objects from infinite map chunks
   */
  drawObjects() {
    if (!this.game.infiniteMap) return;
    
    // Get nearby chunks
    const playerPos = this.game.playerShip.position;
    const currentKey = this.game.infiniteMap.getChunkKey(playerPos.x, playerPos.z);
    const nearbyChunks = this.game.infiniteMap.getNearbyChunks(currentKey);
    
    // Draw objects from each chunk
    for (const chunk of nearbyChunks) {
      for (const object of chunk.objects) {
        // Get object position
        const x = object.position.x;
        const z = object.position.z;
        
        // Convert to mini-map coordinates
        const mapX = this.worldToMapX(x);
        const mapY = this.worldToMapY(z);
        
        // Set color based on object type
        switch (object.type) {
          case 'flora':
            this.ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            break;
          case 'rocks':
            this.ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            break;
          case 'objects':
            this.ctx.fillStyle = 'rgba(255, 69, 0, 0.7)';
            break;
          default:
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        }
        
        // Draw object dot
        this.ctx.beginPath();
        this.ctx.arc(mapX, mapY, object.radius * this.scale, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
  
  /**
   * Draw player on mini-map
   */
  drawPlayer() {
    // Get player position
    const x = this.game.playerShip.position.x;
    const z = this.game.playerShip.position.z;
    
    // Convert to mini-map coordinates
    const mapX = this.worldToMapX(x);
    const mapY = this.worldToMapY(z);
    
    // Draw player direction cone
    this.drawPlayerDirection(mapX, mapY);
    
    // Draw player dot
    this.ctx.fillStyle = '#00ffff';
    this.ctx.beginPath();
    this.ctx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw player glow
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(mapX, mapY, 5, 0, Math.PI * 2);
    this.ctx.stroke();
  }
  
  /**
   * Draw player direction indicator
   */
  drawPlayerDirection(mapX, mapY) {
    // Get player rotation
    const angle = this.game.playerShip.rotation.y;
    
    // Draw direction indicator
    this.ctx.save();
    this.ctx.translate(mapX, mapY);
    this.ctx.rotate(-angle); // Negative because z-axis is inverted
    
    // Draw triangular direction indicator
    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
    this.ctx.beginPath();
    this.ctx.moveTo(0, -10); // Pointing up
    this.ctx.lineTo(-5, 0);
    this.ctx.lineTo(5, 0);
    this.ctx.closePath();
    this.ctx.fill();
    
    this.ctx.restore();
  }
  
  /**
   * Draw enemies on mini-map
   */
  drawEnemies() {
    this.ctx.fillStyle = '#ff3333';
    
    for (const enemy of this.game.enemies) {
      // Get position
      const x = enemy.position.x;
      const z = enemy.position.z;
      
      // Convert to mini-map coordinates
      const mapX = this.worldToMapX(x);
      const mapY = this.worldToMapY(z);
      
      // Draw enemy dot
      this.ctx.beginPath();
      this.ctx.arc(mapX, mapY, 2, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  /**
   * Convert world X coordinate to mini-map X coordinate
   */
  worldToMapX(x) {
    // Get player position
    const playerX = this.game.playerShip.position.x;
    
    // Apply scale and center on player
    return this.offsetX + (x - playerX) * this.scale;
  }
  
  /**
   * Convert world Z coordinate to mini-map Y coordinate
   */
  worldToMapY(z) {
    // Get player position
    const playerZ = this.game.playerShip.position.z;
    
    // Apply scale and center on player (note the negation since Z goes forward)
    return this.offsetY + (z - playerZ) * this.scale;
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggle() {
    this.visible = !this.visible;
    
    if (this.visible) {
      this.show();
    } else {
      this.hide();
    }
  }
  
  /**
   * Show mini-map
   */
  show() {
    this.container.classList.remove('hidden');
    this.visible = true;
  }
  
  /**
   * Hide mini-map
   */
  hide() {
    this.container.classList.add('hidden');
    this.visible = false;
  }
} 
### ./ui/MiniMap.js END ###

### ./scenes/TeamDemo.js BEGIN ###
import * as THREE from 'three';
import { TeamManager, GAME_MODES } from '../core/TeamManager';
import { Enemy } from '../entities/enemies/Enemy';
import { Player } from '../entities/player/Player';

export class TeamDemo {
    constructor(scene, options = {}) {
        this.scene = scene;
        this.options = {
            gameMode: GAME_MODES.TEAM_VS_TEAM,
            playerCount: 2,
            enemyCount: 4,
            ...options
        };

        // Initialize team manager
        this.teamManager = new TeamManager(this.options.gameMode);
        
        // Initialize collections
        this.players = new Map();
        this.enemies = new Map();
        
        // Setup demo
        this.setupDemo();
    }

    setupDemo() {
        // Create players
        for (let i = 0; i < this.options.playerCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                1,
                (Math.random() - 0.5) * 20
            );
            
            const player = new Player(this.scene, position);
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`player${i}`);
            
            player.setTeam(teamId, color);
            this.players.set(`player${i}`, player);
            
            // Log player creation
            console.log(`Created player ${i} on team ${teamId} with color ${color.toString(16)}`);
        }

        // Create enemies
        for (let i = 0; i < this.options.enemyCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                1,
                (Math.random() - 0.5) * 20
            );
            
            const enemyType = ['BASIC', 'HUNTER', 'PATROLLER'][Math.floor(Math.random() * 3)];
            const enemy = new Enemy(this.scene, position, {
                type: enemyType,
                shipModel: ['STANDARD', 'INTERCEPTOR', 'HEAVY', 'SCOUT'][Math.floor(Math.random() * 4)]
            });
            
            // Assign to a random team
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`enemy${i}`);
            enemy.setTeam(teamId, color);
            
            this.enemies.set(`enemy${i}`, enemy);
            
            // Log enemy creation
            console.log(`Created ${enemyType} enemy ${i} on team ${teamId} with color ${color.toString(16)}`);
        }
    }

    update(deltaTime) {
        // Convert players to array for enemy targeting
        const playerArray = Array.from(this.players.values());
        
        // Update all entities
        this.players.forEach(player => {
            if (player.isActive) {
                player.update(deltaTime);
            }
        });

        this.enemies.forEach(enemy => {
            if (enemy.isActive) {
                enemy.update(deltaTime, playerArray, []);
            }
        });
    }

    handleCollisions() {
        // Check collisions between all active entities
        const activeEntities = [
            ...Array.from(this.players.values()).filter(p => p.isActive),
            ...Array.from(this.enemies.values()).filter(e => e.isActive)
        ];

        for (let i = 0; i < activeEntities.length; i++) {
            for (let j = i + 1; j < activeEntities.length; j++) {
                const entity1 = activeEntities[i];
                const entity2 = activeEntities[j];

                // Skip collision check if entities are on the same team
                if (this.teamManager.arePlayersOnSameTeam(entity1.teamId, entity2.teamId)) {
                    continue;
                }

                // Simple distance-based collision
                const distance = entity1.mesh.position.distanceTo(entity2.mesh.position);
                const minDistance = entity1.options.size + entity2.options.size;

                if (distance < minDistance) {
                    // Handle collision
                    entity1.takeDamage(10);
                    entity2.takeDamage(10);
                }
            }
        }
    }

    getTeamScores() {
        return this.teamManager.getTeamScores();
    }

    setGameMode(mode) {
        this.options.gameMode = mode;
        this.teamManager.setGameMode(mode);
        
        // Reassign all entities to teams
        this.players.forEach((player, id) => {
            const { teamId, color } = this.teamManager.assignPlayerToTeam(id);
            player.setTeam(teamId, color);
        });

        this.enemies.forEach((enemy, id) => {
            const { teamId, color } = this.teamManager.assignPlayerToTeam(id);
            enemy.setTeam(teamId, color);
        });
    }
} 
### ./scenes/TeamDemo.js END ###

### ./core/Game.js BEGIN ###
import { GameEngine } from './GameEngine';
import { GameUI } from '../ui/GameUI';
import { MiniMap } from '../ui/MiniMap';
import { GAME_CONFIG } from '../config/GameConfig';
import * as THREE from 'three';
import { TeamManager, GAME_MODES } from './TeamManager';
import { ShipSelectionUI } from '../ui/ShipSelectionUI';
import { Player } from '../entities/player/Player';
import { Enemy } from '../entities/enemies/Enemy';

export class Game {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            gameMode: GAME_MODES.FREE_FOR_ALL,
            isPremium: false,
            ...options
        };

        // Initialize core components
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Setup renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.container.appendChild(this.renderer.domElement);

        // Initialize managers
        this.teamManager = new TeamManager(this.options.gameMode);
        
        // Game state
        this.isRunning = false;
        this.entities = new Map();
        
        // Setup window resize handler
        window.addEventListener('resize', () => this.handleResize());
        
        // Initialize ship selection
        this.initShipSelection();
    }

    initShipSelection() {
        this.shipSelection = new ShipSelectionUI(this.container, {
            isPremium: this.options.isPremium,
            onShipSelect: (selection) => this.startGame(selection)
        });
    }

    startGame(playerSelection) {
        // Hide ship selection
        this.shipSelection.hide();
        
        // Create player
        const player = new Player(this.scene, new THREE.Vector3(0, 0, 0), {
            ...playerSelection.config.stats,
            shipModel: playerSelection.config.model
        });

        // Assign team/color in FFA mode
        const { teamId } = this.teamManager.assignPlayerToTeam('player1');
        player.setTeam(teamId, parseInt(playerSelection.color.replace(/[^\d,]/g, '').split(',').map(x => parseInt(x)).join('')));

        // Store player
        this.entities.set('player1', player);

        // Add some AI players for testing
        this.addAIPlayers(5);

        // Start game loop
        this.isRunning = true;
        this.animate();
    }

    addAIPlayers(count) {
        for (let i = 0; i < count; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 40,
                0,
                (Math.random() - 0.5) * 40
            );

            const enemy = new Enemy(this.scene, position, {
                type: Math.random() > 0.5 ? 'HUNTER' : 'PATROLLER',
                shipModel: ['SCOUT', 'INTERCEPTOR', 'STANDARD'][Math.floor(Math.random() * 3)]
            });

            // Assign team/color
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`ai${i}`);
            enemy.setTeam(teamId, color);

            // Store enemy
            this.entities.set(`ai${i}`, enemy);
        }
    }

    animate() {
        if (!this.isRunning) return;

        requestAnimationFrame(() => this.animate());

        const deltaTime = 16; // Assuming 60fps for now
        
        // Update all entities
        const playerArray = Array.from(this.entities.values());
        this.entities.forEach(entity => {
            if (entity instanceof Enemy) {
                entity.update(deltaTime, playerArray, []);
            } else {
                entity.update(deltaTime);
            }
        });

        // Handle collisions
        this.handleCollisions();

        // Render
        this.renderer.render(this.scene, this.camera);
    }

    handleCollisions() {
        const entities = Array.from(this.entities.values()).filter(e => e.isActive);

        for (let i = 0; i < entities.length; i++) {
            for (let j = i + 1; j < entities.length; j++) {
                const entity1 = entities[i];
                const entity2 = entities[j];

                // Skip collision check if entities are on the same team
                if (this.teamManager.arePlayersOnSameTeam(entity1.teamId, entity2.teamId)) {
                    continue;
                }

                // Simple distance-based collision
                const distance = entity1.mesh.position.distanceTo(entity2.mesh.position);
                const minDistance = entity1.options.size + entity2.options.size;

                if (distance < minDistance) {
                    entity1.takeDamage(10);
                    entity2.takeDamage(10);
                }
            }
        }
    }

    handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }

    destroy() {
        this.isRunning = false;
        
        // Clean up entities
        this.entities.forEach(entity => entity.destroy());
        this.entities.clear();

        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);

        // Clean up THREE.js resources
        this.scene.traverse(object => {
            if (object.geometry) object.geometry.dispose();
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });

        // Remove renderer
        this.renderer.dispose();
        this.container.removeChild(this.renderer.domElement);
    }
} 
### ./core/Game.js END ###

### ./core/TeamManager.js BEGIN ###
export const TEAM_COLORS = {
    RED: 0xff0000,
    BLUE: 0x0000ff,
    YELLOW: 0xffff00,
    GREEN: 0x00ff00,
    PURPLE: 0x800080,
    CYAN: 0x00ffff,
    ORANGE: 0xffa500,
    PINK: 0xff69b4
};

export const GAME_MODES = {
    FREE_FOR_ALL: 'FFA',
    TEAM_VS_TEAM: 'TVT',
    MULTI_TEAM: 'MT'
};

export class TeamManager {
    constructor(gameMode = GAME_MODES.FREE_FOR_ALL) {
        this.gameMode = gameMode;
        this.teams = new Map();
        this.playerTeams = new Map();
        this.teamColors = new Map();
        this.nextTeamId = 1;
        this.usedColors = new Set();
        
        // Initialize default team configurations
        this.initializeTeams();
    }

    initializeTeams() {
        switch (this.gameMode) {
            case GAME_MODES.TEAM_VS_TEAM:
                this.createTeam('RED', TEAM_COLORS.RED);
                this.createTeam('BLUE', TEAM_COLORS.BLUE);
                break;
            case GAME_MODES.MULTI_TEAM:
                this.createTeam('RED', TEAM_COLORS.RED);
                this.createTeam('BLUE', TEAM_COLORS.BLUE);
                this.createTeam('YELLOW', TEAM_COLORS.YELLOW);
                this.createTeam('GREEN', TEAM_COLORS.GREEN);
                break;
            case GAME_MODES.FREE_FOR_ALL:
                // Teams will be created dynamically as players join
                break;
        }
    }

    createTeam(name, color) {
        const teamId = this.nextTeamId++;
        this.teams.set(teamId, {
            id: teamId,
            name,
            color,
            players: new Set(),
            score: 0
        });
        this.teamColors.set(teamId, color);
        this.usedColors.add(color);
        return teamId;
    }

    generateUniqueColor() {
        const availableColors = Object.values(TEAM_COLORS)
            .filter(color => !this.usedColors.has(color));

        if (availableColors.length > 0) {
            return availableColors[Math.floor(Math.random() * availableColors.length)];
        }

        // If all predefined colors are used, generate a random color
        return Math.floor(Math.random() * 0xffffff);
    }

    assignPlayerToTeam(playerId, preferredTeamId = null) {
        if (this.gameMode === GAME_MODES.FREE_FOR_ALL) {
            // In FFA, each player gets their own team
            const color = this.generateUniqueColor();
            const teamId = this.createTeam(`Player ${playerId}`, color);
            this.playerTeams.set(playerId, teamId);
            this.teams.get(teamId).players.add(playerId);
            return { teamId, color };
        }

        if (preferredTeamId && this.teams.has(preferredTeamId)) {
            const team = this.teams.get(preferredTeamId);
            team.players.add(playerId);
            this.playerTeams.set(playerId, preferredTeamId);
            return { teamId: preferredTeamId, color: team.color };
        }

        // Auto-balance teams
        let smallestTeam = null;
        let smallestSize = Infinity;

        for (const [teamId, team] of this.teams) {
            if (team.players.size < smallestSize) {
                smallestTeam = team;
                smallestSize = team.players.size;
            }
        }

        if (smallestTeam) {
            smallestTeam.players.add(playerId);
            this.playerTeams.set(playerId, smallestTeam.id);
            return { teamId: smallestTeam.id, color: smallestTeam.color };
        }

        throw new Error('No teams available for assignment');
    }

    removePlayer(playerId) {
        const teamId = this.playerTeams.get(playerId);
        if (teamId) {
            const team = this.teams.get(teamId);
            if (team) {
                team.players.delete(playerId);
                // In FFA mode, remove empty teams
                if (this.gameMode === GAME_MODES.FREE_FOR_ALL && team.players.size === 0) {
                    this.teams.delete(teamId);
                    this.teamColors.delete(teamId);
                }
            }
            this.playerTeams.delete(playerId);
        }
    }

    getTeamColor(teamId) {
        return this.teamColors.get(teamId);
    }

    getPlayerTeam(playerId) {
        const teamId = this.playerTeams.get(playerId);
        return this.teams.get(teamId);
    }

    updateTeamScore(teamId, points) {
        const team = this.teams.get(teamId);
        if (team) {
            team.score += points;
        }
    }

    getTeamScores() {
        const scores = [];
        for (const [teamId, team] of this.teams) {
            scores.push({
                teamId,
                name: team.name,
                color: team.color,
                score: team.score,
                playerCount: team.players.size
            });
        }
        return scores.sort((a, b) => b.score - a.score);
    }

    arePlayersOnSameTeam(player1Id, player2Id) {
        return this.playerTeams.get(player1Id) === this.playerTeams.get(player2Id);
    }

    setGameMode(newMode) {
        if (newMode === this.gameMode) return;
        
        // Clear existing teams
        this.teams.clear();
        this.playerTeams.clear();
        this.teamColors.clear();
        this.usedColors.clear();
        this.nextTeamId = 1;
        
        // Set new game mode and initialize teams
        this.gameMode = newMode;
        this.initializeTeams();
    }
} 
### ./core/TeamManager.js END ###

### ./core/Scene.js BEGIN ###
import * as THREE from 'three';

class Scene {
    constructor(engine) {
        this.engine = engine;
        this.scene = engine.scene;
        
        // Scene elements
        this.floor = null;
        this.playerHighlight = null;
        this.obstacles = [];
        
        // Scene properties
        this.boundarySize = 25;
        this.gridSize = 100;
        this.gridDivisions = 100;
    }

    init() {
        this.createFloor();
        this.createBoundaryMarkers();
        this.createObstacles();
        return this;
    }

    createFloor() {
        // Create grid
        const gridHelper = new THREE.GridHelper(
            this.gridSize,
            this.gridDivisions,
            0x444444,
            0x222222
        );
        this.engine.add(gridHelper);

        // Create floor with glow effect
        const floorGeometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize);
        const floorMaterial = new THREE.MeshBasicMaterial({
            color: 0x000022,
            transparent: true,
            opacity: 0.2,
        });

        this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
        this.floor.rotation.x = -Math.PI / 2;
        this.floor.position.y = -0.01;
        this.engine.add(this.floor);

        // Create player highlight
        const highlightGeometry = new THREE.CircleGeometry(5, 32);
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.1,
        });

        this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        this.playerHighlight.rotation.x = -Math.PI / 2;
        this.playerHighlight.position.y = 0.02;
        this.engine.add(this.playerHighlight);
    }

    createBoundaryMarkers() {
        const markerSize = 1;
        const markerHeight = 1;
        const numMarkers = 10;

        const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
        const markerMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0x600000,
            transparent: true,
            opacity: 0.7
        });

        const markers = new THREE.Group();

        for (let i = 0; i < numMarkers; i++) {
            const t = (i / (numMarkers - 1)) * 2 - 1;
            const position = this.boundarySize * t;

            ['north', 'south', 'east', 'west'].forEach(direction => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                
                switch(direction) {
                    case 'north':
                        marker.position.set(position, markerHeight / 2, -this.boundarySize);
                        break;
                    case 'south':
                        marker.position.set(position, markerHeight / 2, this.boundarySize);
                        break;
                    case 'east':
                        marker.position.set(this.boundarySize, markerHeight / 2, position);
                        break;
                    case 'west':
                        marker.position.set(-this.boundarySize, markerHeight / 2, position);
                        break;
                }
                
                markers.add(marker);
            });
        }

        this.engine.add(markers);
    }

    createObstacles() {
        const numObstacles = 15;
        
        for (let i = 0; i < numObstacles; i++) {
            const obstacle = this.createRandomObstacle();
            if (obstacle) {
                this.obstacles.push(obstacle);
                this.engine.add(obstacle);
            }
        }
    }

    createRandomObstacle() {
        const shapeType = Math.floor(Math.random() * 3);
        let geometry, size;

        // Create random geometry
        switch(shapeType) {
            case 0: // Box
                size = 1.5 + Math.random() * 3;
                const height = 3 + Math.random() * 4;
                geometry = new THREE.BoxGeometry(size, height, size);
                break;
            case 1: // Cylinder
                const radius = 1 + Math.random() * 2;
                const cylinderHeight = 4 + Math.random() * 5;
                geometry = new THREE.CylinderGeometry(radius, radius, cylinderHeight, 16);
                size = radius * 2;
                break;
            case 2: // Sphere
                const sphereRadius = 1.5 + Math.random() * 2;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                size = sphereRadius * 2;
                break;
        }

        // Create neon material
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
        const material = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color.clone().multiplyScalar(0.5),
            shininess: 100
        });

        // Create mesh
        const obstacle = new THREE.Mesh(geometry, material);

        // Add point light
        const light = new THREE.PointLight(color, 0.5, 5);
        light.position.set(0, 0, 0);
        obstacle.add(light);

        // Set random position (avoiding player spawn area)
        let x, z;
        let validPosition = false;

        while (!validPosition) {
            x = (Math.random() - 0.5) * 45;
            z = (Math.random() - 0.5) * 45;
            
            const distanceFromOrigin = Math.sqrt(x * x + z * z);
            if (distanceFromOrigin > 10) {
                validPosition = true;
            }
        }

        const y = shapeType === 2 ? Math.random() * 3 : size / 2;
        obstacle.position.set(x, y, z);

        return obstacle;
    }

    updatePlayerHighlight(playerPosition) {
        if (this.playerHighlight) {
            this.playerHighlight.position.x = playerPosition.x;
            this.playerHighlight.position.z = playerPosition.z;
            
            const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
            this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
        }
    }

    getFloor() {
        return this.floor;
    }

    getObstacles() {
        return this.obstacles;
    }

    getBoundarySize() {
        return this.boundarySize;
    }

    cleanup() {
        // Cleanup all obstacles
        this.obstacles.forEach(obstacle => {
            obstacle.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        });
        
        // Clear arrays
        this.obstacles = [];
    }
}

export default Scene; 
### ./core/Scene.js END ###

### ./core/GameEngine.js BEGIN ###
import * as THREE from 'three';
import { Player } from '../entities/player/Player';
import { WeaponSystem } from '../entities/weapons/WeaponSystem';
import { EnemyManager } from '../entities/enemies/EnemyManager';
import { GameRoom } from '../ui/GameRoom';
import { SoundManager } from '../assets/SoundManager';
import { RegularLaser } from '../entities/weapons/RegularLaser';
import { GameUI } from '../ui/GameUI';
import { NetworkManager } from './NetworkManager';
import { AssetLoader } from '../assets/AssetLoader';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';

export class GameEngine {
  constructor() {
    // Initialize properties
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.player = null;
    this.score = 0;
    this.isRunning = false;
    this.lastTime = 0;
    this.collisionThreshold = 0.5; // Collision distance threshold
    
    // Game mode and settings
    this.gameMode = 'ffa'; // Default game mode: free-for-all
    this.roomTheme = 'space-station'; // Default room theme
    this.roomSize = { width: 60, height: 60 }; // Default room size
    
    // Initialize UI
    this.ui = new GameUI();
    
    // Multiplayer properties
    this.players = {};  // Will store other players
    this.playerId = null;  // Will be set when joining a game
    this.multiplayerEnabled = false;
    this.teams = {
      red: { score: 0, players: [] },
      blue: { score: 0, players: [] }
    };
    
    // Add NetworkManager instance
    this.networkManager = new NetworkManager();
    
    // Initialize AssetLoader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => console.log(`GameEngine: ${message}`),
      (type, error) => this.handleAssetError(type, error)
    );
    
    // Asset loading state
    this.assetsLoaded = false;
    
    // Initialize Three.js components
    this.initThree();
    
    // Initialize weapon system
    this.weaponSystem = new WeaponSystem(this.scene);
    
    // Initialize enemy manager (will be used for AI opponents)
    this.enemyManager = new EnemyManager(this.scene, this.roomSize.width / 2);
    
    // Initialize game elements
    this.initGame();
  }
  
  initThree() {
    // Create scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000011);
    
    // Create isometric-style camera
    this.camera = new THREE.PerspectiveCamera(
      45, // Lower FOV for more isometric-like view
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    
    // Set camera to isometric position
    this.camera.position.set(40, 40, 40); // Position it at a distance
    this.camera.lookAt(0, 0, 0); // Look at the center of the room
    
    // Create renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    
    // Add renderer to DOM
    document.getElementById('game-container').appendChild(this.renderer.domElement);
  }
  
  async initGame() {
    console.log('Initializing game...');
    
    // Create clock for timing
    this.clock = new THREE.Clock();
    
    // Initialize scene if not set
    if (!this.scene) {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x000011); // Dark blue background
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x444444);
      this.scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1).normalize();
      this.scene.add(directionalLight);
    }
    
    // Initialize camera if not set
    if (!this.camera) {
      this.camera = new THREE.PerspectiveCamera(
        75, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
      );
      this.camera.position.set(0, 10, -10);
      this.camera.lookAt(0, 0, 0);
    }
    
    // Initialize renderer if not set
    if (!this.renderer) {
      this.renderer = new THREE.WebGLRenderer({ antialias: true });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.shadowMap.enabled = true;
      document.body.appendChild(this.renderer.domElement);
    }
    
    // Load assets before proceeding
    try {
      console.log('Loading game assets...');
      this.assetsLoaded = await this.assetLoader.loadAll();
      console.log('Assets loaded successfully:', this.assetsLoaded);
    } catch (error) {
      console.error('Failed to load assets:', error);
      this.handleAssetError('critical', error);
      return;
    }
    
    // Initialize sound manager
    this.soundManager = new SoundManager();
    
    // Initialize player
    this.player = new Player(this.scene, this.camera, this.soundManager);
    
    // Initialize weapon system
    this.weaponSystem = new WeaponSystem(this.scene, this.soundManager);
    
    // Equip player with weapons
    this.player.equipWeapon('primary', new RegularLaser(this.weaponSystem));
    
    // Initialize enemy manager
    this.enemyManager = new EnemyManager(this.scene, this.weaponSystem, this.soundManager);
    
    // Initialize the first room
    this.initializeFirstRoom();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Setup network listeners only after assets are loaded
    if (this.assetsLoaded) {
      this.setupNetworkListeners();
    }
    
    // Show UI
    this.showGameUI();
    
    // Game is now initialized
    this.isInitialized = true;
    console.log('Game initialization complete!');
  }
  
  initGameModeUI() {
    // Clear any existing game mode UI
    const existingUI = document.querySelector('.team-indicator');
    if (existingUI) {
      existingUI.remove();
    }
    
    // Only add UI for team-based modes in multiplayer
    if (!this.multiplayerEnabled) return;
    
    switch (this.gameMode) {
      case 'tdm': // Team Deathmatch
      case 'ctf': // Capture The Flag
        // Create team scores indicator
        const teamIndicator = document.createElement('div');
        teamIndicator.className = 'team-indicator';
        
        const redTeam = document.createElement('div');
        redTeam.className = 'team-score team-red';
        redTeam.innerHTML = 'RED: <span id="red-score">0</span>';
        
        const blueTeam = document.createElement('div');
        blueTeam.className = 'team-score team-blue';
        blueTeam.innerHTML = 'BLUE: <span id="blue-score">0</span>';
        
        teamIndicator.appendChild(redTeam);
        teamIndicator.appendChild(blueTeam);
        
        document.getElementById('game-container').appendChild(teamIndicator);
        
        // Add flag status indicator for CTF mode
        if (this.gameMode === 'ctf') {
          const flagStatus = document.createElement('div');
          flagStatus.className = 'flag-status';
          
          const blueFlag = document.createElement('div');
          blueFlag.className = 'flag-blue';
          blueFlag.innerHTML = '<div class="flag-icon"></div> <span id="blue-flag-status">SECURE</span>';
          
          const redFlag = document.createElement('div');
          redFlag.className = 'flag-red';
          redFlag.innerHTML = '<div class="flag-icon"></div> <span id="red-flag-status">SECURE</span>';
          
          flagStatus.appendChild(blueFlag);
          flagStatus.appendChild(redFlag);
          
          document.getElementById('game-container').appendChild(flagStatus);
        }
        break;
        
      case 'koth': // King of the Hill
        // Create control point status
        const controlIndicator = document.createElement('div');
        controlIndicator.className = 'team-indicator';
        
        const controlPoint = document.createElement('div');
        controlPoint.className = 'team-score';
        controlPoint.innerHTML = 'CONTROL: <span id="control-status">NEUTRAL</span>';
        
        controlIndicator.appendChild(controlPoint);
        document.getElementById('game-container').appendChild(controlIndicator);
        break;
    }
  }
  
  setGameMode(mode) {
    this.gameMode = mode;
    console.log(`Game mode set to: ${mode}`);
    
    // Update UI for the new game mode
    this.initGameModeUI();
  }
  
  setRoomTheme(theme) {
    this.roomTheme = theme;
    console.log(`Room theme set to: ${theme}`);
    
    // If a room exists, regenerate it with the new theme
    if (this.gameRoom) {
      this.gameRoom.cleanup();
      this.gameRoom = new GameRoom(this.scene, this.roomSize, this.roomTheme);
      this.obstacles = this.gameRoom.getObstacles();
    }
  }
  
  start() {
    this.isRunning = true;
    this.lastTime = performance.now();
    
    // Start incrementing score over time (for single player only)
    if (!this.multiplayerEnabled) {
      this.scoreInterval = setInterval(() => {
        this.updateScore(1);
      }, 1000);
      
      // Start the enemy spawner
      this.spawnEnemyTimer = setInterval(() => {
        this.enemyManager.increaseDifficulty(0.05);
        this.enemyManager.increaseMaxEnemies(1);
      }, 30000); // Increase difficulty every 30 seconds
    }
    
    this.gameLoop(this.lastTime);
  }
  
  restart() {
    // Clear timers
    if (this.scoreInterval) {
      clearInterval(this.scoreInterval);
    }
    
    if (this.spawnEnemyTimer) {
      clearInterval(this.spawnEnemyTimer);
    }
    
    // Reset game state
    this.score = 0;
    this.updateScore();
    
    // Clear all projectiles
    this.weaponSystem.clearAllProjectiles();
    
    // Clear enemies
    this.enemyManager.clear();
    
    // Reset player
    this.player.reset();
    
    // Regenerate room
    this.gameRoom.cleanup();
    this.gameRoom = new GameRoom(this.scene, this.roomSize, this.roomTheme);
    this.obstacles = this.gameRoom.getObstacles();
    
    // Position player at spawn point
    const spawnPoint = this.gameRoom.getRandomSpawnPoint();
    this.player.mesh.position.copy(spawnPoint);
    
    // Multiplayer reset
    if (this.multiplayerEnabled) {
      // Reset team scores
      this.teams.red.score = 0;
      this.teams.blue.score = 0;
      this.updateTeamScores();
      
      // Reset multiplayer state (will be implemented with actual networking)
      console.log("Resetting multiplayer state");
    }
    
    // Start score increment timer (for single player)
    if (!this.multiplayerEnabled) {
      this.scoreInterval = setInterval(() => {
        this.updateScore(1);
      }, 1000);
      
      // Start the enemy spawner
      this.spawnEnemyTimer = setInterval(() => {
        this.enemyManager.increaseDifficulty(0.05);
        this.enemyManager.increaseMaxEnemies(1);
      }, 30000); // Increase difficulty every 30 seconds
    }
    
    // Start the game
    this.isRunning = true;
    this.lastTime = performance.now();
    this.gameLoop(this.lastTime);
  }
  
  gameLoop(currentTime) {
    if (!this.isRunning) return;
    
    // Calculate delta time
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // Update game state
    this.update();
    
    // Render scene
    this.renderer.render(this.scene, this.camera);
    
    // Continue the game loop
    requestAnimationFrame(this.gameLoop.bind(this));
  }
  
  update() {
    // Get delta time from the clock
    const deltaTime = this.clock.getDelta();
    
    // Skip update if game is paused
    if (this.isPaused) return;
    
    // Get obstacles from current room
    const obstacles = this.currentRoom?.getObstacles() || [];
    
    // Update player
    if (this.player) {
      this.player.update(deltaTime);
      
      // Check player collisions with obstacles
      if (this.currentRoom) {
        const collided = this.player.checkObstacleCollisions(obstacles);
        if (collided) {
          // Handle collision response here
          console.log('Player collided with obstacle');
        }
      }
    }
    
    // Update enemies
    if (this.enemyManager) {
      this.enemyManager.update(deltaTime, obstacles, this.player);
    }
    
    // Update weapons
    if (this.weaponSystem) {
      // Get targets (player and enemies)
      const targets = [this.player, ...this.enemyManager.getEnemies()].filter(target => target && target.isAlive);
      
      // Check weapon collisions
      const hits = this.weaponSystem.checkCollisions(targets, obstacles);
      
      // Handle hits
      for (const hit of hits) {
        if (hit.target !== 'wall' && typeof hit.target.takeDamage === 'function') {
          hit.target.takeDamage(hit.projectile.damage);
        }
        
        // Create explosion effect
        this.createExplosion(hit.position, hit.projectile.explosionSize || 0.5);
      }
      
      // Update weapon system
      this.weaponSystem.update(deltaTime);
    }
    
    // Update current room
    if (this.currentRoom) {
      this.currentRoom.update(deltaTime);
    }
    
    // Check if player has completed the current room
    if (this.currentRoom && this.player) {
      const isRoomCompleted = this.currentRoom.checkCompletion(this.player);
      if (isRoomCompleted && !this.isTransitioning) {
        this.transitionToNextRoom();
      }
    }
    
    // Update UI
    this.updateUI();
    
    // Send player updates if multiplayer is enabled
    if (this.multiplayerEnabled && this.networkManager.isConnected()) {
      this.sendPlayerUpdate();
    }
  }
  
  updateCamera() {
    // For isometric view, we maintain the camera's relative position 
    // but move it to follow the player
    const cameraOffset = new THREE.Vector3(40, 40, 40);
    
    // We want to keep the isometric angle but position relative to player
    this.camera.position.set(
      this.player.mesh.position.x + cameraOffset.x,
      cameraOffset.y, // Keep the same height
      this.player.mesh.position.z + cameraOffset.z
    );
    
    // Look at the player
    this.camera.lookAt(
      this.player.mesh.position.x,
      0, // Look at ground level
      this.player.mesh.position.z
    );
  }
  
  updateOtherPlayers(deltaTime) {
    // This will be replaced with actual networking code
    // For now, just a placeholder for the multiplayer functionality
    for (const playerId in this.players) {
      const player = this.players[playerId];
      // In real implementation, we'd interpolate positions from the server
    }
  }
  
  checkPlayerCollisions() {
    // Check for collisions with other players
    // This will be implemented with actual networking
  }
  
  updateGameMode(deltaTime) {
    // Handle game mode specific logic
    switch (this.gameMode) {
      case 'tdm': // Team Deathmatch
        // Just update scores when players are hit, already handled in processHitResults
        break;
        
      case 'ctf': // Capture The Flag
        // Check for flag captures, etc.
        this.updateCTFLogic(deltaTime);
        break;
        
      case 'koth': // King of the Hill
        // Check for hill control
        this.updateKOTHLogic(deltaTime);
        break;
        
      case 'ffa': // Free For All
      default:
        // Individual scores, handled in processHitResults
        break;
    }
  }
  
  updateCTFLogic(deltaTime) {
    // This will be implemented with actual flag capture logic
    // For now, just a placeholder
  }
  
  updateKOTHLogic(deltaTime) {
    // This will be implemented with actual hill control logic
    // For now, just a placeholder
  }
  
  processHitResults(hitResults) {
    // Process hits from weapon system
    for (const hit of hitResults) {
      // If hit a wall or obstacle, create a visual effect
      if (hit.target === 'wall' || hit.target === 'obstacle') {
        this.createHitEffect(hit.position);
      } 
      // If hit a target (enemy or player), damage it
      else if (hit.target && hit.target.takeDamage) {
        const damage = hit.projectile.options.damage || 10;
        const destroyed = hit.target.takeDamage(damage);
        
        if (destroyed) {
          if (this.multiplayerEnabled) {
            // Handle multiplayer scoring based on game mode
            switch (this.gameMode) {
              case 'tdm': // Team Deathmatch
                // Add score to the team that got the kill
                const targetTeam = hit.target.team;
                const attackerTeam = this.player.team;
                
                if (targetTeam !== attackerTeam) {
                  this.teams[attackerTeam].score += 1;
                  this.updateTeamScores();
                }
                break;
                
              default: // FFA and other modes
                this.updateScore(25); // Points for destroying a target
                break;
            }
          } else {
            // Single player scoring
            this.updateScore(25); // Points for destroying an enemy
          }
        }
      }
    }
  }
  
  createHitEffect(position) {
    // Create a simple flash effect at the hit position
    const geometry = new THREE.SphereGeometry(0.2, 8, 8);
    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    
    const flash = new THREE.Mesh(geometry, material);
    flash.position.copy(position);
    this.scene.add(flash);
    
    // Animate and remove after short duration
    const startTime = Date.now();
    const duration = 300;
    
    const animateFlash = () => {
      const elapsed = Date.now() - startTime;
      if (elapsed < duration) {
        const scale = 1 + elapsed / duration;
        flash.scale.set(scale, scale, scale);
        material.opacity = 0.8 * (1 - elapsed / duration);
        requestAnimationFrame(animateFlash);
      } else {
        this.scene.remove(flash);
        geometry.dispose();
        material.dispose();
      }
    };
    
    animateFlash();
  }
  
  checkObstacleCollisions(position, radius) {
    // Simple collision check with obstacles
    for (const obstacle of this.obstacles) {
      if (obstacle.type === 'wall') {
        // Box collision with walls
        const halfSize = new THREE.Vector3().copy(obstacle.size).multiplyScalar(0.5);
        
        // Check if position is within the bounding box of the wall
        if (
          position.x > obstacle.position.x - halfSize.x - radius &&
          position.x < obstacle.position.x + halfSize.x + radius &&
          position.z > obstacle.position.z - halfSize.z - radius &&
          position.z < obstacle.position.z + halfSize.z + radius
        ) {
          return true;
        }
      } else if (obstacle.radius) {
        // Cylinder collision
        const dx = position.x - obstacle.position.x;
        const dz = position.z - obstacle.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < obstacle.radius + radius) {
          return true;
        }
      } else if (obstacle.size) {
        // Box collision with rotation if needed
        const halfSize = new THREE.Vector3().copy(obstacle.size).multiplyScalar(0.5);
        
        // For simplicity, just do a bounding sphere check for now
        const dx = position.x - obstacle.position.x;
        const dz = position.z - obstacle.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        // Use the larger dimension as the bounding radius
        const boundingRadius = Math.max(halfSize.x, halfSize.z);
        
        if (distance < boundingRadius + radius) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  updateScore(points = 0) {
    this.score += points;
    document.getElementById('score-value').textContent = this.score;
  }
  
  updateTeamScores() {
    // Update team scores in the UI
    if (this.multiplayerEnabled && (this.gameMode === 'tdm' || this.gameMode === 'ctf')) {
      document.getElementById('red-score').textContent = this.teams.red.score;
      document.getElementById('blue-score').textContent = this.teams.blue.score;
    }
  }
  
  gameOver() {
    this.isRunning = false;
    
    // Clear score interval
    if (this.scoreInterval) {
      clearInterval(this.scoreInterval);
      this.scoreInterval = null;
    }
    
    // Clear enemy spawner
    if (this.spawnEnemyTimer) {
      clearInterval(this.spawnEnemyTimer);
      this.spawnEnemyTimer = null;
    }
    
    // Hide game UI and show game over screen
    if (this.ui) {
      this.ui.hide();
    }
    document.getElementById('final-score').textContent = this.score;
    document.getElementById('game-over').classList.remove('hidden');
  }
  
  handleResize() {
    // Update camera aspect ratio
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    
    // Update renderer size
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  
  // Multiplayer methods
  enableMultiplayer() {
    this.multiplayerEnabled = true;
    console.log("Multiplayer mode enabled");
    
    // Show multiplayer info in UI
    document.getElementById('multiplayer-info').classList.remove('hidden');
    
    // Set up NetworkManager event listeners
    this.setupNetworkListeners();
    
    // Connect to server
    this.connectToServer();
  }
  
  disableMultiplayer() {
    this.multiplayerEnabled = false;
    console.log("Multiplayer mode disabled");
    
    // Hide multiplayer info in UI
    document.getElementById('multiplayer-info').classList.add('hidden');
    
    // Disconnect from server
    this.disconnectFromServer();
  }
  
  setupNetworkListeners() {
    // Clear existing listeners
    this.networkManager.removeAllListeners();
    
    // Handle player joined
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      
      // Create other player visual representation
      const newPlayer = this.createOtherPlayer(playerData);
      this.players[playerData.id] = newPlayer;
      
      // Update player count in UI
      document.getElementById('players-count').textContent = Object.keys(this.players).length + 1; // +1 for local player
    });
    
    // Handle player left
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      
      // Remove player from scene
      if (this.players[id]) {
        this.scene.remove(this.players[id].mesh);
        delete this.players[id];
        
        // Update player count in UI
        document.getElementById('players-count').textContent = Object.keys(this.players).length + 1; // +1 for local player
      }
    });
    
    // Handle player update
    this.networkManager.on('player_update', (data) => {
      if (this.players[data.id]) {
        this.updateOtherPlayer(this.players[data.id], data);
      }
    });
    
    // Handle laser shot from other players
    this.networkManager.on('laser_shot', (data) => {
      // Create laser from other player
      if (data.origin && data.direction) {
        this.createLaserFromPlayer(data.origin, data.direction, data.playerId);
      }
    });
    
    // Handle connection status
    this.networkManager.on('connected', () => {
      console.log('Connected to server');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    // Handle player ID assignment
    this.networkManager.on('player_id', (id) => {
      this.playerId = id;
      console.log('Assigned player ID:', id);
    });
  }
  
  connectToServer(serverUrl = 'http://localhost:3000') {
    if (!this.multiplayerEnabled) return;
    
    console.log(`Connecting to multiplayer server: ${serverUrl}`);
    this.networkManager.connect(serverUrl);
    
    // Update player count in UI
    document.getElementById('players-count').textContent = '1';
    
    // Assign player to a team if in team mode
    if (this.gameMode === 'tdm' || this.gameMode === 'ctf') {
      const team = Math.random() > 0.5 ? 'red' : 'blue';
      this.player.team = team;
      this.teams[team].players.push(this.playerId);
      console.log(`Assigned to team: ${team}`);
    }
  }
  
  disconnectFromServer() {
    console.log("Disconnecting from multiplayer server");
    
    // Use NetworkManager to disconnect
    this.networkManager.disconnect();
    
    // Reset multiplayer state
    this.playerId = null;
    
    // Remove other players from scene
    for (const id in this.players) {
      this.scene.remove(this.players[id].mesh);
    }
    
    // Reset players and teams
    this.players = {};
    this.teams.red.players = [];
    this.teams.blue.players = [];
    this.player.team = null;
  }
  
  sendPlayerUpdate() {
    if (!this.multiplayerEnabled || !this.networkManager.isConnected()) return;
    if (!this.player || !this.player.mesh) return;
    
    const playerData = {
      position: {
        x: this.player.mesh.position.x,
        y: this.player.mesh.position.y,
        z: this.player.mesh.position.z
      },
      rotation: this.player.mesh.rotation.y,
      team: this.player.team,
      name: this.playerName,
      shipType: this.player.shipType
    };
    
    this.networkManager.sendPlayerUpdate(playerData);
  }
  
  createLaserFromPlayer(origin, direction, playerId) {
    // Implement this method to spawn a laser from another player
    // Similar to your existing laser creation code but from a different origin
    const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
    
    // Determine color based on player's team if applicable
    let laserColor = 0xff0000; // Default red
    if (this.players[playerId] && this.players[playerId].team) {
      laserColor = this.players[playerId].team === 'red' ? 0xff0000 : 0x0000ff;
    }
    
    const laserMaterial = new THREE.MeshBasicMaterial({ 
      color: laserColor,
      emissive: laserColor,
      emissiveIntensity: 1.0
    });
    
    const laser = new THREE.Mesh(laserGeometry, laserMaterial);
    
    // Set laser position and rotation
    laser.position.copy(origin);
    
    // Set laser direction
    const laserDirection = new THREE.Vector3().copy(direction);
    laser.lookAt(laserDirection.add(origin));
    
    // Rotate to align with direction
    laser.rotateX(Math.PI / 2);
    
    // Add to scene
    this.scene.add(laser);
    
    // Add to lasers array for update
    this.lasers.push({
      mesh: laser,
      direction: laserDirection.normalize(),
      speed: 0.5, // Adjust as needed
      playerId: playerId
    });
    
    return laser;
  }
  
  /**
   * Initialize the first game room
   */
  initializeFirstRoom() {
    // Clean up any existing room
    if (this.currentRoom) {
      this.currentRoom.cleanup();
    }
    
    // Create a new room
    this.currentRoom = new GameRoom(
      this.scene, 
      { width: 60, height: 60 }, 
      this.roomTheme || 'space-station'
    );
    
    // Position player at spawn point
    if (this.player && this.currentRoom) {
      const spawnPoint = this.currentRoom.getRandomSpawnPoint();
      this.player.mesh.position.copy(spawnPoint);
    }
    
    // Reset current level
    this.currentLevel = 1;
    
    // Update UI
    this.updateLevelDisplay();
  }
  
  /**
   * Update the level display in the UI
   */
  updateLevelDisplay() {
    const levelElement = document.getElementById('level-value');
    if (levelElement) {
      levelElement.textContent = this.currentLevel;
    }
  }
  
  /**
   * Create an explosion effect at the given position
   */
  createExplosion(position, size = 0.5) {
    // Create a sphere for the explosion
    const geometry = new THREE.SphereGeometry(size, 8, 8);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });
    
    const explosion = new THREE.Mesh(geometry, material);
    explosion.position.copy(position);
    this.scene.add(explosion);
    
    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 10);
    light.position.copy(position);
    this.scene.add(light);
    
    // Animate the explosion
    let scale = 1.0;
    const expandSpeed = 2.0;
    const duration = 0.5; // seconds
    let elapsed = 0;
    
    const animate = (deltaTime) => {
      elapsed += deltaTime;
      const progress = elapsed / duration;
      
      if (progress >= 1) {
        // Remove the explosion
        this.scene.remove(explosion);
        this.scene.remove(light);
        return;
      }
      
      // Expand and fade out
      scale += expandSpeed * deltaTime;
      explosion.scale.set(scale, scale, scale);
      
      // Fade out
      const opacity = 1 - progress;
      material.opacity = opacity;
      light.intensity = 2 * opacity;
      
      // Continue animation
      requestAnimationFrame((timestamp) => {
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        animate(delta / 1000); // Convert ms to seconds
      });
    };
    
    // Start animation
    const lastTimestamp = performance.now();
    animate(0);
  }
  
  /**
   * Transition to the next room/level
   */
  transitionToNextRoom() {
    // Set transition flag
    this.isTransitioning = true;
    
    // Fade out effect
    // Here you would implement a visual fade-out effect
    
    // After fade out, create new room
    setTimeout(() => {
      // Clean up old room
      if (this.currentRoom) {
        this.currentRoom.cleanup();
      }
      
      // Increment level
      this.currentLevel++;
      
      // Create new room with increased difficulty
      this.currentRoom = new GameRoom(
        this.scene,
        { width: 60, height: 60 },
        this.roomTheme || 'space-station',
        { 
          difficulty: this.currentLevel * 0.2,
          obstacleCount: Math.min(10 + this.currentLevel, 30)
        }
      );
      
      // Position player at spawn point
      if (this.player && this.currentRoom) {
        const spawnPoint = this.currentRoom.getRandomSpawnPoint();
        this.player.mesh.position.copy(spawnPoint);
      }
      
      // Update UI
      this.updateLevelDisplay();
      
      // Increase enemy manager difficulty
      if (this.enemyManager) {
        this.enemyManager.increaseDifficulty(0.1 * this.currentLevel);
        this.enemyManager.increaseMaxEnemies(1);
      }
      
      // Fade in effect
      // Here you would implement a visual fade-in effect
      
      // Reset transition flag
      setTimeout(() => {
        this.isTransitioning = false;
      }, 500); // After fade-in completes
      
    }, 1000); // After fade-out completes
  }
  
  /**
   * Update UI elements
   */
  updateUI() {
    // Update health and energy displays
    if (this.player) {
      // Update health
      const healthElement = document.getElementById('health-value');
      if (healthElement) {
        healthElement.textContent = Math.round(this.player.health);
        
        // Update health bar
        const healthBar = document.getElementById('health-bar-inner');
        if (healthBar) {
          const healthPercent = (this.player.health / this.player.maxHealth) * 100;
          healthBar.style.width = `${healthPercent}%`;
        }
      }
      
      // Update energy
      const energyElement = document.getElementById('energy-value');
      if (energyElement) {
        energyElement.textContent = Math.round(this.player.energy);
        
        // Update energy bar
        const energyBar = document.getElementById('energy-bar-inner');
        if (energyBar) {
          const energyPercent = (this.player.energy / this.player.maxEnergy) * 100;
          energyBar.style.width = `${energyPercent}%`;
        }
      }
      
      // Update shield
      const shieldElement = document.getElementById('shield-value');
      if (shieldElement) {
        shieldElement.textContent = Math.round(this.player.shields);
        
        // Update shield bar
        const shieldBar = document.getElementById('shield-bar-inner');
        if (shieldBar) {
          const shieldPercent = (this.player.shields / this.player.maxShields) * 100;
          shieldBar.style.width = `${shieldPercent}%`;
        }
      }
    }
    
    // Update score
    const scoreElement = document.getElementById('score-value');
    if (scoreElement && this.player) {
      scoreElement.textContent = this.player.score;
    }
  }
  
  /**
   * Setup event listeners for window resizing and UI controls
   */
  setupEventListeners() {
    // Handle window resize
    window.addEventListener('resize', () => this.handleResize());
    
    // Handle pause/resume game
    const pauseButton = document.getElementById('pause-button');
    if (pauseButton) {
      pauseButton.addEventListener('click', () => {
        this.isPaused = !this.isPaused;
        pauseButton.textContent = this.isPaused ? 'Resume' : 'Pause';
      });
    }
    
    // Handle restart game
    const restartButton = document.getElementById('restart-button');
    if (restartButton) {
      restartButton.addEventListener('click', () => this.restart());
    }
  }
  
  /**
   * Show the game UI elements
   */
  showGameUI() {
    // Show game UI
    if (this.ui) {
      this.ui.show();
    }
    
    // Hide any splash screens or menus
    const splashScreen = document.getElementById('splash-screen');
    if (splashScreen) {
      splashScreen.style.display = 'none';
    }
  }
  
  // Create visual representation for other players
  createOtherPlayer(playerData) {
    console.log('Creating other player with data:', playerData);
    
    // Ensure assets are loaded
    if (!this.assetsLoaded) {
      console.warn('Attempting to create player before assets are loaded');
      return null;
    }
    
    // Get ship type from player data or default to STANDARD
    const shipType = playerData.shipType || 'STANDARD';
    console.log('Using ship type:', shipType);
    
    // Try to get ship model from asset loader first
    let ship = null;
    try {
      ship = this.assetLoader.getOpponentShipModel(shipType);
      if (ship) {
        console.log('Successfully loaded ship model for type:', shipType);
        ship.scale.set(0.45, 0.45, 0.45);
      }
    } catch (error) {
      console.warn('Failed to load ship model:', error);
    }
    
    // Fallback to geometry if model loading failed
    if (!ship) {
      console.log('Using fallback geometry for ship type:', shipType);
      // Create geometry based on ship type
      let geometry;
      switch(shipType) {
        case 'INTERCEPTOR':
          geometry = new THREE.ConeGeometry(0.4, 1.25, 4);
          break;
        case 'HEAVY':
          geometry = new THREE.CylinderGeometry(0.6, 0.7, 1.0, 6);
          break;
        case 'SCOUT':
          geometry = new THREE.ConeGeometry(0.3, 1.1, 5);
          break;
        case 'STANDARD':
        default:
          geometry = new THREE.ConeGeometry(0.5, 1.0, 3);
          break;
      }
      
      // Rotate geometry to align with movement direction
      geometry.rotateX(Math.PI / 2);
      
      // Create material based on team color
      const shipColor = playerData.teamColor || 0x00ffff;
      const material = new THREE.MeshPhongMaterial({ 
        color: shipColor, 
        emissive: shipColor,
        emissiveIntensity: 0.5,
        shininess: 100
      });
      
      // Create mesh
      ship = new THREE.Mesh(geometry, material);
    }
    
    // Add engine glow effect
    const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
    engineGlow.position.set(0, 0, -0.5);
    ship.add(engineGlow);
    
    // Add ship to scene
    this.scene.add(ship);
    
    // Create name label
    const nameDiv = document.createElement('div');
    nameDiv.className = 'player-label';
    nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
    
    const nameLabel = new CSS2DObject(nameDiv);
    nameLabel.position.set(0, 1, 0);
    ship.add(nameLabel);
    
    // Set initial position if provided
    if (playerData.position) {
      ship.position.set(
        playerData.position.x,
        playerData.position.y || 0.5,
        playerData.position.z
      );
    }
    
    // Set initial rotation if provided
    if (playerData.rotation !== undefined) {
      ship.rotation.y = playerData.rotation;
    }
    
    console.log('Player object created successfully:', {
      id: playerData.id,
      name: playerData.name,
      shipType,
      position: ship.position.toArray(),
      rotation: ship.rotation.y
    });
    
    // Return the player object
    return {
      mesh: ship,
      nameLabel,
      engineGlow,
      team: playerData.team,
      health: 100,
      shipType,
      lastUpdate: Date.now()
    };
  }
  
  // Update other player with new data
  updateOtherPlayer(player, data) {
    if (!player || !player.mesh) {
      console.warn('Invalid player object for update:', { player, data });
      return;
    }
    
    const now = Date.now();
    const timeSinceLastUpdate = now - (player.lastUpdate || 0);
    console.log(`Updating player ${data.id}, time since last update: ${timeSinceLastUpdate}ms`);
    
    // Update position with smooth lerping
    if (data.position) {
      const targetPos = new THREE.Vector3(
        data.position.x,
        data.position.y || 0.5,
        data.position.z
      );
      
      const currentPos = player.mesh.position.clone();
      player.mesh.position.lerp(targetPos, 0.3);
      
      // Log position change
      const distance = currentPos.distanceTo(player.mesh.position);
      if (distance > 0.01) {
        console.log('Position updated:', {
          from: currentPos.toArray(),
          to: player.mesh.position.toArray(),
          distance: distance.toFixed(3)
        });
      }
    }
    
    // Update rotation with smooth interpolation
    if (data.rotation !== undefined) {
      const currentRotation = player.mesh.rotation.y;
      
      // Find shortest rotation path
      let rotDiff = data.rotation - currentRotation;
      if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
      if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
      
      const newRotation = currentRotation + rotDiff * 0.3;
      player.mesh.rotation.y = newRotation;
      
      // Log significant rotation changes
      if (Math.abs(rotDiff) > 0.1) {
        console.log('Rotation updated:', {
          from: currentRotation.toFixed(3),
          to: newRotation.toFixed(3),
          difference: rotDiff.toFixed(3)
        });
      }
    }
    
    // Update team if changed
    if (data.team !== undefined && data.team !== player.team) {
      console.log('Team changed:', { from: player.team, to: data.team });
      player.team = data.team;
    }
    
    // Update last update timestamp
    player.lastUpdate = now;
  }

  handleAssetError(type, error) {
    console.error(`Asset loading error (${type}):`, error);
    if (type === 'critical') {
      // Show error UI
      this.ui.showError('Failed to load game assets. Please refresh the page.');
    }
  }
} 
### ./core/GameEngine.js END ###

### ./core/Engine.js BEGIN ###
import * as THREE from 'three';

class Engine {
    constructor() {
        // Core engine properties
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        this.lastTime = Date.now();
        
        // Bind methods
        this.animate = this.animate.bind(this);
        this.handleResize = this.handleResize.bind(this);
    }

    init() {
        this.setupScene();
        this.setupRenderer();
        this.setupCamera();
        this.setupLights();
        this.setupEventListeners();
        
        return this;
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000011);
    }

    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
    }

    setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);

        // Camera smoothing properties
        this.cameraTargetPosition = new THREE.Vector3();
        this.cameraTargetLookAt = new THREE.Vector3();
        this.cameraSmoothingFactor = 0.05;
    }

    setupLights() {
        const ambientLight = new THREE.AmbientLight(0x404040);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        this.scene.add(directionalLight);
    }

    setupEventListeners() {
        window.addEventListener('resize', this.handleResize);
    }

    handleResize() {
        if (this.camera && this.renderer) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    animate() {
        requestAnimationFrame(this.animate);

        const now = Date.now();
        const deltaTime = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // Update game state
        if (this.update) {
            this.update(deltaTime);
        }

        // Render scene
        if (this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }

    start() {
        this.animate();
    }

    cleanup() {
        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);

        // Cleanup THREE.js resources
        this.scene?.traverse(object => {
            if (object.geometry) {
                object.geometry.dispose();
            }
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });

        // Dispose of renderer
        if (this.renderer) {
            this.renderer.dispose();
            document.body.removeChild(this.renderer.domElement);
        }
    }

    // Utility methods for scene management
    add(...objects) {
        objects.forEach(object => this.scene.add(object));
    }

    remove(...objects) {
        objects.forEach(object => this.scene.remove(object));
    }
}

export default Engine; 
### ./core/Engine.js END ###

### ./core/NetworkManager.js BEGIN ###
import { EventEmitter } from 'events';
import { io } from 'socket.io-client';

export class NetworkManager extends EventEmitter {
  constructor() {
    super();
    this.socket = null;
    this.playerId = null;
    this.connected = false;
    this.players = new Map();
    this.lastUpdateTime = 0;
    this.updateInterval = 50; // 20 updates per second
  }

  connect(serverUrl = 'http://localhost:3000') {
    // Don't reconnect if already connected
    if (this.connected) return;

    // Create socket connection
    this.socket = io(serverUrl, {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 10
    });

    // Set up event handlers
    this.socket.on('connect', () => {
      console.log('Connected to game server');
      this.connected = true;
      this.emit('connected');
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from game server');
      this.connected = false;
      this.emit('disconnected');
    });

    this.socket.on('player_id', (id) => {
      this.playerId = id;
      console.log(`Assigned player ID: ${id}`);
      this.emit('player_id', id);
    });

    this.socket.on('player_joined', (player) => {
      if (player.id !== this.playerId) {
        this.players.set(player.id, player);
        console.log(`Player joined: ${player.id}`);
        this.emit('player_joined', player);
      }
    });

    this.socket.on('player_left', (id) => {
      this.players.delete(id);
      console.log(`Player left: ${id}`);
      this.emit('player_left', id);
    });

    this.socket.on('player_update', (update) => {
      if (update.id !== this.playerId) {
        const player = this.players.get(update.id);
        if (player) {
          // Update the player with new data
          Object.assign(player, update);
          player.lastUpdate = Date.now();
          this.emit('player_update', update);
        }
      }
    });

    this.socket.on('laser_shot', (data) => {
      if (data.playerId !== this.playerId) {
        this.emit('laser_shot', data);
      }
    });

    // Handle initial player list
    this.socket.on('players', (players) => {
      players.forEach(player => {
        if (player.id !== this.playerId) {
          this.players.set(player.id, player);
        }
      });
      this.emit('players', players);
    });

    // Handle error
    this.socket.on('error', (error) => {
      console.error('Socket error:', error);
      this.emit('error', error);
    });
  }

  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.playerId = null;
      this.connected = false;
      this.players.clear();
    }
  }

  sendPlayerUpdate(data) {
    if (!this.connected || !this.socket) return;

    const now = Date.now();
    // Throttle updates to save bandwidth
    if (now - this.lastUpdateTime < this.updateInterval) return;
    
    this.lastUpdateTime = now;
    
    this.socket.emit('player_update', {
      id: this.playerId,
      ...data
    });
  }

  sendLaserShot(data) {
    if (!this.connected || !this.socket) return;
    
    this.socket.emit('laser_shot', {
      playerId: this.playerId,
      ...data
    });
  }

  updatePlayerInfo(name, shipType) {
    if (!this.connected || !this.socket) return;
    
    this.socket.emit('player_info', {
      id: this.playerId,
      name: name,
      shipType: shipType
    });
  }

  // Get all other players (not including self)
  getOtherPlayers() {
    return Array.from(this.players.values());
  }

  isConnected() {
    return this.connected;
  }

  getPlayerId() {
    return this.playerId;
  }
} 
### ./core/NetworkManager.js END ###

### ./core/InfiniteMap.js BEGIN ###
import * as THREE from 'three';

/**
 * Manages an infinite map system using chunks
 */
export class InfiniteMap {
  constructor(game) {
    this.game = game;
    this.chunks = new Map(); // Map of loaded chunks
    this.chunkSize = 100; // Size of each chunk in world units
    this.loadDistance = 2; // Number of chunks to load in each direction
    this.cullingDistance = 3; // Number of chunks before culling
    
    // Track current chunk
    this.currentChunkX = 0;
    this.currentChunkZ = 0;
    
    // Asset categories for random placement
    this.assetCategories = {
      flora: [
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SP_Tree01.glb',
        'SP_Tree02.glb',
        'SP_Tree03.glb',
        'SP_Tree04.glb',
      ],
      rocks: [
        'SP_Rock01.glb',
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      objects: [
        'SP_Crystal01.glb',
        'SP_Ground02.glb',
        'SP_Ground03.glb',
        'SP_Ground04.glb',
        'SP_Ground05.glb',
        'SP_Mountain01.glb',
        'SP_Mountain02.glb',
        'SP_Mountain03.glb',
        'SP_Stone01.glb'
      ]
    };
  }

  /**
   * Get chunk key from world coordinates
   */
  getChunkKey(x, z) {
    const chunkX = Math.floor(x / this.chunkSize);
    const chunkZ = Math.floor(z / this.chunkSize);
    return `${chunkX},${chunkZ}`;
  }

  /**
   * Update chunks based on player position
   */
  update(playerPosition) {
    // Get current chunk from player position
    const newChunkX = Math.floor(playerPosition.x / this.chunkSize);
    const newChunkZ = Math.floor(playerPosition.z / this.chunkSize);

    // If chunk changed, update loaded chunks
    if (newChunkX !== this.currentChunkX || newChunkZ !== this.currentChunkZ) {
      this.currentChunkX = newChunkX;
      this.currentChunkZ = newChunkZ;
      this.updateLoadedChunks();
    }
  }

  /**
   * Update which chunks are loaded based on current position
   */
  updateLoadedChunks() {
    // Track which chunks should be kept
    const chunksToKeep = new Set();

    // Calculate chunks to load
    for (let x = -this.loadDistance; x <= this.loadDistance; x++) {
      for (let z = -this.loadDistance; z <= this.loadDistance; z++) {
        const chunkX = this.currentChunkX + x;
        const chunkZ = this.currentChunkZ + z;
        const key = `${chunkX},${chunkZ}`;
        chunksToKeep.add(key);

        // Load chunk if not already loaded
        if (!this.chunks.has(key)) {
          this.loadChunk(chunkX, chunkZ);
        }
      }
    }

    // Unload chunks that are too far away
    for (const [key, chunk] of this.chunks) {
      if (!chunksToKeep.has(key)) {
        const distance = Math.max(
          Math.abs(chunk.x - this.currentChunkX),
          Math.abs(chunk.z - this.currentChunkZ)
        );

        if (distance > this.cullingDistance) {
          this.unloadChunk(key);
        }
      }
    }
  }

  /**
   * Load a new chunk at the specified coordinates
   */
  loadChunk(chunkX, chunkZ) {
    const key = `${chunkX},${chunkZ}`;
    
    // Create chunk container
    const chunk = {
      x: chunkX,
      z: chunkZ,
      objects: [],
      group: new THREE.Group()
    };

    // Calculate world position of chunk corner
    const worldX = chunkX * this.chunkSize;
    const worldZ = chunkZ * this.chunkSize;

    // Add random objects to chunk
    this.populateChunk(chunk, worldX, worldZ);

    // Add chunk to scene
    this.game.scene.add(chunk.group);
    this.chunks.set(key, chunk);
  }

  /**
   * Populate a chunk with random objects
   */
  populateChunk(chunk, worldX, worldZ) {
    // Number of objects to place in each category
    const counts = {
      flora: this.getRandomInt(3, 6),
      rocks: this.getRandomInt(2, 4),
      objects: this.getRandomInt(1, 3)
    };

    // Place objects from each category
    for (const [category, assets] of Object.entries(this.assetCategories)) {
      for (let i = 0; i < counts[category]; i++) {
        // Get random asset from category
        const assetPath = assets[Math.floor(Math.random() * assets.length)];
        
        // Calculate random position within chunk
        const x = worldX + Math.random() * this.chunkSize;
        const z = worldZ + Math.random() * this.chunkSize;

        // Load and place object
        this.game.assetLoader.loadModel(`models/${category}/${assetPath}`)
          .then(model => {
            // Random rotation
            model.rotation.y = Math.random() * Math.PI * 2;

            // Random scale based on category
            let scale = 1;
            if (category === 'flora') {
              scale = 0.5 + Math.random() * 0.5;
            } else if (category === 'rocks') {
              scale = 0.3 + Math.random() * 0.4;
            } else {
              scale = 0.2 + Math.random() * 0.3;
            }
            model.scale.set(scale, scale, scale);

            // Position object
            model.position.set(x, 0, z);

            // Add to chunk group
            chunk.group.add(model);

            // Store object data for collision
            chunk.objects.push({
              model,
              position: model.position.clone(),
              radius: this.calculateCollisionRadius(model, scale),
              type: category
            });
          })
          .catch(error => console.error('Error loading model:', error));
      }
    }
  }

  /**
   * Calculate appropriate collision radius for an object
   */
  calculateCollisionRadius(model, scale) {
    // Calculate using bounding box for more accuracy
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Use the larger of width or depth (horizontal dimensions)
    const radius = Math.max(size.x, size.z) / 2;
    
    // Apply scale
    const scaledRadius = radius * scale;
    
    // Add small padding (10%) for better collision detection
    return scaledRadius * 1.1;
  }

  /**
   * Unload a chunk and remove it from the scene
   */
  unloadChunk(key) {
    const chunk = this.chunks.get(key);
    if (chunk) {
      // Remove from scene
      this.game.scene.remove(chunk.group);
      
      // Dispose of geometries and materials
      chunk.group.traverse(object => {
        if (object.geometry) {
          object.geometry.dispose();
        }
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach(material => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });

      // Remove from chunks map
      this.chunks.delete(key);
    }
  }

  /**
   * Get random integer between min and max (inclusive)
   */
  getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * Check for collisions with objects in nearby chunks
   */
  checkCollisions(position, radius) {
    const currentKey = this.getChunkKey(position.x, position.z);
    const nearbyChunks = this.getNearbyChunks(currentKey);
    
    // First, do a quick sphere-based check for efficiency
    for (const chunk of nearbyChunks) {
      for (const object of chunk.objects) {
        const distance = position.distanceTo(object.position);
        const quickCheckDistance = radius + object.radius;
        
        // Skip detailed check if clearly not colliding
        if (distance > quickCheckDistance * 1.2) continue;
        
        // For close objects, do a more accurate bounding box check
        const model = object.model;
        
        // Get bounding box in world space
        const bbox = new THREE.Box3().setFromObject(model);
        
        // Create a sphere representing the player
        const playerSphere = {
          center: position.clone(),
          radius: radius
        };
        
        // Check if sphere intersects with box - simple approximation
        const collision = this.checkSphereBoxIntersection(playerSphere, bbox);
        
        if (collision) {
          return {
            collided: true,
            object: {
              position: object.position.clone(),
              radius: object.radius,
              type: object.type
            },
            distance: distance
          };
        }
      }
    }
    
    return { collided: false };
  }

  /**
   * Check if a sphere intersects with a box
   */
  checkSphereBoxIntersection(sphere, box) {
    // Find the closest point on the box to the sphere
    const closestPoint = new THREE.Vector3().copy(sphere.center);
    
    // For each axis, clamp the sphere center to the box bounds
    closestPoint.x = Math.max(box.min.x, Math.min(box.max.x, closestPoint.x));
    closestPoint.y = Math.max(box.min.y, Math.min(box.max.y, closestPoint.y));
    closestPoint.z = Math.max(box.min.z, Math.min(box.max.z, closestPoint.z));
    
    // Calculate distance from closest point to sphere center
    const distance = closestPoint.distanceTo(sphere.center);
    
    // If this distance is less than the sphere radius, we have a collision
    return distance < sphere.radius;
  }

  /**
   * Get array of chunks near the specified chunk
   */
  getNearbyChunks(key) {
    const [x, z] = key.split(',').map(Number);
    const nearby = [];
    
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        const nearbyKey = `${x + dx},${z + dz}`;
        const chunk = this.chunks.get(nearbyKey);
        if (chunk) {
          nearby.push(chunk);
        }
      }
    }
    
    return nearby;
  }
} 
### ./core/InfiniteMap.js END ###

### ./config/ShipConfig.js BEGIN ###
export const SHIP_TYPES = {
    SCOUT: 'SCOUT',
    INTERCEPTOR: 'INTERCEPTOR',
    HEAVY: 'HEAVY'
};

export const SHIP_STATUS = {
    FREE: 'FREE',
    PREMIUM: 'PREMIUM'
};

export const SHIP_CONFIGS = {
    [SHIP_TYPES.SCOUT]: {
        name: 'Scout',
        description: 'Fast and agile, but lightly armored',
        status: SHIP_STATUS.FREE,
        stats: {
            health: 80,
            speed: 0.2,
            size: 0.8,
            turnSpeed: 0.15,
            acceleration: 0.12
        },
        model: 'SCOUT',
        abilities: ['Quick Boost', 'Stealth Mode']
    },
    [SHIP_TYPES.INTERCEPTOR]: {
        name: 'Interceptor',
        description: 'Balanced combat vessel',
        status: SHIP_STATUS.FREE,
        stats: {
            health: 100,
            speed: 0.15,
            size: 1.0,
            turnSpeed: 0.1,
            acceleration: 0.1
        },
        model: 'INTERCEPTOR',
        abilities: ['Shield Burst', 'EMP Blast']
    },
    [SHIP_TYPES.HEAVY]: {
        name: 'Heavy Destroyer',
        description: 'Premium battle cruiser with superior firepower',
        status: SHIP_STATUS.PREMIUM,
        stats: {
            health: 150,
            speed: 0.12,
            size: 1.2,
            turnSpeed: 0.08,
            acceleration: 0.08
        },
        model: 'HEAVY',
        abilities: ['Heavy Shield', 'Missile Barrage', 'Area Denial']
    }
};

export class ShipSelector {
    static getAvailableShips(isPremium = false) {
        return Object.entries(SHIP_CONFIGS)
            .filter(([_, config]) => 
                config.status === SHIP_STATUS.FREE || 
                (isPremium && config.status === SHIP_STATUS.PREMIUM)
            )
            .map(([type, config]) => ({
                type,
                ...config
            }));
    }

    static getShipConfig(type) {
        return SHIP_CONFIGS[type];
    }

    static isShipAvailable(type, isPremium = false) {
        const config = SHIP_CONFIGS[type];
        return config && (
            config.status === SHIP_STATUS.FREE || 
            (isPremium && config.status === SHIP_STATUS.PREMIUM)
        );
    }
} 
### ./config/ShipConfig.js END ###

### ./config/Controls.js BEGIN ###
// Control configuration for the game
// This file centralizes all control-related settings and mappings

// Key mappings for different actions
export const KEY_MAPPINGS = {
    // Movement controls
    MOVEMENT: {
        FORWARD: ['KeyW', 'ArrowUp'],
        BACKWARD: ['KeyS', 'ArrowDown'],
        LEFT: ['KeyA', 'ArrowLeft'],
        RIGHT: ['KeyD', 'ArrowRight'],
        STRAFE_LEFT: ['KeyQ'],
        STRAFE_RIGHT: ['KeyE']
    },
    // Weapon controls
    WEAPONS: {
        FIRE: ['Space'],
        SELECT_LASER: ['Digit1'],
        SELECT_GRENADE: ['Digit2'],
        SELECT_BOUNCE: ['Digit3'],
        SWITCH_WEAPON: ['KeyX']
    },
    // UI controls
    UI: {
        TOGGLE_MAP: ['KeyM'],
        TOGGLE_CONTROLS: ['KeyC']
    }
};

// Control settings and configurations
export const CONTROL_SETTINGS = {
    // Movement settings
    MOVEMENT: {
        ROTATION_SPEED: 2.5,
        SHIP_SPEED: 30,
        ACCELERATION: 1.0,
        DECELERATION: 0.95,
        STRAFE_SPEED_MULTIPLIER: 0.8
    },
    // Weapon cooldowns (in milliseconds)
    WEAPON_COOLDOWNS: {
        LASER: 200,
        BOUNCE: 500,
        GRENADE: 1000
    },
    // Touch controls settings
    TOUCH: {
        JOYSTICK_MAX_DISTANCE: 40,
        JOYSTICK_DEAD_ZONE: 10,
        DOUBLE_TAP_DELAY: 300
    }
};

// Visual feedback settings for controls
export const CONTROL_FEEDBACK = {
    INDICATORS: {
        MOVEMENT: [
            { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward' },
            { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward' },
            { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left' },
            { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right' },
            { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left' },
            { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right' }
        ],
        WEAPONS: [
            { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser' },
            { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade' },
            { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser' },
            { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon' }
        ],
        ACTIONS: [
            { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon' }
        ]
    }
};

// Default control state
export const DEFAULT_CONTROL_STATE = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    strafeLeft: false,
    strafeRight: false,
    fire: false,
    switchWeapon: false
};

// Helper functions for control handling
export const ControlUtils = {
    /**
     * Check if a key code matches any of the specified actions
     * @param {string} keyCode - The key code to check
     * @param {string} action - The action to check against
     * @param {string} category - The category of the action (MOVEMENT, WEAPONS, UI)
     * @returns {boolean} - Whether the key matches the action
     */
    isKeyMatch: (keyCode, action, category) => {
        return KEY_MAPPINGS[category]?.[action]?.includes(keyCode) || false;
    },

    /**
     * Get the action for a given key code
     * @param {string} keyCode - The key code to check
     * @returns {Object|null} - The matching action and category, or null if no match
     */
    getActionForKey: (keyCode) => {
        for (const [category, actions] of Object.entries(KEY_MAPPINGS)) {
            for (const [action, keys] of Object.entries(actions)) {
                if (keys.includes(keyCode)) {
                    return { category, action };
                }
            }
        }
        return null;
    },

    /**
     * Check if a key is a weapon selection key
     * @param {string} keyCode - The key code to check
     * @returns {boolean} - Whether the key is a weapon selection key
     */
    isWeaponSelectionKey: (keyCode) => {
        return KEY_MAPPINGS.WEAPONS.SELECT_LASER.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SELECT_GRENADE.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SELECT_BOUNCE.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SWITCH_WEAPON.includes(keyCode);
    }
}; 
### ./config/Controls.js END ###

### ./config/GameConfig.js BEGIN ###
export const GAME_CONFIG = {
    PLAYER: {
        INITIAL_HEALTH: 100,
        INITIAL_ENERGY: 100,
        ENERGY_RECHARGE_RATE: 20,
        MOVEMENT_SPEED: 0.1,
        ROTATION_SPEED: 0.05,
        COLLISION_RADIUS: 0.8
    },
    
    WEAPONS: {
        LASER: {
            COOLDOWN: 200,
            SPEED: 1.2,
            DAMAGE: 10,
            ENERGY_COST: 25,
            TRAIL_LENGTH: 8
        },
        BOUNCE: {
            COOLDOWN: 500,
            SPEED: 0.8,
            DAMAGE: 25,
            ENERGY_COST: 50,
            MAX_BOUNCES: 3,
            TRAIL_LENGTH: 12
        },
        GRENADE: {
            COOLDOWN: 1000,
            EXPLOSION_RADIUS: 4,
            MAX_DAMAGE: 50,
            ENERGY_COST: 100,
            TRAIL_LENGTH: 20
        }
    },
    
    SCENE: {
        BOUNDARY_SIZE: 25,
        GRID_SIZE: 100,
        GRID_DIVISIONS: 100,
        NUM_OBSTACLES: 15,
        MIN_OBSTACLE_DISTANCE: 10
    },
    
    CAMERA: {
        FOV: 75,
        NEAR: 0.1,
        FAR: 1000,
        POSITION: {
            Y: 18,
            Z: -16
        },
        SMOOTHING: 0.05
    },
    
    COLORS: {
        BACKGROUND: 0x000011,
        GRID: {
            MAIN: 0x444444,
            SECONDARY: 0x222222
        },
        LASER: 0x00ffff,
        BOUNCE: 0x00ff99,
        GRENADE: 0xff4500
    },
    
    EFFECTS: {
        PULSE_SPEED: 0.2,
        TRAIL_OPACITY: 0.5,
        GLOW_INTENSITY: 2
    }
};

// Weapon type constants
export const WEAPON_TYPES = {
    LASER: 'LASER',
    BOUNCE: 'BOUNCE',
    GRENADE: 'GRENADE'
}; 
### ./config/GameConfig.js END ###

### ./styles/main.css BEGIN ###
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --neon-text-color: #f40183;
  --neon-border-color: #08f;
  --bg-color: #000;
  --secondary-color: #0ff;
  --accent-color: #ff00ff;
  --success-color: #00ff88;
  --warning-color: #ffaa00;
  --danger-color: #ff3300;
}

body {
  font-family: 'Orbitron', sans-serif;
  background-color: var(--bg-color);
  color: #fff;
  overflow: hidden;
}

/* Loading Screen */
#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--bg-color);
  z-index: 100;
}

.loading-content {
  text-align: center;
}

.loading-content h1 {
  font-size: 4rem;
  margin-bottom: 2rem;
  text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--neon-text-color),
    0 0 20px var(--neon-text-color), 0 0 25px var(--neon-text-color),
    0 0 30px var(--neon-text-color), 0 0 35px var(--neon-text-color);
}

.loader {
  border: 5px solid transparent;
  border-top: 5px solid var(--neon-text-color);
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem;
  box-shadow: 0 0 10px var(--neon-text-color);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Start Screen Enhancements */
#start-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  background: radial-gradient(circle at center, rgba(15, 30, 60, 0.5) 0%, rgba(0, 0, 0, 0.95) 70%);
  overflow: hidden;
}

#start-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(125deg, rgba(0, 60, 255, 0.05), rgba(120, 0, 170, 0.05));
  z-index: -1;
}

.start-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 600px;
  width: 90%;
  padding: 2rem;
  border-radius: 8px;
  background: rgba(5, 10, 20, 0.7);
  box-shadow: 0 0 40px rgba(0, 195, 255, 0.15);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(48, 197, 255, 0.2);
  transform: translateY(0);
  animation: float 6s ease-in-out infinite;
}

@keyframes float {
  0% { transform: translateY(0px); }
  50% { transform: translateY(-15px); }
  100% { transform: translateY(0px); }
}

.start-content h1 {
  font-size: 3.5rem;
  font-weight: 900;
  margin-bottom: 2rem;
  text-align: center;
  color: #fff;
  text-shadow: 
    0 0 10px #ff007b,
    0 0 20px #ff007b,
    0 0 30px #ff007b,
    0 0 40px #ff007b;
  letter-spacing: 0.1em;
  animation: pulsate 2s infinite;
}

@keyframes pulsate {
  0% { text-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 30px #ff007b, 0 0 40px #ff007b; }
  50% { text-shadow: 0 0 15px #ff007b, 0 0 25px #ff007b, 0 0 35px #ff007b, 0 0 50px #ff007b; }
  100% { text-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 30px #ff007b, 0 0 40px #ff007b; }
}

/* Buttons */
.glow-button {
  background-color: transparent;
  color: var(--neon-border-color);
  border: 0.2rem solid var(--neon-border-color);
  border-radius: 0.5rem;
  padding: 1rem 2rem;
  font-size: 1.5rem;
  font-family: 'Orbitron', sans-serif;
  cursor: pointer;
  transition: all 0.3s;
  text-shadow: 0 0 5px var(--neon-border-color), 0 0 10px var(--neon-border-color);
  box-shadow: 0 0 10px var(--neon-border-color), inset 0 0 10px var(--neon-border-color);
}

.glow-button:hover {
  background-color: var(--neon-border-color);
  color: #000;
  box-shadow: 0 0 20px var(--neon-border-color), inset 0 0 20px #000;
}

/* Canvas */
canvas {
  display: block;
}

/* HUD Elements */
.hud {
  position: fixed;
  top: 20px;
  left: 20px;
  color: var(--secondary-color);
  font-size: 1rem;
  text-shadow: 0 0 5px var(--secondary-color);
  z-index: 100;
  pointer-events: none;
}

/* Controls info */
.controls-info {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #00ffff;
  border-radius: 10px;
  padding: 20px;
  color: #fff;
  text-align: center;
  z-index: 1000;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
  animation: fadeIn 0.5s ease-in-out;
}

.controls-info h3 {
  color: #00ffff;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 24px;
}

.controls-info p {
  margin: 8px 0;
  font-size: 16px;
  color: #eee;
}

.controls-info.fade-out {
  animation: fadeOut 0.5s ease-in-out forwards;
}

/* Ensure these keyframes are defined */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Fix hidden class */
.hidden {
  display: none !important;
}

/* Controls */
.control-indicators {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 15px;
  transition: opacity 0.5s ease, transform 0.3s ease;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.4);
  backdrop-filter: blur(5px);
}

.control-indicators.visible {
  opacity: 1;
  transform: translateY(0);
}

.control-indicators.fading {
  opacity: 0.2;
  transform: translateY(10px);
}

.control-indicators.hidden {
  opacity: 0;
  transform: translateY(30px);
  pointer-events: none;
}

.control-group {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}

.movement-controls {
  display: grid;
  grid-template-areas:
    ".    forward    ."
    "left backward right"
    "strafeLeft fire strafeRight";
  grid-gap: 5px;
}

.weapon-controls {
  display: flex;
  justify-content: center;
  gap: 10px;
}

.key-indicator {
  width: 50px;
  height: 50px;
  background: rgba(20, 20, 30, 0.8);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #aaf;
  font-family: 'Rajdhani', sans-serif;
  border: 1px solid rgba(0, 200, 255, 0.2);
  transition: all 0.2s ease;
  box-shadow: 0 0 5px rgba(0, 200, 255, 0.1);
  overflow: hidden;
}

.key-indicator.active {
  background: rgba(0, 150, 200, 0.4);
  color: #fff;
  border-color: rgba(0, 255, 255, 0.8);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
  transform: scale(1.05);
}

.key-indicator .key {
  font-size: 12px;
  background: rgba(0, 0, 0, 0.5);
  padding: 2px 5px;
  border-radius: 4px;
  margin-bottom: 3px;
  font-weight: bold;
}

.key-indicator .label {
  font-size: 18px;
  line-height: 1;
}

.weapon-key {
  background: rgba(30, 20, 40, 0.8);
  border-color: rgba(255, 100, 255, 0.2);
}

.weapon-key.active {
  background: rgba(150, 0, 200, 0.4);
  border-color: rgba(255, 100, 255, 0.8);
  box-shadow: 0 0 15px rgba(255, 100, 255, 0.5);
}

.controls-hint {
  text-align: center;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
  margin-top: 5px;
  font-family: 'Rajdhani', sans-serif;
}

/* Game UI */
.game-ui {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10;
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 220px;
  background: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  backdrop-filter: blur(5px);
  box-shadow: 0 0 15px rgba(0, 200, 255, 0.2);
  border: 1px solid rgba(0, 200, 255, 0.3);
  transition: all 0.3s ease;
}

.game-ui.hidden {
  display: none;
  opacity: 0;
}

.status-bars {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.bar-container {
  display: flex;
  align-items: center;
  gap: 10px;
}

.bar-container {
  flex-direction: row;
}

.bar-label {
  width: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: #fff;
  font-weight: bold;
  order: 1;
}

.bar-outer {
  flex: 1;
  height: 10px;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 5px;
  overflow: hidden;
  position: relative;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
  order: 2;
}

.bar-inner {
  height: 100%;
  transition: width 0.3s ease, background-color 0.3s ease;
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.health-bar {
  background: linear-gradient(90deg, #0f0, #5f0);
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
}

.health-bar.warning {
  background: linear-gradient(90deg, #ff0, #fa0);
  box-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
}

.health-bar.critical {
  background: linear-gradient(90deg, #f00, #a00);
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
  animation: pulse-critical 0.8s infinite;
}

.energy-bar {
  background: linear-gradient(90deg, #00f, #06f);
  box-shadow: 0 0 8px rgba(0, 0, 255, 0.5);
}

.energy-bar.warning {
  background: linear-gradient(90deg, #09f, #07a);
  box-shadow: 0 0 8px rgba(0, 100, 255, 0.5);
}

.energy-bar.critical {
  background: linear-gradient(90deg, #07f, #059);
  box-shadow: 0 0 8px rgba(0, 50, 255, 0.5);
}

.weapon-indicator {
  display: flex;
  align-items: center;
  margin-top: 5px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 5px;
  padding: 5px 10px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.weapon-label {
  font-size: 14px;
  color: #aaa;
  margin-right: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.weapon-name {
  flex: 1;
  text-align: right;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  letter-spacing: 1px;
  text-shadow: 0 0 5px currentColor;
}

.weapon-name.laser {
  color: #0ff;
}

.weapon-name.grenade {
  color: #f70;
}

.weapon-name.bounce {
  color: #0f6;
}

/* Health bar shine effect */
.bar-inner::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 50%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: shine 2s infinite;
}

@keyframes shine {
  0% { left: -100%; }
  100% { left: 200%; }
}

@media (max-width: 768px) {
  .game-ui {
    top: 10px;
    left: 10px;
    width: 180px;
    padding: 10px;
  }
  
  .bar-label, .weapon-label {
    font-size: 12px;
  }
  
  .weapon-name {
    font-size: 14px;
  }
}

.bar-percentage {
  margin-left: 5px;
  color: #fff;
  font-size: 12px;
  min-width: 40px;
  text-align: right;
  order: 3;
}

/* Position indicators in the grid */
#indicator-forward { grid-area: forward; }
#indicator-backward { grid-area: backward; }
#indicator-left { grid-area: left; }
#indicator-right { grid-area: right; }
#indicator-strafeLeft { grid-area: strafeLeft; }
#indicator-strafeRight { grid-area: strafeRight; }
#indicator-fire { grid-area: fire; }

/* Special styling for fire key */
#indicator-fire {
  width: 80px;
  grid-column: span 3;
}

/* Collision Flash Effect */
.collision-flash {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 0, 0, 0.2);
  z-index: 1000;
  pointer-events: none;
  animation: flash 0.15s ease-out;
}

@keyframes flash {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

/* Score Display */
.score-display {
  position: fixed;
  top: 20px;
  right: 20px;
  font-size: 1.5rem;
  color: var(--neon-text-color);
  text-shadow: 0 0 5px var(--neon-text-color);
  z-index: 100;
}

/* Mobile Touch Controls */
.touch-controls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 90;
  display: none; /* Hidden by default, shown on touch devices */
  justify-content: space-between;
  align-items: center;
  pointer-events: none;
  height: 120px;
}

/* Media query for touch devices */
@media (pointer: coarse) {
  .touch-controls {
    display: flex;
  }
  
  .controls-info {
    display: none; /* Hide keyboard controls info on touch devices */
  }
}

/* Controls toggle button for touch devices */
.controls-toggle-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 101;
  background: rgba(0, 0, 0, 0.6);
  color: #00ffff;
  border: 1px solid rgba(0, 255, 255, 0.4);
  border-radius: 10px;
  padding: 10px 15px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 16px;
  cursor: pointer;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  transition: all 0.3s ease;
  display: none; /* Hidden by default, shown on touch devices */
}

.controls-toggle-button:hover,
.controls-toggle-button:active {
  background: rgba(0, 50, 70, 0.8);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

/* Responsive designs for different devices */

/* Base styles (desktop) */
.control-indicators {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 15px;
  transition: opacity 0.5s ease, transform 0.3s ease;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.4);
  backdrop-filter: blur(5px);
}

.key-indicator {
  width: 50px;
  height: 50px;
}

.key-indicator .key {
  font-size: 12px;
}

.key-indicator .label {
  font-size: 18px;
}

/* Large tablet and desktop (landscape) */
@media (min-width: 1024px) {
  .control-indicators {
    bottom: 30px;
    left: 30px;
    padding: 20px;
  }
  
  .key-indicator {
    width: 60px;
    height: 60px;
  }
  
  .key-indicator .key {
    font-size: 14px;
  }
  
  .key-indicator .label {
    font-size: 22px;
  }
  
  .game-ui {
    top: 30px;
    left: 30px;
    width: 250px;
  }
}

/* iPad and smaller tablets */
@media (min-width: 768px) and (max-width: 1023px) {
  .control-indicators {
    bottom: 20px;
    left: 20px;
    padding: 15px;
  }
  
  .key-indicator {
    width: 55px;
    height: 55px;
  }
  
  .game-ui {
    width: 220px;
  }
}

/* Mobile phones (portrait) */
@media (max-width: 767px) {
  .control-indicators {
    bottom: 10px;
    left: 10px;
    padding: 10px;
    gap: 8px;
  }
  
  .key-indicator {
    width: 40px;
    height: 40px;
  }
  
  .key-indicator .key {
    font-size: 10px;
  }
  
  .key-indicator .label {
    font-size: 14px;
  }
  
  .game-ui {
    top: 10px;
    left: 10px;
    width: 180px;
    padding: 10px;
  }
  
  .bar-label, .weapon-label {
    font-size: 12px;
  }
  
  .weapon-name {
    font-size: 14px;
  }
  
  .controls-toggle-button {
    display: block;
    font-size: 14px;
    padding: 8px 12px;
  }
}

/* Very small screens and iPhones in portrait */
@media (max-width: 375px) {
  .control-indicators {
    bottom: 5px;
    left: 5px;
    padding: 8px;
    gap: 5px;
  }
  
  .key-indicator {
    width: 35px;
    height: 35px;
  }
  
  .key-indicator .key {
    font-size: 8px;
  }
  
  .key-indicator .label {
    font-size: 12px;
  }
  
  .game-ui {
    width: 150px;
  }
}

/* Touch device specific styles */
@media (pointer: coarse) {
  .controls-toggle-button {
    display: block;
  }
  
  /* Make touch targets larger */
  .key-indicator {
    min-width: 44px;
    min-height: 44px;
  }
}

/* iPhone-specific fixes - ensure proper viewport */
@media only screen and (max-device-width: 812px) and (-webkit-min-device-pixel-ratio: 2) {
  .touch-controls {
    bottom: env(safe-area-inset-bottom, 20px);
    padding-bottom: 10px;
  }
  
  .controls-toggle-button {
    bottom: env(safe-area-inset-bottom, 20px);
    right: env(safe-area-inset-right, 20px);
  }
}

/* Fix for notched phones */
@supports (padding: max(0px)) {
  .touch-controls {
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }
}

.joystick-container {
  width: 150px;
  height: 150px;
  margin-left: 10px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
}

.joystick {
  width: 100px;
  height: 100px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 50%;
  border: 2px solid rgba(0, 200, 255, 0.3);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.2);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.joystick-knob {
  width: 40px;
  height: 40px;
  background: rgba(0, 200, 255, 0.7);
  border-radius: 50%;
  box-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
  position: absolute;
  transition: transform 0.1s ease;
}

.touch-button {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  background: rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
  border: 2px solid rgba(0, 200, 255, 0.3);
  pointer-events: auto;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.fire-button {
  margin-right: 10px;
  background: rgba(50, 0, 0, 0.5);
  border-color: rgba(255, 100, 100, 0.4);
  box-shadow: 0 0 10px rgba(255, 100, 100, 0.3);
}

.weapon-button {
  margin-right: 90px;
  background: rgba(0, 30, 50, 0.5);
}

/* Mini-Map */
.mini-map-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 95;
  width: 180px;
  height: 180px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 8px;
  padding: 5px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.3);
  backdrop-filter: blur(3px);
  transition: all 0.3s ease;
  transform-origin: bottom right;
  overflow: hidden;
}

.mini-map-container.hidden {
  transform: scale(0);
  opacity: 0;
}

.mini-map {
  width: 100%;
  height: 100%;
  background: rgba(0, 20, 40, 0.4);
  border-radius: 5px;
  border: 1px solid rgba(0, 255, 255, 0.2);
  overflow: hidden;
}

.mini-map canvas {
  width: 100%;
  height: 100%;
}

/* Subtle M key hint */
.mini-map-hint {
  position: absolute;
  bottom: 7px;
  right: 7px;
  font-size: 10px;
  color: rgba(0, 255, 255, 0.5);
  font-family: 'Rajdhani', sans-serif;
  opacity: 0.7;
  text-shadow: 0 0 2px rgba(0, 255, 255, 0.5);
  pointer-events: none;
}

/* Responsive adjustments for mini-map */
@media (max-width: 768px) {
  .mini-map-container {
    width: 150px;
    height: 150px;
  }
}

@media (max-width: 480px) {
  .mini-map-container {
    bottom: 150px; /* Position above touch controls on mobile */
    width: 120px;
    height: 120px;
  }
}

/* Game container */
#game-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 1;
}

#game-container canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Error screen */
#error-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 1100;
  color: #ff0000;
}

/* Animations */
.fade-in {
  animation: fadeIn 0.5s ease-in forwards;
}

.fade-out {
  animation: fadeOut 0.5s ease-out forwards;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Controls display */
#controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  padding: 15px;
  border-radius: 10px;
  z-index: 700;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
  border: 1px solid rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
}

#controls.visible {
  opacity: 1;
  visibility: visible;
}

.control-section {
  margin: 10px;
  display: flex;
  gap: 10px;
  align-items: center;
}

.control-indicator {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 8px 12px;
  border-radius: 5px;
  background: rgba(0, 20, 40, 0.6);
  border: 1px solid rgba(0, 255, 255, 0.1);
  transition: all 0.2s ease;
}

.control-indicator.active {
  background: rgba(0, 100, 150, 0.4);
  border-color: rgba(0, 255, 255, 0.5);
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
}

/* Touch controls */
.touch-controls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 600;
  display: none;
}

@media (hover: none) and (pointer: coarse) {
  .touch-controls {
    display: block;
  }
}

.joystick-container {
  width: 120px;
  height: 120px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  position: relative;
}

.joystick {
  width: 60px;
  height: 60px;
  background: rgba(0, 255, 255, 0.3);
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.touch-button {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  color: #fff;
  font-size: 12px;
  text-align: center;
}

.ship-selection {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50%;
    max-width: 600px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ffff;
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    z-index: 1000;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

.ship-selection.visible {
    opacity: 1;
    visibility: visible;
}

.ship-selection.hidden {
    opacity: 0;
    visibility: hidden;
}

.ship-selection-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.3);
}

.ship-selection-header h2 {
    color: #00ffff;
    margin: 0;
    font-size: 18px;
}

.ships-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 10px;
}

.ship-option {
    background: rgba(0, 20, 40, 0.5);
    border: 1px solid #333;
    border-radius: 8px;
    padding: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 13px;
}

.ship-option h3 {
    color: #00ffff;
    margin: 0 0 2px 0;
    font-size: 15px;
}

.ship-option p {
    margin: 0 0 5px 0;
    font-size: 11px;
}

.stat {
    margin: 3px 0;
    display: flex;
    align-items: center;
}

.stat label {
    display: inline-block;
    width: 80px;
    color: #888;
    font-size: 11px;
}

.preview-section {
    text-align: center;
    margin-bottom: 10px;
}

.preview-section h3 {
    color: #00ffff;
    margin-bottom: 5px;
    font-size: 15px;
}

#ship-preview {
    width: 100%;
    height: 150px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #333;
}

.ship-details {
    padding: 8px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    margin-bottom: 10px;
    border: 1px solid #333;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-gap: 10px;
}

.ship-details-left {
    grid-column: 1;
}

.ship-details-right {
    grid-column: 2;
}

.ship-name {
    color: #00ffff;
    margin: 0 0 2px 0;
    font-size: 15px;
    grid-column: 1 / -1;
}

.ship-description {
    color: #aaa;
    margin-bottom: 5px;
    font-size: 11px;
    grid-column: 1 / -1;
}

.special-abilities {
    margin-top: 5px;
}

.special-abilities h4 {
    color: #00ffff;
    margin: 0 0 5px 0;
    font-size: 13px;
}

.ability {
    display: inline-block;
    margin: 2px;
    padding: 3px 6px;
    background: rgba(0, 255, 255, 0.1);
    border: 1px solid #00ffff;
    border-radius: 4px;
    color: #00ffff;
    font-size: 11px;
}

.launch-button {
    display: block;
    width: 150px;
    margin: 0 auto;
    padding: 8px 15px;
    background: #00ff00;
    border: none;
    border-radius: 5px;
    color: #000;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    align-self: center;
}

.stat-bar {
    display: inline-block;
    flex: 1;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    margin: 0 5px;
}

.stat-bar > div {
    height: 100%;
    background: #00ffff;
    transition: width 0.3s ease;
}

.stat-value {
    width: 40px;
    text-align: right;
    color: #00ffff;
    font-size: 11px;
}

.visible {
    display: flex;
    flex-direction: column;
}

/* Player Name Input Styling */
.player-input {
  margin: 20px 0 30px;
  width: 100%;
  max-width: 350px;
  position: relative;
}

#player-name {
  width: 100%;
  padding: 15px 20px;
  border: 2px solid #30c5ff;
  background-color: rgba(0, 10, 30, 0.7);
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  text-align: center;
  border-radius: 4px;
  box-shadow: 
    0 0 10px rgba(48, 197, 255, 0.5),
    0 0 20px rgba(48, 197, 255, 0.2);
  transition: all 0.3s ease;
  outline: none;
  letter-spacing: 1px;
  position: relative;
  backdrop-filter: blur(5px);
}

#player-name:focus {
  border-color: #ff3e88;
  box-shadow: 
    0 0 15px rgba(255, 62, 136, 0.6),
    0 0 30px rgba(255, 62, 136, 0.3);
  transform: scale(1.02);
}

#player-name::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.input-info {
  margin-top: 10px;
  font-size: 12px;
  color: #8af3ff;
  text-align: center;
  opacity: 0.8;
  letter-spacing: 0.5px;
  font-weight: 400;
}

/* Enhanced Start Button */
#start-button {
  margin-top: 20px;
  padding: 15px 40px;
  font-size: 18px;
  font-weight: 600;
  letter-spacing: 2px;
  color: #fff;
  background: linear-gradient(45deg, #0062ff, #00c3ff);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 
    0 0 15px rgba(0, 195, 255, 0.7),
    0 0 30px rgba(0, 195, 255, 0.4);
  position: relative;
  overflow: hidden;
  font-family: 'Orbitron', sans-serif;
  text-transform: uppercase;
}

#start-button::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    to bottom right,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.1) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  transform: rotate(45deg);
  animation: shine 3s infinite;
}

#start-button:hover {
  transform: translateY(-3px) scale(1.05);
  box-shadow: 
    0 0 20px rgba(0, 195, 255, 0.8),
    0 0 40px rgba(0, 195, 255, 0.5);
  background: linear-gradient(45deg, #00c3ff, #0062ff);
}

#start-button:active {
  transform: translateY(1px) scale(0.98);
  box-shadow: 
    0 0 10px rgba(0, 195, 255, 0.6),
    0 0 20px rgba(0, 195, 255, 0.3);
}

@keyframes shine {
  0% { left: -100%; }
  20% { left: 100%; }
  100% { left: 100%; }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .start-content h1 {
    font-size: 2.5rem;
  }
  
  #player-name {
    font-size: 14px;
    padding: 12px 15px;
  }
  
  #start-button {
    padding: 12px 30px;
    font-size: 16px;
  }
}

@media (max-width: 480px) {
  .start-content h1 {
    font-size: 2rem;
  }
  
  .start-content {
    padding: 1.5rem;
  }
}

/* Multiplayer Information */
#multiplayer-info {
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  color: #00ffff;
  padding: 10px;
  border-radius: 5px;
  font-family: 'Orbitron', sans-serif;
  border: 1px solid #00ffff;
  z-index: 100;
}

.connection-indicator, .players-indicator {
  margin: 5px 0;
  display: flex;
  justify-content: space-between;
}

#connection-status {
  color: #ff3333;
  font-weight: bold;
}

#connection-status.connected {
  color: #33ff33;
}

#players-count {
  color: #ffff33;
  font-weight: bold;
}

/* Player Labels */
.player-label {
  color: #00ffff;
  font-family: 'Orbitron', sans-serif;
  padding: 2px 6px;
  border-radius: 4px;
  background-color: rgba(0, 0, 0, 0.7);
  font-size: 10px;
  white-space: nowrap;
  text-align: center;
  transform: translate(-50%, -50%);
  pointer-events: none;
  text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
} 
### ./styles/main.css END ###

### ./styles/controls.css BEGIN ###
#controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 10px;
    z-index: 1000;
    transition: opacity 0.5s ease;
    pointer-events: none;
}

.control-section {
    display: flex;
    gap: 10px;
    padding: 0 15px;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
}

.control-section:last-child {
    border-right: none;
}

.control-indicator {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 40px;
}

.control-indicator .key {
    background: rgba(255, 255, 255, 0.1);
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 12px;
    color: #fff;
    margin-bottom: 4px;
}

.control-indicator .label {
    font-size: 16px;
    color: #fff;
}

.control-indicator .tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
}

.control-indicator:hover .tooltip {
    opacity: 1;
}

/* Mobile and tablet adjustments */
@media (max-width: 768px) {
    #controls {
        flex-direction: column;
        bottom: 10px;
        gap: 10px;
        padding: 10px;
    }
    
    .control-section {
        border-right: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding: 10px 0;
    }
    
    .control-section:last-child {
        border-bottom: none;
    }
    
    .control-indicator {
        min-width: 30px;
    }
    
    .control-indicator .key {
        font-size: 10px;
        padding: 3px 6px;
    }
    
    .control-indicator .label {
        font-size: 14px;
    }
} 
### ./styles/controls.css END ###

### ./assets/ModelLoader.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader';

// Manager to handle and cache all loaded models
export class ModelLoader {
  constructor() {
    // Cache for storing loaded models to avoid reloading
    this.modelCache = new Map();
    
    // Create loaders
    this.gltfLoader = new GLTFLoader();
    
    // Loading manager to track progress
    this.loadingManager = new THREE.LoadingManager();
    this.loadingManager.onProgress = (url, loaded, total) => {
      const progress = (loaded / total) * 100;
      console.log(`Loading: ${Math.round(progress)}% (${url})`);
    };
    
    // Set up loaders with manager
    this.gltfLoader.manager = this.loadingManager;
  }
  
  /**
   * Load a 3D model from path
   * @param {string} path - Path to the model file, relative to the assets directory
   * @returns {Promise} - Promise that resolves with the loaded model
   */
  loadModel(path) {
    // Add assets prefix for webpack build
    const assetPath = path.startsWith('assets/') ? path : `assets/${path}`;
    
    // Check if model is already in cache
    if (this.modelCache.has(assetPath)) {
      return Promise.resolve(this.modelCache.get(assetPath).clone());
    }
    
    // If not in cache, load it
    return new Promise((resolve, reject) => {
      this.gltfLoader.load(
        assetPath,
        (gltf) => {
          // Store original in cache
          this.modelCache.set(assetPath, gltf.scene.clone());
          
          // Process the model for better performance
          this.processModel(gltf.scene);
          
          resolve(gltf.scene);
        },
        (progress) => {
          // Optional progress callback
        },
        (error) => {
          console.error(`Error loading model from ${assetPath}:`, error);
          reject(error);
        }
      );
    });
  }
  
  /**
   * Process model to optimize it
   * @param {THREE.Group} model - The loaded model
   */
  processModel(model) {
    console.log('Processing model in ModelLoader, initial scale:', model.scale.x, model.scale.y, model.scale.z);
    
    // Traverse the model and optimize materials, geometries, etc.
    model.traverse((node) => {
      if (node.isMesh) {
        console.log(`ModelLoader found mesh: ${node.name}, Scale:`, node.scale);
        
        // Enable shadows
        node.castShadow = true;
        node.receiveShadow = true;
        
        // Keep materials but ensure they're properly configured
        if (node.material) {
          // Ensure material has appropriate render settings
          node.material.needsUpdate = true;
        }
      }
    });
    
    // Center the model if needed
    this.centerModel(model);
    
    console.log('Model after processing, final scale:', model.scale.x, model.scale.y, model.scale.z);
  }
  
  /**
   * Center the model at its geometric center
   * @param {THREE.Group} model - The model to center
   */
  centerModel(model) {
    // Create a bounding box for the model
    const boundingBox = new THREE.Box3().setFromObject(model);
    
    // Calculate the center of the bounding box
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    
    // Move the model so its center is at the origin
    model.position.sub(center);
  }
  
  /**
   * Clear the model cache (useful when memory needs to be freed)
   */
  clearCache() {
    this.modelCache.clear();
  }
  
  /**
   * Get a list of all loaded model paths
   * @returns {Array} - Array of paths to loaded models
   */
  getLoadedModelPaths() {
    return Array.from(this.modelCache.keys());
  }
} 
### ./assets/ModelLoader.js END ###

### ./assets/SoundManager.js BEGIN ###
import * as THREE from 'three';

/**
 * SoundManager class for managing game audio
 */
export class SoundManager {
  constructor() {
    // Initialize audio listeners, buffers, and sources
    this.listener = new THREE.AudioListener();
    this.sounds = new Map();
    this.music = null;
    this.isMuted = false;
    
    // Default volumes
    this.effectsVolume = 0.5;
    this.musicVolume = 0.3;
    
    // Preload common sounds
    this.preloadSounds();
    
    // Setup audio control buttons
    this.setupAudioControls();
  }
  
  /**
   * Preload common game sounds
   */
  preloadSounds() {
    // Create a sound loader
    const audioLoader = new THREE.AudioLoader();
    
    // Define common sounds to preload with updated paths
    const soundsToLoad = [
      { name: 'laser', path: 'assets/sounds/laser.mp3' },
      { name: 'explosion', path: 'assets/sounds/explosion.mp3' },
      { name: 'hit', path: 'assets/sounds/hit.mp3' },
      { name: 'powerup', path: 'assets/sounds/powerup.mp3' },
      { name: 'engine', path: 'assets/sounds/engine.mp3', loop: true },
      { name: 'laser-bounce', path: 'assets/sounds/laser-bounce.mp3' },
      { name: 'weapon-switch', path: 'assets/sounds/weapon-switch.mp3' },
      { name: 'collision', path: 'assets/sounds/collision.mp3' },
      { name: 'weapon-charging', path: 'assets/sounds/weapon-charging.mp3' },
      { name: 'bounce', path: 'assets/sounds/bounce.mp3' },
      { name: 'weapon-armor-hit', path: 'assets/sounds/weapon-armor-hit.mp3' },
      { name: 'grenade-laser', path: 'assets/sounds/grenade-laser.mp3' }
    ];
    
    // Load each sound
    soundsToLoad.forEach(soundInfo => {
      try {
        const sound = new THREE.Audio(this.listener);
        
        audioLoader.load(
          soundInfo.path,
          buffer => {
            sound.setBuffer(buffer);
            sound.setVolume(this.effectsVolume);
            if (soundInfo.loop) {
              sound.setLoop(true);
            }
            this.sounds.set(soundInfo.name, sound);
            console.log(`Loaded sound: ${soundInfo.name}`);
          },
          xhr => {
            console.log(`${soundInfo.name}: ${(xhr.loaded / xhr.total * 100)}% loaded`);
          },
          error => {
            console.error(`Error loading sound ${soundInfo.name}:`, error);
          }
        );
      } catch (error) {
        console.error(`Failed to setup sound ${soundInfo.name}:`, error);
      }
    });
    
    // Load background music with updated path
    try {
      this.music = new THREE.Audio(this.listener);
      audioLoader.load(
        'assets/sounds/background_music.mp3',
        buffer => {
          this.music.setBuffer(buffer);
          this.music.setVolume(this.musicVolume);
          this.music.setLoop(true);
        },
        xhr => {
          console.log(`Background music: ${(xhr.loaded / xhr.total * 100)}% loaded`);
        },
        error => {
          console.error('Error loading background music:', error);
        }
      );
    } catch (error) {
      console.error('Failed to setup background music:', error);
    }
  }
  
  /**
   * Setup audio control buttons
   */
  setupAudioControls() {
    // Add event listeners for audio controls if they exist in the DOM
    const muteButton = document.getElementById('mute-button');
    if (muteButton) {
      muteButton.addEventListener('click', () => this.toggleMute());
    }
    
    const effectsVolumeSlider = document.getElementById('effects-volume');
    if (effectsVolumeSlider) {
      effectsVolumeSlider.value = this.effectsVolume * 100;
      effectsVolumeSlider.addEventListener('input', (e) => {
        this.setEffectsVolume(e.target.value / 100);
      });
    }
    
    const musicVolumeSlider = document.getElementById('music-volume');
    if (musicVolumeSlider) {
      musicVolumeSlider.value = this.musicVolume * 100;
      musicVolumeSlider.addEventListener('input', (e) => {
        this.setMusicVolume(e.target.value / 100);
      });
    }
  }
  
  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.isMuted) return;
    
    const sound = this.sounds.get(name);
    if (!sound) {
      console.warn(`Sound '${name}' not found`);
      return;
    }
    
    let soundToPlay = sound;
    
    // If sound is already playing, create a new instance
    if (sound.isPlaying) {
      try {
        // Create a new audio instance
        if (position) {
          // For positional audio
          const soundClone = new THREE.PositionalAudio(this.listener);
          soundClone.setBuffer(sound.buffer);
          soundClone.setVolume(this.effectsVolume);
          soundClone.setRefDistance(10); // Distance at which the volume is at full
          soundToPlay = soundClone;
        } else {
          // For non-positional audio - create new instead of cloning
          const soundClone = new THREE.Audio(this.listener);
          soundClone.setBuffer(sound.buffer);
          soundClone.setVolume(this.effectsVolume);
          soundToPlay = soundClone;
        }
        
        // Clean up clone after playing
        soundToPlay.onEnded = () => {
          if (soundToPlay.source) {
            soundToPlay.disconnect();
            soundToPlay.source = null; // Prevent memory leaks
          }
        };
      } catch (error) {
        console.error("Error creating new sound instance:", error);
        // If cloning fails, don't play any sound rather than crashing
        return;
      }
    }
    
    // If position is provided, make it positional
    if (position && !sound.isPlaying) {
      // We're using the original sound, convert it to positional if needed
      if (!(soundToPlay instanceof THREE.PositionalAudio)) {
        try {
          // Create new positional audio
          const positionalSound = new THREE.PositionalAudio(this.listener);
          positionalSound.setBuffer(sound.buffer);
          positionalSound.setVolume(this.effectsVolume);
          positionalSound.setRefDistance(10);
          soundToPlay = positionalSound;
        } catch (error) {
          console.error("Error creating positional audio:", error);
          // Fall back to non-positional
        }
      }
    }
    
    // Apply position if provided
    if (position && soundToPlay instanceof THREE.PositionalAudio) {
      try {
        // Check if we need to add this to an object in the scene
        const dummyObject = new THREE.Object3D();
        dummyObject.position.copy(position);
        dummyObject.add(soundToPlay);
        
        // Cleanup function to remove the dummy object after playing
        soundToPlay.onEnded = () => {
          if (dummyObject.parent) dummyObject.parent.remove(dummyObject);
          if (soundToPlay.source) {
            soundToPlay.disconnect();
            soundToPlay.source = null;
          }
        };
        
        // Add to scene or listener (we assume listener is in scene)
        if (this.listener && this.listener.parent) {
          this.listener.parent.add(dummyObject);
        } else {
          console.warn('Audio listener has no parent, positional audio may not work correctly');
          // Just play non-positional as fallback
        }
      } catch (error) {
        console.error("Error setting up positional audio:", error);
        // Fall back to just playing the sound
      }
    }
    
    // Play the sound
    try {
      soundToPlay.play();
    } catch (error) {
      console.error("Error playing sound:", error);
    }
  }
  
  /**
   * Start playing background music
   */
  playMusic() {
    if (this.isMuted || !this.music || this.music.isPlaying) return;
    
    this.music.play();
  }
  
  /**
   * Stop background music
   */
  stopMusic() {
    if (!this.music || !this.music.isPlaying) return;
    
    this.music.stop();
  }
  
  /**
   * Toggle mute state for all audio
   */
  toggleMute() {
    this.isMuted = !this.isMuted;
    
    // Update mute button if it exists
    const muteButton = document.getElementById('mute-button');
    if (muteButton) {
      muteButton.textContent = this.isMuted ? '🔇' : '🔊';
    }
    
    if (this.isMuted) {
      // Pause all sounds
      this.sounds.forEach(sound => {
        if (sound.isPlaying) {
          sound.pause();
        }
      });
      
      // Pause music
      if (this.music && this.music.isPlaying) {
        this.music.pause();
      }
    } else {
      // Resume music
      if (this.music && !this.music.isPlaying) {
        this.music.play();
      }
    }
  }
  
  /**
   * Set volume for sound effects
   * @param {number} volume - Volume level (0-1)
   */
  setEffectsVolume(volume) {
    this.effectsVolume = Math.max(0, Math.min(1, volume));
    
    // Update all sound effects with new volume
    this.sounds.forEach(sound => {
      sound.setVolume(this.effectsVolume);
    });
  }
  
  /**
   * Set volume for background music
   * @param {number} volume - Volume level (0-1)
   */
  setMusicVolume(volume) {
    this.musicVolume = Math.max(0, Math.min(1, volume));
    
    if (this.music) {
      this.music.setVolume(this.musicVolume);
    }
  }
  
  /**
   * Get the audio listener for positioning
   * @returns {THREE.AudioListener} The audio listener
   */
  getListener() {
    return this.listener;
  }
} 
### ./assets/SoundManager.js END ###

### ./assets/AssetLoader.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';

class AssetLoader {
    constructor() {
        this.loadingState = {
            started: false,
            completed: false,
            errors: [],
            timeouts: new Map(),
            retryCount: new Map(),
            maxRetries: 3,
            loadingPromises: new Map()
        };

        this.assets = {
            models: new Map(),
            sounds: new Map(),
            textures: new Map()
        };

        this.onProgress = null;
        this.onError = null;
    }

    setCallbacks(onProgress, onError) {
        this.onProgress = onProgress;
        this.onError = onError;
        return this;
    }

    async loadAll() {
        if (this.loadingState.started) {
            console.warn('Asset loading already in progress');
            return;
        }

        this.loadingState.started = true;
        this.loadingState.completed = false;
        this.loadingState.errors = [];

        try {
            const modelsToLoad = [
                'ships/ALTSPACE1.glb',
                'ships/ALTSPACE2.glb',
                'terrain/Terrain.glb',
                'terrain/Water.glb',
                'objects/SP_Stone01.glb',
                'objects/SP_Ground05.glb'
            ];

            const loader = new GLTFLoader();
            
            for (const model of modelsToLoad) {
                try {
                    const loaded = await this.loadWithRetry(() => 
                        this.loadModel(loader, model, `assets/models/${model}`)
                    );
                    if (loaded) {
                        console.log(`✅ Successfully loaded model: ${model}`);
                        
                        // Add aliases for ship models
                        if (model === 'ships/ALTSPACE1.glb') {
                            this.assets.models.set('FIGHTER', this.assets.models.get(model));
                            this.assets.models.set('SCOUT', this.assets.models.get(model));
                        } else if (model === 'ships/ALTSPACE2.glb') {
                            this.assets.models.set('INTERCEPTOR', this.assets.models.get(model));
                            this.assets.models.set('EXPERIMENTAL', this.assets.models.get(model));
                        }
                    }
                } catch (error) {
                    console.error(`⛔ Failed to load model ${model}:`, error);
                    this.handleError('model', error);
                }
            }

            this.loadingState.completed = true;
            return true;
        } catch (error) {
            this.handleError('critical', error);
            return false;
        }
    }

    async loadModel(loader, key, path) {
        return new Promise((resolve, reject) => {
            console.log(`🔍 Actually loading model: ${key} from: ${path}`);
            
            const timeoutId = setTimeout(() => {
                reject(new Error(`Model loading timeout: ${key}`));
            }, 15000);

            loader.load(
                path,
                (gltf) => {
                    clearTimeout(timeoutId);
                    console.log(`✅ Successfully loaded model: ${key}`);
                    
                    // Store the original model before any scaling
                    this.assets.models.set(key, gltf.scene);
                    this.onProgress?.(`Loaded model: ${key}`);
                    resolve();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100);
                    this.onProgress?.(`Loading ${key}: ${Math.round(percent)}%`);
                },
                (error) => {
                    clearTimeout(timeoutId);
                    console.error(`⛔ Error loading model ${key}:`, error.message);
                    reject(new Error(`Error loading model ${key}: ${error.message}`));
                }
            );
        });
    }

    async loadTextures() {
        const textureLoader = new THREE.TextureLoader();
        const texturePaths = {
            // Add texture paths when needed
        };

        const loadPromises = Object.entries(texturePaths).map(([key, path]) => {
            return this.loadWithRetry(() => this.loadTexture(textureLoader, key, path));
        });

        await Promise.all(loadPromises);
    }

    async loadTexture(loader, key, path) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Texture loading timeout: ${key}`));
            }, 10000);

            loader.load(
                path,
                (texture) => {
                    clearTimeout(timeoutId);
                    this.assets.textures.set(key, texture);
                    this.onProgress?.(`Loaded texture: ${key}`);
                    resolve();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100);
                    this.onProgress?.(`Loading ${key}: ${Math.round(percent)}%`);
                },
                (error) => {
                    clearTimeout(timeoutId);
                    reject(new Error(`Error loading texture ${key}: ${error.message}`));
                }
            );
        });
    }

    async loadWithRetry(loadFunction) {
        const key = loadFunction.name || 'unknown';
        let retryCount = 0;

        while (retryCount < this.loadingState.maxRetries) {
            try {
                return await loadFunction();
            } catch (error) {
                retryCount++;
                if (retryCount === this.loadingState.maxRetries) {
                    this.handleError(key, error);
                    throw error;
                }
                console.warn(`Retrying ${key} (attempt ${retryCount}/${this.loadingState.maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            }
        }
    }

    handleError(assetType, error) {
        console.error(`Error loading ${assetType}:`, error);
        this.loadingState.errors.push({ type: assetType, error: error.message });
        this.onError?.(assetType, error.message);
    }

    getModel(key) {
        return this.assets.models.get(key);
    }

    getTexture(key) {
        return this.assets.textures.get(key);
    }

    isLoaded() {
        return this.loadingState.completed;
    }

    getErrors() {
        return this.loadingState.errors;
    }

    cleanup() {
        // Dispose of all loaded assets
        this.assets.models.forEach(model => {
            model.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        });

        this.assets.textures.forEach(texture => texture.dispose());

        // Clear all maps
        this.assets.models.clear();
        this.assets.textures.clear();

        // Reset loading state
        this.loadingState = {
            started: false,
            completed: false,
            errors: [],
            timeouts: new Map(),
            retryCount: new Map(),
            maxRetries: 3,
            loadingPromises: new Map()
        };
    }

    // Force ship sizes to be consistent
    normalizeShipSizes() {
        console.log('🛠️ NORMALIZING SHIP SIZES');
        
        // Check what models we have
        const modelKeys = Array.from(this.assets.models.keys());
        console.log('Available models:', modelKeys);
        
        // Skip if no models are loaded
        if (this.assets.models.size === 0) {
            console.warn('⚠️ No models loaded yet, skipping normalization');
            return;
        }
        
        // Set all models to scale 1
        modelKeys.forEach(key => {
            try {
                const model = this.assets.models.get(key);
                if (model) {
                    console.log(`Setting standard scale 1.0 for ${key}`);
                    model.scale.set(1, 1, 1);
                }
            } catch (error) {
                console.error(`Error setting scale for model ${key}:`, error);
            }
        });
        
        console.log('🛠️ SHIP SIZE NORMALIZATION COMPLETE');
    }
    
    // Method to get a cloned ship model
    getShipModel(key) {
        try {
            console.log(`Getting ship model: ${key}`);
            
            // First try direct key lookup
            let model = this.assets.models.get(key);
            
            // If not found, try the file path
            if (!model) {
                model = this.assets.models.get(`ships/${key}.glb`);
            }
            
            // If still not found, try aliases
            if (!model) {
                console.log(`Trying to find model by alias: ${key}`);
                if (key === 'FIGHTER' || key === 'SCOUT') {
                    model = this.assets.models.get('ships/ALTSPACE1.glb');
                } else if (key === 'INTERCEPTOR' || key === 'EXPERIMENTAL') {
                    model = this.assets.models.get('ships/ALTSPACE2.glb');
                }
            }
            
            if (!model) {
                console.warn(`Ship model with key "${key}" not found!`);
                return null;
            }
            
            return this.cloneAndPrepareModel(model);
        } catch (error) {
            console.error(`Error cloning ship model ${key}:`, error);
            return null;
        }
    }

    // New method to handle model cloning and preparation
    cloneAndPrepareModel(model) {
        // DIAGNOSTIC: Log scale before cloning
        console.log(`DIAGNOSTIC: Original model scale before clone - [${model.scale.x}, ${model.scale.y}, ${model.scale.z}]`);
        
        // Clone the model
        const cloned = model.clone();
        
        // Apply consistent scaling as specified in Task 12
        cloned.scale.set(0.45, 0.45, 0.45);
        
        // Ensure materials are properly cloned
        cloned.traverse(node => {
            if (node.isMesh && node.material) {
                // Clone material to prevent sharing between instances
                node.material = node.material.clone();
                
                // Ensure material properties are set
                if (!node.material.color) node.material.color = new THREE.Color(0xffffff);
                if (!node.material.emissive) node.material.emissive = new THREE.Color(0x000000);
                
                // Enable shadows
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // DIAGNOSTIC: Log scale after cloning
        console.log(`DIAGNOSTIC: Cloned model scale - [${cloned.scale.x}, ${cloned.scale.y}, ${cloned.scale.z}]`);
        
        return cloned;
    }

    // Method to get a cloned ship model for opponents
    getOpponentShipModel(key) {
        try {
            console.log(`Getting opponent ship model: ${key}`);
            // Use the same model loading logic as getShipModel
            const model = this.getShipModel(key);
            
            if (!model) {
                console.warn(`No model found for opponent ship type: ${key}`);
                return null;
            }
            
            // Clone the model to ensure each opponent has their own instance
            const clonedModel = model.clone();
            
            // Apply any opponent-specific modifications here if needed
            // For example, different materials or effects
            
            return clonedModel;
        } catch (error) {
            console.error(`Error getting opponent ship model ${key}:`, error);
            return null;
        }
    }

    // Add the loadModels method used by ShipSelectionUI
    async loadModels() {
        console.log('Loading ship models for selection UI');
        
        if (this.assets.models.has('FIGHTER') && this.assets.models.has('INTERCEPTOR')) {
            console.log('Ship models already loaded, using cached versions');
            return true;
        }
        
        const shipModels = [
            'ships/ALTSPACE1.glb',
            'ships/ALTSPACE2.glb'
        ];
        
        const loader = new GLTFLoader();
        
        for (const model of shipModels) {
            try {
                const loaded = await this.loadWithRetry(() => 
                    this.loadModel(loader, model, `assets/models/${model}`)
                );
                if (loaded) {
                    console.log(`✅ Successfully loaded ship model: ${model} for selection UI`);
                    
                    // Add aliases for ship models
                    if (model === 'ships/ALTSPACE1.glb') {
                        this.assets.models.set('FIGHTER', this.assets.models.get(model));
                        this.assets.models.set('SCOUT', this.assets.models.get(model));
                    } else if (model === 'ships/ALTSPACE2.glb') {
                        this.assets.models.set('INTERCEPTOR', this.assets.models.get(model));
                        this.assets.models.set('EXPERIMENTAL', this.assets.models.get(model));
                    }
                }
            } catch (error) {
                console.error(`⛔ Failed to load ship model ${model}:`, error);
                this.handleError('model', error);
            }
        }
        
        return true;
    }
}

export default AssetLoader; 
### ./assets/AssetLoader.js END ###

### ./entities/Ship.js BEGIN ###
import * as THREE from 'three';
import { EventEmitter } from 'events';

export class Ship extends EventEmitter {
    constructor(scene, position, options = {}) {
        super();
        
        this.scene = scene;
        this.options = { 
            health: 100, 
            speed: 0.1,
            type: 'BASIC',
            teamId: null,
            teamColor: 0xffffff,
            maxHealth: 100,
            size: 1.0,
            shipModel: 'STANDARD',
            ...options 
        };
        
        this.health = this.options.health;
        this.maxHealth = this.options.maxHealth;
        this.isActive = true;
        this.teamId = this.options.teamId;
        this.mesh = null;
        
        // Initialize the ship if position is provided
        if (position) {
            this.createMesh(position);
            // Add to scene if mesh was created
            if (this.mesh) {
                this.scene.add(this.mesh);
            }
            // Initialize effects
            this.initializeEffects();
        }
    }

    createMesh(position) {
        // This is a base method that can be overridden by subclasses
        // In the base class, implement default behavior
        
        const geometry = this.createGeometry();
        const material = this.createMaterial();
        
        // Create mesh
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(position || new THREE.Vector3());
        this.mesh.position.y = this.options.size;
        
        // Add engine glow
        this.addEngineGlow();
        
        return this.mesh;
    }
    
    createGeometry() {
        // Ship models based on type
        const models = {
            STANDARD: () => new THREE.ConeGeometry(this.options.size, this.options.size * 2, 3),
            INTERCEPTOR: () => {
                const geometry = new THREE.ConeGeometry(this.options.size * 0.8, this.options.size * 2.5, 4);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            },
            HEAVY: () => new THREE.CylinderGeometry(
                this.options.size * 1.2,
                this.options.size * 1.4,
                this.options.size * 2,
                6
            ),
            SCOUT: () => {
                const geometry = new THREE.ConeGeometry(this.options.size * 0.6, this.options.size * 2.2, 5);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            }
        };

        // Get geometry based on ship model or fallback to STANDARD
        const geometry = (models[this.options.shipModel] || models.STANDARD)();
        geometry.rotateX(Math.PI / 2);
        
        return geometry;
    }
    
    createMaterial() {
        // Create material with team color and effects
        return new THREE.MeshStandardMaterial({
            color: this.options.teamColor,
            emissive: this.options.teamColor,
            emissiveIntensity: 0.5,
            metalness: 0.7,
            roughness: 0.3
        });
    }

    addEngineGlow() {
        const engineLight = new THREE.PointLight(this.options.teamColor, 1, 2);
        engineLight.position.set(0, 0, -this.options.size);
        this.mesh.add(engineLight);
    }

    initializeEffects() {
        this.effects = {
            damageTween: null,
            enginePulse: { value: 0 }
        };
    }

    update(deltaTime) {
        if (!this.isActive) return;

        // Update engine pulse effect
        this.updateEngineEffect(deltaTime);
    }

    updateEngineEffect(deltaTime) {
        this.effects.enginePulse.value += deltaTime * 0.005;
        const pulseIntensity = 0.5 + 0.2 * Math.sin(this.effects.enginePulse.value);
        this.material.emissiveIntensity = pulseIntensity;
    }

    takeDamage(amount) {
        if (!this.isActive) return;

        this.health = Math.max(0, this.health - amount);
        this.flashOnDamage();

        if (this.health <= 0) {
            this.destroy();
        }

        // Emit damage event
        this.emit('damage', {
            amount,
            remainingHealth: this.health,
            maxHealth: this.maxHealth
        });
    }

    flashOnDamage() {
        const originalEmissive = this.material.emissive.getHex();
        this.material.emissive.setHex(0xffffff);

        setTimeout(() => {
            if (this.material) {
                this.material.emissive.setHex(originalEmissive);
            }
        }, 100);
    }

    destroy() {
        if (!this.isActive) return;

        this.isActive = false;
        this.createExplosionEffect();
        
        // Emit destroy event
        this.emit('destroy', {
            position: this.mesh.position.clone(),
            teamId: this.teamId
        });

        // Remove from scene after explosion
        setTimeout(() => {
            if (this.mesh && this.mesh.parent) {
                this.mesh.parent.remove(this.mesh);
            }
        }, 1000);
    }

    createExplosionEffect() {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];
        const particles = [];

        for (let i = 0; i < particleCount; i++) {
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            velocities.push(velocity);
            particles.push(new THREE.Vector3(0, 0, 0));
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: this.options.teamColor,
            size: 0.2,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        particleSystem.position.copy(this.mesh.position);
        this.scene.add(particleSystem);

        const startTime = Date.now();
        const duration = 1000;

        const animateExplosion = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed < duration) {
                for (let i = 0; i < particleCount; i++) {
                    particles[i].add(velocities[i]);
                    positions[i * 3] = particles[i].x;
                    positions[i * 3 + 1] = particles[i].y;
                    positions[i * 3 + 2] = particles[i].z;
                }
                geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - (elapsed / duration);
                requestAnimationFrame(animateExplosion);
            } else {
                this.scene.remove(particleSystem);
            }
        };

        animateExplosion();
    }

    setTeam(teamId, teamColor) {
        this.teamId = teamId;
        this.options.teamColor = teamColor;
        if (this.material) {
            this.material.color.setHex(teamColor);
            this.material.emissive.setHex(teamColor);
        }
    }
} 
### ./entities/Ship.js END ###

### ./entities/weapons/RegularLaser.js BEGIN ###
import * as THREE from 'three';
import { Laser } from './Laser';

/**
 * RegularLaser weapon class
 */
export class RegularLaser extends Laser {
  constructor(weaponSystem) {
    super(weaponSystem.scene, null, null, {
      damage: 10, range: 50, speed: 50, color: 0x00ffff
    });
    this.weaponSystem = weaponSystem;
    this.cooldown = 0.2;
    this.currentCooldown = 0;
    this.energyCost = 5;
  }
  
  /**
   * Update cooldown timer and laser position
   * @param {number} deltaTime - Time since last frame in seconds
   */
  update(deltaTime) {
    // Call parent update to handle movement and range checking
    super.update(deltaTime);
    
    // Handle cooldown timer
    if (this.currentCooldown > 0) {
      this.currentCooldown -= deltaTime;
    }
  }
  
  /**
   * Check if weapon can fire
   * @param {object} player - Player object with energy properties
   * @returns {boolean} - True if weapon can fire
   */
  canFire(player) {
    return this.currentCooldown <= 0 && player.energy >= this.energyCost;
  }
  
  /**
   * Fire the weapon
   * @param {THREE.Vector3} position - Starting position of projectile
   * @param {THREE.Vector3} direction - Direction to fire
   * @param {object} player - Player object for energy management
   * @returns {boolean} - True if weapon fired successfully
   */
  fire(position, direction, options = {}) {
    // Position and orient the laser
    this.mesh.position.copy(position);
    this.direction = direction.normalize();
    this.initialPosition = position.clone();
    
    // Store initial properties
    this.teamId = options.teamId;
    
    // Set color based on team
    if (options.teamColor) {
      if (this.mesh.material) {
        this.mesh.material.color.set(options.teamColor);
      }
    }
    
    // Play sound if available
    if (this.weaponSystem.scene.soundManager) {
      this.weaponSystem.scene.soundManager.playSound('laser', position);
    }
    
    return this;
  }
  
  /**
   * Create a laser projectile
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Direction to fire
   * @returns {object} - Projectile object
   */
  createProjectile(position, direction) {
    // Create laser geometry and material
    const geometry = new THREE.CylinderGeometry(
      this.size.width, 
      this.size.width, 
      this.size.length, 
      8
    );
    
    // Rotate geometry to point along z-axis
    geometry.rotateX(Math.PI / 2);
    
    // Create glowing material
    const material = new THREE.MeshBasicMaterial({
      color: this.color,
      transparent: true,
      opacity: 0.8
    });
    
    // Create mesh
    const mesh = new THREE.Mesh(geometry, material);
    
    // Set initial position
    mesh.position.copy(position);
    
    // Set rotation to match direction
    mesh.quaternion.setFromUnitVectors(
      new THREE.Vector3(0, 0, 1), 
      direction.clone().normalize()
    );
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(this.color, 1, 2);
    mesh.add(light);
    
    // Create projectile object
    const projectile = {
      mesh: mesh,
      direction: direction.clone().normalize(),
      speed: this.speed,
      distance: 0,
      maxDistance: this.range,
      damage: this.damage,
      isActive: true,
      owner: 'player',
      type: 'laser',
      explosionSize: this.explosionSize,
      
      // Update method
      update: function(deltaTime) {
        if (!this.isActive) return false;
        
        // Move projectile
        const moveAmount = this.speed * deltaTime;
        this.mesh.position.addScaledVector(this.direction, moveAmount);
        this.distance += moveAmount;
        
        // Deactivate if max distance reached
        if (this.distance >= this.maxDistance) {
          this.isActive = false;
          return false;
        }
        
        return true;
      },
      
      // Handle collision
      handleCollision: function() {
        this.isActive = false;
      },
      
      // Get current position
      get position() {
        return this.mesh.position;
      }
    };
    
    return projectile;
  }
} 
### ./entities/weapons/RegularLaser.js END ###

### ./entities/weapons/WeaponSystem.js BEGIN ###
import * as THREE from 'three';
import { Laser } from './Laser';

export class WeaponSystem {
  constructor(scene) {
    this.scene = scene;
    this.projectiles = [];
    
    // Weapon types
    this.weaponTypes = {
      LASER: {
        name: 'Regular Laser',
        color: 0x00ffff,
        cooldown: 300,
        length: 3,
        thickness: 0.1,
        speed: 0.3,
        damage: 10
      },
      BOUNCE_LASER: {
        name: 'Bounce Laser',
        color: 0xff00ff,
        cooldown: 500,
        length: 2.5,
        thickness: 0.15,
        speed: 0.25,
        damage: 8,
        bounces: 3
      },
      QUANTUM_GRENADE: {
        name: 'Quantum Grenade',
        color: 0xffff00,
        cooldown: 1000,
        speed: 0.15,
        radius: 0.3,
        damage: 25,
        areaEffectRadius: 5,
        delay: 3000
      }
    };
    
    // Audio (will be implemented later)
    this.audioEnabled = false;
  }
  
  fireWeapon(weaponType, position, direction, options = {}) {
    const config = this.weaponTypes[weaponType] || this.weaponTypes['LASER'];
    let projectile = this.createLaser(position, direction, {
      ...config,
      ...options
    });
    
    if (projectile) {
      this.projectiles.push(projectile);
    }
    
    // Network synchronization if available
    if (this.scene.networkManager) {
      this.scene.networkManager.emit('laser_shot', {
        origin: position,
        direction: direction,
        type: weaponType
      });
    }
    
    return projectile;
  }
  
  createLaser(position, direction, config) {
    // Create laser projectile
    return new Laser(this.scene, position, direction, config);
  }
  
  update(deltaTime) {
    // Update all projectiles
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const projectile = this.projectiles[i];
      
      // Update projectile
      projectile.update(deltaTime);
      
      // Remove inactive projectiles
      if (!projectile.isActive) {
        this.projectiles.splice(i, 1);
      }
    }
  }
  
  checkCollisions(targets, obstacles) {
    const hitResults = [];
    
    // Skip if no active projectiles
    if (this.projectiles.length === 0) return hitResults;
    
    // Ensure targets is an array
    const targetArray = Array.isArray(targets) ? targets : [];
    
    // Format obstacles to wall segments if needed
    const wallSegments = this.formatObstacles(obstacles);
    
    // Check each projectile for collisions
    for (const projectile of this.projectiles) {
      if (!projectile.isActive) continue;
      
      // Check wall collisions
      if (wallSegments && this.checkWallCollision(projectile, wallSegments)) {
        hitResults.push({
          projectile: projectile,
          target: 'wall',
          position: projectile.position.clone()
        });
        
        // Handle the hit
        projectile.handleCollision();
        continue;
      }
      
      // Check target collisions
      if (targetArray.length > 0) {
        for (const target of targetArray) {
          if (this.checkTargetCollision(projectile, target)) {
            hitResults.push({
              projectile: projectile,
              target: target,
              position: projectile.position.clone()
            });
            
            // Handle the hit
            projectile.handleCollision();
            break;
          }
        }
      }
    }
    
    return hitResults;
  }
  
  formatObstacles(obstacles) {
    // If obstacles is already an array of wall segments, return it
    if (Array.isArray(obstacles) && obstacles.length > 0 && 
        obstacles[0].start && obstacles[0].end) {
      return obstacles;
    }
    
    // Format obstacles into wall segments if they're in the GameRoom format
    if (Array.isArray(obstacles)) {
      const wallSegments = [];
      
      for (const obstacle of obstacles) {
        if (!obstacle || !obstacle.position) continue;
        
        if (obstacle.type === 'wall' && obstacle.size) {
          // Create line segments for walls
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          // Determine if it's a horizontal or vertical wall
          if (obstacle.size.x > obstacle.size.z) {
            // Horizontal wall
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z),
              end: new THREE.Vector3(x + halfWidth, 0, z)
            });
          } else {
            // Vertical wall
            wallSegments.push({
              start: new THREE.Vector3(x, 0, z - halfDepth),
              end: new THREE.Vector3(x, 0, z + halfDepth)
            });
          }
        } else if (obstacle.radius) {
          // For cylindrical obstacles, we'll approximate with line segments
          const segments = 8; // Number of line segments to approximate circle
          const center = obstacle.position;
          const radius = obstacle.radius;
          
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2;
            const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
            const x1 = center.x + Math.cos(angle1) * radius;
            const z1 = center.z + Math.sin(angle1) * radius;
            const x2 = center.x + Math.cos(angle2) * radius;
            const z2 = center.z + Math.sin(angle2) * radius;
            
            wallSegments.push({
              start: new THREE.Vector3(x1, 0, z1),
              end: new THREE.Vector3(x2, 0, z2)
            });
          }
        } else if (obstacle.size) {
          // Box obstacle - create four wall segments
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z - halfDepth),
            end: new THREE.Vector3(x + halfWidth, 0, z - halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x + halfWidth, 0, z - halfDepth),
            end: new THREE.Vector3(x + halfWidth, 0, z + halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x + halfWidth, 0, z + halfDepth),
            end: new THREE.Vector3(x - halfWidth, 0, z + halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z + halfDepth),
            end: new THREE.Vector3(x - halfWidth, 0, z - halfDepth)
          });
        }
      }
      
      return wallSegments;
    }
    
    // If obstacles is not in a recognized format, return an empty array
    return [];
  }
  
  checkWallCollision(projectile, wallSegments) {
    // Simple collision check for laser projectiles
    const projectilePosition = new THREE.Vector2(
      projectile.position.x,
      projectile.position.z
    );
    
    const radius = projectile.options.thickness;
    
    // Check each wall segment
    for (const segment of wallSegments) {
      const wallStart = new THREE.Vector2(segment.start.x, segment.start.z);
      const wallEnd = new THREE.Vector2(segment.end.x, segment.end.z);
      
      // Calculate closest point on wall segment to projectile
      const wallVector = wallEnd.clone().sub(wallStart);
      const projectileToWallStart = projectilePosition.clone().sub(wallStart);
      
      // Project projectile onto wall line
      const wallLength = wallVector.length();
      const wallDirection = wallVector.clone().normalize();
      const projectionLength = projectileToWallStart.dot(wallDirection);
      
      // Find closest point on wall segment
      let closestPoint;
      if (projectionLength < 0) {
        closestPoint = wallStart;
      } else if (projectionLength > wallLength) {
        closestPoint = wallEnd;
      } else {
        closestPoint = wallStart.clone().add(wallDirection.multiplyScalar(projectionLength));
      }
      
      // Calculate distance from projectile to closest point
      const distance = projectilePosition.distanceTo(closestPoint);
      
      // Check if collision occurred
      if (distance < radius) {
        return true;
      }
    }
    
    return false;
  }
  
  checkTargetCollision(projectile, target) {
    // Simple distance-based collision check
    if (!target.mesh) return false;
    
    // Get target position (assume it has a mesh with position)
    const targetPosition = target.mesh.position;
    
    // Calculate distance
    const distance = projectile.position.distanceTo(targetPosition);
    
    // Simple radius check (can be enhanced later)
    const collisionThreshold = 0.5 + projectile.options.thickness;
    return distance < collisionThreshold;
  }
  
  clearAllProjectiles() {
    // Deactivate all projectiles
    for (const projectile of this.projectiles) {
      projectile.deactivate();
    }
    
    // Clear array
    this.projectiles = [];
  }
} 
### ./entities/weapons/WeaponSystem.js END ###

### ./entities/weapons/Laser.js BEGIN ###
import * as THREE from 'three';

export class Laser {
  constructor(scene, position, direction, options = {}) {
    this.scene = scene;
    this.options = { speed: 0.3, color: 0x00ffff, ...options };
    this.mesh = this.createMesh();
    if (position) this.mesh.position.copy(position);
    if (direction) this.direction = direction.normalize();
    this.scene.add(this.mesh);
    this.isActive = true;
  }

  createMesh() {
    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: this.options.color });
    return new THREE.Mesh(geometry, material);
  }
  
  update(deltaTime) {
    if (!this.isActive) return;
    
    // Move in direction
    if (this.direction) {
      this.mesh.position.add(
        this.direction.clone().multiplyScalar(this.options.speed * deltaTime)
      );
    }
    
    // Check if laser has exceeded its range
    if (this.options.range) {
      const distance = this.mesh.position.distanceTo(this.initialPosition);
      if (distance > this.options.range) {
        this.deactivate();
      }
    }
  }
  
  deactivate() {
    if (!this.isActive) return;
    
    this.isActive = false;
    if (this.mesh && this.scene) {
      this.scene.remove(this.mesh);
    }
    
    // Dispose of geometry and materials
    if (this.mesh) {
      if (this.mesh.geometry) this.mesh.geometry.dispose();
      if (this.mesh.material) {
        if (Array.isArray(this.mesh.material)) {
          this.mesh.material.forEach(material => material.dispose());
        } else {
          this.mesh.material.dispose();
        }
      }
    }
  }
} 
### ./entities/weapons/Laser.js END ###

### ./entities/enemies/EnemyManager.js BEGIN ###
import * as THREE from 'three';
import { Enemy } from './Enemy';

export class EnemyManager {
  constructor(scene, mazeSize = 10) {
    this.scene = scene;
    this.mazeSize = mazeSize;
    this.enemies = [];
    
    // Enemy types with their probabilities and configs
    this.enemyTypes = {
      BASIC: {
        probability: 0.6,
        color: 0xff0000,
        health: 30,
        speed: 0.005
      },
      HUNTER: {
        probability: 0.3,
        color: 0xff00ff,
        health: 20,
        speed: 0.008,
        detectionRadius: 15
      },
      PATROLLER: {
        probability: 0.1,
        color: 0xffaa00,
        health: 40,
        speed: 0.004
      }
    };
    
    // Spawn settings
    this.maxEnemies = 10;
    this.spawnInterval = 5000; // 5 seconds
    this.lastSpawnTime = 0;
    this.spawnDistanceFromPlayer = 10;
    this.difficulty = 1; // Scales over time
  }
  
  update(deltaTime, playerPosition, obstacles) {
    // Check if we should spawn new enemies
    this.checkSpawn(playerPosition);
    
    // Ensure obstacles are correctly formatted for enemies
    const wallSegments = this.formatObstaclesForCollision(obstacles);
    
    // Update all active enemies
    for (let i = this.enemies.length - 1; i >= 0; i--) {
      const enemy = this.enemies[i];
      
      // Skip inactive enemies - they'll be removed later
      if (!enemy.isActive) {
        this.enemies.splice(i, 1);
        continue;
      }
      
      // Update enemy behavior
      enemy.update(deltaTime, playerPosition, wallSegments);
    }
  }
  
  checkSpawn(playerPosition) {
    // Skip if player position isn't available
    if (!playerPosition) return;
    
    const currentTime = Date.now();
    
    // Check if it's time to spawn and we're under the limit
    if (currentTime - this.lastSpawnTime > this.spawnInterval && this.enemies.length < this.maxEnemies) {
      this.lastSpawnTime = currentTime;
      this.spawnEnemy(playerPosition);
    }
  }
  
  spawnEnemy(playerPosition) {
    // Determine spawn position (away from player)
    const spawnPosition = this.getSpawnPosition(playerPosition);
    if (!spawnPosition) return;
    
    // Determine enemy type based on probabilities
    const enemyType = this.selectEnemyType();
    
    // Get configuration for selected enemy type
    const typeConfig = this.enemyTypes[enemyType];
    
    // Scale difficulty based on current level
    const healthMultiplier = 1 + (this.difficulty - 1) * 0.2;
    const speedMultiplier = 1 + (this.difficulty - 1) * 0.1;
    
    // Create enemy with adjusted settings
    const enemy = new Enemy(this.scene, spawnPosition, {
      type: enemyType,
      color: typeConfig.color,
      health: typeConfig.health * healthMultiplier,
      speed: typeConfig.speed * speedMultiplier,
      detectionRadius: typeConfig.detectionRadius || 10
    });
    
    // Add to active enemies list
    this.enemies.push(enemy);
    
    return enemy;
  }
  
  getSpawnPosition(playerPosition) {
    // Try to find a valid spawn position
    for (let attempt = 0; attempt < 10; attempt++) {
      // Generate random angle around player
      const angle = Math.random() * Math.PI * 2;
      
      // Calculate position at random distance from player (between min and max)
      const minDistance = this.spawnDistanceFromPlayer;
      const maxDistance = this.spawnDistanceFromPlayer + 5;
      const distance = minDistance + Math.random() * (maxDistance - minDistance);
      
      // Calculate position
      const x = playerPosition.x + Math.cos(angle) * distance;
      const z = playerPosition.z + Math.sin(angle) * distance;
      
      // Check if position is within maze bounds
      if (Math.abs(x) < this.mazeSize * 0.8 && Math.abs(z) < this.mazeSize * 0.8) {
        return new THREE.Vector3(x, 0, z);
      }
    }
    
    // If all attempts failed, return null
    return null;
  }
  
  selectEnemyType() {
    // Random value between 0 and 1
    const rand = Math.random();
    
    // Calculate cumulative probability
    let cumulativeProbability = 0;
    
    for (const [type, config] of Object.entries(this.enemyTypes)) {
      cumulativeProbability += config.probability;
      
      if (rand <= cumulativeProbability) {
        return type;
      }
    }
    
    // Fallback to basic enemy
    return 'BASIC';
  }
  
  increaseMaxEnemies(amount = 1) {
    this.maxEnemies += amount;
  }
  
  increaseDifficulty(amount = 0.1) {
    this.difficulty += amount;
    
    // Also decrease spawn interval as difficulty increases
    this.spawnInterval = Math.max(1000, this.spawnInterval - 100);
  }
  
  checkCollisions(playerPosition, playerRadius = 0.5) {
    // Check for collisions between player and enemies
    if (!playerPosition) return false;
    
    for (const enemy of this.enemies) {
      if (!enemy.isActive) continue;
      
      // Simple distance-based collision check
      const distance = enemy.mesh.position.distanceTo(playerPosition);
      
      // If collision detected
      if (distance < playerRadius + enemy.options.size) {
        return enemy;
      }
    }
    
    return null;
  }
  
  clear() {
    // Remove all enemies
    for (const enemy of this.enemies) {
      enemy.destroy();
    }
    
    this.enemies = [];
  }
  
  // Convert obstacle data to wall segments format for collision detection
  formatObstaclesForCollision(obstacles) {
    if (!obstacles || !Array.isArray(obstacles)) return [];
    
    const wallSegments = [];
    
    for (const obstacle of obstacles) {
      if (obstacle.type === 'wall' && obstacle.position && obstacle.size) {
        // Create wall segments from obstacle bounds
        const halfWidth = obstacle.size.x / 2;
        const halfDepth = obstacle.size.z / 2;
        const x = obstacle.position.x;
        const z = obstacle.position.z;
        
        // Create four wall segments for each rectangular wall
        if (obstacle.size.x > obstacle.size.z) {
          // Horizontal wall (longer in x direction)
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z),
            end: new THREE.Vector3(x + halfWidth, 0, z)
          });
        } else {
          // Vertical wall (longer in z direction)
          wallSegments.push({
            start: new THREE.Vector3(x, 0, z - halfDepth),
            end: new THREE.Vector3(x, 0, z + halfDepth)
          });
        }
      } else if (obstacle.type === 'obstacle' && obstacle.position) {
        // Create a simple boundary for other obstacles
        if (obstacle.radius) {
          // For cylindrical obstacles, create a circle approximation using 8 segments
          const radius = obstacle.radius;
          const center = obstacle.position;
          const segments = 8;
          
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2;
            const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
            const x1 = center.x + Math.cos(angle1) * radius;
            const z1 = center.z + Math.sin(angle1) * radius;
            const x2 = center.x + Math.cos(angle2) * radius;
            const z2 = center.z + Math.sin(angle2) * radius;
            
            wallSegments.push({
              start: new THREE.Vector3(x1, 0, z1),
              end: new THREE.Vector3(x2, 0, z2)
            });
          }
        } else if (obstacle.size) {
          // For box obstacles, create four wall segments
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          // Handle rotation if present
          let rotation = 0;
          if (obstacle.rotation) {
            rotation = obstacle.rotation.y;
          }
          
          if (rotation) {
            // Rotated rectangle - more complex calculation
            // For simplicity, we'll just create a simpler collision boundary
            const radius = Math.max(halfWidth, halfDepth);
            const segments = 8;
            
            for (let i = 0; i < segments; i++) {
              const angle1 = (i / segments) * Math.PI * 2;
              const angle2 = ((i + 1) / segments) * Math.PI * 2;
              
              const x1 = x + Math.cos(angle1) * radius;
              const z1 = z + Math.sin(angle1) * radius;
              const x2 = x + Math.cos(angle2) * radius;
              const z2 = z + Math.sin(angle2) * radius;
              
              wallSegments.push({
                start: new THREE.Vector3(x1, 0, z1),
                end: new THREE.Vector3(x2, 0, z2)
              });
            }
          } else {
            // Axis-aligned rectangle - simpler
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z - halfDepth),
              end: new THREE.Vector3(x + halfWidth, 0, z - halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x + halfWidth, 0, z - halfDepth),
              end: new THREE.Vector3(x + halfWidth, 0, z + halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x + halfWidth, 0, z + halfDepth),
              end: new THREE.Vector3(x - halfWidth, 0, z + halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z + halfDepth),
              end: new THREE.Vector3(x - halfWidth, 0, z - halfDepth)
            });
          }
        }
      }
    }
    
    return wallSegments;
  }
} 
### ./entities/enemies/EnemyManager.js END ###

### ./entities/enemies/Enemy.js BEGIN ###
import * as THREE from 'three';
import { Ship } from '../Ship';

export class Enemy extends Ship {
  constructor(scene, position, options = {}) {
    // Set default enemy options
    const enemyOptions = {
      type: 'BASIC',
      health: 30,
      speed: 0.005,
      size: 0.6,
      detectionRadius: 10,
      attackRange: 8,
      shipModel: 'STANDARD',
      ...options
    };
    
    super(scene, position, enemyOptions);
    
    // Enemy-specific properties
    this.targetPosition = null;
    this.lastDirectionChange = 0;
    this.directionChangeInterval = 2000 + Math.random() * 2000;
    this.currentTarget = null;
    this.lastAttackTime = 0;
    this.attackCooldown = 1000;
  }
  
  update(deltaTime, players, wallSegments) {
    if (!this.isActive) return;
    
    super.update(deltaTime);
    
    // Update behavior based on enemy type
    switch (this.options.type) {
      case 'HUNTER':
        this.updateHunter(deltaTime, players, wallSegments);
        break;
      case 'PATROLLER':
        this.updatePatroller(deltaTime, wallSegments);
        break;
      case 'BASIC':
      default:
        this.updateBasic(deltaTime, players, wallSegments);
        break;
    }
  }
  
  updateBasic(deltaTime, players, wallSegments) {
    const currentTime = Date.now();
    
    // Find nearest enemy player
    let nearestTarget = this.findNearestEnemyPlayer(players);
    
    if (nearestTarget && this.isInRange(nearestTarget.position, this.options.detectionRadius)) {
      // If enemy player is in range, engage
      this.currentTarget = nearestTarget;
      this.engageTarget(deltaTime, wallSegments);
    } else {
      // Random movement when no target
      if (currentTime - this.lastDirectionChange > this.directionChangeInterval) {
        this.lastDirectionChange = currentTime;
        const angle = Math.random() * Math.PI * 2;
        this.direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
        this.directionChangeInterval = 2000 + Math.random() * 2000;
      }
      
      if (this.direction) {
        this.moveWithCollision(this.direction, deltaTime, wallSegments);
      }
    }
  }
  
  updateHunter(deltaTime, players, wallSegments) {
    const nearestTarget = this.findNearestEnemyPlayer(players);
    
    if (nearestTarget && this.isInRange(nearestTarget.position, this.options.detectionRadius)) {
      this.currentTarget = nearestTarget;
      this.engageTarget(deltaTime, wallSegments);
    } else {
      this.updateBasic(deltaTime, players, wallSegments);
    }
  }
  
  updatePatroller(deltaTime, wallSegments) {
    if (!this.targetPosition || this.mesh.position.distanceTo(this.targetPosition) < 0.5) {
      this.targetPosition = new THREE.Vector3(
        this.mesh.position.x + (Math.random() * 10 - 5),
        this.mesh.position.y,
        this.mesh.position.z + (Math.random() * 10 - 5)
      );
    }
    
    const toTarget = new THREE.Vector3().subVectors(this.targetPosition, this.mesh.position).normalize();
    this.moveWithCollision(toTarget, deltaTime, wallSegments);
  }
  
  engageTarget(deltaTime, wallSegments) {
    if (!this.currentTarget || !this.currentTarget.isActive) {
      this.currentTarget = null;
      return;
    }

    const toTarget = new THREE.Vector3().subVectors(
      this.currentTarget.position,
      this.mesh.position
    );
    
    const distance = toTarget.length();
    
    if (distance < this.options.attackRange) {
      // Attack if in range and cooldown is ready
      const currentTime = Date.now();
      if (currentTime - this.lastAttackTime > this.attackCooldown) {
        this.attack();
        this.lastAttackTime = currentTime;
      }
      
      // Maintain distance
      if (distance < this.options.attackRange * 0.5) {
        this.moveWithCollision(toTarget.normalize().negate(), deltaTime, wallSegments);
      }
    } else {
      // Move towards target
      this.moveWithCollision(toTarget.normalize(), deltaTime, wallSegments);
    }
    
    // Face target
    const angle = Math.atan2(toTarget.x, toTarget.z);
    this.mesh.rotation.y = angle;
  }
  
  moveWithCollision(direction, deltaTime, wallSegments) {
    const movement = direction.clone().multiplyScalar(this.options.speed * deltaTime);
    const previousPosition = this.mesh.position.clone();
    
    this.mesh.position.add(movement);
    
    if (this.checkWallCollision(wallSegments)) {
      this.mesh.position.copy(previousPosition);
      this.direction = direction.clone().reflect(new THREE.Vector3(1, 0, 0));
    }
    
    // Face movement direction
    if (direction.length() > 0) {
      const angle = Math.atan2(direction.x, direction.z);
      this.mesh.rotation.y = angle;
    }
  }
  
  findNearestEnemyPlayer(players) {
    let nearestDistance = Infinity;
    let nearestPlayer = null;

    players.forEach(player => {
      if (player.isActive && player.teamId !== this.teamId) {
        const distance = this.mesh.position.distanceTo(player.mesh.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestPlayer = player;
        }
      }
    });

    return nearestPlayer;
  }
  
  isInRange(position, range) {
    return this.mesh.position.distanceTo(position) <= range;
  }
  
  attack() {
    // Emit attack event for weapon system to handle
    this.emit('attack', {
      position: this.mesh.position.clone(),
      direction: new THREE.Vector3().subVectors(
        this.currentTarget.mesh.position,
        this.mesh.position
      ).normalize(),
      teamId: this.teamId
    });
  }
  
  checkWallCollision(wallSegments) {
    const pos = this.mesh.position;
    for (const segment of wallSegments) {
      const closest = this.getClosestPoint(pos, segment.start, segment.end);
      if (pos.distanceTo(closest) < this.options.size) return true;
    }
    return false;
  }

  getClosestPoint(point, start, end) {
    const line = end.clone().sub(start);
    const t = Math.max(0, Math.min(1, point.clone().sub(start).dot(line) / line.lengthSq()));
    return start.clone().add(line.multiplyScalar(t));
  }
} 
### ./entities/enemies/Enemy.js END ###

### ./entities/player/Player.js BEGIN ###
import * as THREE from 'three';
import { ModelLoader } from '../../assets/ModelLoader';
import { KEY_MAPPINGS, CONTROL_SETTINGS, DEFAULT_CONTROL_STATE, ControlUtils } from '../../config/Controls';
import { Ship } from '../Ship';

export class Player extends Ship {
  constructor(scene, position, options = {}) {
    // Set default player options
    const playerOptions = {
      type: 'PLAYER',
      health: 100,
      maxHealth: 100,
      speed: 0.15,
      size: 1.0,
      shipModel: 'STANDARD',
      ...options
    };
    
    super(scene, position, playerOptions);
    
    // Player-specific properties
    this.moveDirection = new THREE.Vector3();
    this.velocity = new THREE.Vector3();
    this.rotation = new THREE.Euler();
    this.quaternion = new THREE.Quaternion();
    this.targetQuaternion = new THREE.Quaternion();
    
    // Movement state
    this.moveState = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      boost: false
    };
    
    // Bind event handler methods to preserve 'this' context
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    
    // Initialize controls
    this.setupControls();
  }

  setupControls() {
    // Keyboard controls
    document.addEventListener('keydown', this.handleKeyDown);
    document.addEventListener('keyup', this.handleKeyUp);
    
    // Mouse controls for aiming
    document.addEventListener('mousemove', this.handleMouseMove);
  }

  handleKeyDown(event) {
    switch(event.code) {
        case 'KeyW':
        this.moveState.forward = true;
          break;
        case 'KeyS':
        this.moveState.backward = true;
          break;
        case 'KeyA':
        this.moveState.left = true;
          break;
        case 'KeyD':
        this.moveState.right = true;
          break;
      case 'ShiftLeft':
        this.moveState.boost = true;
          break;
      }
  }
    
  handleKeyUp(event) {
    switch(event.code) {
        case 'KeyW':
        this.moveState.forward = false;
          break;
        case 'KeyS':
        this.moveState.backward = false;
          break;
        case 'KeyA':
        this.moveState.left = false;
          break;
        case 'KeyD':
        this.moveState.right = false;
        break;
      case 'ShiftLeft':
        this.moveState.boost = false;
          break;
      }
  }

  handleMouseMove(event) {
    // Update rotation based on mouse position
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // Calculate target rotation
    this.rotation.y = Math.atan2(mouseX, mouseY);
    this.targetQuaternion.setFromEuler(this.rotation);
  }
  
  update(deltaTime) {
    if (!this.isActive) return;
    
    super.update(deltaTime);
    
    // Update movement
    this.updateMovement(deltaTime);
    
    // Update rotation
    this.updateRotation(deltaTime);
    
    // Emit position update event
    this.emit('positionUpdate', {
      position: this.mesh.position.clone(),
      rotation: this.mesh.rotation.clone(),
      teamId: this.teamId
    });
  }

  updateMovement(deltaTime) {
    // Reset movement direction
    this.moveDirection.set(0, 0, 0);
    
    // Calculate movement direction based on input state
    if (this.moveState.forward) this.moveDirection.z -= 1;
    if (this.moveState.backward) this.moveDirection.z += 1;
    if (this.moveState.left) this.moveDirection.x -= 1;
    if (this.moveState.right) this.moveDirection.x += 1;
    
    // Normalize movement direction
    if (this.moveDirection.lengthSq() > 0) {
      this.moveDirection.normalize();
    }
    
    // Apply speed and boost
    const currentSpeed = this.moveState.boost ? this.options.speed * 1.5 : this.options.speed;
    
    // Update velocity with smooth acceleration
    const acceleration = 0.1;
    this.velocity.lerp(this.moveDirection.multiplyScalar(currentSpeed), acceleration);
    
    // Apply velocity
    this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
    
    // Keep player within bounds (example bounds)
    const bounds = 50;
    this.mesh.position.x = Math.max(-bounds, Math.min(bounds, this.mesh.position.x));
    this.mesh.position.z = Math.max(-bounds, Math.min(bounds, this.mesh.position.z));
    
    // Broadcast position updates for multiplayer
    if (this.networkManager) {
      this.networkManager.emit('player_move', {
        position: this.mesh.position,
        rotation: this.mesh.rotation,
      });
    }
  }

  updateRotation(deltaTime) {
    // Smoothly interpolate current rotation to target rotation
    this.mesh.quaternion.slerp(this.targetQuaternion, 0.1);
  }

  getForwardDirection() {
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(this.mesh.quaternion);
    return forward;
  }

  getRightDirection() {
    const right = new THREE.Vector3(1, 0, 0);
    right.applyQuaternion(this.mesh.quaternion);
    return right;
  }

  // Override destroy to handle player-specific cleanup
  destroy() {
    if (!this.isActive) return;
    
    // Remove event listeners
    document.removeEventListener('keydown', this.handleKeyDown);
    document.removeEventListener('keyup', this.handleKeyUp);
    document.removeEventListener('mousemove', this.handleMouseMove);
    
    // Call parent destroy method
    super.destroy();
    
    // Emit player destroyed event
    this.emit('playerDestroyed', {
      position: this.mesh.position.clone(),
      teamId: this.teamId
    });
  }
} 
### ./entities/player/Player.js END ###

### DIRECTORY . FLATTENED CONTENT ###
### DIRECTORY . FOLDER STRUCTURE ###
./
    index.html
    flatten.py
    index.js
    codebase.md
    ui/
        ShipSelectionUI.js
        GameRoom.js
        GameUI.js
        MiniMap.js
    scenes/
        TeamDemo.js
    core/
        Game.js
        TeamManager.js
        Scene.js
        GameEngine.js
        Engine.js
        NetworkManager.js
        InfiniteMap.js
    config/
        ShipConfig.js
        Controls.js
        GameConfig.js
    constants/
    utils/
    styles/
        main.css
        controls.css
    effects/
    assets/
        ModelLoader.js
        SoundManager.js
        .DS_Store
        AssetLoader.js
        textures/
        images/
        models/
            .DS_Store
            textures/
                tex.png
                Colors3.png
            ships/
                ALTSPACE2.glb
                ALTSPACE1.glb
            flora/
                Grass_01.glb
                .DS_Store
                SmalRoots_01.glb
                BigPlant_06.glb
                SP_Plant08.glb
                SP_Plant07.glb
                Mushrooms.glb
                SP_Tree04.glb
                SP_Tree02.glb
                SP_Tree03.glb
                SP_Tree01.glb
                Tenticles_01.glb
            objects/
                .DS_Store
                SP_Stone01.glb
                SP_Mountain03.glb
                SP_Mountain02.glb
                SP_Mountain01.glb
                SP_Ground03.glb
                SP_Ground02.glb
                SP_Ground05.glb
                SP_Ground04.glb
            terrain/
                .DS_Store
                Water.glb
                Terrain.glb
            rocks/
                SP_Rock01.glb
                SP_Rock03.glb
                SP_Rock02.glb
                SP_Rock06.glb
                .DS_Store
                SP_Rock07.glb
                SP_Rock05.glb
                SP_Rock04.glb
                SP_Rock09.glb
                SP_Rock08.glb
        sounds/
            weapon-switch.mp3
            laser.mp3
            bounce.mp3
            weapon-charging.mp3
            grenade-laser.mp3
            laser-bounce.mp3
            weapon-armor-hit.mp3
    entities/
        Ship.js
        obstacles/
        weapons/
            RegularLaser.js
            WeaponSystem.js
            Laser.js
        enemies/
            EnemyManager.js
            Enemy.js
        player/
            Player.js
### DIRECTORY . FOLDER STRUCTURE ###

### DIRECTORY . FLATTENED CONTENT ###
### ./index.html BEGIN ###
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Drift</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles/main.css">
    <link rel="stylesheet" href="./styles/controls.css">
</head>
<body>
    <div id="loading-screen">
        <div class="loading-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="loader"></div>
            <p>Loading the quantum realm...</p>
        </div>
    </div>
    
    <div id="start-screen" class="hidden">
        <div class="start-content">
            <h1>QUANTUM DRIFT</h1>
            <div class="player-input">
                <input type="text" id="player-name" maxlength="15" placeholder="Enter your pilot name" />
                <p class="input-info">Your name will be visible to other players</p>
            </div>
            <button id="start-button" class="glow-button">START GAME</button>
        </div>
    </div>

    <!-- Game container -->
    <div id="game-container"></div>
    
    <!-- Multiplayer Info -->
    <div id="multiplayer-info" class="hidden">
        <div class="connection-indicator">
            <span>Connection: </span>
            <span id="connection-status">Disconnected</span>
        </div>
        <div class="players-indicator">
            <span>Players: </span>
            <span id="players-count">0</span>
        </div>
    </div>
    
    <!-- Simple HUD for controls info -->
    <div class="controls-info hidden">
        <p>W/↑: Forward | S/↓: Backward</p>
        <p>A/← D/→: Rotate Ship</p>
        <p>Q/E: Strafe Left/Right</p>
        <p>Space: Fire Laser</p>
        <p>Avoid the colored obstacles!</p>
    </div>
</body>
<script type="module" src="./index.js"></script>
</html> 
### ./index.html END ###

### ./flatten.py BEGIN ###
import os
import argparse

def printFolderStructure(directory, output_file):
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n")
    for root, directories, files in os.walk(directory):
        level = root.replace(directory, '').count(os.sep)
        indent = ' ' * 4 * (level)
        output_file.write('{}{}/\n'.format(indent, os.path.basename(root)))
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            output_file.write('{}{}\n'.format(subindent, f))
    output_file.write(f"### DIRECTORY {directory} FOLDER STRUCTURE ###\n\n")

def walkFolderTree(folder):
    for dirpath, dirnames, filenames in os.walk(folder):
        for filename in filenames:
            yield os.path.join(dirpath, filename)

def main():
    parser = argparse.ArgumentParser(description='Flattens a codebase.')
    parser.add_argument('--folders', nargs='*', help='Base folders to process')
    parser.add_argument('--system_instructions', action='store_true', help='Print system instructions')

    system_instructions = """## System Instructions for Language Model Assistance in Code Debugging

### Role Definition:
- **Act as a software engineer** tasked with assisting in debugging code.
- Provide insights, explanations, and solutions based on the provided codebase information.

### Codebase Markdown File Structure:
- The codebase markdown file represents the actual codebase structure and content.
- It begins with a directory tree representation:
  ```
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  (file tree representation)
  ### DIRECTORY path/to/file/tree FOLDER STRUCTURE ###
  ```
- Following the directory tree, the contents of each file are displayed:
  ```
  ### path/to/file1 BEGIN ###
  (content of file1)
  ### path/to/file1 END ###
  
  ### path/to/file2 BEGIN ###
  (content of file2)
  ### path/to/file2 END ###
  ```

### Guidelines for Interaction:
- Respond to queries based on the explicit content provided within the markdown file.
- Avoid making assumptions about the code without clear evidence presented in the file content.
- When seeking specific implementation details, refer to the corresponding section in the markdown file, for example:
  ```
  ### folder1/folder2/myfile.ts BEGIN ###
  (specific implementation details)
  ### folder1/folder2/myfile.ts END ###
  ```

### Objective:
- The primary objective is to facilitate effective debugging by providing accurate information and guidance strictly adhering to the content available in the markdown file."""

    args = parser.parse_args()

    if args.system_instructions:
        print(system_instructions)

        if not args.folders:
            return

    if args.folders:
        base_folders = args.folders
        with open('codebase.md', 'w') as output_file:
            for base_folder in base_folders:
                printFolderStructure(base_folder, output_file)
                
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
                for filepath in walkFolderTree(base_folder):
                    content = f"### {filepath} BEGIN ###\n"
                    
                    try:
                        with open(filepath, "r") as f:
                            content += f.read()
                        content += f"\n### {filepath} END ###\n\n"
                    except:
                        continue
                    
                    output_file.write(content)
                output_file.write(f"### DIRECTORY {base_folder} FLATTENED CONTENT ###\n")
    else:
        print("usage: main.py [-h] --folders FOLDERS [FOLDERS ...] [--system_instructions]")
        print("Error: the following arguments are required: --folders")

if __name__ == "__main__":
    main()
### ./flatten.py END ###

### ./index.js BEGIN ###
import * as THREE from 'three';
import { OrbitControls } from '@three/examples/controls/OrbitControls';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import './styles/main.css';
import { GameUI } from './ui/GameUI';
import { MiniMap } from './ui/MiniMap';
import { CONTROL_SETTINGS, CONTROL_FEEDBACK, DEFAULT_CONTROL_STATE, ControlUtils } from './config/Controls';
import { ShipSelectionUI } from './ui/ShipSelectionUI';
import AssetLoader from './assets/AssetLoader';
import { InfiniteMap } from './core/InfiniteMap';
import { NetworkManager } from './core/NetworkManager';
import { CSS2DRenderer, CSS2DObject } from '@three/examples/renderers/CSS2DRenderer';
import { GAME_CONFIG } from './config/GameConfig';
import { Player } from './entities/player/Player';
import { SoundManager } from './assets/SoundManager';

// Basic Three.js game with a ship
class SimpleGame {
  constructor() {
    // Initialize all properties first
    // Player information
    this.playerName = 'Pilot';  // Default player name
    
    // Create the asset loader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => this.updateLoadingUI(message),
      (type, error) => this.handleLoadError(type, error)
    );
    
    // Initialize SoundManager
    this.soundManager = new SoundManager();
    
    // Asset loading state
    this.loadingState = {
      started: false,
      completed: false,
      errors: []
    };
    
    // Track assets loading
    this.assetsLoaded = false;
    this.shipModelLoaded = false;
    
    // Initialize control state
    this.keys = { ...DEFAULT_CONTROL_STATE };
    
    // Setup animation timing
    this.clock = new THREE.Clock();
    this.lastTime = Date.now();
    
    // Event handling - bind methods
    this.boundHandleResize = this.handleResize.bind(this);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleKeyUp = this.handleKeyUp.bind(this);
    this.boundHandleClick = this.handleClick.bind(this);
    this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    
    // Debounce timers
    this.mouseMoveTimer = null;
    this.resizeTimer = null;
    this.weaponCooldowns = new Map();
    this.lastWeaponSwitch = 0;

    // Setup basic Three.js scene
    this.setupScene();
    
    // Create game UI
    this.ui = new GameUI();
    
    // Create player after scene setup (as specified in Task 8)
    this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
      type: 'PLAYER',
      shipModel: 'STANDARD',
      teamColor: 0x00ffff
    });
    this.scene.add(this.player.mesh);
    
    // For backward compatibility with existing code
    this.playerShip = this.player.mesh;
    
    // Game properties
    this.boundarySize = 100; // Size of the playable area
    
    // Initialize player state
    this.health = 100;
    this.maxHealth = 100;
    this.energy = 100;
    this.maxEnergy = 100;
    this.energyRechargeRate = 20; // Units per second
    this.currentWeapon = 'LASER';
    
    // Initialize available weapons
    this.availableWeapons = ['LASER', 'GRENADE', 'BOUNCE'];
    this.weaponIndex = 0; // Start with LASER
    
    // Load assets
    this.loadAssets();
    
    // Setup controls
    this.setupControls();
    
    // Initialize infinite map after scene setup
    this.infiniteMap = new InfiniteMap(this);
    
    // Create mini-map (after scene setup) but keep it hidden initially
    this.miniMap = new MiniMap(this);
    this.miniMap.hide(); // Make sure it starts hidden
    
    // Handle window resize
    window.addEventListener('resize', this.boundHandleResize);
    
    console.log('Simple game initialized!');

    // Add frame counter
    this.frameCount = 0;
    
    // Initialize NetworkManager
    this.networkManager = new NetworkManager();
    
    // Initialize remotePlayers map for multiplayer
    this.remotePlayers = new Map();
    
    this.networkManager.on('connected', () => {
      console.log('Connected to game server!');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from game server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      // Update player count
      this.updatePlayerCount();
    });
    
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      // Remove player mesh if it exists
      const player = this.remotePlayers.get(id);
      if (player) {
        this.scene.remove(player);
        this.remotePlayers.delete(id);
        console.log(`Removed remote player: ${id}`);
      }
      // Update player count
      this.updatePlayerCount();
    });
    
    // Add player update handling
    this.networkManager.on('player_update', (data) => {
      this.updateRemotePlayer(data.id, data.position, data.rotation);
    });
    
    // Add laser shot handling
    this.networkManager.on('laser_shot', (shotData) => {
      console.log('Received laser shot from network:', shotData);
      const position = new THREE.Vector3(shotData.origin.x, shotData.origin.y, shotData.origin.z);
      const direction = new THREE.Vector3(shotData.direction.x, shotData.direction.y, shotData.direction.z);

      if (shotData.type === 'bounce') {
        this.fireBouncingLaser(position, direction);
      } else {
        this.fireLaser(position, direction);
      }
    });
    
    // Add helper method to update player count
    this.updatePlayerCount = () => {
      const count = this.networkManager.getOtherPlayers().length + 1; // +1 for self
      document.getElementById('players-count').textContent = count;
    };
    
    this.multiplayerEnabled = false;
  }
  
  setupScene() {
    // Create Three.js Scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x0a0a1f); // Dark blue background
    
    // Setup WebGL renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setPixelRatio(window.devicePixelRatio);
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('game-container').appendChild(this.renderer.domElement);
    
    // Create camera
    this.camera = new THREE.PerspectiveCamera(
      60, // FOV
      window.innerWidth / window.innerHeight, // Aspect ratio
      0.1, // Near
      1000 // Far
    );
    
    // Position camera
    this.camera.position.set(0, 7, 15); // Slightly above and behind player
    this.camera.lookAt(0, 0, 0);
    
    // Attach audio listener to camera
    if (this.soundManager) {
      this.camera.add(this.soundManager.getListener());
      console.log('Audio listener attached to camera');
    }
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    this.scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(1, 1, 1).normalize();
    this.scene.add(directionalLight);
    
    // Create a simple grid floor
    this.createFloor();
    
    // Create some obstacles
    this.createObstacles();
  }
  
  async loadAssets() {
    if (this.loadingState.started) {
        console.warn('🔍 Asset loading already in progress');
        return;
    }
    
    this.updateLoadingUI('Loading game assets...');
    
    try {
        // Create initial player with default ship
        if (!this.player) {
            this.player = new Player(this.scene, new THREE.Vector3(0, 0.5, 0), {
                type: 'PLAYER',
                shipModel: 'STANDARD',
                teamColor: 0x00ffff
            });
            this.playerShip = this.player.mesh; // For backward compatibility
        }
        
        // Load all assets through AssetLoader
        await this.assetLoader.loadAll();
        this.assetsLoaded = true;
        this.shipModelLoaded = true;
        
        console.log('✅ All assets loaded successfully');
        this.checkLoadingProgress();
    } catch (error) {
        console.error('🔍 Critical error loading assets:', error);
        this.handleLoadError('critical', error);
    }
  }
  
  handleLoadError(assetType, error) {
    console.error(`Error loading ${assetType}:`, error);
    this.loadingState.errors.push({ type: assetType, error: error.message });
    
    // Update UI with error
    this.updateLoadingUI(`Error loading ${assetType}. ${this.loadingState.errors.length} errors total.`);
    
    // If critical error, show error screen
    if (assetType === 'critical') {
      this.showErrorScreen('Failed to load game assets. Please refresh the page.');
    }
  }
  
  updateLoadingUI(message) {
    const loadingScreen = document.getElementById('loading-screen');
    if (loadingScreen) {
      const messageElement = loadingScreen.querySelector('.loading-message');
      if (messageElement) {
        messageElement.textContent = message;
      }
    }
  }
  
  showErrorScreen(message) {
    // Create error screen if it doesn't exist
    let errorScreen = document.getElementById('error-screen');
    if (!errorScreen) {
      errorScreen = document.createElement('div');
      errorScreen.id = 'error-screen';
      errorScreen.className = 'error-screen';
      
      const errorMessage = document.createElement('div');
      errorMessage.className = 'error-message';
      errorScreen.appendChild(errorMessage);
      
      const retryButton = document.createElement('button');
      retryButton.textContent = 'Retry';
      retryButton.onclick = () => {
        errorScreen.remove();
        this.loadingState = {
          started: false,
          completed: false,
          errors: []
        };
        this.loadAssets();
      };
      errorScreen.appendChild(retryButton);
      
      document.body.appendChild(errorScreen);
    }
    
    // Update error message
    const messageElement = errorScreen.querySelector('.error-message');
    if (messageElement) {
      messageElement.textContent = message;
    }
  }
  
  checkLoadingProgress() {
    console.log('🔍 Checking loading progress...');
    
    // Log loading state
    console.log('Loading state:', JSON.stringify(this.loadingState, null, 2));
    
    // Define what's required for a fully loaded game
    const requiredAssets = {
      shipModel: this.shipModelLoaded,
      assetsLoaded: this.assetLoader.loadingState.completed
    };
    
    // Check if all required assets are loaded
    const allAssetsLoaded = Object.entries(requiredAssets).every(([key, loaded]) => {
      console.log(`🔍 ${key}: ${loaded ? '✅' : '❌'}`);
      return loaded;
    });
    
    if (allAssetsLoaded) {
      console.log('✅ All required assets loaded!');
      this.loadingState.completed = true;
      this.showStartScreen();
    } else {
      // Log which assets are still pending
      const pendingAssets = Object.entries(requiredAssets)
        .filter(([_, loaded]) => !loaded)
        .map(([key]) => key);
      console.log('⏳ Still waiting for:', pendingAssets);
      
      // Update loading UI
      this.updateLoadingUI(`Loading... (${pendingAssets.join(', ')})`);
      
      // Check again after a delay
      setTimeout(() => this.checkLoadingProgress(), 1000);
    }
  }
  
  showStartScreen() {
    console.log('🔍 Attempting to show start screen');
    
    // Timeout to ensure UI has time to update
    setTimeout(() => {
      // Hide loading screen and show start screen
      const loadingScreen = document.getElementById('loading-screen');
      const startScreen = document.getElementById('start-screen');
      
      console.log('🔍 Loading screen element:', loadingScreen);
      console.log('🔍 Start screen element:', startScreen);
      
      if (loadingScreen) {
        console.log('🔍 Adding fade-out class to loading screen');
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          loadingScreen.classList.add('hidden');
          loadingScreen.classList.remove('fade-out');
          console.log('🔍 Loading screen hidden');
        }, 500);
      } else {
        console.error('🔍 Loading screen element not found!');
      }
      
      if (startScreen) {
        console.log('🔍 Showing start screen');
        startScreen.classList.remove('hidden');
        startScreen.classList.add('fade-in');
      } else {
        console.error('🔍 Start screen element not found!');
      }
      
      console.log('🔍 Game ready to start!');
    }, 500);
  }
  
  addThrusterGlow() {
    // Check if player and player mesh exist
    if (!this.player || !this.player.mesh) {
      console.warn('Cannot add thruster glow: Player or player mesh is not initialized');
      return;
    }
    
    // Create a single, efficient thruster glow effect
    // Use instanced mesh for better performance if you have multiple thrusters
    
    // Create a glow for the thruster
    const thrusterGeometry = new THREE.CylinderGeometry(0.2, 0.3, 0.5, 12);
    const thrusterMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.7,
      blending: THREE.AdditiveBlending // Use additive blending for better glow effect
    });
    
    const thruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
    thruster.position.set(0, 0, -0.7); // Position at the back of the ship
    thruster.rotation.x = Math.PI / 2;
    thruster.name = 'thruster'; // Name it for easier reference later
    
    // Add thruster to player mesh
    this.player.mesh.add(thruster);
    
    // Add point light for the thruster
    const thrusterLight = new THREE.PointLight(0x00ffff, 1, 3);
    thrusterLight.position.copy(thruster.position);
    thrusterLight.name = 'thrusterLight';
    
    // Store references for animation
    this.thruster = thruster;
    this.thrusterLight = thrusterLight;
    
    // Create a subtle, animated glow effect with proper initialization
    this.thrusterPulse = { 
      value: 0,
      phase: 0 
    };
    
    // Add to ship model
    if (this.shipModel) {
      this.shipModel.add(thruster);
      this.shipModel.add(thrusterLight);
    }
  }
  
  createFloor() {
    console.log('Creating floor with Terrain.glb model');
    
    // Create a placeholder floor initially - this will be visible until the model loads
    const tempFloorGeometry = new THREE.PlaneGeometry(100, 100, 1, 1);
    const tempFloorMaterial = new THREE.MeshBasicMaterial({
      color: 0x000022,
      transparent: true,
      opacity: 0.2,
    });
    
    this.floor = new THREE.Mesh(tempFloorGeometry, tempFloorMaterial);
    this.floor.rotation.x = -Math.PI / 2;
    this.floor.position.y = -0.01;
    this.scene.add(this.floor);
    
    // Also create an invisible raycasting plane that will always work for targeting
    // This ensures mouse input works consistently regardless of the visual floor model
    this.raycastFloor = new THREE.Mesh(
      new THREE.PlaneGeometry(1000, 1000),
      new THREE.MeshBasicMaterial({ 
        color: 0x00ff00,
        transparent: true, 
        opacity: 0.05, // Very slight visibility for debugging
        side: THREE.DoubleSide
      })
    );
    this.raycastFloor.rotation.x = -Math.PI / 2;
    this.raycastFloor.position.y = 0.1; // Position higher above terrain
    this.scene.add(this.raycastFloor);
    
    // Add debug logging
    console.log('Raycast floor created at height:', this.raycastFloor.position.y, 'and size:', 1000);
    
    // Load texture first
    const textureLoader = new THREE.TextureLoader();
    const texturePromise = new Promise((resolve, reject) => {
      textureLoader.load(
        'assets/models/textures/Colors3.png', 
        texture => {
          console.log('Terrain texture (Colors3.png) loaded successfully');
          // Configure texture 
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;
          texture.repeat.set(8, 8); // Repeat the texture more times for better detail
          resolve(texture);
        },
        undefined,
        error => {
          console.error('Error loading Colors3.png texture:', error);
          // Try fallback texture
          textureLoader.load(
            'assets/models/textures/tex.png', 
            fallbackTexture => {
              console.log('Fallback texture loaded');
              fallbackTexture.wrapS = THREE.RepeatWrapping;
              fallbackTexture.wrapT = THREE.RepeatWrapping;
              fallbackTexture.repeat.set(5, 5);
              resolve(fallbackTexture);
            },
            undefined,
            fallbackError => {
              console.error('Error loading fallback texture:', fallbackError);
              resolve(null); // Resolve with null to continue without texture
            }
          );
        }
      );
    });
    
    // When texture is loaded (or failed), get the terrain model from AssetLoader
    texturePromise.then(texture => {
      // Get terrain model from AssetLoader
      const terrain = this.assetLoader.getModel('terrain/Terrain.glb');
      
      if (terrain) {
        console.log('Using terrain model from AssetLoader');
        
        // Remove the temporary floor
        if (this.floor) {
          this.scene.remove(this.floor);
          this.floor.geometry.dispose();
          this.floor.material.dispose();
        }
        
        // Clone the model to avoid modifying the original
        const terrainClone = terrain.clone();
        
        // Scale the terrain appropriately
        const terrainScale = 100; // Adjust this value to change the overall size
        terrainClone.scale.set(terrainScale, terrainScale * 0.5, terrainScale);
        
        // Position terrain at center and slightly below zero to avoid z-fighting
        terrainClone.position.set(0, -0.2, 0);
        
        // Apply texture if available
        if (texture) {
          terrainClone.traverse((node) => {
            if (node.isMesh) {
              node.material = node.material.clone(); // Clone material to avoid affecting other instances
              node.material.map = texture;
              node.material.needsUpdate = true;
              
              // Enable shadows
              node.castShadow = true;
              node.receiveShadow = true;
            }
          });
        }
        
        // Add to scene
        this.scene.add(terrainClone);
        this.terrain = terrainClone;
        
        console.log('Terrain model added to scene');
        
        // Add a circular highlight around the player's position
        this.createPlayerHighlight();
      } else {
        console.warn('Terrain model not found in AssetLoader, using fallback grid');
        
        // Create a grid as fallback
        const grid = new THREE.GridHelper(100, 100, 0x0000ff, 0x000044);
        grid.position.y = 0;
        this.scene.add(grid);
        this.terrain = grid;
        
        // Add player highlight anyway
        this.createPlayerHighlight();
      }
    });
  }

  // Separate method for player highlight to avoid code duplication
  createPlayerHighlight() {
    // Add a circular highlight around the player's position
    const highlightGeometry = new THREE.CircleGeometry(5, 32);
    const highlightMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.1,
    });
    
    this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
    this.playerHighlight.rotation.x = -Math.PI / 2;
    this.playerHighlight.position.y = 0.02; // Slightly above the floor
    this.scene.add(this.playerHighlight);
  }
  
  createBoundaryMarkers() {
    const boundarySize = 25; // Should match constrainToBounds boundary
    const markerSize = 1;
    const markerHeight = 1;
    const numMarkers = 10; // Number of markers per side
    
    const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
    const markerMaterial = new THREE.MeshPhongMaterial({
      color: 0xff0000,
      emissive: 0x600000,
      transparent: true,
      opacity: 0.7
    });
    
    const markers = new THREE.Group();
    
    // Create boundary markers along the perimeter
    for (let i = 0; i < numMarkers; i++) {
      const t = (i / (numMarkers - 1)) * 2 - 1; // -1 to 1
      const position = boundarySize * t;
      
      // North edge
      const northMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      northMarker.position.set(position, markerHeight / 2, -boundarySize);
      markers.add(northMarker);
      
      // South edge
      const southMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      southMarker.position.set(position, markerHeight / 2, boundarySize);
      markers.add(southMarker);
      
      // East edge
      const eastMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      eastMarker.position.set(boundarySize, markerHeight / 2, position);
      markers.add(eastMarker);
      
      // West edge
      const westMarker = new THREE.Mesh(markerGeometry, markerMaterial);
      westMarker.position.set(-boundarySize, markerHeight / 2, position);
      markers.add(westMarker);
    }
    
    this.scene.add(markers);
  }
  
  createObstacles() {
    // Create obstacle arrays
    this.obstacles = [];
    
    console.log('🚧 Creating immersive landscape with pathways and scattered crystals');
    
    // Define model categories and paths, with a focus on variety and character
    const obstacleCategories = {
      // Small to medium rocks
      rocks: [
        'SP_Rock01.glb', 
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      // Expanded flora selection
      flora: [
        'Grass_01.glb',
        'Mushrooms.glb',
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SmalRoots_01.glb',
        'Tenticles_01.glb',
        'BigPlant_06.glb'
      ],
      // Expanded ground features for creating pathways
      groundFeatures: [
        'objects/SP_Ground02.glb',
        'objects/SP_Ground03.glb',
        'objects/SP_Ground04.glb',
        'objects/SP_Ground05.glb'
      ],
      // Crystal clusters for interest points
      crystals: [
        'objects/SP_Crystal01.glb',
        'objects/SP_Stone01.glb'
      ],
      // Mountains for landscape borders and key landmarks
      mountains: [
        'objects/SP_Mountain01.glb',
        'objects/SP_Mountain02.glb',
        'objects/SP_Mountain03.glb'
      ]
    };
    
    // Enhanced distribution for a more detailed landscape
    const distribution = {
      rocks: 8,
      flora: 10,
      groundFeatures: 18,  // Increased from 12 to 18
      crystals: 9,
      mountains: 12  // Increased from 4 to 12
    };
    
    // Define some pre-made templates for object groupings
    const templates = [
      // Rock garden template
      {
        position: new THREE.Vector3(25, 0, 15),
        rotation: Math.PI / 6,
        elements: [
          { category: 'rocks', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 2.0, rotation: 0 },
          { category: 'rocks', modelIndex: 2, offset: new THREE.Vector3(3, 0, 1), scale: 1.3, rotation: Math.PI/3 },
          { category: 'rocks', modelIndex: 1, offset: new THREE.Vector3(-2, 0, 2), scale: 1.5, rotation: Math.PI/5 },
          { category: 'flora', modelIndex: 1, offset: new THREE.Vector3(2, 0, 3), scale: 1.2, rotation: 0 }
        ]
      },
      // Flora cluster template
      {
        position: new THREE.Vector3(-20, 0, -18),
        rotation: Math.PI / 4,
        elements: [
          { category: 'flora', modelIndex: 4, offset: new THREE.Vector3(0, 0, 0), scale: 1.8, rotation: 0 },
          { category: 'flora', modelIndex: 0, offset: new THREE.Vector3(2, 0, 2), scale: 1.4, rotation: Math.PI/2 },
          { category: 'flora', modelIndex: 3, offset: new THREE.Vector3(-1.5, 0, 1), scale: 1.2, rotation: Math.PI/6 },
          { category: 'rocks', modelIndex: 3, offset: new THREE.Vector3(1, 0, -2), scale: 1.0, rotation: 0 }
        ]
      },
      // Crystal formation template
      {
        position: new THREE.Vector3(-15, 0, 30),
        rotation: -Math.PI / 3,
        elements: [
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(0, 0, 0), scale: 1.5, rotation: 0 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(1.5, 0, 1), scale: 1.0, rotation: Math.PI/2 },
          { category: 'crystals', modelIndex: 0, offset: new THREE.Vector3(-1, 0, 1.5), scale: 0.8, rotation: Math.PI/4 },
          { category: 'groundFeatures', modelIndex: 2, offset: new THREE.Vector3(0, -0.2, 0), scale: 1.8, rotation: 0 }
        ]
      }
    ];
    
    // Create main pathways (4 paths coming from center, like a cross)
    const pathways = [
      { direction: new THREE.Vector3(1, 0, 0), width: 5 },   // East
      { direction: new THREE.Vector3(-1, 0, 0), width: 5 },  // West
      { direction: new THREE.Vector3(0, 0, 1), width: 5 },   // North
      { direction: new THREE.Vector3(0, 0, -1), width: 5 }   // South
    ];
    
    // Add some curved pathways to make it more interesting
    pathways.push(
      { 
        direction: new THREE.Vector3(0.7, 0, 0.7), 
        width: 4,
        curve: 0.8 // Will curve around
      },
      { 
        direction: new THREE.Vector3(-0.7, 0, -0.7), 
        width: 4,
        curve: -0.5 // Will curve the other way
      }
    );
    
    // Create some crystal gardens (clusters of crystals)
    const crystalGardens = [
      { x: 30, z: 30, radius: 8, count: 4 },
      { x: -25, z: 20, radius: 6, count: 3 },
      { x: 15, z: -35, radius: 10, count: 5 }
    ];
    
    // Function to check if a position is near a pathway
    const isNearPathway = (x, z, pathWidth) => {
      for (const path of pathways) {
        // Create a vector from center to this position
        const posVector = new THREE.Vector3(x, 0, z);
        const length = posVector.length();
        
        // Normalize the vector to compare direction
        if (length > 0) posVector.divideScalar(length);
        
        // Check if this aligns with any pathway
        const dot = posVector.dot(path.direction);
        
        // If aligned with path direction and not too close to center
        if (dot > 0.7 && length > 15 && length < 40) {
          // Calculate perpendicular distance to path
          const perpFactor = Math.sqrt(1 - dot * dot) * length;
          if (perpFactor < (path.width || pathWidth)) {
            return true;
          }
          
          // For curved paths
          if (path.curve) {
            // Check if in a curved region
            if (length > 20) {
              // Apply curvature - this is simplified but creates a nice effect
              const curveFactor = (length - 20) * path.curve * 0.1;
              const curvePerp = Math.abs(perpFactor - curveFactor);
              if (curvePerp < (path.width || pathWidth)) {
                return true;
              }
            }
          }
        }
      }
      return false;
    };
    
    // Function to check if position is in a crystal garden
    const isInCrystalGarden = (x, z) => {
      for (const garden of crystalGardens) {
        const dx = x - garden.x;
        const dz = z - garden.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        if (distance < garden.radius) {
          return garden;
        }
      }
      return null;
    };
    
    // Load and place models as obstacles
    for (const [category, models] of Object.entries(obstacleCategories)) {
      const count = distribution[category];
      
      for (let i = 0; i < count; i++) {
        // Select a random model from this category
        const modelPath = models[Math.floor(Math.random() * models.length)];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Create position based on category
        let x, z;
        let attempts = 0;
        let isValid = false;
        let inGarden = null;
        
        while (!isValid && attempts < 30) {
          attempts++;
          
          if (category === 'groundFeatures') {
            // Ground features go along pathways or in open areas
            if (Math.random() < 0.7) {
              // 70% along pathways
              const angle = Math.random() * Math.PI * 2;
              const distance = 15 + Math.random() * 25; // Between 15-40 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
              
              // If not near a pathway, try again
              if (!isNearPathway(x, z, 6)) continue;
            } else {
              // 30% randomly placed
              x = (Math.random() * 80) - 40;
              z = (Math.random() * 80) - 40;
            }
          } else if (category === 'crystals') {
            // Try to place in crystal gardens
            if (Math.random() < 0.7) {
              // 70% in crystal gardens
              const garden = crystalGardens[Math.floor(Math.random() * crystalGardens.length)];
              const angle = Math.random() * Math.PI * 2;
              const distance = Math.random() * garden.radius;
              x = garden.x + Math.cos(angle) * distance;
              z = garden.z + Math.sin(angle) * distance;
              inGarden = garden;
            } else {
              // 30% scattered elsewhere, avoiding pathways
              x = (Math.random() * 70) - 35;
              z = (Math.random() * 70) - 35;
              
              // If near a pathway, try again
              if (isNearPathway(x, z, 6)) continue;
            }
          } else if (category === 'mountains') {
            // Mountains go on the periphery with more diverse placement
            if (i < 4) {
              // Place 4 mountains at the far corners of the map
              const angle = (Math.PI/4) + (i * Math.PI/2); // Place at 45°, 135°, 225°, 315°
              const distance = 40 + Math.random() * 5; // Between 40-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else if (i < 8) {
              // Place 4 mountains at cardinal directions, but further out
              const angle = (i - 4) * Math.PI/2; // Place at 0°, 90°, 180°, 270°
              const distance = 42 + Math.random() * 8; // Between 42-50 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            } else {
              // Place remaining mountains randomly but still on periphery
              const angle = Math.random() * Math.PI * 2;
              const distance = 35 + Math.random() * 10; // Between 35-45 from center
              x = Math.cos(angle) * distance;
              z = Math.sin(angle) * distance;
            }
            
            // If near a pathway, try again (want mountains to border but not block paths)
            if (isNearPathway(x, z, 8)) continue;
          } else {
            // Rocks and flora go anywhere but not on paths
            x = (Math.random() * 80) - 40;
            z = (Math.random() * 80) - 40;
            
            // Avoid pathways for these obstacles
            if (isNearPathway(x, z, 5)) continue;
          }
          
          // Keep all objects away from center spawn
          if (Math.sqrt(x * x + z * z) < 15) continue;
          
          // Position is valid
          isValid = true;
        }
        
        if (!isValid) continue; // Skip if couldn't find valid position
        
        // Scale factors tailored by category and context
        let scale;
        if (category === 'rocks') {
          scale = 1.5 + Math.random() * 1.0; // Larger rocks (1.5-2.5)
        } else if (category === 'flora') {
          scale = 1.2 + Math.random() * 0.8; // Taller flora (1.2-2.0)
        } else if (category === 'groundFeatures') {
          if (isNearPathway(x, z, 6)) {
            // Ground features along pathways have more consistent size
            scale = 1.2 + Math.random() * 0.6; // Medium-sized ground (1.2-1.8)
          } else {
            // Ground features away from pathways can vary more
            scale = 0.8 + Math.random() * 1.4; // Variable ground features (0.8-2.2)
          }
        } else if (category === 'crystals') {
          if (inGarden) {
            // Varied crystal sizes in gardens
            scale = 0.5 + Math.random() * 1.4; // Variety of sizes (0.5-1.9)
          } else {
            // Scattered crystals are smaller
            scale = 0.7 + Math.random() * 0.6; // Smaller scattered (0.7-1.3)
          }
        } else if (category === 'mountains') {
          // More diverse mountain scales based on position
          if (i < 4) {
            // Corner mountains are largest
            scale = 2.2 + Math.random() * 1.3; // Largest mountains (2.2-3.5)
          } else if (i < 8) {
            // Cardinal direction mountains are medium-large
            scale = 1.8 + Math.random() * 1.0; // Medium-large mountains (1.8-2.8)
          } else {
            // Random mountains have varied sizes
            scale = 1.4 + Math.random() * 1.6; // Variable mountains (1.4-3.0)
          }
        }
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale and position
            model.scale.set(scale, scale, scale);
            model.position.set(x, 0, z); // Will adjust y based on model size
            
            // Add randomized rotation, except for ground features on pathways
            if (category === 'groundFeatures' && isNearPathway(x, z, 6)) {
              // Align with nearest pathway for ground features
              const alignAngle = Math.atan2(z, x);
              model.rotation.y = alignAngle + (Math.random() * 0.5 - 0.25); // Slight variation
            } else {
              model.rotation.y = Math.random() * Math.PI * 2;
            }
            
            // Enable shadows with optimization
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Optimize materials while keeping visual quality
                if (node.material) {
                  // Add category-specific visual enhancements
                  if (category === 'crystals' && modelPath.includes('Crystal')) {
                    // Make crystals glow with random colors
                    const crystalColors = [
                      new THREE.Color(0x00ffff), // cyan
                      new THREE.Color(0xff00ff), // magenta
                      new THREE.Color(0x88bbff), // light blue
                      new THREE.Color(0xffaa00)  // orange
                    ];
                    
                    // Random crystal color
                    const crystalColor = crystalColors[Math.floor(Math.random() * crystalColors.length)];
                    node.material.emissive = crystalColor;
                    node.material.emissiveIntensity = 0.3 + Math.random() * 0.3; // 0.3-0.6
                  } else if (category === 'mountains') {
                    // Give mountains a slight purple/blue tint
                    node.material.color = new THREE.Color(0x9090b0);
                  } else if (category === 'groundFeatures') {
                    // Give ground features varied earthy tones
                    const groundColors = [
                      new THREE.Color(0x908070), // tan
                      new THREE.Color(0x807060), // brown
                      new THREE.Color(0x708060), // olive
                      new THREE.Color(0x606070)  // slate
                    ];
                    node.material.color = groundColors[Math.floor(Math.random() * groundColors.length)];
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // IMPROVED COLLISION DETECTION: Use oriented bounding box for more accurate collisions
            // First, compute an accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use the improved ground placement calculation
            const groundY = this.calculateGroundOffset(model, category, scale);
            model.position.y = groundY;
            
            // Generate compound collision shapes for more accurate collision detection
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, scale);
            
            // Create better collision data with compound shapes
            const obstacleData = {
              mesh: model,
              type: category,
              // Advanced collision data
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              // Keep bounding box for broad-phase checks
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * scale / 2),
                  model.position.y - (size.y * scale / 2),
                  model.position.z - (size.z * scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * scale / 2),
                  model.position.y + (size.y * scale / 2),
                  model.position.z + (size.z * scale / 2)
                ),
                size: size.clone().multiplyScalar(scale),
                rotation: model.rotation.y
              },
              // Also keep a simple radius for quick distance checks
              size: Math.max(size.x, size.z) * scale * 0.5,
              position: model.position.clone()
            };
            
            this.obstacles.push(obstacleData);
            
            // Log first few obstacles for debugging
            if (this.obstacles.length <= 3) {
              console.log(`Created ${category} obstacle from ${modelPath}: width=${size.x * scale}, height=${size.y * scale}, depth=${size.z * scale} at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
            }
          },
          undefined, // Progress callback
          (error) => {
            console.error(`Error loading obstacle model ${fullPath}:`, error);
          }
        );
      }
    }
    
    // Create a special centerpiece crystal formation
    this.createCenterpiece();
    
    // Create template-based object groupings for more cohesive landscape
    this.createTemplateGroupings(templates, obstacleCategories);
    
    console.log(`Started loading ${Object.values(distribution).reduce((a, b) => a + b, 0)} obstacles with pathways and crystal gardens`);
  }
  
  /**
   * Create template-based object groupings
   */
  createTemplateGroupings(templates, categoryModels) {
    console.log('Creating template-based object groupings');
    
    templates.forEach((template, templateIndex) => {
      const templatePosition = template.position;
      const templateRotation = template.rotation;
      
      // Process each element in the template
      template.elements.forEach(element => {
        const category = element.category;
        
        // Get the model list for this category
        const models = categoryModels[category];
        if (!models || models.length === 0) return;
        
        // Select model by index or randomly if index is out of bounds
        const modelIndex = element.modelIndex < models.length ? element.modelIndex : Math.floor(Math.random() * models.length);
        const modelPath = models[modelIndex];
        
        // Handle different paths based on category
        let fullPath;
        if (modelPath.includes('/')) {
          // Path already includes the folder
          fullPath = `assets/models/${modelPath}`;
        } else {
          // Use the category as the folder
          fullPath = `assets/models/${category}/${modelPath}`;
        }
        
        // Calculate final position with rotation applied to offset
        const offset = element.offset.clone();
        
        // Apply template rotation to the offset
        if (templateRotation) {
          // Create rotation matrix
          const rotMatrix = new THREE.Matrix4().makeRotationY(templateRotation);
          offset.applyMatrix4(rotMatrix);
        }
        
        // Final position combines template position and rotated offset
        const finalPosition = new THREE.Vector3(
          templatePosition.x + offset.x,
          templatePosition.y + offset.y,
          templatePosition.z + offset.z
        );
        
        // Final rotation combines template rotation and element rotation
        const finalRotation = templateRotation + element.rotation;
        
        // Use loader to get the model
        const loader = new GLTFLoader();
        loader.load(
          fullPath,
          (gltf) => {
            const model = gltf.scene;
            
            // Apply scale
            model.scale.set(element.scale, element.scale, element.scale);
            
            // Set initial position 
            model.position.copy(finalPosition);
            
            // Apply rotation
            model.rotation.y = finalRotation;
            
            // Enable shadows with appropriate material enhancements
            model.traverse(node => {
              if (node.isMesh) {
                node.castShadow = true;
                node.receiveShadow = true;
                
                // Apply category-specific visual effects
                if (node.material) {
                  if (category === 'crystals') {
                    // Crystal glow effect
                    node.material.emissive = new THREE.Color(0x88bbff);
                    node.material.emissiveIntensity = 0.3;
                  }
                }
              }
            });
            
            // Add to scene
            this.scene.add(model);
            
            // Compute accurate bounding box
            const bbox = new THREE.Box3().setFromObject(model);
            const size = bbox.getSize(new THREE.Vector3());
            
            // Use improved ground placement
            const groundY = this.calculateGroundOffset(model, category, element.scale);
            model.position.y = groundY + element.offset.y; // Apply any intentional Y offset
            
            // Generate compound collision shapes
            const collisionShapes = this.generateCompoundCollisionShapes(model, category, element.scale);
            
            // Add to obstacles array with collision data
            this.obstacles.push({
              mesh: model,
              type: category,
              collisionShape: 'compound',
              compoundShapes: collisionShapes.map(shape => {
                // Transform shape centers to world coordinates
                const worldCenter = shape.center.clone();
                worldCenter.add(model.position);
                
                return {
                  ...shape,
                  center: worldCenter,
                  worldRotation: model.rotation.y + (shape.rotation || 0)
                };
              }),
              boundingBox: {
                min: new THREE.Vector3(
                  model.position.x - (size.x * element.scale / 2),
                  model.position.y - (size.y * element.scale / 2),
                  model.position.z - (size.z * element.scale / 2)
                ),
                max: new THREE.Vector3(
                  model.position.x + (size.x * element.scale / 2),
                  model.position.y + (size.y * element.scale / 2),
                  model.position.z + (size.z * element.scale / 2)
                ),
                size: size.clone().multiplyScalar(element.scale),
                rotation: model.rotation.y
              },
              size: Math.max(size.x, size.z) * element.scale * 0.5,
              position: model.position.clone()
            });
            
            console.log(`Template ${templateIndex+1}: Added ${category} model at [${model.position.x.toFixed(1)}, ${model.position.y.toFixed(1)}, ${model.position.z.toFixed(1)}]`);
          },
          undefined,
          (error) => {
            console.error(`Error loading template model ${fullPath}:`, error);
          }
        );
      });
    });
  }
  
  setupControls() {
    // Store active keys for visual feedback
    this.activeKeys = new Set();
    
    // Add visual indicators for controls
    this.createControlIndicators();
    
    // Detect if we're on a touch device
    this.isTouchDevice = 'ontouchstart' in window;
    
    // Keyboard controls
    document.addEventListener('keydown', this.boundHandleKeyDown);
    document.addEventListener('keyup', this.boundHandleKeyUp);
    
    // Mouse controls - attach to the canvas for better precision
    const canvas = this.renderer.domElement;
    canvas.addEventListener('click', this.boundHandleClick);
    canvas.addEventListener('mousemove', this.boundHandleMouseMove);
    
    // Setup touch controls for mobile devices
    if (this.isTouchDevice) {
      this.setupTouchControls();
    }
  }
  
  createControlIndicators() {
    console.log('Creating control indicators');
    // Create container if it doesn't exist
    if (!this.controlsContainer) {
        this.controlsContainer = document.createElement('div');
        this.controlsContainer.id = 'controls';
        this.controlsContainer.className = 'control-indicators';
        document.body.appendChild(this.controlsContainer);
        console.log('Control container created');
    }

    // Clear existing indicators
    this.controlsContainer.innerHTML = '';
    
    // Create the movement controls grid
    const movementControls = document.createElement('div');
    movementControls.className = 'movement-controls control-group';
    
    // Create the weapon controls section
    const weaponControls = document.createElement('div');
    weaponControls.className = 'weapon-controls control-group';
    
    // Define the key indicators for movement
    const movementKeys = [
        { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward', gridArea: 'forward' },
        { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward', gridArea: 'backward' },
        { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left', gridArea: 'left' },
        { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right', gridArea: 'right' },
        { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left', gridArea: 'strafeLeft' },
        { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right', gridArea: 'strafeRight' },
        { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon', gridArea: 'fire' }
    ];
    
    // Define the key indicators for weapons
    const weaponKeys = [
        { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser', className: 'weapon-key' },
        { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade', className: 'weapon-key' },
        { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser', className: 'weapon-key' },
        { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon', className: 'weapon-key' }
    ];
    
    // Create movement indicators
    movementKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        movementControls.appendChild(indicator);
    });
    
    // Create weapon indicators
    weaponKeys.forEach(keyInfo => {
        const indicator = document.createElement('div');
        indicator.id = `indicator-${keyInfo.id}`;
        indicator.className = `key-indicator ${keyInfo.className || ''}`;
        indicator.innerHTML = `
            <span class="key">${keyInfo.key}</span>
            <span class="label">${keyInfo.label}</span>
        `;
        indicator.title = keyInfo.tooltip;
        weaponControls.appendChild(indicator);
    });
    
    // Add a controls hint
    const hint = document.createElement('div');
    hint.className = 'controls-hint';
    hint.textContent = 'Press C to toggle controls visibility';
    
    // Add all elements to controls container
    this.controlsContainer.appendChild(movementControls);
    this.controlsContainer.appendChild(weaponControls);
    this.controlsContainer.appendChild(hint);
    
    console.log('Control indicators created with updated structure');
  }
  
  updateControlIndicators() {
    // Skip if control indicators aren't created yet
    if (!this.controlsContainer) return;
    
    // Update movement keys
    this.updateIndicatorState('forward', this.keys.forward);
    this.updateIndicatorState('backward', this.keys.backward);
    this.updateIndicatorState('left', this.keys.left);
    this.updateIndicatorState('right', this.keys.right);
    this.updateIndicatorState('strafeLeft', this.keys.strafeLeft);
    this.updateIndicatorState('strafeRight', this.keys.strafeRight);
    
    // Update fire state
    this.updateIndicatorState('fire', this.keys.fire);
    
    // Update weapon selection
    this.updateIndicatorState('selectLaser', this.currentWeapon === 'LASER');
    this.updateIndicatorState('selectGrenade', this.currentWeapon === 'GRENADE');
    this.updateIndicatorState('selectBounce', this.currentWeapon === 'BOUNCE');
  }
  
  updateIndicatorState(id, isActive) {
    const indicator = this.controlsContainer?.querySelector(`#indicator-${id}`);
    if (indicator) {
      if (isActive) {
        indicator.classList.add('active');
      } else {
        indicator.classList.remove('active');
      }
    }
  }
  
  handleResize(event) {
    // Debounce resize events
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    
    this.resizeTimer = setTimeout(() => {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.resizeTimer = null;
    }, 100);
  }
  
  handleKeyDown(event) {
    // Handle escape key for in-game menu
    if (event.code === 'Escape') {
        this.showInGameMenu();
        return;
    }
    
    // Handle 'C' key to toggle controls visibility
    if (event.code === 'KeyC') {
        console.log('C key pressed - toggling controls');
        this.toggleControls();
        return;
    }
    
    // Handle 'M' key to toggle mini-map
    if (event.code === 'KeyM') {
        this.toggleMiniMap();
        return;
    }

    // Get control action from key mapping
    const action = ControlUtils.getActionForKey(event.code);
    
    // Skip if key isn't mapped or event is repeated
    if (!action || event.repeat) return;
    
    // Handle weapon selection
    if (action.category === 'WEAPONS') {
        if (action.action === 'SWITCH_WEAPON') {
            this.cycleWeapon();
            return;
        } else if (action.action === 'SELECT_LASER') {
            this.selectWeapon('LASER');
            return;
        } else if (action.action === 'SELECT_GRENADE') {
            this.selectWeapon('GRENADE');
            return;
        } else if (action.action === 'SELECT_BOUNCE') {
            this.selectWeapon('BOUNCE');
            return;
        }
    }
    
    // Handle UI controls
    if (action.category === 'UI') {
        if (action.action === 'TOGGLE_MAP') {
            this.toggleMiniMap();
            return;
        } else if (action.action === 'TOGGLE_CONTROLS') {
            this.toggleControls();
            return;
        }
    }
    
    // Set key state to active
    if (action.category === 'MOVEMENT') {
        this.keys[action.action.toLowerCase()] = true;
    }
    
    // Store active key for visual feedback
    this.activeKeys.add(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
    
    // Prevent default browser behavior for game controls
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'Tab', 'KeyM'].includes(event.code)) {
        event.preventDefault();
    }
}
  
  handleKeyUp(event) {
    const action = ControlUtils.getActionForKey(event.code);
    if (!action) return;
    
    // Skip weapon selection keys on keyup
    if (action.category === 'WEAPONS' && action.action.startsWith('SELECT_')) {
      return;
    }
    
    // Set key state to inactive
    if (action.category === 'MOVEMENT') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'WEAPONS') {
      this.keys[action.action.toLowerCase()] = false;
    } else if (action.category === 'UI') {
      this.keys[action.action.toLowerCase()] = false;
    }
    
    // Remove from active keys
    this.activeKeys.delete(event.code);
    
    // Update control indicators
    this.updateControlIndicators();
  }
  
  handleClick(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault) {
        event.preventDefault();
    }
    
    // Prevent rapid-fire clicking
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
        return;
    }
    
    // Get click coordinates relative to canvas
    const rect = this.renderer.domElement.getBoundingClientRect();
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid click coordinates');
        return;
    }
    
    const x = clientX - rect.left;
    const y = clientY - rect.top;
    
    // Convert to normalized device coordinates
    const mouse = new THREE.Vector2(
        (x / this.renderer.domElement.clientWidth) * 2 - 1,
        -(y / this.renderer.domElement.clientHeight) * 2 + 1
    );
    
    // Handle weapon-specific targeting
    if (this.currentWeapon === 'GRENADE') {
        this.handleGrenadeTargeting({ 
            clientX, 
            clientY,
            preventDefault: () => {} // Add dummy preventDefault for consistency
        });
    } else {
        this.handleDirectionalFiring({ clientX, clientY });
    }
  }
  
  handleMouseMove(event) {
    // Skip if we're moving too frequently (throttle)
    if (this.mouseMoveTimer) {
        return;
    }
    
    // Use requestAnimationFrame for smoother updates
    this.mouseMoveTimer = requestAnimationFrame(() => {
        // Get mouse coordinates relative to canvas
        const rect = this.renderer.domElement.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        
        // Update targeting indicators for any weapon type
        this.updateTargetingIndicator({
            clientX: event.clientX,
            clientY: event.clientY
        });
        
        // Additional targeting for grenade if that's the current weapon
        if (this.currentWeapon === 'GRENADE') {
            this.updateGrenadeTargetingIndicator({
                clientX: event.clientX,
                clientY: event.clientY
            });
        }
        
        this.mouseMoveTimer = null;
    });
}
  
  handleFireAction() {
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;
    
    if (now < weaponCooldown) {
      return;
    }
    
    // Set cooldown based on weapon type
    const cooldownTime = this.currentWeapon === 'GRENADE' ? 1000 :
                        this.currentWeapon === 'BOUNCE' ? 500 :
                        200;
    
    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);
    this.fireCurrentWeapon();
  }
  
  setupTouchControls() {
    // Create touch control container
    const touchControls = document.createElement('div');
    touchControls.className = 'touch-controls';
    document.body.appendChild(touchControls);
    
    // Create virtual joystick for movement
    const joystickContainer = document.createElement('div');
    joystickContainer.className = 'joystick-container';
    touchControls.appendChild(joystickContainer);
    
    const joystick = document.createElement('div');
    joystick.className = 'joystick';
    joystickContainer.appendChild(joystick);
    
    const joystickKnob = document.createElement('div');
    joystickKnob.className = 'joystick-knob';
    joystick.appendChild(joystickKnob);
    
    // Create fire button
    const fireButton = document.createElement('div');
    fireButton.className = 'touch-button fire-button';
    fireButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.ACTIONS.find(a => a.id === 'fire').label;
    touchControls.appendChild(fireButton);
    
    // Create weapon switch button
    const weaponButton = document.createElement('div');
    weaponButton.className = 'touch-button weapon-button';
    weaponButton.innerHTML = CONTROL_FEEDBACK.INDICATORS.WEAPONS.find(w => w.id === 'switchWeapon').label;
    touchControls.appendChild(weaponButton);
    
    // Joystick handling
    let joystickActive = false;
    let joystickOrigin = { x: 0, y: 0 };
    
    joystick.addEventListener('touchstart', (e) => {
      joystickActive = true;
      const touch = e.touches[0];
      const rect = joystick.getBoundingClientRect();
      joystickOrigin.x = rect.left + rect.width / 2;
      joystickOrigin.y = rect.top + rect.height / 2;
      handleJoystickMove(touch);
      e.preventDefault();
    });
    
    document.addEventListener('touchmove', (e) => {
      if (joystickActive) {
        const touch = e.touches[0];
        handleJoystickMove(touch);
        e.preventDefault();
      }
    });
    
    document.addEventListener('touchend', (e) => {
      if (joystickActive) {
        joystickActive = false;
        joystickKnob.style.transform = 'translate(0, 0)';
        
        // Reset movement keys using DEFAULT_CONTROL_STATE
        Object.keys(DEFAULT_CONTROL_STATE).forEach(key => {
          if (key.startsWith('forward') || key.startsWith('backward') || 
              key.startsWith('left') || key.startsWith('right') || 
              key.startsWith('strafe')) {
            this.keys[key] = DEFAULT_CONTROL_STATE[key];
          }
        });
        
        this.updateControlIndicators();
      }
    });
    
    const handleJoystickMove = (touch) => {
      const maxDistance = CONTROL_SETTINGS.TOUCH.JOYSTICK_MAX_DISTANCE;
      const deadZone = CONTROL_SETTINGS.TOUCH.JOYSTICK_DEAD_ZONE;
      
      // Calculate distance from center
      const dx = touch.clientX - joystickOrigin.x;
      const dy = touch.clientY - joystickOrigin.y;
      
      // Limit distance to maxDistance
      const distance = Math.min(Math.sqrt(dx * dx + dy * dy), maxDistance);
      const angle = Math.atan2(dy, dx);
      
      // Move joystick knob
      const knobX = distance * Math.cos(angle);
      const knobY = distance * Math.sin(angle);
      joystickKnob.style.transform = `translate(${knobX}px, ${knobY}px)`;
      
      // Convert joystick position to key presses using deadzone
      this.keys.forward = dy < -deadZone;
      this.keys.backward = dy > deadZone;
      this.keys.left = dx < -deadZone;
      this.keys.right = dx > deadZone;
      
      this.updateControlIndicators();
    };
    
    // Fire button handling with weapon cooldown
    let lastFireTime = 0;
    fireButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      const cooldown = CONTROL_SETTINGS.WEAPON_COOLDOWNS[this.currentWeapon];
      
      if (now - lastFireTime >= cooldown) {
        this.keys.fire = true;
        this.fireCurrentWeapon();
        lastFireTime = now;
      }
      
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    fireButton.addEventListener('touchend', (e) => {
      this.keys.fire = false;
      this.updateControlIndicators();
      e.preventDefault();
    });
    
    // Weapon switch button handling with cooldown
    let lastWeaponSwitchTime = 0;
    weaponButton.addEventListener('touchstart', (e) => {
      const now = Date.now();
      if (now - lastWeaponSwitchTime >= 200) { // 200ms cooldown for weapon switching
        this.cycleWeapon();
        lastWeaponSwitchTime = now;
      }
      e.preventDefault();
    });
    
    // Enable directional fire on game area tap
    const gameArea = document.querySelector('canvas');
    if (gameArea) {
      let lastTapTime = 0;
      
      gameArea.addEventListener('touchstart', (e) => {
        // Ignore if touch is in control areas
        const touch = e.touches[0];
        const isInControlArea = 
          touchControls.contains(document.elementFromPoint(touch.clientX, touch.clientY));
          
        if (!isInControlArea && this.playerShip) {
          const now = Date.now();
          const doubleTapDelay = CONTROL_SETTINGS.TOUCH.DOUBLE_TAP_DELAY;
          
          // Check for double tap
          if (now - lastTapTime < doubleTapDelay) {
            // Handle double tap action (e.g., special weapon)
            this.cycleWeapon();
          } else {
            // Handle single tap (directional firing)
            const touchX = touch.clientX;
            const touchY = touch.clientY;
            
            // Handle directional firing similarly to mouse
            const touchPoint = new THREE.Vector2(
              (touchX / window.innerWidth) * 2 - 1,
              -(touchY / window.innerHeight) * 2 + 1
            );
            
            // Use raycasting to determine the point in 3D space
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(touchPoint, this.camera);
            
            // Check for intersection with the floor
            const intersects = raycaster.intersectObject(this.floor);
            
            if (intersects.length > 0) {
              const targetPoint = intersects[0].point;
              
              // Calculate the direction from the player to the target point
              const shipPosition = this.playerShip.position.clone();
              const direction = targetPoint.clone().sub(shipPosition).normalize();
              
              // Only care about horizontal direction (ignore y component)
              direction.y = 0;
              direction.normalize();
              
              // Store the original rotation
              const originalRotation = this.playerShip.rotation.clone();
              
              // Temporarily rotate the ship to face the target
              this.playerShip.lookAt(shipPosition.clone().add(direction));
              
              // Fire the weapon in that direction
              if (this.currentWeapon === 'GRENADE') {
                // For grenades, we simulate a tap at the target location
                const targetEvent = {
                  clientX: touchX,
                  clientY: touchY,
                  preventDefault: () => {}
                };
                this.handleGrenadeTargeting(targetEvent);
              } else {
                // For lasers and bounce, fire in the direction
                this.fireCurrentWeapon(direction);
              }
              
              // Restore the original rotation
              this.playerShip.rotation.copy(originalRotation);
            }
          }
          
          lastTapTime = now;
          e.preventDefault();
        }
      });
    }
  }
  
  toggleControls() {
    // Clear any existing timeout
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
      this.controlsTimeout = null;
    }
    
    // Also clear any auto-fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (!this.controlsContainer) {
      this.createControlIndicators();
    }
    
    if (this.controlsContainer.classList.contains('visible')) {
      this.fadeOutControls();
    } else {
      this.fadeInControls();
    }
  }
  
  fadeInControls() {
    console.log('Fading in controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // Remove any classes that might hide the controls
        this.controlsContainer.classList.remove('hidden', 'fading');
        // Add the visible class
        this.controlsContainer.classList.add('visible');
        console.log('Controls should now be visible with class: visible');
        
        // Set a timeout to automatically fade out the controls after 5 seconds
        // (but only if we're in the game and not in a menu)
        if (this.isRunning) {
            this.controlsFadeTimeout = setTimeout(() => {
              console.log('Auto-hiding controls after timeout');
              this.fadeOutControls();
            }, 5000);
        }
    } else {
        console.warn('Control container not found during fade in');
        // Try to create controls if they don't exist
        this.createControlIndicators();
        // And then try to show them
        if (this.controlsContainer) {
            this.controlsContainer.classList.add('visible');
            
            // Also set the auto-fade timeout for the newly created controls
            // (but only if we're in the game and not in a menu)
            if (this.isRunning) {
                this.controlsFadeTimeout = setTimeout(() => {
                  console.log('Auto-hiding newly created controls after timeout');
                  this.fadeOutControls();
                }, 5000);
            }
        }
    }
  }
  
  fadeOutControls() {
    console.log('Fading out controls');
    
    // Clear any existing fade timeout
    if (this.controlsFadeTimeout) {
      clearTimeout(this.controlsFadeTimeout);
      this.controlsFadeTimeout = null;
    }
    
    if (this.controlsContainer) {
        // First add the fading class for the transition
        this.controlsContainer.classList.add('fading');
        this.controlsContainer.classList.remove('visible');
        
        // After the transition completes, add the hidden class
        setTimeout(() => {
            if (this.controlsContainer) {
                this.controlsContainer.classList.add('hidden');
            }
        }, 500); // Match the transition time from CSS
    } else {
        console.warn('Control container not found during fade out');
    }
  }
  
  updateWeaponUI() {
    // Update UI to reflect weapon change
    if (this.ui) {
        this.ui.updateWeapon(this.currentWeapon);
        
        // Update targeting indicator color if it exists
        if (this.targetingIndicator) {
            const colors = {
                'LASER': new THREE.Color(0x00ffff),
                'GRENADE': new THREE.Color(0xff4500),
                'BOUNCE': new THREE.Color(0x00ff99)
            };
            const color = colors[this.currentWeapon] || colors['LASER'];
            
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
        }
    }
    
    // Log weapon change
    console.log('Weapon updated:', this.currentWeapon);
}

selectWeapon(weaponType) {
    console.log('Selecting specific weapon:', weaponType);
    const index = this.availableWeapons.indexOf(weaponType);
    if (index !== -1) {
        this.weaponIndex = index;
        this.currentWeapon = weaponType;
        console.log('Weapon selection successful');
        
        // Update UI to reflect weapon change
        this.updateWeaponUI();
        
        // Play weapon switch sound if available
        this.playSound('weapon-switch');
    } else {
        console.warn('Attempted to select unavailable weapon:', weaponType);
    }
}
  
  cycleWeapon() {
    console.log('Cycling weapon from:', this.currentWeapon);
    this.weaponIndex = (this.weaponIndex + 1) % this.availableWeapons.length;
    this.currentWeapon = this.availableWeapons[this.weaponIndex];
    console.log('New weapon selected:', this.currentWeapon);
    
    // Update UI to reflect weapon change
    this.updateWeaponUI();
    
    // Play weapon switch sound
    this.playSound('weapon-switch');
}
  
  fireGrenade() {
    console.log("Grenade weapon selected - click to target");
  }
  
  animate() {
    // Call animationFrame with this instance as context
    requestAnimationFrame(this.animate.bind(this));
    
    try {
      // Calculate delta time
      const now = performance.now();
      const deltaTime = (now - this.lastTime) / 1000; // in seconds
      this.lastTime = now;
      
      // Update frame counter
      this.frameCount++;
      
      // Limit update rate
      if (this.frameCount % 2 === 0) { // Reduce update frequency
        // Only update gameplay if the player ship exists
        if (this.playerShip) {
          // Update player
          if (typeof this.updatePlayer === 'function') {
            this.updatePlayer(deltaTime);
          }
          
          // Update other elements - only if they exist
          if (typeof this.updateLasers === 'function') {
            this.updateLasers();
          }
          
          if (typeof this.updateEnergy === 'function') {
            this.updateEnergy(deltaTime);
          }
          
          if (typeof this.updateCamera === 'function') {
            this.updateCamera();
          }
          
          // Update collision detection
          if (typeof this.checkObstacleCollisions === 'function') {
            this.checkObstacleCollisions();
          }
          
          // Update thruster effects
          if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
          }
          
          // Check if boost is active and update energy consumption
          if (this.keys && this.keys.boost && this.energy > 0) {
            this.energy = Math.max(0, this.energy - 30 * deltaTime); // Boost drains energy
            if (this.ui) {
              this.ui.updateEnergy(this.energy, this.maxEnergy);
            }
          }
        }
        
        // Update bounceLasers if they exist
        if (this.bouncingLasers && this.bouncingLasers.length > 0 && 
            typeof this.updateBouncingLasers === 'function') {
          this.updateBouncingLasers();
        }
        
        // Update grenades if they exist
        if (this.grenades && this.grenades.length > 0 && 
            typeof this.updateGrenades === 'function') {
          this.updateGrenades();
        }
        
        // Update multiplayer
        if (this.multiplayerEnabled && this.networkManager) {
          // Send our position and rotation to server
          if (this.playerShip) {
            this.networkManager.sendPlayerUpdate({
              position: {
                x: this.playerShip.position.x,
                y: this.playerShip.position.y,
                z: this.playerShip.position.z
              },
              rotation: this.playerShip.rotation.y,
              name: this.playerName,
              shipType: this.currentShipType || 'default'
            });
          }
          
          // Update other players
          if (typeof this.updateOtherPlayers === 'function') {
            this.updateOtherPlayers();
          }
        }
      }
      
      // Render the scene
      if (this.renderer && this.scene && this.camera) {
        this.renderer.render(this.scene, this.camera);
        
        // Render CSS2D elements if renderer exists
        if (this.labelRenderer) {
          this.labelRenderer.render(this.scene, this.camera);
        }
      }
    } catch (error) {
      console.error("Error in animate loop:", error);
      // Don't rethrow, we want to keep the animation loop running
    }
  }
  
  updatePlayer(deltaTime) {
    if (!this.playerShip) return;
    
    // Save original position in case we need to revert due to collision
    const originalPosition = this.playerShip.position.clone();
    
    // ORIGINAL SHIP MOVEMENT PHYSICS
    const moveSpeed = 10; // Base movement speed
    const rotateSpeed = 2.5; // Base rotation speed
    
    let moved = false; // Track if the ship moved
    
    // Handle forward/backward movement
    if (this.keys.forward) {
        // Move forward
        const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(forwardDir, moveSpeed * deltaTime);
        moved = true;
    }
    else if (this.keys.backward) {
        // Move backward
        const backwardDir = new THREE.Vector3(0, 0, -1).applyQuaternion(this.playerShip.quaternion);
        this.playerShip.position.addScaledVector(backwardDir, moveSpeed * deltaTime);
        moved = true;
    }

    // Handle left/right rotation
    if (this.keys.left) {
        // Rotate left
        this.playerShip.rotation.y += rotateSpeed * deltaTime;
        moved = true;
    }
    else if (this.keys.right) {
        // Rotate right
        this.playerShip.rotation.y -= rotateSpeed * deltaTime;
        moved = true;
    }
    
    // Update player highlight to follow the player ship
    if (this.playerHighlight) {
        this.playerHighlight.position.x = this.playerShip.position.x;
        this.playerHighlight.position.z = this.playerShip.position.z;
        
        // Add a subtle pulsing effect to the highlight
        const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
        this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
    }
    
    // Check for collisions after movement
    if (moved) {
        this.checkObstacleCollisions();
        
        // If no collisions, update thruster effects
        if (typeof this.updateThrusterEffects === 'function') {
            this.updateThrusterEffects();
        }
        
        // Send position update to server if multiplayer is enabled
        if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
            this.sendPlayerPositionUpdate();
        }
    }
  }
  
  updateLasers() {
    if (!this.lasers) return;
    
    for (let i = this.lasers.length - 1; i >= 0; i--) {
      const laser = this.lasers[i];
      
      // Move laser
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update trail effect
      laser.trailPoints.push(laser.mesh.position.clone());
      if (laser.trailPoints.length > 8) { // Reduced trail length for better performance
        laser.trailPoints.shift();
      }
      
      // Update trail geometry
      const positions = new Float32Array(laser.trailPoints.length * 3);
      for (let j = 0; j < laser.trailPoints.length; j++) {
        positions[j * 3] = laser.trailPoints[j].x;
        positions[j * 3 + 1] = laser.trailPoints[j].y;
        positions[j * 3 + 2] = laser.trailPoints[j].z;
      }
      laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Pulse effect
      laser.pulsePhase += 0.3;
      const pulse = Math.sin(laser.pulsePhase) * 0.2 + 0.8;
      laser.mesh.material.opacity = pulse;
      const light = laser.mesh.children[0];
      if (light) {
        light.intensity = pulse * 2;
      }
      
      // Increment lifetime
      laser.lifeTime++;
      
      // Remove old lasers
      if (laser.lifeTime > laser.maxLifeTime) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.lasers.splice(i, 1);
        continue;
      }
      
      // Check for collisions with obstacles
      for (let j = 0; j < this.obstacles.length; j++) {
        const obstacle = this.obstacles[j];
        
        // Simple distance check
        if (laser.mesh.position.distanceTo(obstacle.position) < 1.5) {
          // Create enhanced hit effect
          this.createEnhancedHitEffect(laser.mesh.position.clone(), laser.direction.clone());
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.lasers.splice(i, 1);
          break;
        }
      }
    }
  }

  createEnhancedHitEffect(position, direction) {
    // Create a burst of particles
    const particleCount = 15;
    const particles = [];
    
    // Create particle material
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.1, 0.1);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity based on impact direction
      const spread = Math.PI / 2; // 90 degree spread
      const angle = Math.random() * spread - spread/2;
      const speed = 0.2 + Math.random() * 0.3;
      
      // Calculate velocity
      const velocity = direction.clone()
        .applyAxisAngle(new THREE.Vector3(0, 1, 0), angle)
        .multiplyScalar(speed);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0; // Full life
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.3, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(position.clone().add(direction));
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }
  
  checkObstacleCollisions() {
    if (!this.playerShip || !this.infiniteMap) {
      console.log('Skipping collision check - player ship or infinite map not available');
      return;
    }
    
    // Get player collision info
    const playerRadius = this.playerShip.userData.collisionRadius || 0.35;
    const playerPos = this.playerShip.position.clone();
    
    // Create player sphere for collision checks
    const playerSphere = {
      center: playerPos,
      radius: playerRadius
    };
    
    // Check collisions with infinite map objects first
    const mapCollision = this.infiniteMap.checkCollisions(playerPos, playerRadius);
    
    if (mapCollision.collided) {
      // Handle collision from infinite map
      this.handleObjectCollision(playerPos, mapCollision.object.position, mapCollision.object.type || 'terrain');
      return; // Stop checking after handling one collision
    }
    
    // Check local obstacles with more accurate collision detection
    for (const obstacle of this.obstacles) {
      if (!obstacle.mesh) continue;
      
      // First, do a quick broad-phase check with spheres for efficiency
      const obstaclePos = obstacle.position.clone();
      const distance = playerPos.distanceTo(obstaclePos);
      const quickCheckDistance = playerRadius + obstacle.size;
      
      // Skip detailed check if clearly not colliding
      if (distance > quickCheckDistance * 1.5) continue;
      
      // Determine if collision happened based on shape type
      let collision = false;
      
      if (obstacle.collisionShape === 'compound' && obstacle.compoundShapes) {
        // Use compound shape collision detection for complex objects
        collision = this.checkCompoundCollision(playerSphere, obstacle.compoundShapes);
      } else if (obstacle.collisionShape === 'complex' && obstacle.boundingBox) {
        // Fall back to oriented bounding box if compound shapes not available
        collision = this.checkBoxCollision(
          playerPos, playerRadius,
          obstacle.boundingBox, 
          obstacle.boundingBox.rotation
        );
      } else {
        // Simplest case: sphere-based collision for backward compatibility
        collision = distance < quickCheckDistance;
      }
      
      if (collision) {
        // Handle the collision
        this.handleObjectCollision(playerPos, obstaclePos, obstacle.type);
        break; // Only handle one collision at a time
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (compound shapes)
   */
  checkCompoundCollision(playerSphere, compoundShapes) {
    // Check collision against each shape in the compound
    for (const shape of compoundShapes) {
      let collision = false;
      
      if (shape.type === 'box') {
        // Box vs sphere collision
        collision = this.checkBoxSphereCollision(
          shape.center,
          shape.halfExtents,
          shape.worldRotation || 0,
          playerSphere
        );
      } else if (shape.type === 'sphere') {
        // Sphere vs sphere collision (simpler case)
        const distance = playerSphere.center.distanceTo(shape.center);
        collision = distance < (playerSphere.radius + shape.radius);
      }
      
      if (collision) {
        return true; // Collision with any part means collision with the compound
      }
    }
    
    return false; // No collision with any part
  }
  
  /**
   * Check collision between a rotated box and a sphere
   */
  checkBoxSphereCollision(boxCenter, boxHalfExtents, boxRotation, sphere) {
    // Transform sphere center to box space (accounting for rotation)
    const toSphere = new THREE.Vector3().subVectors(sphere.center, boxCenter);
    
    // Apply inverse rotation to get into box space
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(-boxRotation);
      toSphere.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on box to sphere in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-boxHalfExtents.x, Math.min(boxHalfExtents.x, toSphere.x)),
      Math.max(-boxHalfExtents.y, Math.min(boxHalfExtents.y, toSphere.y)),
      Math.max(-boxHalfExtents.z, Math.min(boxHalfExtents.z, toSphere.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (boxRotation) {
      const rotMatrix = new THREE.Matrix4().makeRotationY(boxRotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to sphere center (for efficiency)
    const squaredDistance = sphere.center.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than sphere radius squared
    return squaredDistance < (sphere.radius * sphere.radius);
  }

  /**
   * Handle collision with any object
   */
  handleObjectCollision(playerPos, objectPos, objectType) {
    console.log(`COLLISION DETECTED with ${objectType}: Pushing ship back`);
    
    // Push player away from obstacle
    const pushDir = new THREE.Vector3()
      .subVectors(playerPos, objectPos)
      .normalize();
      
    // Adjust push force based on object type
    let pushForce = 0.7; // Default push force
    let damageAmount = 5; // Default damage
    
    // Customize collision response based on type
    switch(objectType) {
      case 'rocks':
        pushForce = 0.85; // Rocks push strongly
        damageAmount = 8;
        break;
      case 'specialObjects':
      case 'groundFeatures':
        pushForce = 0.75; // Ground features push medium
        damageAmount = 6;
        break;
      case 'mountains':
        pushForce = 1.0; // Mountains push very strongly
        damageAmount = 10;
        break;
      case 'crystals':
        pushForce = 0.7; // Crystals push medium but with special effect
        damageAmount = 7;
        
        // Add special crystal collision effect
        this.createCrystalCollisionEffect(objectPos);
        break;
      case 'centerpiece':
        pushForce = 0.9; // Centerpiece pushes strongly
        damageAmount = 9;
        
        // Add special centerpiece collision effect
        this.createCrystalCollisionEffect(objectPos, true);
        break;
      case 'flora':
        pushForce = 0.6; // Flora pushes gently
        damageAmount = 3;
        break;
      default:
        // Use default values
        break;
    }
    
    // Apply the push force
    this.playerShip.position.addScaledVector(pushDir, pushForce);
    
    // Flash collision warning
    this.flashCollisionWarning();
    
    // Apply damage if the function exists
    if (typeof this.applyDamage === 'function') {
      this.applyDamage(damageAmount);
    }
    
    // Play appropriate collision sound based on object type
    let soundToPlay = 'collision';
    
    if (objectType === 'specialObjects') {
      // Crystal-like sounds for special objects
      soundToPlay = 'crystalHit';
    } else if (objectType === 'mountains') {
      // Heavy impact for mountains
      soundToPlay = 'heavyImpact';
    }
    
    // Play the sound if it exists, otherwise fall back to default collision
    if (this.playSound) {
      try {
        this.playSound(soundToPlay);
      } catch (e) {
        // Fall back to default if sound doesn't exist
        try {
          this.playSound('collision');
        } catch (e2) {
          // No sound available
        }
      }
    }
  }

  /**
   * Check collision between player (sphere) and obstacle (oriented box)
   */
  checkBoxCollision(playerPos, playerRadius, box, rotation) {
    // Get box center
    const boxCenter = new THREE.Vector3(
      (box.min.x + box.max.x) / 2,
      (box.min.y + box.max.y) / 2,
      (box.min.z + box.max.z) / 2
    );
    
    // Calculate half extents of box
    const halfExtents = new THREE.Vector3(
      (box.max.x - box.min.x) / 2,
      (box.max.y - box.min.y) / 2,
      (box.max.z - box.min.z) / 2
    );
    
    // Vector from box center to player
    const toPlayer = new THREE.Vector3().subVectors(playerPos, boxCenter);
    
    // If we have rotation, apply inverse rotation to convert to box space
    if (rotation) {
      // Create rotation matrix for the box (negative rotation to invert)
      const rotMatrix = new THREE.Matrix4().makeRotationY(-rotation);
      toPlayer.applyMatrix4(rotMatrix);
    }
    
    // Find closest point on the box to the player in box space
    const closestPoint = new THREE.Vector3(
      Math.max(-halfExtents.x, Math.min(halfExtents.x, toPlayer.x)),
      Math.max(-halfExtents.y, Math.min(halfExtents.y, toPlayer.y)),
      Math.max(-halfExtents.z, Math.min(halfExtents.z, toPlayer.z))
    );
    
    // If using rotation, convert closest point back to world space
    let worldClosestPoint;
    if (rotation) {
      // Create rotation matrix for the box
      const rotMatrix = new THREE.Matrix4().makeRotationY(rotation);
      worldClosestPoint = closestPoint.clone().applyMatrix4(rotMatrix).add(boxCenter);
    } else {
      worldClosestPoint = closestPoint.clone().add(boxCenter);
    }
    
    // Calculate squared distance from closest point to player center
    const squaredDistance = playerPos.distanceToSquared(worldClosestPoint);
    
    // Collision occurs if distance is less than player radius squared
    return squaredDistance < (playerRadius * playerRadius);
  }
  
  updateCamera() {
    // Check if cameraTargetPosition is initialized
    if (!this.cameraTargetPosition) {
      this.cameraTargetPosition = new THREE.Vector3();
      this.cameraTargetLookAt = new THREE.Vector3();
      this.cameraSmoothingFactor = 0.05;
    }
    
    // If playerShip doesn't exist, early return
    if (!this.playerShip) return;
    
    // Define the camera offset from the player
    const offsetY = 18; // Height above the player
    const offsetZ = -16; // Distance behind the player (adjusted for larger ship)
    
    // Get the player's forward direction vector (simplified)
    const forwardDir = new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
    
    // Calculate camera target position (directly above and slightly behind player)
    this.cameraTargetPosition.copy(this.playerShip.position);
    this.cameraTargetPosition.y += offsetY;
    
    // Move camera back based on player's orientation
    const backOffset = forwardDir.clone().multiplyScalar(offsetZ);
    this.cameraTargetPosition.add(backOffset);
    
    // Smoothly move camera toward target position
    this.camera.position.lerp(this.cameraTargetPosition, this.cameraSmoothingFactor);
    
    // Make camera look at the player
    this.cameraTargetLookAt.copy(this.playerShip.position);
    this.camera.lookAt(this.cameraTargetLookAt);
  }
  
  updateThrusterEffects() {
    // Skip if ship model isn't loaded
    if (!this.shipModel || !this.thruster || !this.thrusterLight) return;
    
    // Use stored references instead of finding children each time
    const { thruster, thrusterLight } = this;
    
    // Base thruster scale and opacity on movement
    const isMovingForward = this.keys.forward;
    const isMovingBackward = this.keys.backward;
    
    // Update thruster pulse for ambient animation
    this.thrusterPulse.value = (this.thrusterPulse.value + 0.1) % (Math.PI * 2);
    const pulseEffect = Math.sin(this.thrusterPulse.value) * 0.1;
    
    if (isMovingForward) {
      // Full thruster when moving forward
      const randomScale = 1 + Math.random() * 0.2 + pulseEffect;
      thruster.scale.set(1, 1, randomScale);
      thruster.material.opacity = 0.7 + Math.random() * 0.3;
      thrusterLight.intensity = 1.2 + Math.random() * 0.3 + pulseEffect;
      
      // Add color variation for a more dynamic effect
      const hue = (Date.now() % 1000) / 1000; // Cycle through colors over time
      thruster.material.color.setHSL(hue, 1, 0.5);
      thrusterLight.color.setHSL(hue, 1, 0.5);
    } else if (isMovingBackward) {
      // Reduced thruster when moving backward
      const randomScale = 0.3 + Math.random() * 0.1 + pulseEffect * 0.5;
      thruster.scale.set(0.5, 0.5, randomScale);
      thruster.material.opacity = 0.4 + Math.random() * 0.2;
      thrusterLight.intensity = 0.6 + Math.random() * 0.2 + pulseEffect * 0.5;
      
      // Cooler color for reverse thrust
      thruster.material.color.setHSL(0.6, 1, 0.5); // Blue-ish
      thrusterLight.color.setHSL(0.6, 1, 0.5);
    } else {
      // Idle state with subtle pulsing
      const idleScale = 0.3 + pulseEffect;
      thruster.scale.set(0.3, 0.3, idleScale);
      thruster.material.opacity = 0.3 + pulseEffect;
      thrusterLight.intensity = 0.4 + pulseEffect;
      
      // Neutral color for idle
      thruster.material.color.setHSL(0.5, 0.7, 0.5); // Cyan-ish
      thrusterLight.color.setHSL(0.5, 0.7, 0.5);
    }
    
    // Performance optimization: only update material if it's visible
    if (thruster.material.opacity < 0.01) {
      thruster.visible = false;
      thrusterLight.visible = false;
    } else {
      thruster.visible = true;
      thrusterLight.visible = true;
    }
  }
  
  flashCollisionWarning() {
    // Create a full-screen flash effect for collision
    const flashOverlay = document.createElement('div');
    flashOverlay.className = 'collision-flash';
    document.body.appendChild(flashOverlay);
    
    // Remove after animation completes
    setTimeout(() => {
      document.body.removeChild(flashOverlay);
    }, 150);
  }
  
  updateEnergy(deltaTime) {
    // Validate parameters
    if (typeof deltaTime !== 'number' || deltaTime < 0) {
        console.warn('Invalid deltaTime in updateEnergy:', deltaTime);
        return;
    }

    // Initialize energy values if undefined
    if (typeof this.energy !== 'number') this.energy = 0;
    if (typeof this.maxEnergy !== 'number') this.maxEnergy = 100;
    if (typeof this.energyRechargeRate !== 'number') this.energyRechargeRate = 20;

    // Store old energy for change detection
    const oldEnergy = this.energy;

    // Calculate recharge amount
    const rechargeAmount = this.energyRechargeRate * deltaTime;
    
    // Apply recharge with bounds checking
    this.energy = Math.min(this.maxEnergy, this.energy + rechargeAmount);

    // Update UI only if energy changed
    if (this.energy !== oldEnergy) {
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        }

        // Play charging sound when energy is low (under 10%)
        if (this.energy < (this.maxEnergy * 0.1)) {
            this.playSound('weapon-charging');
        }

        // Log significant energy changes (more than 1 unit) for debugging
        if (Math.abs(this.energy - oldEnergy) > 1) {
            console.log(`Energy updated: ${oldEnergy.toFixed(1)} -> ${this.energy.toFixed(1)} (Δ${deltaTime.toFixed(3)}s)`);
        }
    }
  }
  
  updateGrenades() {
    if (!this.grenades || this.grenades.length === 0) return;
    
    for (let i = this.grenades.length - 1; i >= 0; i--) {
      const grenade = this.grenades[i];
      
      // If the grenade has exploded, handle explosion effects
      if (grenade.exploded) {
        // Increase the explosion radius until maximum
        grenade.explosionMesh.scale.addScalar(0.2);
        grenade.explosionLight.intensity -= 0.1;
        
        // Remove explosion after it's done
        if (grenade.explosionLight.intensity <= 0) {
          this.scene.remove(grenade.explosionMesh);
          this.scene.remove(grenade.trail);
          this.grenades.splice(i, 1);
        }
        continue;
      }
      
      // Update the grenade position along the arc
      grenade.progress += 0.02;
      
      if (grenade.progress >= 1) {
        // Explode when reaching the target
        this.explodeGrenade(grenade, i);
      } else {
        // Move along a quadratic bezier curve for arcing trajectory
        const p0 = grenade.startPos;
        const p1 = grenade.midPos;
        const p2 = grenade.endPos;
        
        // Quadratic bezier formula: p = (1-t)^2 * p0 + 2(1-t)t * p1 + t^2 * p2
        const t = grenade.progress;
        const oneMinusT = 1 - t;
        
        grenade.mesh.position.x = oneMinusT * oneMinusT * p0.x + 2 * oneMinusT * t * p1.x + t * t * p2.x;
        grenade.mesh.position.y = oneMinusT * oneMinusT * p0.y + 2 * oneMinusT * t * p1.y + t * t * p2.y;
        grenade.mesh.position.z = oneMinusT * oneMinusT * p0.z + 2 * oneMinusT * t * p1.z + t * t * p2.z;
        
        // Add trail effect
        const point = grenade.mesh.position.clone();
        grenade.trailPoints.push(point);
        
        // Keep only the last 20 trail points
        if (grenade.trailPoints.length > 20) {
          grenade.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(grenade.trailPoints.length * 3);
        for (let j = 0; j < grenade.trailPoints.length; j++) {
          positions[j * 3] = grenade.trailPoints[j].x;
          positions[j * 3 + 1] = grenade.trailPoints[j].y;
          positions[j * 3 + 2] = grenade.trailPoints[j].z;
        }
        
        grenade.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        grenade.trail.geometry.attributes.position.needsUpdate = true;
      }
    }
  }
  
  explodeGrenade(grenade, index) {
    // Remove the grenade mesh
    this.scene.remove(grenade.mesh);
    
    // Create explosion geometry
    const explosionGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const explosionMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8
    });
    const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
    explosionMesh.position.copy(grenade.mesh.position);
    
    // Add to scene
    this.scene.add(explosionMesh);
    
    // Add explosion light
    const explosionLight = new THREE.PointLight(0xff6600, 3, 10);
    explosionMesh.add(explosionLight);
    
    // Mark as exploded
    grenade.exploded = true;
    grenade.explosionMesh = explosionMesh;
    grenade.explosionLight = explosionLight;
    
    // Calculate damage radius
    const explosionCenter = grenade.mesh.position.clone();
    const maxDamage = 50; // Maximum damage at center - 50% of health
    const damageRadius = grenade.explosionRadius || 4; // Default radius of 4 units
    
    // Check for obstacle hits in explosion radius
    for (const obstacle of this.obstacles) {
      const distance = obstacle.position.distanceTo(explosionCenter);
      if (distance < damageRadius) {
        // Calculate damage based on distance (linear falloff)
        const damagePercent = 1 - (distance / damageRadius);
        const hitPoint = obstacle.position.clone().add(
          explosionCenter.clone().sub(obstacle.position).normalize().multiplyScalar(distance * 0.8)
        );
        this.createHitEffect(hitPoint);
      }
    }
    
    // Check for player damage
    const playerPosition = this.playerShip.position.clone();
    playerPosition.y = 0; // Project to ground plane
    const grenadePosition = explosionCenter.clone();
    grenadePosition.y = 0; // Project to ground plane
    
    const playerDistance = playerPosition.distanceTo(grenadePosition);
    if (playerDistance < damageRadius) {
      // Calculate damage with distance falloff
      const damagePercent = 1 - (playerDistance / damageRadius);
      const damage = Math.floor(maxDamage * damagePercent);
      
      // Apply damage to player
      this.health = Math.max(0, this.health - damage);
      
      // Update UI
      if (this.ui) {
        this.ui.updateHealth(this.health, this.maxHealth);
      }
      
      // Visual feedback
      this.flashCollisionWarning();
      this.createHitEffect(playerPosition);
    }
  }
  
  updateBouncingLasers() {
    if (!this.bouncingLasers || this.bouncingLasers.length === 0) return;
    
    const playerPos = this.playerShip ? this.playerShip.position.clone() : null;
    
    // Update each laser
    for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
      const laser = this.bouncingLasers[i];
      
      // Skip invalid lasers
      if (!laser || !laser.mesh) continue;
      
      // Update laser position
      laser.mesh.position.add(laser.direction.clone().multiplyScalar(laser.speed));
      
      // Update the trail
      if (laser.trail) {
        // Add current position to trail points
        laser.trailPoints.push(laser.mesh.position.clone());
        
        // Limit the number of trail points
        if (laser.trailPoints.length > 20) {
          laser.trailPoints.shift();
        }
        
        // Update trail geometry
        const positions = new Float32Array(laser.trailPoints.length * 3);
        for (let j = 0; j < laser.trailPoints.length; j++) {
          positions[j * 3] = laser.trailPoints[j].x;
          positions[j * 3 + 1] = laser.trailPoints[j].y;
          positions[j * 3 + 2] = laser.trailPoints[j].z;
        }
        
        // Update geometry
        laser.trail.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        laser.trail.geometry.attributes.position.needsUpdate = true;
      }
      
      // Check for collisions with obstacles
      let collision = false;
      let closestPoint = null;
      let closestDistance = Infinity;
      let closestNormal = null;
      
      // Check for collision with each obstacle
      for (const obstacle of this.obstacles) {
        if (!obstacle.geometry) continue;
        
        let intersection = null;
        let normal = null;
        
        if (obstacle.geometry instanceof THREE.SphereGeometry) {
          const radius = obstacle.geometry.parameters.radius;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else if (obstacle.geometry instanceof THREE.CylinderGeometry) {
          const radius = obstacle.geometry.parameters.radiusTop;
          intersection = tempRay.intersectSphere(
            new THREE.Sphere(obstacle.position, radius),
            tempVector
          );
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        } else {
          // For boxes, use bounding sphere as approximation
          const boundingSphere = obstacle.geometry.boundingSphere;
          if (!boundingSphere) {
            obstacle.geometry.computeBoundingSphere();
          }
          const sphere = new THREE.Sphere(
            obstacle.position,
            obstacle.geometry.boundingSphere.radius
          );
          intersection = tempRay.intersectSphere(sphere, tempVector);
          if (intersection) {
            normal = intersection.clone().sub(obstacle.position).normalize();
          }
        }
        
        if (intersection) {
          const dist = laser.mesh.position.distanceTo(intersection);
          if (dist < closestDist && dist < laser.speed * 1.2) {
            closestDist = dist;
            closestPoint = intersection;
            closestNormal = normal;
          }
        }
      }
      
      // Handle bounce if collision found
      if (closestPoint && closestNormal) {
        // Position at intersection point
        laser.mesh.position.copy(closestPoint);
        
        // Calculate reflection direction
        const dot = laser.direction.dot(closestNormal);
        const reflection = laser.direction.clone()
          .sub(closestNormal.multiplyScalar(2 * dot))
          .normalize();
        
        // Update direction with some randomness for more interesting bounces
        const randomAngle = (Math.random() - 0.5) * 0.2; // Small random angle
        reflection.applyAxisAngle(new THREE.Vector3(0, 1, 0), randomAngle);
        laser.direction.copy(reflection);
        
        // Increment bounce count
        laser.bounces++;
        
        // Create bounce effect
        this.createBounceEffect(closestPoint.clone(), closestNormal.clone());
        
        // Play bounce sound
        this.playSound('bounce');
        
        // Enable player collision after first bounce
        laser.canHitPlayer = true;
        
        // Increase speed slightly with each bounce
        laser.speed *= 1.1;
        
        bounced = true;
      }
      
      // If no bounce, move normally
      if (!bounced) {
        laser.mesh.position.copy(nextPosition);
      }
      
      // Check for enemy collisions - new code
      if (this.enemyManager && this.enemyManager.enemies.length > 0) {
        for (let j = this.enemyManager.enemies.length - 1; j >= 0; j--) {
          const enemy = this.enemyManager.enemies[j];
          if (!enemy.isActive) continue;
          
          const enemyPos = enemy.mesh.position.clone();
          enemyPos.y = 0.5; // Adjust to match laser height
          
          // Check if the laser hit the enemy
          const hitDistance = 0.7; // Collision distance for enemy hits
          if (laser.mesh.position.distanceTo(enemyPos) < hitDistance) {
            // Enemy hit
            enemy.takeDamage(10); // Damage the enemy
            
            // Create hit effect
            this.createHitEffect(enemyPos);
            
            // Play hit sound
            this.playSound('weapon-armor-hit');
            
            // Remove laser
            this.scene.remove(laser.mesh);
            this.scene.remove(laser.trail);
            this.bouncingLasers.splice(i, 1);
            break; // Exit the enemy loop
          }
        }
      }
      
      // Check for player collision
      if (laser.canHitPlayer) {
        const playerPos = this.playerShip.position.clone();
        playerPos.y = 0.5;
        
        if (laser.mesh.position.distanceTo(playerPos) < 1) {
          // Player hit
          this.health -= 10;
          if (this.health < 0) this.health = 0;
          
          // Update UI
          this.ui.updateHealth(this.health, this.maxHealth);
          
          // Visual feedback
          this.flashCollisionWarning();
          this.createBounceEffect(playerPos, new THREE.Vector3(0, 1, 0));
          
          // Remove laser
          this.scene.remove(laser.mesh);
          this.scene.remove(laser.trail);
          this.bouncingLasers.splice(i, 1);
          continue;
        }
      }
      
      // Update lifetime
      laser.lifeTime++;
      
      // Remove if too old or too many bounces
      if (laser.lifeTime > laser.maxLifeTime || laser.bounces >= laser.maxBounces) {
        this.scene.remove(laser.mesh);
        this.scene.remove(laser.trail);
        this.bouncingLasers.splice(i, 1);
      }
    }
  }
  
  // Create a special effect for laser bounces
  createBounceEffect(position, normal) {
    // Create a particle burst effect at the bounce point
    const particleCount = 20;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleSizes = new Float32Array(particleCount);
    
    // Add a flash of light at bounce point
    const bounceLight = new THREE.PointLight(0x00ffcc, 3, 5);
    bounceLight.position.copy(position);
    this.scene.add(bounceLight);
    
    // Create a ring effect at bounce point
    const ringGeometry = new THREE.RingGeometry(0.1, 0.5, 24);
    const ringMaterial = new THREE.MeshBasicMaterial({
      color: 0x00ffcc,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
    ring.position.copy(position);
    
    // Orient the ring according to the normal
    if (Math.abs(normal.y) > 0.99) { // If normal is pointing mainly up/down
      ring.rotation.x = Math.PI / 2; // Rotate to lie flat
    } else {
      // Point the ring along the normal
      const rotationAxis = new THREE.Vector3(0, 1, 0).cross(normal).normalize();
      const angle = Math.acos(normal.dot(new THREE.Vector3(0, 1, 0)));
      ring.setRotationFromAxisAngle(rotationAxis, angle);
    }
    
    this.scene.add(ring);
    
    // Create particles around bounce point
    for (let i = 0; i < particleCount; i++) {
      // Random direction from bounce point
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(2)).normalize();
      
      // Starting at bounce point
      const startPoint = position.clone();
      particlePositions[i * 3] = startPoint.x;
      particlePositions[i * 3 + 1] = startPoint.y;
      particlePositions[i * 3 + 2] = startPoint.z;
      
      // Random sizes for particles
      particleSizes[i] = Math.random() * 0.1 + 0.05;
    }
    
    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeometry.setAttribute('size', new THREE.BufferAttribute(particleSizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      color: 0x00ffcc,
      size: 0.1,
      transparent: true,
      opacity: 0.8,
      blending: THREE.AdditiveBlending
    });
    
    const particles = new THREE.Points(particleGeometry, particleMaterial);
    this.scene.add(particles);
    
    // Store particle velocities
    const particleVelocities = [];
    for (let i = 0; i < particleCount; i++) {
      const direction = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1, 
        Math.random() * 2 - 1
      ).normalize();
      
      // Bias direction toward normal
      direction.add(normal.clone().multiplyScalar(1.5)).normalize();
      
      // Random speed
      const speed = Math.random() * 0.1 + 0.05;
      particleVelocities.push(direction.multiplyScalar(speed));
    }
    
    // Animate particles and effects
    let frameCount = 0;
    const maxFrames = 30;
    
    const animate = () => {
      frameCount++;
      
      // Update particles
      const positions = particles.geometry.attributes.position.array;
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] += particleVelocities[i].x;
        positions[i * 3 + 1] += particleVelocities[i].y;
        positions[i * 3 + 2] += particleVelocities[i].z;
        
        // Slow down particles over time
        particleVelocities[i].multiplyScalar(0.95);
      }
      
      particles.geometry.attributes.position.needsUpdate = true;
      
      // Fade the light
      bounceLight.intensity *= 0.85;
      
      // Expand and fade the ring
      ring.scale.addScalar(0.15);
      ring.material.opacity *= 0.9;
      
      // Fade the particles
      particles.material.opacity *= 0.92;
      
      if (frameCount < maxFrames) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(bounceLight);
        this.scene.remove(ring);
        this.scene.remove(particles);
      }
    };
    
    // Start animation
    animate();
  }
  
  // Now add new methods to handle grenade targeting
  updateGrenadeTargetingIndicator(event) {
    // Create targeting indicator if it doesn't exist
    if (!this.grenadeTargetIndicator) {
      // Create targeting indicator
      const targetGeometry = new THREE.RingGeometry(0.2, 0.3, 32);
      const targetMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xff4500, 
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      this.grenadeTargetIndicator = new THREE.Mesh(targetGeometry, targetMaterial);
      this.grenadeTargetIndicator.rotation.x = Math.PI / 2; // Make it horizontal
      
      // Add pulsing animation
      this.grenadeTargetIndicator.pulse = 0;
      
      // Add to scene
      this.scene.add(this.grenadeTargetIndicator);
    }
    
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // Update indicator color based on range
        if (distance > maxRange) {
          this.grenadeTargetIndicator.material.color.set(0xff0000); // Red for out of range
        } else {
          this.grenadeTargetIndicator.material.color.set(0x00ff00); // Green for valid
        }
        
        // Position the targeting indicator
        this.grenadeTargetIndicator.position.copy(targetPoint);
        this.grenadeTargetIndicator.position.y = 0.1; // Slightly above floor
        
        // Pulse animation
        this.grenadeTargetIndicator.pulse += 0.1;
        const scale = 1 + 0.2 * Math.sin(this.grenadeTargetIndicator.pulse);
        this.grenadeTargetIndicator.scale.set(scale, scale, scale);
        
        // Store target point for launching
        this.grenadeTargetPoint = targetPoint.clone();
    }
  }
  
  handleGrenadeTargeting(event) {
    // Ensure we have a valid event object
    if (event && event.preventDefault && typeof event.preventDefault === 'function') {
        event.preventDefault();
    }
    
    // Validate energy before proceeding
    if (!this.energy || !this.maxEnergy) {
        console.warn('Energy values invalid:', { energy: this.energy, maxEnergy: this.maxEnergy });
        return;
    }
    
    // Check if we have enough energy - now requires FULL energy
    if (this.energy < this.maxEnergy) {
        console.log("Not enough energy for grenade");
        return;
    }
    
    // Validate event coordinates
    const clientX = event.clientX || (event.touches && event.touches[0].clientX);
    const clientY = event.clientY || (event.touches && event.touches[0].clientY);
    
    if (typeof clientX !== 'number' || typeof clientY !== 'number') {
        console.warn('Invalid grenade target coordinates');
        return;
    }
    
    // Get the position where to throw the grenade
    const mouse = new THREE.Vector2(
        (clientX / window.innerWidth) * 2 - 1,
        -(clientY / window.innerHeight) * 2 + 1
    );
    
    // Raycasting to get the point on the floor
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Use raycastFloor for consistent targeting
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Check if the target is within maximum range
        const maxRange = 20;
        const shipPosition = this.playerShip.position.clone();
        shipPosition.y = 0; // Project to ground plane
        
        // Vector from ship to target
        const toTarget = targetPoint.clone().sub(shipPosition);
        const distance = toTarget.length();
        
        // If beyond max range, limit to max range
        if (distance > maxRange) {
            toTarget.normalize().multiplyScalar(maxRange);
            targetPoint.copy(shipPosition).add(toTarget);
        }
        
        // Consume full energy
        this.energy = 0;
        
        // Update UI with energy change
        if (this.ui && typeof this.ui.updateEnergy === 'function') {
            this.ui.updateEnergy(this.energy, this.maxEnergy);
        } else {
            console.warn('UI energy update failed');
        }
        
        // Create and launch the grenade
        this.launchGrenade(targetPoint);
    }
  }
  
  launchGrenade(targetPoint) {
    // Create grenade mesh
    const grenadeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
    const grenadeMaterial = new THREE.MeshPhongMaterial({
      color: 0xff4500,
      emissive: 0xff2000,
      emissiveIntensity: 0.5
    });
    const grenade = new THREE.Mesh(grenadeGeometry, grenadeMaterial);
    
    // Position at the ship
    grenade.position.copy(this.playerShip.position);
    grenade.position.y = 0.5; // Slightly above floor
    
    // Add to scene
    this.scene.add(grenade);
    
    // Add grenade trail effect
    const trail = new THREE.Points(
      new THREE.BufferGeometry(),
      new THREE.PointsMaterial({
        color: 0xff4500,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      })
    );
    this.scene.add(trail);
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(0xff4500, 1, 3);
    grenade.add(light);
    
    // Store grenade data for animation
    if (!this.grenades) {
      this.grenades = [];
    }
    
    // Calculate the arc of the grenade
    const startPos = grenade.position.clone();
    const endPos = targetPoint.clone();
    const midPos = startPos.clone().add(endPos.clone().sub(startPos).multiplyScalar(0.5));
    midPos.y += 5; // Arc height
    
    this.grenades.push({
      mesh: grenade,
      trail: trail,
      startPos: startPos,
      midPos: midPos,
      endPos: endPos,
      progress: 0,
      exploded: false,
      explosionRadius: 4,
      trailPoints: []
    });

    // Play grenade launch sound
    this.playSound('grenade-laser');
  }
  
  // Add a method to show targeting indicator for all weapons
  updateTargetingIndicator(event) {
    // Skip if indicator was recently updated
    if (this.lastIndicatorUpdate && Date.now() - this.lastIndicatorUpdate < 16) {
        return;
    }
    this.lastIndicatorUpdate = Date.now();

    // Get the mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );
    
    // Log the normalized mouse position occasionally
    if (Math.random() < 0.01) {
      console.log('Mouse normalized position:', mouse);
    }
    
    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);
    
    // Check for intersection with the raycastFloor
    const intersects = raycaster.intersectObject(this.raycastFloor);
    
    // Log raycasting results occasionally for debugging
    if (Math.random() < 0.01) {
      console.log('Raycast results:', { 
        intersections: intersects.length, 
        raycastFloorExists: !!this.raycastFloor,
        raycastFloorPosition: this.raycastFloor ? this.raycastFloor.position.y : 'N/A'
      });
    }
    
    if (intersects.length > 0) {
        const targetPoint = intersects[0].point;
        
        // Create or update targeting indicator
        if (!this.targetingIndicator) {
            console.log('Creating new targeting indicator');
            // Create a more efficient indicator using a single geometry
            const geometry = new THREE.Group();
            
            // Outer ring with fewer segments - MAKE LARGER
            const outerRing = new THREE.RingGeometry(0.8, 1.0, 16);
            const material = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8, // Increased opacity
                side: THREE.DoubleSide
            });
            const outer = new THREE.Mesh(outerRing, material);
            
            // Inner ring with fewer segments - MAKE LARGER
            const innerRing = new THREE.RingGeometry(0.2, 0.4, 16);
            const inner = new THREE.Mesh(innerRing, material.clone());
            
            // Simplified crosshair - MAKE LARGER
            const lineGeometry = new THREE.BufferGeometry();
            const lineVertices = new Float32Array([
                -0.6, 0, 0,
                0.6, 0, 0,
                0, -0.6, 0,
                0, 0.6, 0
            ]);
            lineGeometry.setAttribute('position', new THREE.BufferAttribute(lineVertices, 3));
            const lines = new THREE.LineSegments(lineGeometry, material.clone());
            
            geometry.add(outer);
            geometry.add(inner);
            geometry.add(lines);
            
            this.targetingIndicator = geometry;
            this.targetingIndicator.rotation.x = Math.PI / 2;
            this.scene.add(this.targetingIndicator);
        }
        
        // Update position - INCREASE HEIGHT
        this.targetingIndicator.position.copy(targetPoint);
        this.targetingIndicator.position.y = 0.5; // Much higher above the terrain
        
        // Update color based on weapon type
        const colors = {
            'LASER': new THREE.Color(0x00ffff),
            'GRENADE': new THREE.Color(0xff4500),
            'BOUNCE': new THREE.Color(0x00ff99)
        };
        const color = colors[this.currentWeapon] || colors['LASER'];
        
        // Only update colors if they've changed
        if (!this.lastWeaponColor || this.lastWeaponColor !== this.currentWeapon) {
            this.targetingIndicator.children.forEach(child => {
                if (child.material) {
                    child.material.color = color;
                }
            });
            this.lastWeaponColor = this.currentWeapon;
        }
        
        // Simplified pulse animation
        if (!this.targetingIndicator.pulse) {
            this.targetingIndicator.pulse = 0;
        }
        this.targetingIndicator.pulse = (this.targetingIndicator.pulse + 0.1) % (Math.PI * 2);
        const pulseScale = 1.0 + 0.1 * Math.sin(this.targetingIndicator.pulse);
        this.targetingIndicator.scale.setScalar(pulseScale);
        
        // Show indicator
        this.targetingIndicator.visible = true;
        
        // Reset fade timeout
        if (this.targetingTimeout) {
            clearTimeout(this.targetingTimeout);
        }
        this.targetingTimeout = setTimeout(() => {
            if (this.targetingIndicator && this.targetingIndicator.visible) {
                this.targetingIndicator.visible = false;
            }
        }, 1000);
        
        // Extract target direction for firing
        const direction = new THREE.Vector3()
            .subVectors(targetPoint, this.playerShip.position)
            .normalize();
        
        // Store direction for firing
        this.targetDirection = direction;
    }
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggleMiniMap() {
    if (this.miniMap) {
      this.miniMap.toggle();
    }
  }
  
  // Add cleanup method
  cleanup() {
    // Stop and remove all sounds
    this.soundPools.forEach(pool => {
      pool.forEach(wrapper => {
        if (wrapper.sound.isPlaying) {
          wrapper.sound.stop();
        }
        wrapper.sound.buffer = null;
      });
    });
    
    // Clear sound pools and loaded sounds
    this.soundPools.clear();
    this.loadedSounds.clear();
    this.soundLoadPromises.clear();
    
    // Remove audio listener from camera
    if (this.audioListener) {
      this.camera.remove(this.audioListener);
      this.audioListener = null;
    }
    
    // Remove event listeners
    window.removeEventListener('resize', this.boundHandleResize);
    document.removeEventListener('keydown', this.boundHandleKeyDown);
    document.removeEventListener('keyup', this.boundHandleKeyUp);
    document.removeEventListener('click', this.boundHandleClick);
    document.removeEventListener('mousemove', this.boundHandleMouseMove);
    
    // Clear timers
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
      this.resizeTimer = null;
    }
    
    if (this.mouseMoveTimer) {
      clearTimeout(this.mouseMoveTimer);
      this.mouseMoveTimer = null;
    }
    
    // Clear weapon cooldowns
    this.weaponCooldowns.clear();
    
    // Clear key states
    Object.keys(this.keys).forEach(key => {
      this.keys[key] = false;
    });
    this.activeKeys.clear();
  }

  startGame() {
    console.log("Starting game...");
    
    // Get player name from input
    const playerNameInput = document.getElementById('player-name');
    this.playerName = playerNameInput.value.trim() || 'Pilot-' + Math.floor(Math.random() * 1000);
    
    // Hide start screen
    const startScreen = document.getElementById('start-screen');
    startScreen.classList.add('hidden');
    
    // Enable multiplayer mode by default
    this.multiplayerEnabled = true;
    
    // Connect to server
    if (this.networkManager) {
      this.networkManager.connect();
      
      // Show multiplayer info UI
      const multiplayerInfo = document.getElementById('multiplayer-info');
      if (multiplayerInfo) {
        multiplayerInfo.classList.remove('hidden');
      }
      
      // Update player info on server
      this.networkManager.updatePlayerInfo(this.playerName, this.currentShipType || 'default');
    }
    
    // Show ship selection screen
    this.showShipSelection();
  }

  showShipSelection() {
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
      console.error('Game container not found');
      return;
    }

    // Initialize ship selection if not already done
    if (!this.shipSelection) {
      this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
          this.shipSelection.hide();
          this.startGameplay(selection);
        }
      });
    }
    this.shipSelection.show();
  }

  startGameplay(shipSelection) {
    console.log('🔍 Starting gameplay with ship selection:', shipSelection);
    
    // First apply the ship selection
    this.applyShipSelection(shipSelection);
    
    // Set game as running (if this property exists)
    this.isRunning = true;
    
    // Show game UI (using either method)
    if (typeof this.ui !== 'undefined' && typeof this.ui.show === 'function') {
        this.ui.show();
    } else {
        // Show game UI directly
        const gameUI = document.querySelector('.game-ui');
        if (gameUI) {
            gameUI.classList.remove('hidden');
        }
    }
    
    // Show mini-map if it exists
    if (this.miniMap && typeof this.miniMap.show === 'function') {
        this.miniMap.show();
    }
    
    // Create and show controls if not already created
    if (!this.controlsContainer && typeof this.createControlIndicators === 'function') {
        this.createControlIndicators();
    }
    this.fadeInControls();
    
    // IMPORTANT: Double-check that the player ship has a proper collision radius
    if (this.playerShip) {
        this.playerShip.userData.collisionRadius = 0.35; // Use the same reduced value as defined earlier
        console.log('🛡️ Verified player ship collision radius:', this.playerShip.userData.collisionRadius);
    } else {
        console.error('⚠️ Player ship not available when starting gameplay!');
    }
    
    // Manually check for collisions once to make sure it's working
    setTimeout(() => {
        console.log('🔍 Running initial collision check...');
        this.checkObstacleCollisions();
    }, 500);

    // Start animation loop
    this.animate();
    
    console.log('✅ Game started successfully!');
  }

  applyShipSelection(selection) {
    console.log('🔍 Applying ship selection:', selection);
    
    // Clear existing ship model
    if (this.playerShip) {
        // Remove all children (previous ship model)
        while (this.playerShip.children.length > 0) {
            const child = this.playerShip.children[0];
            this.playerShip.remove(child);
        }
    }
    
    // Set ship model based on selection
    const type = selection.type.toUpperCase(); // Make sure it's uppercase for consistency
    this.setShipModel(type);
    this.currentShipType = type;
    
    // Position ship at a random location in the playing area
    // Avoid spawning too close to the center (where other players might spawn)
    const spawnRadius = 30; // Radius from center for spawning
    const randomAngle = Math.random() * Math.PI * 2; // Random angle
    const randomDistance = spawnRadius * (0.5 + Math.random() * 0.5); // Between 50% and 100% of spawn radius
    
    // Calculate position
    const spawnX = Math.cos(randomAngle) * randomDistance;
    const spawnZ = Math.sin(randomAngle) * randomDistance;
    
    // Set player ship position
    if (this.playerShip) {
        this.playerShip.position.set(spawnX, this.playerShip.position.y, spawnZ);
        
        // Set random rotation
        this.playerShip.rotation.y = Math.random() * Math.PI * 2;
        
        console.log(`Player spawned at position: [${spawnX.toFixed(2)}, ${spawnZ.toFixed(2)}], rotation: ${this.playerShip.rotation.y.toFixed(2)}`);
    }
    
    // Apply ship color if specified
    if (selection.color && this.playerShip) {
        const color = new THREE.Color(selection.color);
        
        // Apply color to all meshes in the ship model
        this.playerShip.traverse(child => {
            if (child.isMesh && child.material) {
                try {
                    // Clone the material to avoid affecting other instances
                    if (!child.material._isCloned) {
                        child.material = child.material.clone();
                        child.material._isCloned = true;
                    }
                    
                    // Update material color properties with safety checks
                    if (child.material.color) {
                        child.material.color.set(color);
                    }
                    
                    if (child.material.emissive) {
                        child.material.emissive.set(color);
                        child.material.emissiveIntensity = 0.3;
                    }
                    
                    // Update the material
                    child.material.needsUpdate = true;
                } catch (error) {
                    console.warn('Error setting material properties:', error);
                }
            }
        });
    }
    
    console.log('✅ Ship configuration applied successfully');
    
    // Verify collision detection is working
    console.log('🔍 Verifying collision detection is working');
}

exitToMainMenu() {
    // Stop animation loop
    this.isRunning = false;

    // Hide in-game menu if it exists
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
      menuContainer.classList.add('hidden');
    }

    // Hide game UI
    this.ui.hide();
    if (this.miniMap) {
      this.miniMap.hide();
    }
    this.fadeOutControls();

    // Clean up ship selection if it exists
    if (this.shipSelection) {
      this.shipSelection.hide();
    }

    // Show start screen
    const startScreen = document.getElementById('start-screen');
    if (startScreen) {
      startScreen.classList.remove('hidden');
      startScreen.classList.add('fade-in');
    }

    // Reset game state
    this.resetGameState();
  }

  resetGameState() {
    console.log('🔄 Resetting game state...');
    
    // Reset player position
    if (this.playerShip) {
        this.playerShip.position.set(0, 0.5, 0);
        this.playerShip.rotation.set(0, 0, 0);
    }
    
    // Reset camera to original position
    if (this.camera) {
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);
    }
    
    // Reset player stats
    this.health = this.maxHealth || 100;
    this.energy = this.maxEnergy || 100;
    
    // Update UI - use existing methods if available
    if (typeof this.updateUI === 'function') {
        this.updateUI();
    } else {
        // Update health bar
        const healthBar = document.querySelector('.health-bar .bar-inner');
        if (healthBar) {
            healthBar.style.width = '100%';
        }
        
        // Update energy bar
        const energyBar = document.querySelector('.energy-bar .bar-inner');
        if (energyBar) {
            energyBar.style.width = '100%';
        }
    }
    
    // Original way of clearing lasers
    if (this.lasers) {
        for (let i = this.lasers.length - 1; i >= 0; i--) {
            const laser = this.lasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.lasers = [];
    }
    
    // Clear bouncing lasers
    if (this.bouncingLasers) {
        for (let i = this.bouncingLasers.length - 1; i >= 0; i--) {
            const laser = this.bouncingLasers[i];
            if (laser.mesh && laser.mesh.parent) {
                laser.mesh.parent.remove(laser.mesh);
            }
        }
        this.bouncingLasers = [];
    }
    
    // Clear grenades
    if (this.grenades) {
        for (let i = this.grenades.length - 1; i >= 0; i--) {
            const grenade = this.grenades[i];
            if (grenade.mesh && grenade.mesh.parent) {
                grenade.mesh.parent.remove(grenade.mesh);
            }
        }
        this.grenades = [];
    }
    
    // Reset movement keys
    this.keys = {
        forward: false,
        backward: false,
        left: false,
        right: false,
        strafeLeft: false,
        strafeRight: false
    };
    
    // Reset weapon state to original
    this.currentWeapon = 'laser';
    this.weaponCooldown = 0;
    this.grenadeTargeting = false;
    
    // Make sure the player exists
    if (!this.playerShip) {
        this.createDefaultShip();
    }
    
    // Reset player velocity (original behavior)
    this.playerVelocity = new THREE.Vector3();
    this.playerRotation = new THREE.Vector3();
    
    // Update weapon UI - use existing method if available
    if (typeof this.updateWeaponUI === 'function') {
        this.updateWeaponUI();
    }
    
    // Update control indicators - use existing method if available
    if (typeof this.updateControlIndicators === 'function') {
        this.updateControlIndicators();
    }
    
    console.log('✅ Game state reset complete');
  }

  handleDirectionalFiring(event) {
    // Get mouse position in normalized device coordinates
    const mouse = new THREE.Vector2(
        (event.clientX / window.innerWidth) * 2 - 1,
        -(event.clientY / window.innerHeight) * 2 + 1
    );

    // Use raycasting to determine the point in 3D space
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, this.camera);

    // Check for intersection with an invisible plane at ship's height
    const planeNormal = new THREE.Vector3(0, 1, 0);
    const shipHeight = this.playerShip.position.y;
    const plane = new THREE.Plane(planeNormal, -shipHeight);
    
    const targetPoint = new THREE.Vector3();
    raycaster.ray.intersectPlane(plane, targetPoint);

    if (targetPoint) {
        // Calculate direction from ship to target
        const direction = targetPoint.clone().sub(this.playerShip.position).normalize();
        direction.y = 0; // Keep shots parallel to ground

        // Get the ship's current forward direction
        const shipForward = new THREE.Vector3(0, 0, 1);
        shipForward.applyQuaternion(this.playerShip.quaternion);
        shipForward.y = 0;
        shipForward.normalize();

        // Calculate the angle between ship's forward direction and target direction
        const angle = shipForward.angleTo(direction);
        
        // Only fire if the target is within a reasonable angle (e.g., 60 degrees) from ship's forward direction
        const maxFiringAngle = Math.PI / 3; // 60 degrees
        
        if (angle <= maxFiringAngle) {
            // Fire weapon in the calculated direction
            this.fireCurrentWeapon(direction);
        }
    }
  }

  fireCurrentWeapon(direction) {
    // Check weapon cooldown
    const now = Date.now();
    const weaponCooldown = this.weaponCooldowns.get(this.currentWeapon) || 0;

    if (now < weaponCooldown) {
        return;
    }

    // Define energy costs for each weapon from GAME_CONFIG
    const energyCosts = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.ENERGY_COST,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.ENERGY_COST,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.ENERGY_COST
    };

    // Check if we have enough energy
    const energyCost = energyCosts[this.currentWeapon];
    if (this.energy < energyCost) {
        console.log(`Not enough energy for ${this.currentWeapon}`);
        return;
    }

    // Set cooldown based on weapon type from GAME_CONFIG
    const cooldowns = {
        'LASER': GAME_CONFIG.WEAPONS.LASER.COOLDOWN,
        'BOUNCE': GAME_CONFIG.WEAPONS.BOUNCE.COOLDOWN,
        'GRENADE': GAME_CONFIG.WEAPONS.GRENADE.COOLDOWN
    };
    const cooldownTime = cooldowns[this.currentWeapon];

    this.weaponCooldowns.set(this.currentWeapon, now + cooldownTime);

    // Consume energy
    this.energy = Math.max(0, this.energy - energyCost);
    
    // Update UI with energy change
    if (this.ui && typeof this.ui.updateEnergy === 'function') {
        this.ui.updateEnergy(this.energy, this.maxEnergy);
    }

    // Use target direction if available, otherwise use ship orientation
    let firingDirection;
    
    // If we have a targetDirection from mouse, use that instead of ship orientation
    if (this.targetDirection && (this.currentWeapon === 'LASER' || this.currentWeapon === 'BOUNCE')) {
        firingDirection = this.targetDirection.clone();
        console.log('Using mouse targeting direction:', firingDirection);
    } else {
        // Fall back to ship orientation if no target direction
        firingDirection = direction || new THREE.Vector3(0, 0, 1).applyQuaternion(this.playerShip.quaternion);
        console.log('Using ship orientation direction:', firingDirection);
    }
    
    // Ensure direction is normalized
    firingDirection.normalize();
    
    // Get firing position (slightly in front of ship)
    const position = this.playerShip.position.clone().add(firingDirection.clone().multiplyScalar(1.5));
    position.y = 0.5; // Set height

    // Create weapon effect based on type
    switch (this.currentWeapon) {
        case 'LASER':
            this.fireLaser(position, firingDirection);
            this.playSound('laser');
            
            // Send laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection
                });
            }
            break;
        case 'BOUNCE':
            this.fireBouncingLaser(position, firingDirection);
            this.playSound('laser-bounce');
            
            // Send bounce laser shot to other players if multiplayer is enabled
            if (this.multiplayerEnabled && this.networkManager && this.networkManager.isConnected()) {
                this.networkManager.sendLaserShot({
                    origin: position,
                    direction: firingDirection,
                    type: 'bounce'
                });
            }
            break;
        case 'GRENADE':
            // Grenades are handled separately through handleGrenadeTargeting
            break;
    }

    // Visual feedback for firing
    this.createMuzzleFlash(position, firingDirection);

    // Log energy state for debugging
    console.log(`Weapon fired: ${this.currentWeapon}, Energy remaining: ${this.energy}/${this.maxEnergy}`);
}

createMuzzleFlash(position, direction) {
  // Create a quick flash effect at the firing position
  const flashGeometry = new THREE.CircleGeometry(0.3, 16);
  const flashMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 1,
    side: THREE.DoubleSide
  });
  
  const flash = new THREE.Mesh(flashGeometry, flashMaterial);
  
  // Position flash at the weapon position, oriented to face the camera
  flash.position.copy(position);
  flash.position.y += 0.1; // Slightly above ship
  
  // Update flash to always face camera
  flash.lookAt(this.camera.position);
  
  // Add to scene
  this.scene.add(flash);
  
  // Create flash animation with subtle scaling
  let scale = 1;
  const animate = () => {
    scale += 0.2;
    flash.scale.set(scale, scale, scale);
    
    // Reduce opacity as flash grows
    if (flash.material) {
      flash.material.opacity = Math.max(0, 1 - (scale - 1) / 2);
      
      // Remove when fully transparent
      if (flash.material.opacity <= 0) {
        this.scene.remove(flash);
        if (flash.material) flash.material.dispose();
        if (flash.geometry) flash.geometry.dispose();
        return;
      }
    }
    
    // Continue animation
    requestAnimationFrame(animate);
  };
  animate();
}

  fireLaser(position, direction) {
    // Create laser geometry - make it longer and thinner for better visual
    const geometry = new THREE.CylinderGeometry(0.05, 0.05, 3, 8);
    geometry.rotateX(-Math.PI / 2); // Changed rotation to negative to flip direction

    // Create glowing material with better visual effects
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Orient laser along direction - using lookAt for more accurate direction
    const targetPos = position.clone().add(direction.clone().multiplyScalar(10));
    laser.lookAt(targetPos);

    // Add to scene
    this.scene.add(laser);

    // Add point light for glow effect with better parameters
    const light = new THREE.PointLight(0x00ffff, 2, 4);
    light.position.set(0, 0, 0); // Center of the laser
    laser.add(light);

    // Add a trail effect
    const trailGeometry = new THREE.BufferGeometry();
    const trailMaterial = new THREE.LineBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.5,
      blending: THREE.AdditiveBlending
    });
    const trail = new THREE.Line(trailGeometry, trailMaterial);
    this.scene.add(trail);

    // Initialize lasers array if it doesn't exist
    if (!this.lasers) {
      this.lasers = [];
    }

    // Store laser data with enhanced properties
    this.lasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 1.2, // Slightly increased speed for better feel
      lifeTime: 0,
      maxLifeTime: 40,
      trailPoints: [],
      pulsePhase: 0
    });
  }

  fireBouncingLaser(position, direction) {
    // Create bouncing laser geometry - using a smaller sphere for better visuals
    const geometry = new THREE.SphereGeometry(0.15, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ff99,
      transparent: true,
      opacity: 0.8
    });

    const laser = new THREE.Mesh(geometry, material);
    laser.position.copy(position);

    // Add point light for glow effect
    const light = new THREE.PointLight(0x00ff99, 2, 3);
    laser.add(light);

    // Create enhanced trail effect
    const trail = new THREE.Line(
      new THREE.BufferGeometry(),
      new THREE.LineBasicMaterial({
        color: 0x00ff99,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
      })
    );

    // Add to scene
    this.scene.add(laser);
    this.scene.add(trail);

    // Initialize bouncing lasers array if it doesn't exist
    if (!this.bouncingLasers) {
      this.bouncingLasers = [];
    }

    // Store bouncing laser data with improved parameters
    this.bouncingLasers.push({
      mesh: laser,
      trail: trail,
      direction: direction.clone(), // Clone the direction to prevent reference issues
      speed: 0.8, // Increased speed for better feel
      bounces: 0,
      maxBounces: 3,
      lifeTime: 0,
      maxLifeTime: 120,
      canHitPlayer: false,
      bounceTimeout: 15, // Reduced timeout for better gameplay
      trailPoints: [],
      pulsePhase: 0
    });
  }

  createHitEffect(position) {
    // Create particle burst effect
    const particleCount = 15;
    const particles = [];
    
    // Create particle material with orange/red color for explosion
    const particleMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });

    for (let i = 0; i < particleCount; i++) {
      // Create small particle geometry
      const particleGeometry = new THREE.PlaneGeometry(0.2, 0.2);
      const particle = new THREE.Mesh(particleGeometry, particleMaterial.clone());
      
      // Position at hit point
      particle.position.copy(position);
      
      // Random velocity in all directions
      const velocity = new THREE.Vector3(
        Math.random() * 2 - 1,
        Math.random() * 2 - 1,
        Math.random() * 2 - 1
      ).normalize().multiplyScalar(0.2 + Math.random() * 0.3);
      
      particle.userData.velocity = velocity;
      particle.userData.life = 1.0;
      
      this.scene.add(particle);
      particles.push(particle);
    }

    // Add impact flash
    const flashGeometry = new THREE.CircleGeometry(0.5, 16);
    const flashMaterial = new THREE.MeshBasicMaterial({
      color: 0xff6600,
      transparent: true,
      opacity: 0.8,
      side: THREE.DoubleSide
    });
    
    const flash = new THREE.Mesh(flashGeometry, flashMaterial);
    flash.position.copy(position);
    flash.lookAt(this.camera.position);
    this.scene.add(flash);

    // Add point light
    const light = new THREE.PointLight(0xff6600, 3, 6);
    light.position.copy(position);
    this.scene.add(light);

    // Animate particles and effects
    let frame = 0;
    const animate = () => {
      frame++;
      
      // Update particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const particle = particles[i];
        
        // Move particle
        particle.position.add(particle.userData.velocity);
        
        // Reduce life
        particle.userData.life -= 0.05;
        
        // Update opacity
        particle.material.opacity = particle.userData.life;
        
        // Remove dead particles
        if (particle.userData.life <= 0) {
          this.scene.remove(particle);
          particles.splice(i, 1);
        }
      }

      // Update flash
      flash.scale.addScalar(0.2);
      flashMaterial.opacity *= 0.8;

      // Update light
      light.intensity *= 0.8;

      // Continue animation if particles remain
      if (particles.length > 0 && frame < 20) {
        requestAnimationFrame(animate);
      } else {
        // Clean up
        this.scene.remove(flash);
        this.scene.remove(light);
      }
    };

    // Start animation
    animate();
  }

  showInGameMenu() {
    // Pause the game
    this.isRunning = false;
    
    // Create or reuse the menu element
    let menuContainer = document.getElementById('in-game-menu');
    if (!menuContainer) {
      menuContainer = document.createElement('div');
      menuContainer.id = 'in-game-menu';
      menuContainer.className = 'menu-container';
      document.getElementById('game-container').appendChild(menuContainer);
      
      // Style the menu
      menuContainer.style.position = 'absolute';
      menuContainer.style.top = '50%';
      menuContainer.style.left = '50%';
      menuContainer.style.transform = 'translate(-50%, -50%)';
      menuContainer.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
      menuContainer.style.padding = '20px';
      menuContainer.style.borderRadius = '10px';
      menuContainer.style.color = '#fff';
      menuContainer.style.textAlign = 'center';
      menuContainer.style.zIndex = '1000';
      menuContainer.style.border = '2px solid #00ffff';
      menuContainer.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.4)';
      menuContainer.style.minWidth = '300px';
    }
    
    // Create menu content
    menuContainer.innerHTML = `
      <h2 style="color: #00ffff; margin-top: 0;">Game Menu</h2>
      <div class="menu-options">
        <button id="resume-button" class="menu-button">Resume Game</button>
        <button id="change-ship-button" class="menu-button">Change Ship</button>
        <button id="exit-button" class="menu-button">Exit to Main Menu</button>
      </div>
    `;
    
    // Style buttons
    const buttons = menuContainer.querySelectorAll('.menu-button');
    buttons.forEach(button => {
      button.style.display = 'block';
      button.style.width = '100%';
      button.style.padding = '10px';
      button.style.margin = '10px 0';
      button.style.backgroundColor = '#001a33';
      button.style.color = '#00ffff';
      button.style.border = '1px solid #00ffff';
      button.style.borderRadius = '5px';
      button.style.cursor = 'pointer';
      button.style.fontSize = '16px';
      button.style.transition = 'all 0.2s';
      
      // Hover effect
      button.onmouseenter = () => {
        button.style.backgroundColor = '#00ffff';
        button.style.color = '#001a33';
      };
      button.onmouseleave = () => {
        button.style.backgroundColor = '#001a33';
        button.style.color = '#00ffff';
      };
    });
    
    // Add event listeners
    document.getElementById('resume-button').addEventListener('click', () => this.resumeGame());
    document.getElementById('change-ship-button').addEventListener('click', () => this.showShipChangeScreen());
    document.getElementById('exit-button').addEventListener('click', () => this.exitToMainMenu());
    
    // Show the menu
    menuContainer.classList.remove('hidden');
  }
  
  resumeGame() {
    console.log('Hiding menus');
    
    // Hide ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
    }
    
    // Hide menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
  }
  
  showShipChangeScreen() {
    // Hide the menu
    const menuContainer = document.getElementById('in-game-menu');
    if (menuContainer) {
        menuContainer.classList.add('hidden');
    }
    
    // Make sure we have a container
    const container = document.getElementById('game-container');
    if (!container) {
        console.error('Game container not found');
        return;
    }
    
    // Clean up existing ship selection if it exists
    if (this.shipSelection) {
        this.shipSelection.hide();
        
        // Safely remove the element from DOM if it exists and has a parent
        if (this.shipSelection.element && this.shipSelection.element.parentNode) {
            this.shipSelection.element.parentNode.removeChild(this.shipSelection.element);
        }
        
        this.shipSelection = null;
    }
    
    // Create new ship selection instance
    this.shipSelection = new ShipSelectionUI(container, {
        isPremium: false,
        onShipSelect: (selection) => {
            this.shipSelection.hide();
            this.applyShipSelection(selection);
        }
    });
    
    // Show the ship selection UI
    this.shipSelection.show();
  }

  /**
   * Calculate proper ground offset for an object based on its type and geometry
   */
  calculateGroundOffset(model, category, scale) {
    // Get the bounding box
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Calculate the distance from the object's pivot to its bottom
    const pivotToBottom = bbox.min.y;
    
    // The base offset is the distance needed to move the object so its bottom touches the ground
    let groundOffset = -pivotToBottom;
    
    // Add category-specific adjustments with more refined values
    switch(category) {
      case 'rocks':
        // Rocks typically need to be slightly embedded in the ground
        groundOffset += size.y * 0.08;
        break;
      case 'flora':
        // Flora should be firmly planted in the ground
        groundOffset += size.y * 0.03;
        break;
      case 'groundFeatures':
        // Ground features should be partially embedded, varying by model
        if (model.name && model.name.includes('Ground02')) {
          groundOffset += size.y * 0.15; // SP_Ground02 needs more embedding
        } else if (model.name && model.name.includes('Ground05')) {
          groundOffset += size.y * 0.05; // SP_Ground05 needs less embedding
        } else {
          groundOffset += size.y * 0.1; // Default for other ground features
        }
        break;
      case 'crystals':
        // Crystals should appear to be growing from the ground
        groundOffset += size.y * 0.15;
        break;
      case 'mountains':
        // Mountains need to be firmly embedded with varying depths
        const mountainDepth = 0.08 + (Math.random() * 0.05); // Random depth between 8-13%
        groundOffset += size.y * mountainDepth;
        break;
      case 'centerpiece':
        // Centerpiece gets special treatment
        groundOffset += size.y * 0.12;
        break;
      default:
        // Default adjustment for unknown types
        groundOffset += 0;
    }
    
    // Scale the offset according to the object's scale
    // Add a small global offset to prevent z-fighting
    return (groundOffset * scale) + 0.01;
  }

  /**
   * Create a special centerpiece for the landscape
   */
  createCenterpiece() {
    // Create a special formation at a designated spot
    const centerpiece = {
      position: new THREE.Vector3(0, 0, -35), // Prominent position
      models: [
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 2.5, offset: new THREE.Vector3(0, 0, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.8, offset: new THREE.Vector3(2, 0, 1), rotation: Math.PI/4 },
        { path: 'assets/models/objects/SP_Crystal01.glb', scale: 1.6, offset: new THREE.Vector3(-1.5, 0, -1), rotation: -Math.PI/5 },
        { path: 'assets/models/objects/SP_Ground05.glb', scale: 2.0, offset: new THREE.Vector3(0, -0.5, 0), rotation: 0 },
        { path: 'assets/models/objects/SP_Stone01.glb', scale: 1.2, offset: new THREE.Vector3(2.5, 0, -1.5), rotation: Math.PI/3 }
      ]
    };
    
    // Load each model in the centerpiece
    centerpiece.models.forEach((model, index) => {
      const loader = new GLTFLoader();
      loader.load(
        model.path,
        (gltf) => {
          const object = gltf.scene;
          
          // Apply scale
          object.scale.set(model.scale, model.scale, model.scale);
          
          // Position relative to centerpiece
          object.position.copy(centerpiece.position.clone().add(model.offset));
          
          // Apply rotation
          object.rotation.y = model.rotation;
          
          // Add special glow effect for crystals
          if (model.path.includes('Crystal')) {
            object.traverse(node => {
              if (node.isMesh && node.material) {
                node.material.emissive = new THREE.Color(0xff00ff);
                node.material.emissiveIntensity = 0.5;
                
                // Add a point light for extra effect
                const light = new THREE.PointLight(0xff00ff, 2, 10);
                light.position.set(0, 2 * model.scale, 0);
                object.add(light);
              }
            });
          }
          
          // Add to scene
          this.scene.add(object);
          
          // Create collision data
          const bbox = new THREE.Box3().setFromObject(object);
          const size = bbox.getSize(new THREE.Vector3());
          
          // Use improved ground placement
          const groundY = this.calculateGroundOffset(object, 'centerpiece', model.scale);
          object.position.y = groundY + model.offset.y; // Add the intentional offset for composition
          
          // Generate compound collision shapes
          const collisionShapes = this.generateCompoundCollisionShapes(object, 'centerpiece', model.scale);
          
          // Add to obstacles
          this.obstacles.push({
            mesh: object,
            type: 'centerpiece',
            collisionShape: 'compound',
            compoundShapes: collisionShapes.map(shape => {
              // Transform shape centers to world coordinates
              const worldCenter = shape.center.clone();
              worldCenter.add(object.position);
              
              return {
                ...shape,
                center: worldCenter,
                worldRotation: object.rotation.y + (shape.rotation || 0)
              };
            }),
            boundingBox: {
              min: new THREE.Vector3(
                object.position.x - (size.x * model.scale / 2),
                object.position.y - (size.y * model.scale / 2),
                object.position.z - (size.z * model.scale / 2)
              ),
              max: new THREE.Vector3(
                object.position.x + (size.x * model.scale / 2),
                object.position.y + (size.y * model.scale / 2),
                object.position.z + (size.z * model.scale / 2)
              ),
              size: size.clone().multiplyScalar(model.scale),
              rotation: object.rotation.y
            },
            size: Math.max(size.x, size.z) * model.scale * 0.5,
            position: object.position.clone()
          });
          
          console.log(`Centerpiece: Added ${model.path.split('/').pop()} at position [${object.position.x.toFixed(1)}, ${object.position.y.toFixed(1)}, ${object.position.z.toFixed(1)}]`);
        },
        undefined,
        (error) => {
          console.error(`Error loading centerpiece model ${model.path}:`, error);
        }
      );
    });
  }

  /**
   * Create a special effect when colliding with crystals
   */
  createCrystalCollisionEffect(position, isSpecial = false) {
    // Create particles for crystal collision
    const particleCount = isSpecial ? 30 : 15;
    const color = isSpecial ? 0xff00ff : 0x00ffff;
    
    for (let i = 0; i < particleCount; i++) {
      // Create a small glowing cube
      const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
      const material = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8
      });
      
      const particle = new THREE.Mesh(geometry, material);
      
      // Position at collision point
      particle.position.copy(position);
      
      // Add small random offset
      particle.position.x += (Math.random() - 0.5) * 2;
      particle.position.y += Math.random() * 3;
      particle.position.z += (Math.random() - 0.5) * 2;
      
      // Add to scene
      this.scene.add(particle);
      
      // Create velocity for particle
      const velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.2,
        Math.random() * 0.2 + 0.1,
        (Math.random() - 0.5) * 0.2
      );
      
      // Animate the particle
      const startTime = Date.now();
      const duration = 1000 + Math.random() * 1000; // 1-2 seconds
      
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = elapsed / duration;
        
        if (progress >= 1) {
          // Remove particle when animation completes
          this.scene.remove(particle);
          particle.geometry.dispose();
          particle.material.dispose();
          return;
        }
        
        // Update position
        particle.position.add(velocity);
        
        // Slow down over time
        velocity.multiplyScalar(0.98);
        
        // Fade out
        particle.material.opacity = 0.8 * (1 - progress);
        
        // Continue animation
        requestAnimationFrame(animate);
      };
      
      // Start animation
      animate();
    }
  }

  /**
   * Generate compound collision shapes for more accurate collision detection
   */
  generateCompoundCollisionShapes(model, category, scale) {
    // Generate a compound collision shape based on model geometry and category
    const shapes = [];
    const bbox = new THREE.Box3().setFromObject(model);
    
    // Helper function to add a box shape
    const addBoxShape = (center, size, rotation = 0) => {
      shapes.push({
        type: 'box',
        center: center.clone(),
        halfExtents: size.clone().multiplyScalar(0.5),
        rotation: rotation
      });
    };
    
    // Helper function to add a sphere shape
    const addSphereShape = (center, radius) => {
      shapes.push({
        type: 'sphere',
        center: center.clone(),
        radius: radius
      });
    };
    
    // Different collision shape strategies based on category
    switch(category) {
      case 'rocks':
        // For rocks, use 1-3 overlapping boxes based on size
        const rockSize = bbox.getSize(new THREE.Vector3());
        const rockCenter = new THREE.Vector3();
        bbox.getCenter(rockCenter);
        
        // Main box
        addBoxShape(rockCenter, rockSize);
        
        // For larger rocks, add 1-2 more boxes at slight offsets for better shape approximation
        if (rockSize.x > 1.5 * scale || rockSize.z > 1.5 * scale) {
          // Add a second box, slightly offset and rotated
          const offset = new THREE.Vector3(
            (Math.random() - 0.5) * 0.3 * rockSize.x,
            0,
            (Math.random() - 0.5) * 0.3 * rockSize.z
          );
          
          const secondSize = new THREE.Vector3(
            rockSize.x * (0.7 + Math.random() * 0.3),
            rockSize.y * 0.9,
            rockSize.z * (0.7 + Math.random() * 0.3)
          );
          
          addBoxShape(rockCenter.clone().add(offset), secondSize, Math.PI * 0.25);
          
          // For very large rocks, add a third box
          if (rockSize.x > 2.5 * scale || rockSize.z > 2.5 * scale) {
            const thirdOffset = new THREE.Vector3(
              (Math.random() - 0.5) * 0.4 * rockSize.x,
              rockSize.y * 0.2,
              (Math.random() - 0.5) * 0.4 * rockSize.z
            );
            
            const thirdSize = new THREE.Vector3(
              rockSize.x * (0.6 + Math.random() * 0.2),
              rockSize.y * 0.7,
              rockSize.z * (0.6 + Math.random() * 0.2)
            );
            
            addBoxShape(rockCenter.clone().add(thirdOffset), thirdSize, Math.PI * 0.125);
          }
        }
        break;
        
      case 'flora':
        // For flora, use a smaller box for the base and a sphere for the top
        const floraSize = bbox.getSize(new THREE.Vector3());
        const floraCenter = new THREE.Vector3();
        bbox.getCenter(floraCenter);
        
        // Box for the base/stem
        const stemSize = new THREE.Vector3(
          floraSize.x * 0.2,
          floraSize.y * 0.6,
          floraSize.z * 0.2
        );
        
        const stemCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (stemSize.y / 2),
          floraCenter.z
        );
        
        addBoxShape(stemCenter, stemSize);
        
        // Sphere for the top/foliage
        const foliageCenter = new THREE.Vector3(
          floraCenter.x,
          bbox.min.y + (floraSize.y * 0.7),
          floraCenter.z
        );
        
        const foliageRadius = Math.max(floraSize.x, floraSize.z) * 0.5;
        addSphereShape(foliageCenter, foliageRadius);
        break;
        
      case 'mountains':
        // For mountains, use a pyramid-like composition of boxes
        const mountainSize = bbox.getSize(new THREE.Vector3());
        const mountainCenter = new THREE.Vector3();
        bbox.getCenter(mountainCenter);
        
        // Base box (wider)
        const baseSize = new THREE.Vector3(
          mountainSize.x,
          mountainSize.y * 0.3,
          mountainSize.z
        );
        
        const baseCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + (baseSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(baseCenter, baseSize);
        
        // Middle box (narrower)
        const middleSize = new THREE.Vector3(
          mountainSize.x * 0.8,
          mountainSize.y * 0.4,
          mountainSize.z * 0.8
        );
        
        const middleCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + (middleSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(middleCenter, middleSize);
        
        // Top box (narrowest)
        const topSize = new THREE.Vector3(
          mountainSize.x * 0.5,
          mountainSize.y * 0.3,
          mountainSize.z * 0.5
        );
        
        const topCenter = new THREE.Vector3(
          mountainCenter.x,
          bbox.min.y + baseSize.y + middleSize.y + (topSize.y / 2),
          mountainCenter.z
        );
        
        addBoxShape(topCenter, topSize);
        break;
        
      case 'crystals':
        // For crystals, use a combination of boxes at different angles
        const crystalSize = bbox.getSize(new THREE.Vector3());
        const crystalCenter = new THREE.Vector3();
        bbox.getCenter(crystalCenter);
        
        // Calculate a better fitting box size (narrower)
        const mainCrystalSize = new THREE.Vector3(
          crystalSize.x * 0.7,
          crystalSize.y,
          crystalSize.z * 0.7
        );
        
        // Add the main crystal shape
        addBoxShape(crystalCenter, mainCrystalSize, model.rotation.y);
        
        // For larger crystals, add some angled shards
        if (crystalSize.y > 1.0 * scale) {
          // Add up to 3 additional shards
          const shardCount = 1 + Math.floor(Math.random() * 3);
          
          for (let i = 0; i < shardCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = crystalSize.x * 0.3;
            
            const offset = new THREE.Vector3(
              Math.cos(angle) * distance,
              crystalSize.y * (Math.random() * 0.2),
              Math.sin(angle) * distance
            );
            
            const shardSize = new THREE.Vector3(
              crystalSize.x * (0.2 + Math.random() * 0.3),
              crystalSize.y * (0.4 + Math.random() * 0.4),
              crystalSize.z * (0.2 + Math.random() * 0.3)
            );
            
            const shardRotation = Math.random() * Math.PI;
            addBoxShape(crystalCenter.clone().add(offset), shardSize, shardRotation);
          }
        }
        break;
        
      case 'groundFeatures':
        // For ground features, use a more accurate horizontal shape with the right height
        const groundSize = bbox.getSize(new THREE.Vector3());
        const groundCenter = new THREE.Vector3();
        bbox.getCenter(groundCenter);
        
        // Just use a single box but with better proportions
        const adjustedSize = new THREE.Vector3(
          groundSize.x,
          groundSize.y * 0.7, // Lower height to prevent floating
          groundSize.z
        );
        
        // Center it properly on the ground
        const adjustedCenter = new THREE.Vector3(
          groundCenter.x,
          bbox.min.y + (adjustedSize.y / 2),
          groundCenter.z
        );
        
        addBoxShape(adjustedCenter, adjustedSize, model.rotation.y);
        break;
        
      case 'centerpiece':
        // For centerpiece, create a custom multi-part shape
        const centerpieceSize = bbox.getSize(new THREE.Vector3());
        const centerpieceCenter = new THREE.Vector3();
        bbox.getCenter(centerpieceCenter);
        
        // Main box
        addBoxShape(centerpieceCenter, centerpieceSize);
        
        // Add a sphere on top for the crystal parts
        const sphereCenter = new THREE.Vector3(
          centerpieceCenter.x,
          centerpieceCenter.y + (centerpieceSize.y * 0.2),
          centerpieceCenter.z
        );
        
        const sphereRadius = Math.max(centerpieceSize.x, centerpieceSize.z) * 0.6;
        addSphereShape(sphereCenter, sphereRadius);
        break;
        
      default:
        // Default: just use a box based on the bounding box
        const size = bbox.getSize(new THREE.Vector3());
        const center = new THREE.Vector3();
        bbox.getCenter(center);
        addBoxShape(center, size);
        break;
    }
    
    return shapes;
  }

  updateOtherPlayers() {
    if (!this.networkManager || !this.multiplayerEnabled || !this.assetLoader) return;
  
    const otherPlayers = this.networkManager.getOtherPlayers();
    if (!this.otherPlayerObjects) this.otherPlayerObjects = {};
  
    otherPlayers.forEach(playerData => {
      let playerObject = this.otherPlayerObjects[playerData.id];
  
      if (!playerObject) {
        console.log('Creating new player representation for:', playerData.id);
        const shipType = (playerData.shipType || 'STANDARD').toUpperCase();
        const shipModel = this.assetLoader.getOpponentShipModel(shipType);
  
        if (!shipModel) {
          console.warn(`No model found for ship type: ${shipType}, falling back to default`);
          // Fallback geometry if model fails
          const geometry = new THREE.ConeGeometry(0.5, 1.0, 8);
          geometry.rotateX(Math.PI / 2);
          const material = new THREE.MeshPhongMaterial({ 
            color: playerData.teamColor || 0x00ffff,
            emissive: playerData.teamColor || 0x00ffff,
            emissiveIntensity: 0.5
          });
          const ship = new THREE.Mesh(geometry, material);
          this.scene.add(ship);
          playerObject = { ship, lastUpdate: Date.now() };
        } else {
          // Scale the model consistently (matching player ship scaling)
          shipModel.scale.set(0.45, 0.45, 0.45);
          this.scene.add(shipModel);
          playerObject = { ship: shipModel, lastUpdate: Date.now() };
        }
  
        // Add engine glow
        const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
        engineGlow.position.set(0, 0, -0.7);
        playerObject.ship.add(engineGlow);
        playerObject.engineGlow = engineGlow;
  
        // Add name label
        const nameDiv = document.createElement('div');
        nameDiv.className = 'player-label';
        nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
        const nameLabel = new CSS2DObject(nameDiv);
        nameLabel.position.set(0, 1.8, 0);
        playerObject.ship.add(nameLabel);
        playerObject.nameLabel = nameLabel;
  
        this.otherPlayerObjects[playerData.id] = playerObject;
      }
  
      // Update position and rotation
      if (playerData.position) {
        playerObject.ship.position.lerp(
          new THREE.Vector3(playerData.position.x, playerData.position.y || 0.5, playerData.position.z),
          0.3
        );
      }
      if (playerData.rotation !== undefined) {
        const targetY = playerData.rotation;
        let rotDiff = targetY - playerObject.ship.rotation.y;
        if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        playerObject.ship.rotation.y += rotDiff * 0.3;
      }
  
      playerObject.lastUpdate = Date.now();
    });
  
    // Clean up disconnected players
    const now = Date.now();
    Object.keys(this.otherPlayerObjects).forEach(id => {
      const playerObj = this.otherPlayerObjects[id];
      if (now - playerObj.lastUpdate > 10000) {
        console.log('Removing disconnected player:', id);
        this.scene.remove(playerObj.ship);
        delete this.otherPlayerObjects[id];
        this.updatePlayerCount();
      }
    });
  }

  // Helper method to send player position and rotation to the server
  sendPlayerPositionUpdate() {
    if (!this.playerShip || !this.networkManager || !this.networkManager.isConnected()) return;
    
    // Create a simple data object with player information
    const playerData = {
      position: {
        x: this.playerShip.position.x,
        y: this.playerShip.position.y,
        z: this.playerShip.position.z
      },
      rotation: this.playerShip.rotation.y,
      shipType: this.currentShipType || 'STANDARD',
      name: this.playerName
    };
    
    // Send the update to the network manager
    this.networkManager.sendPlayerUpdate(playerData);
  }

  // Add the missing setShipModel function
  setShipModel(type) {
    console.log('🔍 Setting ship model:', type);
    
    // Get the ship model from assets
    let model = this.assetLoader.getShipModel(type);
    
    // If model is null or undefined, create fallback model
    if (!model) {
      console.warn('⚠️ Using fallback ship model for type:', type);
      
      // Create a simple geometric shape as fallback
      const geometry = new THREE.BoxGeometry(1, 0.5, 2);
      const material = new THREE.MeshPhongMaterial({ 
        color: 0x00ffff, 
        specular: 0x111111, 
        shininess: 30 
      });
      model = new THREE.Mesh(geometry, material);
    }
    
    // Clear existing player ship if it exists
    if (this.playerShip) {
      if (this.scene) {
        this.scene.remove(this.playerShip);
      }
      this.playerShip = null;
    }
    
    // Set the new ship model
    this.playerShip = model;
    
    // Position the ship appropriately
    if (this.playerShip && this.scene) {
      this.playerShip.position.set(0, 0.5, 0);
      this.scene.add(this.playerShip);
    }
    
    return this.playerShip;
  }

  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.soundManager) {
      console.log(`Playing sound: ${name}`);
      this.soundManager.playSound(name, position);
    } else {
      console.warn(`Cannot play sound '${name}': SoundManager not initialized`);
    }
  }

  /**
   * Update a remote player's position and rotation
   * @param {string} id - Player ID
   * @param {Object} position - Position coordinates
   * @param {Object} rotation - Rotation coordinates
   */
  updateRemotePlayer(id, position, rotation) {
    // Get existing player or create a new one
    let player = this.remotePlayers.get(id);
    
    if (!player) {
      // Create a new player mesh if this is the first update
      player = this.createRemotePlayerMesh();
      this.remotePlayers.set(id, player);
      this.scene.add(player);
      console.log(`Created new remote player: ${id}`);
    }
    
    // Update player position and rotation
    if (position) {
      player.position.set(position.x, position.y, position.z);
    }
    
    if (rotation) {
      player.rotation.set(rotation.x, rotation.y, rotation.z);
    }
  }
  
  /**
   * Create a mesh for a remote player
   * @returns {THREE.Object3D} Player mesh
   */
  createRemotePlayerMesh() {
    // For simplicity, we'll use a simple colored box for remote players
    const geometry = new THREE.BoxGeometry(1, 1, 2);
    const material = new THREE.MeshLambertMaterial({ color: 0xff0000 }); // Red for other players
    const mesh = new THREE.Mesh(geometry, material);
    
    // Add name label
    const nameLabel = document.createElement('div');
    nameLabel.className = 'player-label';
    nameLabel.textContent = 'Player';
    
    const playerLabel = new CSS2DObject(nameLabel);
    playerLabel.position.set(0, 1.5, 0);
    mesh.add(playerLabel);
    
    return mesh;
  }
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
  // Initialize game
  const game = new SimpleGame();
  
  // Add start button event listener
  document.getElementById('start-button').addEventListener('click', () => {
    // Get the player name from the input field
    const playerNameInput = document.getElementById('player-name');
    if (playerNameInput && playerNameInput.value.trim() !== '') {
      // Store the player name
      game.playerName = playerNameInput.value.trim();
      console.log(`Player name set to: ${game.playerName}`);
    } else {
      console.log('Using default player name: ' + game.playerName);
    }
    
    // Start the game
    game.startGame();
  });
}); 
### ./index.js END ###


### ./codebase.md END ###

### ./ui/ShipSelectionUI.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';
import { ShipSelector, SHIP_TYPES, SHIP_STATUS } from '../config/ShipConfig';
import { TEAM_COLORS } from '../core/TeamManager';
import AssetLoader from '../assets/AssetLoader';

export class ShipSelectionUI {
    constructor(container, options = {}) {
        this.container = container;
        if (!this.container) {
            console.error('Game container not found');
            return;
        }
        
        this.options = {
            onShipSelect: null,
            isPremium: false,
            ...options
        };

        this.selectedShip = 'scout';
        this.selectedColor = '#00ff00';
        this.previewScene = null;
        this.previewCamera = null;
        this.previewRenderer = null;
        this.currentModel = null;
        
        // Initialize the asset loader
        this.assetLoader = new AssetLoader().setCallbacks(
            (message) => console.log(`Ship Selection: ${message}`),
            (type, error) => console.error(`Ship Selection Error: ${type} - ${error}`)
        );
        
        this.createUI();
        // Add a small delay to ensure DOM is fully ready
        setTimeout(() => {
            this.setupPreview();
            this.loadShipModels();
        }, 100);
    }

    createUI() {
        // Create main container
        this.element = document.createElement('div');
        this.element.className = 'ship-selection';
        this.element.innerHTML = `
            <div class="ship-selection-header">
                <h2>Choose Your Quantum Ship</h2>
                <div class="color-picker">
                    <label>Ship Color:</label>
                    <input type="color" value="${this.selectedColor}">
                </div>
            </div>
            <div class="ships-container">
                <div class="ship-option selected" data-ship="scout">
                    <h3>Scout</h3>
                    <p>Fast and agile, but lightly armored</p>
                    <div class="stats">
                        <div class="stat">
                            <label>Health</label>
                            <div class="stat-bar"><div style="width: 53%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Speed</label>
                            <div class="stat-bar"><div style="width: 100%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Size</label>
                            <div class="stat-bar"><div style="width: 67%"></div></div>
                        </div>
                    </div>
                </div>
                <div class="ship-option" data-ship="interceptor">
                    <h3>Interceptor</h3>
                    <p>Balanced combat vessel</p>
                    <div class="stats">
                        <div class="stat">
                            <label>Health</label>
                            <div class="stat-bar"><div style="width: 80%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Speed</label>
                            <div class="stat-bar"><div style="width: 85%"></div></div>
                        </div>
                        <div class="stat">
                            <label>Size</label>
                            <div class="stat-bar"><div style="width: 75%"></div></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="preview-section">
                <h3>Ship Preview</h3>
                <div id="ship-preview"></div>
            </div>
            <div class="ship-details">
                <div class="ship-name">Scout</div>
                <p class="ship-description">Fast and agile, but lightly armored</p>
                
                <div class="ship-details-left">
                    <div class="stat">
                        <label>Health</label>
                        <div class="stat-bar"><div style="width: 53%"></div></div>
                        <span class="stat-value">53%</span>
                    </div>
                    <div class="stat">
                        <label>Speed</label>
                        <div class="stat-bar"><div style="width: 100%"></div></div>
                        <span class="stat-value">100%</span>
                    </div>
                    <div class="stat">
                        <label>Size</label>
                        <div class="stat-bar"><div style="width: 67%"></div></div>
                        <span class="stat-value">67%</span>
                    </div>
                </div>
                
                <div class="ship-details-right">
                    <div class="special-abilities">
                        <h4>Special Abilities</h4>
                        <div class="ability">Quick Boost</div>
                        <div class="ability">Stealth Mode</div>
                    </div>
                </div>
            </div>
            <button class="launch-button">Launch</button>
        `;

        // Add to container
        this.container.appendChild(this.element);

        // Add class to properly show the UI
        this.element.classList.add('visible');

        // Setup event listeners
        this.setupEventListeners();
    }

    setupPreview() {
        // Get preview container
        this.previewContainer = this.element.querySelector('#ship-preview');
        if (!this.previewContainer) {
            console.error('Preview container not found');
            return;
        }

        // Set initial dimensions
        this.previewContainer.style.width = '100%';
        this.previewContainer.style.height = '150px';

        // Create scene
        this.previewScene = new THREE.Scene();
        this.previewScene.background = new THREE.Color(0x000011);

        // Create camera
        this.previewCamera = new THREE.PerspectiveCamera(
            65,
            this.previewContainer.clientWidth / this.previewContainer.clientHeight,
            0.1,
            1000
        );
        this.previewCamera.position.set(0, 0.3, 2.5);
        this.previewCamera.lookAt(0, 0, 0);

        // Create renderer
        this.previewRenderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true
        });
        this.previewRenderer.setSize(this.previewContainer.clientWidth, this.previewContainer.clientHeight);
        this.previewRenderer.setClearColor(0x000011);
        this.previewContainer.appendChild(this.previewRenderer.domElement);

        // Add lights
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
        this.previewScene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1, 1, 1).normalize();
        this.previewScene.add(directionalLight);

        // Add a grid to help with orientation
        const gridHelper = new THREE.GridHelper(8, 8, 0x333333, 0x222222);
        gridHelper.position.y = -0.5;
        this.previewScene.add(gridHelper);

        // Handle window resize
        window.addEventListener('resize', () => {
            if (this.previewContainer && this.previewCamera && this.previewRenderer) {
                this.previewCamera.aspect = this.previewContainer.clientWidth / this.previewContainer.clientHeight;
                this.previewCamera.updateProjectionMatrix();
                this.previewRenderer.setSize(this.previewContainer.clientWidth, this.previewContainer.clientHeight);
            }
        });

        // Start animation
        this.animate();
    }

    setupEventListeners() {
        // Store bound handlers for cleanup
        this.boundHandleShipSelection = this.handleShipSelection.bind(this);
        this.boundHandleLaunch = this.handleLaunch.bind(this);
        this.boundHandleColorChange = this.handleColorChange.bind(this);
        this.boundHandleResize = this.handleResize.bind(this);
        
        // Ship selection - make sure to use the right selector
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(option => {
            option.addEventListener('click', this.boundHandleShipSelection);
        });
        
        // Launch button
        const launchButton = this.element.querySelector('.launch-button');
        launchButton.addEventListener('click', this.boundHandleLaunch);
        
        // Color picker
        const colorPicker = this.element.querySelector('input[type="color"]');
        colorPicker.addEventListener('change', this.boundHandleColorChange);
        
        // Handle window resize for the preview
        window.addEventListener('resize', this.boundHandleResize);
    }

    selectShip(shipType) {
        this.selectedShip = shipType;
        
        // Update details section
        const details = this.element.querySelector('.ship-details');
        const shipName = details.querySelector('.ship-name');
        const shipDesc = details.querySelector('.ship-description');
        
        const config = this.getShipConfig();
        shipName.textContent = config.name;
        shipDesc.textContent = config.description;
        
        // Update the stats
        const leftSection = details.querySelector('.ship-details-left');
        leftSection.innerHTML = '';
        
        Object.entries(config.stats).forEach(([key, value]) => {
            const percentage = Math.round(value * 100);
            const statElement = document.createElement('div');
            statElement.className = 'stat';
            statElement.innerHTML = `
                <label>${key.charAt(0).toUpperCase() + key.slice(1)}</label>
                <div class="stat-bar"><div style="width: ${percentage}%"></div></div>
                <span class="stat-value">${percentage}%</span>
            `;
            leftSection.appendChild(statElement);
        });
        
        // Update abilities
        const abilitiesContainer = details.querySelector('.special-abilities');
        abilitiesContainer.innerHTML = '<h4>Special Abilities</h4>';
        config.abilities.forEach(ability => {
            const abilityEl = document.createElement('div');
            abilityEl.className = 'ability';
            abilityEl.textContent = ability;
            abilitiesContainer.appendChild(abilityEl);
        });
        
        // Update preview
        this.updatePreview();
    }

    async loadShipModels() {
        try {
            // Load ships using the central AssetLoader
            await this.assetLoader.loadModels();
            console.log('Ship models loaded successfully via AssetLoader');
            
            // Set initial preview
            this.updatePreview();
        } catch (error) {
            console.error('Error loading ship models:', error);
        }
    }

    updatePreview() {
        // Remove current model if it exists
        if (this.currentModel) {
            this.previewScene.remove(this.currentModel);
            this.currentModel = null;
        }

        // Convert selectedShip to the format expected by AssetLoader
        const modelKey = this.selectedShip.toUpperCase();
        
        // Get the model from AssetLoader and clone it
        const model = this.assetLoader.getShipModel(modelKey);
        
        if (model) {
            this.currentModel = model;
            
            // Update material color
            this.currentModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    try {
                        // Clone material to avoid affecting other instances
                        child.material = child.material.clone();
                        
                        // Apply color with safety checks
                        if (child.material.color) {
                            child.material.color = new THREE.Color(this.selectedColor);
                        }
                        
                        if (child.material.emissive) {
                            child.material.emissive = new THREE.Color(this.selectedColor).multiplyScalar(0.3);
                        }
                        
                        child.material.needsUpdate = true;
                    } catch (error) {
                        console.warn('Error setting preview material properties:', error);
                    }
                }
            });

            // Set preview-specific scale
            this.currentModel.scale.set(0.25, 0.25, 0.25);
            this.currentModel.position.set(0, 0, 0);
            this.currentModel.rotation.set(0, 0, 0);

            // Add to scene
            this.previewScene.add(this.currentModel);
        } else {
            console.log('Model not available for preview');
        }
    }

    animate = () => {
        if (!this.previewRenderer || !this.previewScene || !this.previewCamera) {
            return;
        }
        
        requestAnimationFrame(this.animate);

        // Rotate the model if it exists
        if (this.currentModel) {
            this.currentModel.rotation.y += 0.01;
        }

        this.previewRenderer.render(this.previewScene, this.previewCamera);
    }

    getShipConfig() {
        if (this.selectedShip === 'scout') {
            return {
                type: 'fighter',
                name: 'Scout',
                description: 'Fast and agile, but lightly armored',
                stats: {
                    health: 0.53,
                    speed: 1.0,
                    size: 0.67,
                    turnSpeed: 1.0,
                    acceleration: 1.0
                },
                abilities: ['Quick Boost', 'Stealth Mode']
            };
        } else {
            return {
                type: 'experimental',
                name: 'Interceptor',
                description: 'Balanced combat vessel',
                stats: {
                    health: 0.8,
                    speed: 0.85,
                    size: 0.75,
                    turnSpeed: 0.7,
                    acceleration: 0.9
                },
                abilities: ['Shield Generator', 'EMP Burst']
            };
        }
    }

    show() {
        this.element.classList.add('visible');
    }

    hide() {
        this.element.classList.add('hidden');
    }

    updateOptions(newOptions) {
        this.options = {
            ...this.options,
            ...newOptions
        };
    }

    cleanup() {
        // Stop animation loop
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
        }
        
        // Clean up event listeners using the stored bound handlers
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(option => {
            option.removeEventListener('click', this.boundHandleShipSelection);
        });
        
        const launchButton = this.element.querySelector('.launch-button');
        if (launchButton) {
            launchButton.removeEventListener('click', this.boundHandleLaunch);
        }
        
        const colorPicker = this.element.querySelector('input[type="color"]');
        if (colorPicker) {
            colorPicker.removeEventListener('change', this.boundHandleColorChange);
        }
        
        window.removeEventListener('resize', this.boundHandleResize);
        
        // Clean up THREE.js resources
        if (this.previewRenderer) {
            this.previewRenderer.dispose();
        }
        
        if (this.previewScene) {
            // Let Three.js handle most of the cleanup, but we should clear the scene
            this.previewScene = null;
        }
        
        // No need to explicitly dispose of models as they're managed by AssetLoader
        this.previewRenderer = null;
        this.previewCamera = null;
        this.currentModel = null;
    }

    handleShipSelection = (event) => {
        const option = event.currentTarget;
        const shipType = option.dataset.ship;
        console.log(`Selecting ship: ${shipType}`);
        this.selectShip(shipType);
        
        // Update UI to show selected
        const shipOptions = this.element.querySelectorAll('.ship-option');
        shipOptions.forEach(opt => {
            opt.classList.remove('selected');
        });
        option.classList.add('selected');
    }
    
    handleLaunch = () => {
        if (this.selectedShip && this.options.onShipSelect) {
            console.log(`Launching with ship: ${this.selectedShip}`);
            
            // Create selection data in the format the game expects
            const selectionData = {
                type: this.selectedShip.toUpperCase(),
                color: this.selectedColor,
                config: this.getShipConfig()
            };
            
            // Hide UI before calling the callback
            this.hide();
            
            // Clean up resources
            this.cleanup();
            
            // First remove the element from the DOM to prevent any interference
            if (this.element.parentNode) {
                this.element.parentNode.removeChild(this.element);
            }
            
            // Then call the callback with ship selection data
            this.options.onShipSelect(selectionData);
        }
    }
    
    handleColorChange = (event) => {
        this.selectedColor = event.target.value;
        this.updatePreview();
    }
    
    handleResize = () => {
        if (this.previewRenderer && this.previewCamera) {
            const container = this.previewContainer;
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            this.previewCamera.aspect = width / height;
            this.previewCamera.updateProjectionMatrix();
            
            this.previewRenderer.setSize(width, height);
        }
    }
} 
### ./ui/ShipSelectionUI.js END ###

### ./ui/GameRoom.js BEGIN ###
import * as THREE from 'three';

export class GameRoom {
  constructor(scene, size = { width: 60, height: 60 }, theme = 'space-station') {
    this.scene = scene;
    this.size = size;
    this.theme = theme;
    
    // Room properties
    this.roomObjects = [];
    this.obstacles = [];
    this.spawnPoints = [];
    this.coverPoints = [];
    this.roomCenter = new THREE.Vector3(0, 0, 0);
    
    // Generate room
    this.generateRoom();
  }
  
  generateRoom() {
    // Create room floor
    this.createFloor();
    
    // Create room walls
    this.createWalls();
    
    // Add obstacles and cover points
    this.addObstacles();
    
    // Add spawn points
    this.addSpawnPoints();
    
    // Add decorative elements
    this.addDecorations();
  }
  
  createFloor() {
    // Create floor with grid texture
    const floorGeometry = new THREE.PlaneGeometry(this.size.width, this.size.height);
    
    // Create custom shader material for grid effect
    const floorMaterial = new THREE.MeshStandardMaterial({
      color: this.getThemeColors().floor,
      roughness: 0.8,
      metalness: 0.2,
      emissive: this.getThemeColors().floorEmissive,
      emissiveIntensity: 0.1
    });
    
    // Create floor mesh
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.position.set(0, 0, 0);
    this.scene.add(floor);
    this.roomObjects.push(floor);
    
    // Add grid lines
    this.addGridLines();
  }
  
  addGridLines() {
    // Create grid material
    const gridMaterial = new THREE.LineBasicMaterial({ 
      color: this.getThemeColors().grid,
      transparent: true,
      opacity: 0.3
    });
    
    // Create horizontal grid lines
    const gridStep = 5;
    const halfWidth = this.size.width / 2;
    const halfHeight = this.size.height / 2;
    
    const gridHelper = new THREE.GridHelper(
      Math.max(this.size.width, this.size.height), 
      Math.max(this.size.width, this.size.height) / gridStep
    );
    gridHelper.material.opacity = 0.2;
    gridHelper.material.transparent = true;
    gridHelper.position.y = 0.02; // Slightly above floor to prevent z-fighting
    this.scene.add(gridHelper);
    this.roomObjects.push(gridHelper);
  }
  
  createWalls() {
    // Create walls around the room
    const wallHeight = 3;
    const wallThickness = 1;
    
    // Calculate positions
    const halfWidth = this.size.width / 2;
    const halfHeight = this.size.height / 2;
    
    // Get theme wall material
    const wallMaterial = new THREE.MeshStandardMaterial({
      color: this.getThemeColors().wall,
      emissive: this.getThemeColors().wallEmissive,
      emissiveIntensity: 0.5,
      roughness: 0.3,
      metalness: 0.7
    });
    
    // North Wall
    const northWall = new THREE.Mesh(
      new THREE.BoxGeometry(this.size.width + wallThickness * 2, wallHeight, wallThickness),
      wallMaterial
    );
    northWall.position.set(0, wallHeight / 2, -halfHeight - wallThickness/2);
    this.scene.add(northWall);
    this.roomObjects.push(northWall);
    this.obstacles.push({
      type: 'wall',
      position: northWall.position.clone(),
      size: new THREE.Vector3(this.size.width + wallThickness*2, wallHeight, wallThickness)
    });
    
    // South Wall
    const southWall = new THREE.Mesh(
      new THREE.BoxGeometry(this.size.width + wallThickness * 2, wallHeight, wallThickness),
      wallMaterial
    );
    southWall.position.set(0, wallHeight / 2, halfHeight + wallThickness/2);
    this.scene.add(southWall);
    this.roomObjects.push(southWall);
    this.obstacles.push({
      type: 'wall',
      position: southWall.position.clone(),
      size: new THREE.Vector3(this.size.width + wallThickness*2, wallHeight, wallThickness)
    });
    
    // East Wall
    const eastWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, this.size.height + wallThickness * 2),
      wallMaterial
    );
    eastWall.position.set(halfWidth + wallThickness/2, wallHeight / 2, 0);
    this.scene.add(eastWall);
    this.roomObjects.push(eastWall);
    this.obstacles.push({
      type: 'wall',
      position: eastWall.position.clone(),
      size: new THREE.Vector3(wallThickness, wallHeight, this.size.height + wallThickness*2)
    });
    
    // West Wall
    const westWall = new THREE.Mesh(
      new THREE.BoxGeometry(wallThickness, wallHeight, this.size.height + wallThickness * 2),
      wallMaterial
    );
    westWall.position.set(-halfWidth - wallThickness/2, wallHeight / 2, 0);
    this.scene.add(westWall);
    this.roomObjects.push(westWall);
    this.obstacles.push({
      type: 'wall',
      position: westWall.position.clone(),
      size: new THREE.Vector3(wallThickness, wallHeight, this.size.height + wallThickness*2)
    });
  }
  
  addObstacles() {
    // Add between 5-10 random obstacles in the room
    const obstacleCount = 5 + Math.floor(Math.random() * 6);
    
    for (let i = 0; i < obstacleCount; i++) {
      this.addRandomObstacle();
    }
  }
  
  addRandomObstacle() {
    // Types of obstacles: block, cylinder, barrier
    const types = ['block', 'cylinder', 'barrier'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random position in the room
    const halfWidth = this.size.width / 2 - 5; // Stay away from walls
    const halfHeight = this.size.height / 2 - 5;
    
    const x = (Math.random() * 2 - 1) * halfWidth;
    const z = (Math.random() * 2 - 1) * halfHeight;
    
    // Random size
    const width = 2 + Math.random() * 5;
    const height = 1 + Math.random() * 2;
    const depth = 2 + Math.random() * 5;
    
    // Create obstacle based on type
    let mesh;
    let obstacleData = {
      type: 'obstacle',
      position: new THREE.Vector3(x, height/2, z)
    };
    
    switch (type) {
      case 'block':
        const blockGeometry = new THREE.BoxGeometry(width, height, depth);
        const blockMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.5,
          metalness: 0.5
        });
        mesh = new THREE.Mesh(blockGeometry, blockMaterial);
        mesh.position.set(x, height/2, z);
        obstacleData.size = new THREE.Vector3(width, height, depth);
        break;
        
      case 'cylinder':
        const radius = width / 2;
        const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, height, 16);
        const cylinderMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.5,
          metalness: 0.5
        });
        mesh = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
        mesh.position.set(x, height/2, z);
        obstacleData.radius = radius;
        obstacleData.height = height;
        break;
        
      case 'barrier':
        const barrierGeometry = new THREE.BoxGeometry(width, height, 0.5);
        const barrierMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().obstacle,
          emissive: this.getThemeColors().obstacleEmissive,
          emissiveIntensity: 0.4,
          roughness: 0.3,
          metalness: 0.7,
          transparent: true,
          opacity: 0.8
        });
        mesh = new THREE.Mesh(barrierGeometry, barrierMaterial);
        mesh.position.set(x, height/2, z);
        
        // Random rotation
        mesh.rotation.y = Math.random() * Math.PI * 2;
        
        obstacleData.size = new THREE.Vector3(width, height, 0.5);
        obstacleData.rotation = mesh.rotation.clone();
        break;
    }
    
    this.scene.add(mesh);
    this.roomObjects.push(mesh);
    this.obstacles.push(obstacleData);
    
    // Add a cover point near this obstacle
    this.coverPoints.push(new THREE.Vector3(
      x + (Math.random() - 0.5) * 3,
      0,
      z + (Math.random() - 0.5) * 3
    ));
  }
  
  addSpawnPoints() {
    // Add spawn points in the corners
    const halfWidth = this.size.width / 2 - 8;
    const halfHeight = this.size.height / 2 - 8;
    
    // Four corners
    this.spawnPoints.push(
      new THREE.Vector3(-halfWidth, 0, -halfHeight),
      new THREE.Vector3(halfWidth, 0, -halfHeight),
      new THREE.Vector3(-halfWidth, 0, halfHeight),
      new THREE.Vector3(halfWidth, 0, halfHeight)
    );
    
    // Add a few more random spawn points
    for (let i = 0; i < 4; i++) {
      const x = (Math.random() * 2 - 1) * halfWidth;
      const z = (Math.random() * 2 - 1) * halfHeight;
      this.spawnPoints.push(new THREE.Vector3(x, 0, z));
    }
  }
  
  addDecorations() {
    // Add decorative elements based on theme
    const decorationCount = 10 + Math.floor(Math.random() * 10);
    
    // Add lights around the room
    for (let i = 0; i < decorationCount; i++) {
      this.addRandomDecoration();
    }
    
    // Add room lights
    this.addRoomLights();
  }
  
  addRandomDecoration() {
    // Types of decorations: console, crate, panel
    const types = ['console', 'crate', 'panel'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    // Random position near walls
    const halfWidth = this.size.width / 2 - 2;
    const halfHeight = this.size.height / 2 - 2;
    
    let x, z;
    const nearWall = Math.random() > 0.5;
    
    if (nearWall) {
      // Position near a wall
      if (Math.random() > 0.5) {
        // Near east/west wall
        x = (Math.random() > 0.5 ? 1 : -1) * halfWidth;
        z = (Math.random() * 2 - 1) * halfHeight;
      } else {
        // Near north/south wall
        x = (Math.random() * 2 - 1) * halfWidth;
        z = (Math.random() > 0.5 ? 1 : -1) * halfHeight;
      }
    } else {
      // Random position
      x = (Math.random() * 2 - 1) * halfWidth;
      z = (Math.random() * 2 - 1) * halfHeight;
    }
    
    // Create decoration based on type
    let mesh;
    
    switch (type) {
      case 'console':
        const consoleGeometry = new THREE.BoxGeometry(2, 1, 1);
        const consoleMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().console,
          emissive: this.getThemeColors().consoleEmissive,
          emissiveIntensity: 0.5,
          roughness: 0.3,
          metalness: 0.8
        });
        mesh = new THREE.Mesh(consoleGeometry, consoleMaterial);
        
        // Add a light on top
        const consoleLight = new THREE.PointLight(
          this.getThemeColors().consoleLight, 
          0.5, 
          5
        );
        consoleLight.position.set(0, 1, 0);
        mesh.add(consoleLight);
        break;
        
      case 'crate':
        const crateGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const crateMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().crate,
          roughness: 0.7,
          metalness: 0.2
        });
        mesh = new THREE.Mesh(crateGeometry, crateMaterial);
        break;
        
      case 'panel':
        const panelGeometry = new THREE.PlaneGeometry(2, 1.5);
        const panelMaterial = new THREE.MeshStandardMaterial({
          color: this.getThemeColors().panel,
          emissive: this.getThemeColors().panelEmissive,
          emissiveIntensity: 0.3,
          roughness: 0.4,
          metalness: 0.6,
          side: THREE.DoubleSide
        });
        mesh = new THREE.Mesh(panelGeometry, panelMaterial);
        
        // Orient towards center
        mesh.lookAt(this.roomCenter);
        // Adjust to be vertical
        mesh.rotation.x = 0;
        break;
    }
    
    mesh.position.set(x, 0.75, z);
    this.scene.add(mesh);
    this.roomObjects.push(mesh);
  }
  
  addRoomLights() {
    // Ambient light for the room
    const ambientLight = new THREE.AmbientLight(0x222233, 0.5);
    this.scene.add(ambientLight);
    this.roomObjects.push(ambientLight);
    
    // Add main overhead light
    const mainLight = new THREE.PointLight(
      this.getThemeColors().mainLight, 
      1, 
      100
    );
    mainLight.position.set(0, 15, 0);
    this.scene.add(mainLight);
    this.roomObjects.push(mainLight);
    
    // Add accent lights in corners
    const cornerLightPositions = [
      new THREE.Vector3(-this.size.width / 3, 5, -this.size.height / 3),
      new THREE.Vector3(this.size.width / 3, 5, -this.size.height / 3),
      new THREE.Vector3(-this.size.width / 3, 5, this.size.height / 3),
      new THREE.Vector3(this.size.width / 3, 5, this.size.height / 3)
    ];
    
    for (const position of cornerLightPositions) {
      const cornerLight = new THREE.PointLight(
        this.getThemeColors().accentLight,
        0.6,
        30
      );
      cornerLight.position.copy(position);
      this.scene.add(cornerLight);
      this.roomObjects.push(cornerLight);
    }
  }
  
  getRandomSpawnPoint() {
    if (this.spawnPoints.length === 0) return new THREE.Vector3(0, 0, 0);
    return this.spawnPoints[Math.floor(Math.random() * this.spawnPoints.length)].clone();
  }
  
  /**
   * Get all obstacles in the room, including walls and other objects
   * @returns {Array} Array of obstacles with position and size/radius information
   */
  getObstacles() {
    const obstacles = [];
    
    // Add walls
    if (this.walls && this.walls.length > 0) {
      obstacles.push(...this.walls.map(wall => ({
        type: 'wall',
        position: wall.position.clone(),
        size: wall.size ? { x: wall.size.x, y: wall.size.y, z: wall.size.z } : { x: 1, y: 1, z: 1 },
        rotation: wall.rotation ? wall.rotation.clone() : new THREE.Euler()
      })));
    }
    
    // Add other obstacles like pillars, etc.
    if (this.obstacles && this.obstacles.length > 0) {
      obstacles.push(...this.obstacles.map(obstacle => {
        if (obstacle.geometry && obstacle.geometry.type.includes('Cylinder')) {
          // Cylindrical obstacles
          return {
            type: 'cylinder',
            position: obstacle.position.clone(),
            radius: obstacle.geometry.parameters?.radiusTop || 1,
            height: obstacle.geometry.parameters?.height || 2
          };
        } else {
          // Box obstacles
          return {
            type: 'box',
            position: obstacle.position.clone(),
            size: {
              x: obstacle.scale.x,
              y: obstacle.scale.y,
              z: obstacle.scale.z
            },
            rotation: obstacle.rotation.clone()
          };
        }
      }));
    }
    
    // Add environmental hazards if they exist
    if (this.hazards && this.hazards.length > 0) {
      obstacles.push(...this.hazards.map(hazard => ({
        type: 'hazard',
        position: hazard.position.clone(),
        radius: hazard.radius || 1,
        damage: hazard.damage || 10
      })));
    }
    
    return obstacles;
  }
  
  cleanup() {
    // Remove all room objects from the scene
    for (const object of this.roomObjects) {
      this.scene.remove(object);
      
      // Dispose geometries and materials
      if (object.geometry) {
        object.geometry.dispose();
      }
      
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    }
    
    // Clear arrays
    this.roomObjects = [];
    this.obstacles = [];
    this.spawnPoints = [];
    this.coverPoints = [];
  }
  
  getThemeColors() {
    // Return colors based on room theme
    switch(this.theme) {
      case 'alien-hive':
        return {
          floor: 0x112211,
          floorEmissive: 0x224422,
          wall: 0x336633,
          wallEmissive: 0x44ff44,
          grid: 0x33ff33,
          obstacle: 0x225522,
          obstacleEmissive: 0x33ff33,
          console: 0x336633,
          consoleEmissive: 0x44ff66,
          consoleLight: 0x66ff66,
          crate: 0x225522,
          panel: 0x112211,
          panelEmissive: 0x33ff33,
          mainLight: 0x33ff33,
          accentLight: 0x66ff66
        };
      case 'neon-city':
        return {
          floor: 0x000011,
          floorEmissive: 0x000033,
          wall: 0x110022,
          wallEmissive: 0xff00ff,
          grid: 0x0088ff,
          obstacle: 0x220033,
          obstacleEmissive: 0xff00ff,
          console: 0x330044,
          consoleEmissive: 0xff00ff,
          consoleLight: 0xff00ff,
          crate: 0x110022,
          panel: 0x220044,
          panelEmissive: 0xff00aa,
          mainLight: 0xffffff,
          accentLight: 0xff00ff
        };
      case 'space-station':
      default:
        return {
          floor: 0x111122,
          floorEmissive: 0x0000ff,
          wall: 0x334455,
          wallEmissive: 0x0088ff,
          grid: 0x0088ff,
          obstacle: 0x334455,
          obstacleEmissive: 0x0088ff,
          console: 0x223344,
          consoleEmissive: 0x00ffff,
          consoleLight: 0x00ffff,
          crate: 0x445566,
          panel: 0x223344,
          panelEmissive: 0x0088ff,
          mainLight: 0xaaccff,
          accentLight: 0x0088ff
        };
    }
  }
} 
### ./ui/GameRoom.js END ###

### ./ui/GameUI.js BEGIN ###
/**
 * GameUI class for handling all game UI elements
 */
export class GameUI {
  constructor() {
    this.uiContainer = null;
    this.controlsInfo = null;
    this.healthBar = null;
    this.energyBar = null;
    this.weaponIndicator = null;

    this.createUI();
  }

  /**
   * Create all UI elements
   */
  createUI() {
    // Remove existing controls-info if it exists
    const oldControls = document.querySelector('.controls-info');
    if (oldControls) {
      oldControls.remove();
    }

    // Create main UI container
    this.uiContainer = document.createElement('div');
    this.uiContainer.className = 'game-ui';
    this.uiContainer.id = 'game-ui';
    document.body.appendChild(this.uiContainer);

    // Create status bars container
    const statusBars = document.createElement('div');
    statusBars.className = 'status-bars';
    this.uiContainer.appendChild(statusBars);

    // Create health bar
    const healthBarContainer = document.createElement('div');
    healthBarContainer.className = 'bar-container health-bar-container';
    statusBars.appendChild(healthBarContainer);

    const healthLabel = document.createElement('div');
    healthLabel.className = 'bar-label';
    healthLabel.innerHTML = '❤️'; // Heart emoji for health
    healthBarContainer.appendChild(healthLabel);

    const healthBarOuter = document.createElement('div');
    healthBarOuter.className = 'bar-outer';
    healthBarContainer.appendChild(healthBarOuter);

    this.healthBar = document.createElement('div');
    this.healthBar.className = 'bar-inner health-bar';
    healthBarOuter.appendChild(this.healthBar);

    // Create health percentage display
    this.healthPercentage = document.createElement('div');
    this.healthPercentage.className = 'bar-percentage';
    this.healthPercentage.textContent = '100%';
    healthBarContainer.appendChild(this.healthPercentage);

    // Create energy bar
    const energyBarContainer = document.createElement('div');
    energyBarContainer.className = 'bar-container energy-bar-container';
    statusBars.appendChild(energyBarContainer);

    const energyLabel = document.createElement('div');
    energyLabel.className = 'bar-label';
    energyLabel.innerHTML = '⚡'; // Lightning emoji for energy
    energyBarContainer.appendChild(energyLabel);

    const energyBarOuter = document.createElement('div');
    energyBarOuter.className = 'bar-outer';
    energyBarContainer.appendChild(energyBarOuter);

    this.energyBar = document.createElement('div');
    this.energyBar.className = 'bar-inner energy-bar';
    energyBarOuter.appendChild(this.energyBar);

    // Create energy percentage display
    this.energyPercentage = document.createElement('div');
    this.energyPercentage.className = 'bar-percentage';
    this.energyPercentage.textContent = '100%';
    energyBarContainer.appendChild(this.energyPercentage);

    // Create weapon indicator
    this.weaponIndicator = document.createElement('div');
    this.weaponIndicator.className = 'weapon-indicator';
    this.uiContainer.appendChild(this.weaponIndicator);

    const weaponLabel = document.createElement('div');
    weaponLabel.className = 'weapon-label';
    weaponLabel.textContent = '🔫';  // Weapon emoji
    this.weaponIndicator.appendChild(weaponLabel);

    this.weaponName = document.createElement('div');
    this.weaponName.className = 'weapon-name laser';
    this.weaponName.textContent = 'LASER';
    this.weaponIndicator.appendChild(this.weaponName);

    // Initially hide the UI
    this.uiContainer.classList.add('hidden');
  }

  /**
   * Show the UI
   */
  show() {
    if (this.uiContainer) {
      this.uiContainer.classList.remove('hidden');
      this.uiContainer.style.display = 'flex';
      this.uiContainer.style.opacity = '1';
    }
  }

  /**
   * Hide the UI
   */
  hide() {
    if (this.uiContainer) {
      this.uiContainer.classList.add('hidden');
      this.uiContainer.style.display = 'none';
      this.uiContainer.style.opacity = '0';
    }
  }

  /**
   * Update health bar
   * @param {number} health - Current health value
   * @param {number} maxHealth - Maximum health value
   */
  updateHealth(health, maxHealth) {
    const percentage = (health / maxHealth) * 100;
    this.healthBar.style.width = `${percentage}%`;

    // Change color based on health level
    if (percentage < 30) {
      this.healthBar.classList.add('critical');
    } else if (percentage < 60) {
      this.healthBar.classList.remove('critical');
      this.healthBar.classList.add('warning');
    } else {
      this.healthBar.classList.remove('critical', 'warning');
    }

    this.healthPercentage.textContent = `${percentage.toFixed(0)}%`;
  }

  /**
   * Update energy bar
   * @param {number} energy - Current energy value
   * @param {number} maxEnergy - Maximum energy value
   */
  updateEnergy(energy, maxEnergy) {
    const percentage = (energy / maxEnergy) * 100;
    this.energyBar.style.width = `${percentage}%`;

    // Change color based on energy level
    if (percentage < 30) {
      this.energyBar.classList.add('critical');
    } else if (percentage < 60) {
      this.energyBar.classList.remove('critical');
      this.energyBar.classList.add('warning');
    } else {
      this.energyBar.classList.remove('critical', 'warning');
    }

    this.energyPercentage.textContent = `${percentage.toFixed(0)}%`;
  }

  /**
   * Update weapon indicator
   * @param {string} weaponName - Name of the current weapon
   */
  updateWeapon(weaponName) {
    this.weaponName.textContent = weaponName;

    // Remove all weapon classes
    this.weaponName.classList.remove('laser', 'grenade', 'bounce');

    // Add the appropriate class for styling
    switch(weaponName.toLowerCase()) {
      case 'laser':
        this.weaponName.classList.add('laser');
        break;
      case 'grenade':
        this.weaponName.classList.add('grenade');
        break;
      case 'bounce':
        this.weaponName.classList.add('bounce');
        break;
    }
  }
} 
### ./ui/GameUI.js END ###

### ./ui/MiniMap.js BEGIN ###
/**
 * MiniMap class for displaying a top-down radar view of the game
 */
export class MiniMap {
  constructor(game) {
    this.game = game;
    this.visible = true;
    this.container = null;
    this.canvas = null;
    this.ctx = null;
    this.mapScale = 15; // Scale factor for map (pixels per world unit)
    
    // Scale factor for converting world coordinates to mini-map coordinates
    this.scale = 0.08;
    
    // Mini-map center offset in pixels
    this.offsetX = 0;
    this.offsetY = 0;
    
    this.createMiniMap();
  }
  
  /**
   * Create the mini-map UI
   */
  createMiniMap() {
    this.container = document.createElement('div');
    this.container.className = 'mini-map-container';
    document.body.appendChild(this.container);
    
    // Create mini-map area
    const miniMap = document.createElement('div');
    miniMap.className = 'mini-map';
    this.container.appendChild(miniMap);
    
    // Add subtle M key hint
    const hint = document.createElement('div');
    hint.className = 'mini-map-hint';
    hint.textContent = 'M';
    this.container.appendChild(hint);
    
    // Create canvas for drawing
    this.canvas = document.createElement('canvas');
    this.canvas.width = 300;
    this.canvas.height = 300;
    miniMap.appendChild(this.canvas);
    this.ctx = this.canvas.getContext('2d');
    
    // Calculate center offset
    this.offsetX = this.canvas.width / 2;
    this.offsetY = this.canvas.height / 2;
  }
  
  /**
   * Update the mini-map with current game state
   */
  update() {
    if (!this.visible || !this.ctx || !this.game.playerShip) return;
    
    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw background
    this.ctx.fillStyle = 'rgba(0, 20, 40, 0.2)';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Draw grid lines
    this.drawGridLines();
    
    // Draw objects from infinite map
    this.drawObjects();
    
    // Draw player
    this.drawPlayer();
    
    // Draw enemies (if any exist)
    if (this.game.enemies) {
      this.drawEnemies();
    }
  }
  
  /**
   * Draw grid lines on mini-map
   */
  drawGridLines() {
    const gridSize = 10; // World units
    const gridLines = 20; // Number of grid lines in each direction
    
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
    this.ctx.lineWidth = 0.5;
    
    // Get player position
    const playerX = this.game.playerShip.position.x;
    const playerZ = this.game.playerShip.position.z;
    
    const startX = Math.floor(playerX / gridSize) * gridSize - (gridLines * gridSize / 2);
    const startZ = Math.floor(playerZ / gridSize) * gridSize - (gridLines * gridSize / 2);
    
    // Draw vertical lines
    for (let i = 0; i <= gridLines; i++) {
      const worldX = startX + i * gridSize;
      const mapX = this.worldToMapX(worldX);
      
      this.ctx.beginPath();
      this.ctx.moveTo(mapX, 0);
      this.ctx.lineTo(mapX, this.canvas.height);
      this.ctx.stroke();
    }
    
    // Draw horizontal lines
    for (let i = 0; i <= gridLines; i++) {
      const worldZ = startZ + i * gridSize;
      const mapY = this.worldToMapY(worldZ);
      
      this.ctx.beginPath();
      this.ctx.moveTo(0, mapY);
      this.ctx.lineTo(this.canvas.width, mapY);
      this.ctx.stroke();
    }
  }
  
  /**
   * Draw objects from infinite map chunks
   */
  drawObjects() {
    if (!this.game.infiniteMap) return;
    
    // Get nearby chunks
    const playerPos = this.game.playerShip.position;
    const currentKey = this.game.infiniteMap.getChunkKey(playerPos.x, playerPos.z);
    const nearbyChunks = this.game.infiniteMap.getNearbyChunks(currentKey);
    
    // Draw objects from each chunk
    for (const chunk of nearbyChunks) {
      for (const object of chunk.objects) {
        // Get object position
        const x = object.position.x;
        const z = object.position.z;
        
        // Convert to mini-map coordinates
        const mapX = this.worldToMapX(x);
        const mapY = this.worldToMapY(z);
        
        // Set color based on object type
        switch (object.type) {
          case 'flora':
            this.ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
            break;
          case 'rocks':
            this.ctx.fillStyle = 'rgba(128, 128, 128, 0.7)';
            break;
          case 'objects':
            this.ctx.fillStyle = 'rgba(255, 69, 0, 0.7)';
            break;
          default:
            this.ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        }
        
        // Draw object dot
        this.ctx.beginPath();
        this.ctx.arc(mapX, mapY, object.radius * this.scale, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }
  }
  
  /**
   * Draw player on mini-map
   */
  drawPlayer() {
    // Get player position
    const x = this.game.playerShip.position.x;
    const z = this.game.playerShip.position.z;
    
    // Convert to mini-map coordinates
    const mapX = this.worldToMapX(x);
    const mapY = this.worldToMapY(z);
    
    // Draw player direction cone
    this.drawPlayerDirection(mapX, mapY);
    
    // Draw player dot
    this.ctx.fillStyle = '#00ffff';
    this.ctx.beginPath();
    this.ctx.arc(mapX, mapY, 3, 0, Math.PI * 2);
    this.ctx.fill();
    
    // Draw player glow
    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
    this.ctx.lineWidth = 1;
    this.ctx.beginPath();
    this.ctx.arc(mapX, mapY, 5, 0, Math.PI * 2);
    this.ctx.stroke();
  }
  
  /**
   * Draw player direction indicator
   */
  drawPlayerDirection(mapX, mapY) {
    // Get player rotation
    const angle = this.game.playerShip.rotation.y;
    
    // Draw direction indicator
    this.ctx.save();
    this.ctx.translate(mapX, mapY);
    this.ctx.rotate(-angle); // Negative because z-axis is inverted
    
    // Draw triangular direction indicator
    this.ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
    this.ctx.beginPath();
    this.ctx.moveTo(0, -10); // Pointing up
    this.ctx.lineTo(-5, 0);
    this.ctx.lineTo(5, 0);
    this.ctx.closePath();
    this.ctx.fill();
    
    this.ctx.restore();
  }
  
  /**
   * Draw enemies on mini-map
   */
  drawEnemies() {
    this.ctx.fillStyle = '#ff3333';
    
    for (const enemy of this.game.enemies) {
      // Get position
      const x = enemy.position.x;
      const z = enemy.position.z;
      
      // Convert to mini-map coordinates
      const mapX = this.worldToMapX(x);
      const mapY = this.worldToMapY(z);
      
      // Draw enemy dot
      this.ctx.beginPath();
      this.ctx.arc(mapX, mapY, 2, 0, Math.PI * 2);
      this.ctx.fill();
    }
  }
  
  /**
   * Convert world X coordinate to mini-map X coordinate
   */
  worldToMapX(x) {
    // Get player position
    const playerX = this.game.playerShip.position.x;
    
    // Apply scale and center on player
    return this.offsetX + (x - playerX) * this.scale;
  }
  
  /**
   * Convert world Z coordinate to mini-map Y coordinate
   */
  worldToMapY(z) {
    // Get player position
    const playerZ = this.game.playerShip.position.z;
    
    // Apply scale and center on player (note the negation since Z goes forward)
    return this.offsetY + (z - playerZ) * this.scale;
  }
  
  /**
   * Toggle mini-map visibility
   */
  toggle() {
    this.visible = !this.visible;
    
    if (this.visible) {
      this.show();
    } else {
      this.hide();
    }
  }
  
  /**
   * Show mini-map
   */
  show() {
    this.container.classList.remove('hidden');
    this.visible = true;
  }
  
  /**
   * Hide mini-map
   */
  hide() {
    this.container.classList.add('hidden');
    this.visible = false;
  }
} 
### ./ui/MiniMap.js END ###

### ./scenes/TeamDemo.js BEGIN ###
import * as THREE from 'three';
import { TeamManager, GAME_MODES } from '../core/TeamManager';
import { Enemy } from '../entities/enemies/Enemy';
import { Player } from '../entities/player/Player';

export class TeamDemo {
    constructor(scene, options = {}) {
        this.scene = scene;
        this.options = {
            gameMode: GAME_MODES.TEAM_VS_TEAM,
            playerCount: 2,
            enemyCount: 4,
            ...options
        };

        // Initialize team manager
        this.teamManager = new TeamManager(this.options.gameMode);
        
        // Initialize collections
        this.players = new Map();
        this.enemies = new Map();
        
        // Setup demo
        this.setupDemo();
    }

    setupDemo() {
        // Create players
        for (let i = 0; i < this.options.playerCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                1,
                (Math.random() - 0.5) * 20
            );
            
            const player = new Player(this.scene, position);
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`player${i}`);
            
            player.setTeam(teamId, color);
            this.players.set(`player${i}`, player);
            
            // Log player creation
            console.log(`Created player ${i} on team ${teamId} with color ${color.toString(16)}`);
        }

        // Create enemies
        for (let i = 0; i < this.options.enemyCount; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 20,
                1,
                (Math.random() - 0.5) * 20
            );
            
            const enemyType = ['BASIC', 'HUNTER', 'PATROLLER'][Math.floor(Math.random() * 3)];
            const enemy = new Enemy(this.scene, position, {
                type: enemyType,
                shipModel: ['STANDARD', 'INTERCEPTOR', 'HEAVY', 'SCOUT'][Math.floor(Math.random() * 4)]
            });
            
            // Assign to a random team
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`enemy${i}`);
            enemy.setTeam(teamId, color);
            
            this.enemies.set(`enemy${i}`, enemy);
            
            // Log enemy creation
            console.log(`Created ${enemyType} enemy ${i} on team ${teamId} with color ${color.toString(16)}`);
        }
    }

    update(deltaTime) {
        // Convert players to array for enemy targeting
        const playerArray = Array.from(this.players.values());
        
        // Update all entities
        this.players.forEach(player => {
            if (player.isActive) {
                player.update(deltaTime);
            }
        });

        this.enemies.forEach(enemy => {
            if (enemy.isActive) {
                enemy.update(deltaTime, playerArray, []);
            }
        });
    }

    handleCollisions() {
        // Check collisions between all active entities
        const activeEntities = [
            ...Array.from(this.players.values()).filter(p => p.isActive),
            ...Array.from(this.enemies.values()).filter(e => e.isActive)
        ];

        for (let i = 0; i < activeEntities.length; i++) {
            for (let j = i + 1; j < activeEntities.length; j++) {
                const entity1 = activeEntities[i];
                const entity2 = activeEntities[j];

                // Skip collision check if entities are on the same team
                if (this.teamManager.arePlayersOnSameTeam(entity1.teamId, entity2.teamId)) {
                    continue;
                }

                // Simple distance-based collision
                const distance = entity1.mesh.position.distanceTo(entity2.mesh.position);
                const minDistance = entity1.options.size + entity2.options.size;

                if (distance < minDistance) {
                    // Handle collision
                    entity1.takeDamage(10);
                    entity2.takeDamage(10);
                }
            }
        }
    }

    getTeamScores() {
        return this.teamManager.getTeamScores();
    }

    setGameMode(mode) {
        this.options.gameMode = mode;
        this.teamManager.setGameMode(mode);
        
        // Reassign all entities to teams
        this.players.forEach((player, id) => {
            const { teamId, color } = this.teamManager.assignPlayerToTeam(id);
            player.setTeam(teamId, color);
        });

        this.enemies.forEach((enemy, id) => {
            const { teamId, color } = this.teamManager.assignPlayerToTeam(id);
            enemy.setTeam(teamId, color);
        });
    }
} 
### ./scenes/TeamDemo.js END ###

### ./core/Game.js BEGIN ###
import { GameEngine } from './GameEngine';
import { GameUI } from '../ui/GameUI';
import { MiniMap } from '../ui/MiniMap';
import { GAME_CONFIG } from '../config/GameConfig';
import * as THREE from 'three';
import { TeamManager, GAME_MODES } from './TeamManager';
import { ShipSelectionUI } from '../ui/ShipSelectionUI';
import { Player } from '../entities/player/Player';
import { Enemy } from '../entities/enemies/Enemy';

export class Game {
    constructor(container, options = {}) {
        this.container = container;
        this.options = {
            gameMode: GAME_MODES.FREE_FOR_ALL,
            isPremium: false,
            ...options
        };

        // Initialize core components
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Setup renderer
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.container.appendChild(this.renderer.domElement);

        // Initialize managers
        this.teamManager = new TeamManager(this.options.gameMode);
        
        // Game state
        this.isRunning = false;
        this.entities = new Map();
        
        // Setup window resize handler
        window.addEventListener('resize', () => this.handleResize());
        
        // Initialize ship selection
        this.initShipSelection();
    }

    initShipSelection() {
        this.shipSelection = new ShipSelectionUI(this.container, {
            isPremium: this.options.isPremium,
            onShipSelect: (selection) => this.startGame(selection)
        });
    }

    startGame(playerSelection) {
        // Hide ship selection
        this.shipSelection.hide();
        
        // Create player
        const player = new Player(this.scene, new THREE.Vector3(0, 0, 0), {
            ...playerSelection.config.stats,
            shipModel: playerSelection.config.model
        });

        // Assign team/color in FFA mode
        const { teamId } = this.teamManager.assignPlayerToTeam('player1');
        player.setTeam(teamId, parseInt(playerSelection.color.replace(/[^\d,]/g, '').split(',').map(x => parseInt(x)).join('')));

        // Store player
        this.entities.set('player1', player);

        // Add some AI players for testing
        this.addAIPlayers(5);

        // Start game loop
        this.isRunning = true;
        this.animate();
    }

    addAIPlayers(count) {
        for (let i = 0; i < count; i++) {
            const position = new THREE.Vector3(
                (Math.random() - 0.5) * 40,
                0,
                (Math.random() - 0.5) * 40
            );

            const enemy = new Enemy(this.scene, position, {
                type: Math.random() > 0.5 ? 'HUNTER' : 'PATROLLER',
                shipModel: ['SCOUT', 'INTERCEPTOR', 'STANDARD'][Math.floor(Math.random() * 3)]
            });

            // Assign team/color
            const { teamId, color } = this.teamManager.assignPlayerToTeam(`ai${i}`);
            enemy.setTeam(teamId, color);

            // Store enemy
            this.entities.set(`ai${i}`, enemy);
        }
    }

    animate() {
        if (!this.isRunning) return;

        requestAnimationFrame(() => this.animate());

        const deltaTime = 16; // Assuming 60fps for now
        
        // Update all entities
        const playerArray = Array.from(this.entities.values());
        this.entities.forEach(entity => {
            if (entity instanceof Enemy) {
                entity.update(deltaTime, playerArray, []);
            } else {
                entity.update(deltaTime);
            }
        });

        // Handle collisions
        this.handleCollisions();

        // Render
        this.renderer.render(this.scene, this.camera);
    }

    handleCollisions() {
        const entities = Array.from(this.entities.values()).filter(e => e.isActive);

        for (let i = 0; i < entities.length; i++) {
            for (let j = i + 1; j < entities.length; j++) {
                const entity1 = entities[i];
                const entity2 = entities[j];

                // Skip collision check if entities are on the same team
                if (this.teamManager.arePlayersOnSameTeam(entity1.teamId, entity2.teamId)) {
                    continue;
                }

                // Simple distance-based collision
                const distance = entity1.mesh.position.distanceTo(entity2.mesh.position);
                const minDistance = entity1.options.size + entity2.options.size;

                if (distance < minDistance) {
                    entity1.takeDamage(10);
                    entity2.takeDamage(10);
                }
            }
        }
    }

    handleResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;

        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
    }

    destroy() {
        this.isRunning = false;
        
        // Clean up entities
        this.entities.forEach(entity => entity.destroy());
        this.entities.clear();

        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);

        // Clean up THREE.js resources
        this.scene.traverse(object => {
            if (object.geometry) object.geometry.dispose();
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });

        // Remove renderer
        this.renderer.dispose();
        this.container.removeChild(this.renderer.domElement);
    }
} 
### ./core/Game.js END ###

### ./core/TeamManager.js BEGIN ###
export const TEAM_COLORS = {
    RED: 0xff0000,
    BLUE: 0x0000ff,
    YELLOW: 0xffff00,
    GREEN: 0x00ff00,
    PURPLE: 0x800080,
    CYAN: 0x00ffff,
    ORANGE: 0xffa500,
    PINK: 0xff69b4
};

export const GAME_MODES = {
    FREE_FOR_ALL: 'FFA',
    TEAM_VS_TEAM: 'TVT',
    MULTI_TEAM: 'MT'
};

export class TeamManager {
    constructor(gameMode = GAME_MODES.FREE_FOR_ALL) {
        this.gameMode = gameMode;
        this.teams = new Map();
        this.playerTeams = new Map();
        this.teamColors = new Map();
        this.nextTeamId = 1;
        this.usedColors = new Set();
        
        // Initialize default team configurations
        this.initializeTeams();
    }

    initializeTeams() {
        switch (this.gameMode) {
            case GAME_MODES.TEAM_VS_TEAM:
                this.createTeam('RED', TEAM_COLORS.RED);
                this.createTeam('BLUE', TEAM_COLORS.BLUE);
                break;
            case GAME_MODES.MULTI_TEAM:
                this.createTeam('RED', TEAM_COLORS.RED);
                this.createTeam('BLUE', TEAM_COLORS.BLUE);
                this.createTeam('YELLOW', TEAM_COLORS.YELLOW);
                this.createTeam('GREEN', TEAM_COLORS.GREEN);
                break;
            case GAME_MODES.FREE_FOR_ALL:
                // Teams will be created dynamically as players join
                break;
        }
    }

    createTeam(name, color) {
        const teamId = this.nextTeamId++;
        this.teams.set(teamId, {
            id: teamId,
            name,
            color,
            players: new Set(),
            score: 0
        });
        this.teamColors.set(teamId, color);
        this.usedColors.add(color);
        return teamId;
    }

    generateUniqueColor() {
        const availableColors = Object.values(TEAM_COLORS)
            .filter(color => !this.usedColors.has(color));

        if (availableColors.length > 0) {
            return availableColors[Math.floor(Math.random() * availableColors.length)];
        }

        // If all predefined colors are used, generate a random color
        return Math.floor(Math.random() * 0xffffff);
    }

    assignPlayerToTeam(playerId, preferredTeamId = null) {
        if (this.gameMode === GAME_MODES.FREE_FOR_ALL) {
            // In FFA, each player gets their own team
            const color = this.generateUniqueColor();
            const teamId = this.createTeam(`Player ${playerId}`, color);
            this.playerTeams.set(playerId, teamId);
            this.teams.get(teamId).players.add(playerId);
            return { teamId, color };
        }

        if (preferredTeamId && this.teams.has(preferredTeamId)) {
            const team = this.teams.get(preferredTeamId);
            team.players.add(playerId);
            this.playerTeams.set(playerId, preferredTeamId);
            return { teamId: preferredTeamId, color: team.color };
        }

        // Auto-balance teams
        let smallestTeam = null;
        let smallestSize = Infinity;

        for (const [teamId, team] of this.teams) {
            if (team.players.size < smallestSize) {
                smallestTeam = team;
                smallestSize = team.players.size;
            }
        }

        if (smallestTeam) {
            smallestTeam.players.add(playerId);
            this.playerTeams.set(playerId, smallestTeam.id);
            return { teamId: smallestTeam.id, color: smallestTeam.color };
        }

        throw new Error('No teams available for assignment');
    }

    removePlayer(playerId) {
        const teamId = this.playerTeams.get(playerId);
        if (teamId) {
            const team = this.teams.get(teamId);
            if (team) {
                team.players.delete(playerId);
                // In FFA mode, remove empty teams
                if (this.gameMode === GAME_MODES.FREE_FOR_ALL && team.players.size === 0) {
                    this.teams.delete(teamId);
                    this.teamColors.delete(teamId);
                }
            }
            this.playerTeams.delete(playerId);
        }
    }

    getTeamColor(teamId) {
        return this.teamColors.get(teamId);
    }

    getPlayerTeam(playerId) {
        const teamId = this.playerTeams.get(playerId);
        return this.teams.get(teamId);
    }

    updateTeamScore(teamId, points) {
        const team = this.teams.get(teamId);
        if (team) {
            team.score += points;
        }
    }

    getTeamScores() {
        const scores = [];
        for (const [teamId, team] of this.teams) {
            scores.push({
                teamId,
                name: team.name,
                color: team.color,
                score: team.score,
                playerCount: team.players.size
            });
        }
        return scores.sort((a, b) => b.score - a.score);
    }

    arePlayersOnSameTeam(player1Id, player2Id) {
        return this.playerTeams.get(player1Id) === this.playerTeams.get(player2Id);
    }

    setGameMode(newMode) {
        if (newMode === this.gameMode) return;
        
        // Clear existing teams
        this.teams.clear();
        this.playerTeams.clear();
        this.teamColors.clear();
        this.usedColors.clear();
        this.nextTeamId = 1;
        
        // Set new game mode and initialize teams
        this.gameMode = newMode;
        this.initializeTeams();
    }
} 
### ./core/TeamManager.js END ###

### ./core/Scene.js BEGIN ###
import * as THREE from 'three';

class Scene {
    constructor(engine) {
        this.engine = engine;
        this.scene = engine.scene;
        
        // Scene elements
        this.floor = null;
        this.playerHighlight = null;
        this.obstacles = [];
        
        // Scene properties
        this.boundarySize = 25;
        this.gridSize = 100;
        this.gridDivisions = 100;
    }

    init() {
        this.createFloor();
        this.createBoundaryMarkers();
        this.createObstacles();
        return this;
    }

    createFloor() {
        // Create grid
        const gridHelper = new THREE.GridHelper(
            this.gridSize,
            this.gridDivisions,
            0x444444,
            0x222222
        );
        this.engine.add(gridHelper);

        // Create floor with glow effect
        const floorGeometry = new THREE.PlaneGeometry(this.gridSize, this.gridSize);
        const floorMaterial = new THREE.MeshBasicMaterial({
            color: 0x000022,
            transparent: true,
            opacity: 0.2,
        });

        this.floor = new THREE.Mesh(floorGeometry, floorMaterial);
        this.floor.rotation.x = -Math.PI / 2;
        this.floor.position.y = -0.01;
        this.engine.add(this.floor);

        // Create player highlight
        const highlightGeometry = new THREE.CircleGeometry(5, 32);
        const highlightMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0.1,
        });

        this.playerHighlight = new THREE.Mesh(highlightGeometry, highlightMaterial);
        this.playerHighlight.rotation.x = -Math.PI / 2;
        this.playerHighlight.position.y = 0.02;
        this.engine.add(this.playerHighlight);
    }

    createBoundaryMarkers() {
        const markerSize = 1;
        const markerHeight = 1;
        const numMarkers = 10;

        const markerGeometry = new THREE.BoxGeometry(markerSize, markerHeight, markerSize);
        const markerMaterial = new THREE.MeshPhongMaterial({
            color: 0xff0000,
            emissive: 0x600000,
            transparent: true,
            opacity: 0.7
        });

        const markers = new THREE.Group();

        for (let i = 0; i < numMarkers; i++) {
            const t = (i / (numMarkers - 1)) * 2 - 1;
            const position = this.boundarySize * t;

            ['north', 'south', 'east', 'west'].forEach(direction => {
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                
                switch(direction) {
                    case 'north':
                        marker.position.set(position, markerHeight / 2, -this.boundarySize);
                        break;
                    case 'south':
                        marker.position.set(position, markerHeight / 2, this.boundarySize);
                        break;
                    case 'east':
                        marker.position.set(this.boundarySize, markerHeight / 2, position);
                        break;
                    case 'west':
                        marker.position.set(-this.boundarySize, markerHeight / 2, position);
                        break;
                }
                
                markers.add(marker);
            });
        }

        this.engine.add(markers);
    }

    createObstacles() {
        const numObstacles = 15;
        
        for (let i = 0; i < numObstacles; i++) {
            const obstacle = this.createRandomObstacle();
            if (obstacle) {
                this.obstacles.push(obstacle);
                this.engine.add(obstacle);
            }
        }
    }

    createRandomObstacle() {
        const shapeType = Math.floor(Math.random() * 3);
        let geometry, size;

        // Create random geometry
        switch(shapeType) {
            case 0: // Box
                size = 1.5 + Math.random() * 3;
                const height = 3 + Math.random() * 4;
                geometry = new THREE.BoxGeometry(size, height, size);
                break;
            case 1: // Cylinder
                const radius = 1 + Math.random() * 2;
                const cylinderHeight = 4 + Math.random() * 5;
                geometry = new THREE.CylinderGeometry(radius, radius, cylinderHeight, 16);
                size = radius * 2;
                break;
            case 2: // Sphere
                const sphereRadius = 1.5 + Math.random() * 2;
                geometry = new THREE.SphereGeometry(sphereRadius, 16, 16);
                size = sphereRadius * 2;
                break;
        }

        // Create neon material
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
        const material = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color.clone().multiplyScalar(0.5),
            shininess: 100
        });

        // Create mesh
        const obstacle = new THREE.Mesh(geometry, material);

        // Add point light
        const light = new THREE.PointLight(color, 0.5, 5);
        light.position.set(0, 0, 0);
        obstacle.add(light);

        // Set random position (avoiding player spawn area)
        let x, z;
        let validPosition = false;

        while (!validPosition) {
            x = (Math.random() - 0.5) * 45;
            z = (Math.random() - 0.5) * 45;
            
            const distanceFromOrigin = Math.sqrt(x * x + z * z);
            if (distanceFromOrigin > 10) {
                validPosition = true;
            }
        }

        const y = shapeType === 2 ? Math.random() * 3 : size / 2;
        obstacle.position.set(x, y, z);

        return obstacle;
    }

    updatePlayerHighlight(playerPosition) {
        if (this.playerHighlight) {
            this.playerHighlight.position.x = playerPosition.x;
            this.playerHighlight.position.z = playerPosition.z;
            
            const pulseFactor = (Math.sin(Date.now() * 0.003) + 1) / 2;
            this.playerHighlight.material.opacity = 0.05 + pulseFactor * 0.1;
        }
    }

    getFloor() {
        return this.floor;
    }

    getObstacles() {
        return this.obstacles;
    }

    getBoundarySize() {
        return this.boundarySize;
    }

    cleanup() {
        // Cleanup all obstacles
        this.obstacles.forEach(obstacle => {
            obstacle.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        });
        
        // Clear arrays
        this.obstacles = [];
    }
}

export default Scene; 
### ./core/Scene.js END ###

### ./core/GameEngine.js BEGIN ###
import * as THREE from 'three';
import { Player } from '../entities/player/Player';
import { WeaponSystem } from '../entities/weapons/WeaponSystem';
import { EnemyManager } from '../entities/enemies/EnemyManager';
import { GameRoom } from '../ui/GameRoom';
import { SoundManager } from '../assets/SoundManager';
import { RegularLaser } from '../entities/weapons/RegularLaser';
import { GameUI } from '../ui/GameUI';
import { NetworkManager } from './NetworkManager';
import { AssetLoader } from '../assets/AssetLoader';
import { CSS2DObject } from 'three/examples/jsm/renderers/CSS2DRenderer';

export class GameEngine {
  constructor() {
    // Initialize properties
    this.scene = null;
    this.camera = null;
    this.renderer = null;
    this.player = null;
    this.score = 0;
    this.isRunning = false;
    this.lastTime = 0;
    this.collisionThreshold = 0.5; // Collision distance threshold
    
    // Game mode and settings
    this.gameMode = 'ffa'; // Default game mode: free-for-all
    this.roomTheme = 'space-station'; // Default room theme
    this.roomSize = { width: 60, height: 60 }; // Default room size
    
    // Initialize UI
    this.ui = new GameUI();
    
    // Multiplayer properties
    this.players = {};  // Will store other players
    this.playerId = null;  // Will be set when joining a game
    this.multiplayerEnabled = false;
    this.teams = {
      red: { score: 0, players: [] },
      blue: { score: 0, players: [] }
    };
    
    // Add NetworkManager instance
    this.networkManager = new NetworkManager();
    
    // Initialize AssetLoader
    this.assetLoader = new AssetLoader().setCallbacks(
      (message) => console.log(`GameEngine: ${message}`),
      (type, error) => this.handleAssetError(type, error)
    );
    
    // Asset loading state
    this.assetsLoaded = false;
    
    // Initialize Three.js components
    this.initThree();
    
    // Initialize weapon system
    this.weaponSystem = new WeaponSystem(this.scene);
    
    // Initialize enemy manager (will be used for AI opponents)
    this.enemyManager = new EnemyManager(this.scene, this.roomSize.width / 2);
    
    // Initialize game elements
    this.initGame();
  }
  
  initThree() {
    // Create scene
    this.scene = new THREE.Scene();
    this.scene.background = new THREE.Color(0x000011);
    
    // Create isometric-style camera
    this.camera = new THREE.PerspectiveCamera(
      45, // Lower FOV for more isometric-like view
      window.innerWidth / window.innerHeight, 
      0.1, 
      1000
    );
    
    // Set camera to isometric position
    this.camera.position.set(40, 40, 40); // Position it at a distance
    this.camera.lookAt(0, 0, 0); // Look at the center of the room
    
    // Create renderer
    this.renderer = new THREE.WebGLRenderer({ antialias: true });
    this.renderer.setSize(window.innerWidth, window.innerHeight);
    this.renderer.setPixelRatio(window.devicePixelRatio);
    
    // Add renderer to DOM
    document.getElementById('game-container').appendChild(this.renderer.domElement);
  }
  
  async initGame() {
    console.log('Initializing game...');
    
    // Create clock for timing
    this.clock = new THREE.Clock();
    
    // Initialize scene if not set
    if (!this.scene) {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x000011); // Dark blue background
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x444444);
      this.scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(1, 1, 1).normalize();
      this.scene.add(directionalLight);
    }
    
    // Initialize camera if not set
    if (!this.camera) {
      this.camera = new THREE.PerspectiveCamera(
        75, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
      );
      this.camera.position.set(0, 10, -10);
      this.camera.lookAt(0, 0, 0);
    }
    
    // Initialize renderer if not set
    if (!this.renderer) {
      this.renderer = new THREE.WebGLRenderer({ antialias: true });
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.shadowMap.enabled = true;
      document.body.appendChild(this.renderer.domElement);
    }
    
    // Load assets before proceeding
    try {
      console.log('Loading game assets...');
      this.assetsLoaded = await this.assetLoader.loadAll();
      console.log('Assets loaded successfully:', this.assetsLoaded);
    } catch (error) {
      console.error('Failed to load assets:', error);
      this.handleAssetError('critical', error);
      return;
    }
    
    // Initialize sound manager
    this.soundManager = new SoundManager();
    
    // Initialize player
    this.player = new Player(this.scene, this.camera, this.soundManager);
    
    // Initialize weapon system
    this.weaponSystem = new WeaponSystem(this.scene, this.soundManager);
    
    // Equip player with weapons
    this.player.equipWeapon('primary', new RegularLaser(this.weaponSystem));
    
    // Initialize enemy manager
    this.enemyManager = new EnemyManager(this.scene, this.weaponSystem, this.soundManager);
    
    // Initialize the first room
    this.initializeFirstRoom();
    
    // Setup event listeners
    this.setupEventListeners();
    
    // Setup network listeners only after assets are loaded
    if (this.assetsLoaded) {
      this.setupNetworkListeners();
    }
    
    // Show UI
    this.showGameUI();
    
    // Game is now initialized
    this.isInitialized = true;
    console.log('Game initialization complete!');
  }
  
  initGameModeUI() {
    // Clear any existing game mode UI
    const existingUI = document.querySelector('.team-indicator');
    if (existingUI) {
      existingUI.remove();
    }
    
    // Only add UI for team-based modes in multiplayer
    if (!this.multiplayerEnabled) return;
    
    switch (this.gameMode) {
      case 'tdm': // Team Deathmatch
      case 'ctf': // Capture The Flag
        // Create team scores indicator
        const teamIndicator = document.createElement('div');
        teamIndicator.className = 'team-indicator';
        
        const redTeam = document.createElement('div');
        redTeam.className = 'team-score team-red';
        redTeam.innerHTML = 'RED: <span id="red-score">0</span>';
        
        const blueTeam = document.createElement('div');
        blueTeam.className = 'team-score team-blue';
        blueTeam.innerHTML = 'BLUE: <span id="blue-score">0</span>';
        
        teamIndicator.appendChild(redTeam);
        teamIndicator.appendChild(blueTeam);
        
        document.getElementById('game-container').appendChild(teamIndicator);
        
        // Add flag status indicator for CTF mode
        if (this.gameMode === 'ctf') {
          const flagStatus = document.createElement('div');
          flagStatus.className = 'flag-status';
          
          const blueFlag = document.createElement('div');
          blueFlag.className = 'flag-blue';
          blueFlag.innerHTML = '<div class="flag-icon"></div> <span id="blue-flag-status">SECURE</span>';
          
          const redFlag = document.createElement('div');
          redFlag.className = 'flag-red';
          redFlag.innerHTML = '<div class="flag-icon"></div> <span id="red-flag-status">SECURE</span>';
          
          flagStatus.appendChild(blueFlag);
          flagStatus.appendChild(redFlag);
          
          document.getElementById('game-container').appendChild(flagStatus);
        }
        break;
        
      case 'koth': // King of the Hill
        // Create control point status
        const controlIndicator = document.createElement('div');
        controlIndicator.className = 'team-indicator';
        
        const controlPoint = document.createElement('div');
        controlPoint.className = 'team-score';
        controlPoint.innerHTML = 'CONTROL: <span id="control-status">NEUTRAL</span>';
        
        controlIndicator.appendChild(controlPoint);
        document.getElementById('game-container').appendChild(controlIndicator);
        break;
    }
  }
  
  setGameMode(mode) {
    this.gameMode = mode;
    console.log(`Game mode set to: ${mode}`);
    
    // Update UI for the new game mode
    this.initGameModeUI();
  }
  
  setRoomTheme(theme) {
    this.roomTheme = theme;
    console.log(`Room theme set to: ${theme}`);
    
    // If a room exists, regenerate it with the new theme
    if (this.gameRoom) {
      this.gameRoom.cleanup();
      this.gameRoom = new GameRoom(this.scene, this.roomSize, this.roomTheme);
      this.obstacles = this.gameRoom.getObstacles();
    }
  }
  
  start() {
    this.isRunning = true;
    this.lastTime = performance.now();
    
    // Start incrementing score over time (for single player only)
    if (!this.multiplayerEnabled) {
      this.scoreInterval = setInterval(() => {
        this.updateScore(1);
      }, 1000);
      
      // Start the enemy spawner
      this.spawnEnemyTimer = setInterval(() => {
        this.enemyManager.increaseDifficulty(0.05);
        this.enemyManager.increaseMaxEnemies(1);
      }, 30000); // Increase difficulty every 30 seconds
    }
    
    this.gameLoop(this.lastTime);
  }
  
  restart() {
    // Clear timers
    if (this.scoreInterval) {
      clearInterval(this.scoreInterval);
    }
    
    if (this.spawnEnemyTimer) {
      clearInterval(this.spawnEnemyTimer);
    }
    
    // Reset game state
    this.score = 0;
    this.updateScore();
    
    // Clear all projectiles
    this.weaponSystem.clearAllProjectiles();
    
    // Clear enemies
    this.enemyManager.clear();
    
    // Reset player
    this.player.reset();
    
    // Regenerate room
    this.gameRoom.cleanup();
    this.gameRoom = new GameRoom(this.scene, this.roomSize, this.roomTheme);
    this.obstacles = this.gameRoom.getObstacles();
    
    // Position player at spawn point
    const spawnPoint = this.gameRoom.getRandomSpawnPoint();
    this.player.mesh.position.copy(spawnPoint);
    
    // Multiplayer reset
    if (this.multiplayerEnabled) {
      // Reset team scores
      this.teams.red.score = 0;
      this.teams.blue.score = 0;
      this.updateTeamScores();
      
      // Reset multiplayer state (will be implemented with actual networking)
      console.log("Resetting multiplayer state");
    }
    
    // Start score increment timer (for single player)
    if (!this.multiplayerEnabled) {
      this.scoreInterval = setInterval(() => {
        this.updateScore(1);
      }, 1000);
      
      // Start the enemy spawner
      this.spawnEnemyTimer = setInterval(() => {
        this.enemyManager.increaseDifficulty(0.05);
        this.enemyManager.increaseMaxEnemies(1);
      }, 30000); // Increase difficulty every 30 seconds
    }
    
    // Start the game
    this.isRunning = true;
    this.lastTime = performance.now();
    this.gameLoop(this.lastTime);
  }
  
  gameLoop(currentTime) {
    if (!this.isRunning) return;
    
    // Calculate delta time
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    
    // Update game state
    this.update();
    
    // Render scene
    this.renderer.render(this.scene, this.camera);
    
    // Continue the game loop
    requestAnimationFrame(this.gameLoop.bind(this));
  }
  
  update() {
    // Get delta time from the clock
    const deltaTime = this.clock.getDelta();
    
    // Skip update if game is paused
    if (this.isPaused) return;
    
    // Get obstacles from current room
    const obstacles = this.currentRoom?.getObstacles() || [];
    
    // Update player
    if (this.player) {
      this.player.update(deltaTime);
      
      // Check player collisions with obstacles
      if (this.currentRoom) {
        const collided = this.player.checkObstacleCollisions(obstacles);
        if (collided) {
          // Handle collision response here
          console.log('Player collided with obstacle');
        }
      }
    }
    
    // Update enemies
    if (this.enemyManager) {
      this.enemyManager.update(deltaTime, obstacles, this.player);
    }
    
    // Update weapons
    if (this.weaponSystem) {
      // Get targets (player and enemies)
      const targets = [this.player, ...this.enemyManager.getEnemies()].filter(target => target && target.isAlive);
      
      // Check weapon collisions
      const hits = this.weaponSystem.checkCollisions(targets, obstacles);
      
      // Handle hits
      for (const hit of hits) {
        if (hit.target !== 'wall' && typeof hit.target.takeDamage === 'function') {
          hit.target.takeDamage(hit.projectile.damage);
        }
        
        // Create explosion effect
        this.createExplosion(hit.position, hit.projectile.explosionSize || 0.5);
      }
      
      // Update weapon system
      this.weaponSystem.update(deltaTime);
    }
    
    // Update current room
    if (this.currentRoom) {
      this.currentRoom.update(deltaTime);
    }
    
    // Check if player has completed the current room
    if (this.currentRoom && this.player) {
      const isRoomCompleted = this.currentRoom.checkCompletion(this.player);
      if (isRoomCompleted && !this.isTransitioning) {
        this.transitionToNextRoom();
      }
    }
    
    // Update UI
    this.updateUI();
    
    // Send player updates if multiplayer is enabled
    if (this.multiplayerEnabled && this.networkManager.isConnected()) {
      this.sendPlayerUpdate();
    }
  }
  
  updateCamera() {
    // For isometric view, we maintain the camera's relative position 
    // but move it to follow the player
    const cameraOffset = new THREE.Vector3(40, 40, 40);
    
    // We want to keep the isometric angle but position relative to player
    this.camera.position.set(
      this.player.mesh.position.x + cameraOffset.x,
      cameraOffset.y, // Keep the same height
      this.player.mesh.position.z + cameraOffset.z
    );
    
    // Look at the player
    this.camera.lookAt(
      this.player.mesh.position.x,
      0, // Look at ground level
      this.player.mesh.position.z
    );
  }
  
  updateOtherPlayers(deltaTime) {
    // This will be replaced with actual networking code
    // For now, just a placeholder for the multiplayer functionality
    for (const playerId in this.players) {
      const player = this.players[playerId];
      // In real implementation, we'd interpolate positions from the server
    }
  }
  
  checkPlayerCollisions() {
    // Check for collisions with other players
    // This will be implemented with actual networking
  }
  
  updateGameMode(deltaTime) {
    // Handle game mode specific logic
    switch (this.gameMode) {
      case 'tdm': // Team Deathmatch
        // Just update scores when players are hit, already handled in processHitResults
        break;
        
      case 'ctf': // Capture The Flag
        // Check for flag captures, etc.
        this.updateCTFLogic(deltaTime);
        break;
        
      case 'koth': // King of the Hill
        // Check for hill control
        this.updateKOTHLogic(deltaTime);
        break;
        
      case 'ffa': // Free For All
      default:
        // Individual scores, handled in processHitResults
        break;
    }
  }
  
  updateCTFLogic(deltaTime) {
    // This will be implemented with actual flag capture logic
    // For now, just a placeholder
  }
  
  updateKOTHLogic(deltaTime) {
    // This will be implemented with actual hill control logic
    // For now, just a placeholder
  }
  
  processHitResults(hitResults) {
    // Process hits from weapon system
    for (const hit of hitResults) {
      // If hit a wall or obstacle, create a visual effect
      if (hit.target === 'wall' || hit.target === 'obstacle') {
        this.createHitEffect(hit.position);
      } 
      // If hit a target (enemy or player), damage it
      else if (hit.target && hit.target.takeDamage) {
        const damage = hit.projectile.options.damage || 10;
        const destroyed = hit.target.takeDamage(damage);
        
        if (destroyed) {
          if (this.multiplayerEnabled) {
            // Handle multiplayer scoring based on game mode
            switch (this.gameMode) {
              case 'tdm': // Team Deathmatch
                // Add score to the team that got the kill
                const targetTeam = hit.target.team;
                const attackerTeam = this.player.team;
                
                if (targetTeam !== attackerTeam) {
                  this.teams[attackerTeam].score += 1;
                  this.updateTeamScores();
                }
                break;
                
              default: // FFA and other modes
                this.updateScore(25); // Points for destroying a target
                break;
            }
          } else {
            // Single player scoring
            this.updateScore(25); // Points for destroying an enemy
          }
        }
      }
    }
  }
  
  createHitEffect(position) {
    // Create a simple flash effect at the hit position
    const geometry = new THREE.SphereGeometry(0.2, 8, 8);
    const material = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.8
    });
    
    const flash = new THREE.Mesh(geometry, material);
    flash.position.copy(position);
    this.scene.add(flash);
    
    // Animate and remove after short duration
    const startTime = Date.now();
    const duration = 300;
    
    const animateFlash = () => {
      const elapsed = Date.now() - startTime;
      if (elapsed < duration) {
        const scale = 1 + elapsed / duration;
        flash.scale.set(scale, scale, scale);
        material.opacity = 0.8 * (1 - elapsed / duration);
        requestAnimationFrame(animateFlash);
      } else {
        this.scene.remove(flash);
        geometry.dispose();
        material.dispose();
      }
    };
    
    animateFlash();
  }
  
  checkObstacleCollisions(position, radius) {
    // Simple collision check with obstacles
    for (const obstacle of this.obstacles) {
      if (obstacle.type === 'wall') {
        // Box collision with walls
        const halfSize = new THREE.Vector3().copy(obstacle.size).multiplyScalar(0.5);
        
        // Check if position is within the bounding box of the wall
        if (
          position.x > obstacle.position.x - halfSize.x - radius &&
          position.x < obstacle.position.x + halfSize.x + radius &&
          position.z > obstacle.position.z - halfSize.z - radius &&
          position.z < obstacle.position.z + halfSize.z + radius
        ) {
          return true;
        }
      } else if (obstacle.radius) {
        // Cylinder collision
        const dx = position.x - obstacle.position.x;
        const dz = position.z - obstacle.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        if (distance < obstacle.radius + radius) {
          return true;
        }
      } else if (obstacle.size) {
        // Box collision with rotation if needed
        const halfSize = new THREE.Vector3().copy(obstacle.size).multiplyScalar(0.5);
        
        // For simplicity, just do a bounding sphere check for now
        const dx = position.x - obstacle.position.x;
        const dz = position.z - obstacle.position.z;
        const distance = Math.sqrt(dx * dx + dz * dz);
        
        // Use the larger dimension as the bounding radius
        const boundingRadius = Math.max(halfSize.x, halfSize.z);
        
        if (distance < boundingRadius + radius) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  updateScore(points = 0) {
    this.score += points;
    document.getElementById('score-value').textContent = this.score;
  }
  
  updateTeamScores() {
    // Update team scores in the UI
    if (this.multiplayerEnabled && (this.gameMode === 'tdm' || this.gameMode === 'ctf')) {
      document.getElementById('red-score').textContent = this.teams.red.score;
      document.getElementById('blue-score').textContent = this.teams.blue.score;
    }
  }
  
  gameOver() {
    this.isRunning = false;
    
    // Clear score interval
    if (this.scoreInterval) {
      clearInterval(this.scoreInterval);
      this.scoreInterval = null;
    }
    
    // Clear enemy spawner
    if (this.spawnEnemyTimer) {
      clearInterval(this.spawnEnemyTimer);
      this.spawnEnemyTimer = null;
    }
    
    // Hide game UI and show game over screen
    if (this.ui) {
      this.ui.hide();
    }
    document.getElementById('final-score').textContent = this.score;
    document.getElementById('game-over').classList.remove('hidden');
  }
  
  handleResize() {
    // Update camera aspect ratio
    this.camera.aspect = window.innerWidth / window.innerHeight;
    this.camera.updateProjectionMatrix();
    
    // Update renderer size
    this.renderer.setSize(window.innerWidth, window.innerHeight);
  }
  
  // Multiplayer methods
  enableMultiplayer() {
    this.multiplayerEnabled = true;
    console.log("Multiplayer mode enabled");
    
    // Show multiplayer info in UI
    document.getElementById('multiplayer-info').classList.remove('hidden');
    
    // Set up NetworkManager event listeners
    this.setupNetworkListeners();
    
    // Connect to server
    this.connectToServer();
  }
  
  disableMultiplayer() {
    this.multiplayerEnabled = false;
    console.log("Multiplayer mode disabled");
    
    // Hide multiplayer info in UI
    document.getElementById('multiplayer-info').classList.add('hidden');
    
    // Disconnect from server
    this.disconnectFromServer();
  }
  
  setupNetworkListeners() {
    // Clear existing listeners
    this.networkManager.removeAllListeners();
    
    // Handle player joined
    this.networkManager.on('player_joined', (playerData) => {
      console.log('Player joined:', playerData);
      
      // Create other player visual representation
      const newPlayer = this.createOtherPlayer(playerData);
      this.players[playerData.id] = newPlayer;
      
      // Update player count in UI
      document.getElementById('players-count').textContent = Object.keys(this.players).length + 1; // +1 for local player
    });
    
    // Handle player left
    this.networkManager.on('player_left', (id) => {
      console.log('Player left:', id);
      
      // Remove player from scene
      if (this.players[id]) {
        this.scene.remove(this.players[id].mesh);
        delete this.players[id];
        
        // Update player count in UI
        document.getElementById('players-count').textContent = Object.keys(this.players).length + 1; // +1 for local player
      }
    });
    
    // Handle player update
    this.networkManager.on('player_update', (data) => {
      if (this.players[data.id]) {
        this.updateOtherPlayer(this.players[data.id], data);
      }
    });
    
    // Handle laser shot from other players
    this.networkManager.on('laser_shot', (data) => {
      // Create laser from other player
      if (data.origin && data.direction) {
        this.createLaserFromPlayer(data.origin, data.direction, data.playerId);
      }
    });
    
    // Handle connection status
    this.networkManager.on('connected', () => {
      console.log('Connected to server');
      document.getElementById('connection-status').textContent = 'Connected';
      document.getElementById('connection-status').classList.add('connected');
    });
    
    this.networkManager.on('disconnected', () => {
      console.log('Disconnected from server');
      document.getElementById('connection-status').textContent = 'Disconnected';
      document.getElementById('connection-status').classList.remove('connected');
    });
    
    // Handle player ID assignment
    this.networkManager.on('player_id', (id) => {
      this.playerId = id;
      console.log('Assigned player ID:', id);
    });
  }
  
  connectToServer(serverUrl = 'http://localhost:3000') {
    if (!this.multiplayerEnabled) return;
    
    console.log(`Connecting to multiplayer server: ${serverUrl}`);
    this.networkManager.connect(serverUrl);
    
    // Update player count in UI
    document.getElementById('players-count').textContent = '1';
    
    // Assign player to a team if in team mode
    if (this.gameMode === 'tdm' || this.gameMode === 'ctf') {
      const team = Math.random() > 0.5 ? 'red' : 'blue';
      this.player.team = team;
      this.teams[team].players.push(this.playerId);
      console.log(`Assigned to team: ${team}`);
    }
  }
  
  disconnectFromServer() {
    console.log("Disconnecting from multiplayer server");
    
    // Use NetworkManager to disconnect
    this.networkManager.disconnect();
    
    // Reset multiplayer state
    this.playerId = null;
    
    // Remove other players from scene
    for (const id in this.players) {
      this.scene.remove(this.players[id].mesh);
    }
    
    // Reset players and teams
    this.players = {};
    this.teams.red.players = [];
    this.teams.blue.players = [];
    this.player.team = null;
  }
  
  sendPlayerUpdate() {
    if (!this.multiplayerEnabled || !this.networkManager.isConnected()) return;
    if (!this.player || !this.player.mesh) return;
    
    const playerData = {
      position: {
        x: this.player.mesh.position.x,
        y: this.player.mesh.position.y,
        z: this.player.mesh.position.z
      },
      rotation: this.player.mesh.rotation.y,
      team: this.player.team,
      name: this.playerName,
      shipType: this.player.shipType
    };
    
    this.networkManager.sendPlayerUpdate(playerData);
  }
  
  createLaserFromPlayer(origin, direction, playerId) {
    // Implement this method to spawn a laser from another player
    // Similar to your existing laser creation code but from a different origin
    const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
    
    // Determine color based on player's team if applicable
    let laserColor = 0xff0000; // Default red
    if (this.players[playerId] && this.players[playerId].team) {
      laserColor = this.players[playerId].team === 'red' ? 0xff0000 : 0x0000ff;
    }
    
    const laserMaterial = new THREE.MeshBasicMaterial({ 
      color: laserColor,
      emissive: laserColor,
      emissiveIntensity: 1.0
    });
    
    const laser = new THREE.Mesh(laserGeometry, laserMaterial);
    
    // Set laser position and rotation
    laser.position.copy(origin);
    
    // Set laser direction
    const laserDirection = new THREE.Vector3().copy(direction);
    laser.lookAt(laserDirection.add(origin));
    
    // Rotate to align with direction
    laser.rotateX(Math.PI / 2);
    
    // Add to scene
    this.scene.add(laser);
    
    // Add to lasers array for update
    this.lasers.push({
      mesh: laser,
      direction: laserDirection.normalize(),
      speed: 0.5, // Adjust as needed
      playerId: playerId
    });
    
    return laser;
  }
  
  /**
   * Initialize the first game room
   */
  initializeFirstRoom() {
    // Clean up any existing room
    if (this.currentRoom) {
      this.currentRoom.cleanup();
    }
    
    // Create a new room
    this.currentRoom = new GameRoom(
      this.scene, 
      { width: 60, height: 60 }, 
      this.roomTheme || 'space-station'
    );
    
    // Position player at spawn point
    if (this.player && this.currentRoom) {
      const spawnPoint = this.currentRoom.getRandomSpawnPoint();
      this.player.mesh.position.copy(spawnPoint);
    }
    
    // Reset current level
    this.currentLevel = 1;
    
    // Update UI
    this.updateLevelDisplay();
  }
  
  /**
   * Update the level display in the UI
   */
  updateLevelDisplay() {
    const levelElement = document.getElementById('level-value');
    if (levelElement) {
      levelElement.textContent = this.currentLevel;
    }
  }
  
  /**
   * Create an explosion effect at the given position
   */
  createExplosion(position, size = 0.5) {
    // Create a sphere for the explosion
    const geometry = new THREE.SphereGeometry(size, 8, 8);
    const material = new THREE.MeshBasicMaterial({
      color: 0x00ffff,
      transparent: true,
      opacity: 0.8
    });
    
    const explosion = new THREE.Mesh(geometry, material);
    explosion.position.copy(position);
    this.scene.add(explosion);
    
    // Add point light
    const light = new THREE.PointLight(0x00ffff, 2, 10);
    light.position.copy(position);
    this.scene.add(light);
    
    // Animate the explosion
    let scale = 1.0;
    const expandSpeed = 2.0;
    const duration = 0.5; // seconds
    let elapsed = 0;
    
    const animate = (deltaTime) => {
      elapsed += deltaTime;
      const progress = elapsed / duration;
      
      if (progress >= 1) {
        // Remove the explosion
        this.scene.remove(explosion);
        this.scene.remove(light);
        return;
      }
      
      // Expand and fade out
      scale += expandSpeed * deltaTime;
      explosion.scale.set(scale, scale, scale);
      
      // Fade out
      const opacity = 1 - progress;
      material.opacity = opacity;
      light.intensity = 2 * opacity;
      
      // Continue animation
      requestAnimationFrame((timestamp) => {
        const delta = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        animate(delta / 1000); // Convert ms to seconds
      });
    };
    
    // Start animation
    const lastTimestamp = performance.now();
    animate(0);
  }
  
  /**
   * Transition to the next room/level
   */
  transitionToNextRoom() {
    // Set transition flag
    this.isTransitioning = true;
    
    // Fade out effect
    // Here you would implement a visual fade-out effect
    
    // After fade out, create new room
    setTimeout(() => {
      // Clean up old room
      if (this.currentRoom) {
        this.currentRoom.cleanup();
      }
      
      // Increment level
      this.currentLevel++;
      
      // Create new room with increased difficulty
      this.currentRoom = new GameRoom(
        this.scene,
        { width: 60, height: 60 },
        this.roomTheme || 'space-station',
        { 
          difficulty: this.currentLevel * 0.2,
          obstacleCount: Math.min(10 + this.currentLevel, 30)
        }
      );
      
      // Position player at spawn point
      if (this.player && this.currentRoom) {
        const spawnPoint = this.currentRoom.getRandomSpawnPoint();
        this.player.mesh.position.copy(spawnPoint);
      }
      
      // Update UI
      this.updateLevelDisplay();
      
      // Increase enemy manager difficulty
      if (this.enemyManager) {
        this.enemyManager.increaseDifficulty(0.1 * this.currentLevel);
        this.enemyManager.increaseMaxEnemies(1);
      }
      
      // Fade in effect
      // Here you would implement a visual fade-in effect
      
      // Reset transition flag
      setTimeout(() => {
        this.isTransitioning = false;
      }, 500); // After fade-in completes
      
    }, 1000); // After fade-out completes
  }
  
  /**
   * Update UI elements
   */
  updateUI() {
    // Update health and energy displays
    if (this.player) {
      // Update health
      const healthElement = document.getElementById('health-value');
      if (healthElement) {
        healthElement.textContent = Math.round(this.player.health);
        
        // Update health bar
        const healthBar = document.getElementById('health-bar-inner');
        if (healthBar) {
          const healthPercent = (this.player.health / this.player.maxHealth) * 100;
          healthBar.style.width = `${healthPercent}%`;
        }
      }
      
      // Update energy
      const energyElement = document.getElementById('energy-value');
      if (energyElement) {
        energyElement.textContent = Math.round(this.player.energy);
        
        // Update energy bar
        const energyBar = document.getElementById('energy-bar-inner');
        if (energyBar) {
          const energyPercent = (this.player.energy / this.player.maxEnergy) * 100;
          energyBar.style.width = `${energyPercent}%`;
        }
      }
      
      // Update shield
      const shieldElement = document.getElementById('shield-value');
      if (shieldElement) {
        shieldElement.textContent = Math.round(this.player.shields);
        
        // Update shield bar
        const shieldBar = document.getElementById('shield-bar-inner');
        if (shieldBar) {
          const shieldPercent = (this.player.shields / this.player.maxShields) * 100;
          shieldBar.style.width = `${shieldPercent}%`;
        }
      }
    }
    
    // Update score
    const scoreElement = document.getElementById('score-value');
    if (scoreElement && this.player) {
      scoreElement.textContent = this.player.score;
    }
  }
  
  /**
   * Setup event listeners for window resizing and UI controls
   */
  setupEventListeners() {
    // Handle window resize
    window.addEventListener('resize', () => this.handleResize());
    
    // Handle pause/resume game
    const pauseButton = document.getElementById('pause-button');
    if (pauseButton) {
      pauseButton.addEventListener('click', () => {
        this.isPaused = !this.isPaused;
        pauseButton.textContent = this.isPaused ? 'Resume' : 'Pause';
      });
    }
    
    // Handle restart game
    const restartButton = document.getElementById('restart-button');
    if (restartButton) {
      restartButton.addEventListener('click', () => this.restart());
    }
  }
  
  /**
   * Show the game UI elements
   */
  showGameUI() {
    // Show game UI
    if (this.ui) {
      this.ui.show();
    }
    
    // Hide any splash screens or menus
    const splashScreen = document.getElementById('splash-screen');
    if (splashScreen) {
      splashScreen.style.display = 'none';
    }
  }
  
  // Create visual representation for other players
  createOtherPlayer(playerData) {
    console.log('Creating other player with data:', playerData);
    
    // Ensure assets are loaded
    if (!this.assetsLoaded) {
      console.warn('Attempting to create player before assets are loaded');
      return null;
    }
    
    // Get ship type from player data or default to STANDARD
    const shipType = playerData.shipType || 'STANDARD';
    console.log('Using ship type:', shipType);
    
    // Try to get ship model from asset loader first
    let ship = null;
    try {
      ship = this.assetLoader.getOpponentShipModel(shipType);
      if (ship) {
        console.log('Successfully loaded ship model for type:', shipType);
        ship.scale.set(0.45, 0.45, 0.45);
      }
    } catch (error) {
      console.warn('Failed to load ship model:', error);
    }
    
    // Fallback to geometry if model loading failed
    if (!ship) {
      console.log('Using fallback geometry for ship type:', shipType);
      // Create geometry based on ship type
      let geometry;
      switch(shipType) {
        case 'INTERCEPTOR':
          geometry = new THREE.ConeGeometry(0.4, 1.25, 4);
          break;
        case 'HEAVY':
          geometry = new THREE.CylinderGeometry(0.6, 0.7, 1.0, 6);
          break;
        case 'SCOUT':
          geometry = new THREE.ConeGeometry(0.3, 1.1, 5);
          break;
        case 'STANDARD':
        default:
          geometry = new THREE.ConeGeometry(0.5, 1.0, 3);
          break;
      }
      
      // Rotate geometry to align with movement direction
      geometry.rotateX(Math.PI / 2);
      
      // Create material based on team color
      const shipColor = playerData.teamColor || 0x00ffff;
      const material = new THREE.MeshPhongMaterial({ 
        color: shipColor, 
        emissive: shipColor,
        emissiveIntensity: 0.5,
        shininess: 100
      });
      
      // Create mesh
      ship = new THREE.Mesh(geometry, material);
    }
    
    // Add engine glow effect
    const engineGlow = new THREE.PointLight(playerData.teamColor || 0x00ffff, 1, 2);
    engineGlow.position.set(0, 0, -0.5);
    ship.add(engineGlow);
    
    // Add ship to scene
    this.scene.add(ship);
    
    // Create name label
    const nameDiv = document.createElement('div');
    nameDiv.className = 'player-label';
    nameDiv.textContent = playerData.name || `Player-${playerData.id.substring(0, 4)}`;
    
    const nameLabel = new CSS2DObject(nameDiv);
    nameLabel.position.set(0, 1, 0);
    ship.add(nameLabel);
    
    // Set initial position if provided
    if (playerData.position) {
      ship.position.set(
        playerData.position.x,
        playerData.position.y || 0.5,
        playerData.position.z
      );
    }
    
    // Set initial rotation if provided
    if (playerData.rotation !== undefined) {
      ship.rotation.y = playerData.rotation;
    }
    
    console.log('Player object created successfully:', {
      id: playerData.id,
      name: playerData.name,
      shipType,
      position: ship.position.toArray(),
      rotation: ship.rotation.y
    });
    
    // Return the player object
    return {
      mesh: ship,
      nameLabel,
      engineGlow,
      team: playerData.team,
      health: 100,
      shipType,
      lastUpdate: Date.now()
    };
  }
  
  // Update other player with new data
  updateOtherPlayer(player, data) {
    if (!player || !player.mesh) {
      console.warn('Invalid player object for update:', { player, data });
      return;
    }
    
    const now = Date.now();
    const timeSinceLastUpdate = now - (player.lastUpdate || 0);
    console.log(`Updating player ${data.id}, time since last update: ${timeSinceLastUpdate}ms`);
    
    // Update position with smooth lerping
    if (data.position) {
      const targetPos = new THREE.Vector3(
        data.position.x,
        data.position.y || 0.5,
        data.position.z
      );
      
      const currentPos = player.mesh.position.clone();
      player.mesh.position.lerp(targetPos, 0.3);
      
      // Log position change
      const distance = currentPos.distanceTo(player.mesh.position);
      if (distance > 0.01) {
        console.log('Position updated:', {
          from: currentPos.toArray(),
          to: player.mesh.position.toArray(),
          distance: distance.toFixed(3)
        });
      }
    }
    
    // Update rotation with smooth interpolation
    if (data.rotation !== undefined) {
      const currentRotation = player.mesh.rotation.y;
      
      // Find shortest rotation path
      let rotDiff = data.rotation - currentRotation;
      if (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
      if (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
      
      const newRotation = currentRotation + rotDiff * 0.3;
      player.mesh.rotation.y = newRotation;
      
      // Log significant rotation changes
      if (Math.abs(rotDiff) > 0.1) {
        console.log('Rotation updated:', {
          from: currentRotation.toFixed(3),
          to: newRotation.toFixed(3),
          difference: rotDiff.toFixed(3)
        });
      }
    }
    
    // Update team if changed
    if (data.team !== undefined && data.team !== player.team) {
      console.log('Team changed:', { from: player.team, to: data.team });
      player.team = data.team;
    }
    
    // Update last update timestamp
    player.lastUpdate = now;
  }

  handleAssetError(type, error) {
    console.error(`Asset loading error (${type}):`, error);
    if (type === 'critical') {
      // Show error UI
      this.ui.showError('Failed to load game assets. Please refresh the page.');
    }
  }
} 
### ./core/GameEngine.js END ###

### ./core/Engine.js BEGIN ###
import * as THREE from 'three';

class Engine {
    constructor() {
        // Core engine properties
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        this.lastTime = Date.now();
        
        // Bind methods
        this.animate = this.animate.bind(this);
        this.handleResize = this.handleResize.bind(this);
    }

    init() {
        this.setupScene();
        this.setupRenderer();
        this.setupCamera();
        this.setupLights();
        this.setupEventListeners();
        
        return this;
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000011);
    }

    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(this.renderer.domElement);
    }

    setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        this.camera.position.set(0, 15, -10);
        this.camera.lookAt(0, 0, 0);

        // Camera smoothing properties
        this.cameraTargetPosition = new THREE.Vector3();
        this.cameraTargetLookAt = new THREE.Vector3();
        this.cameraSmoothingFactor = 0.05;
    }

    setupLights() {
        const ambientLight = new THREE.AmbientLight(0x404040);
        this.scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(1, 1, 1).normalize();
        this.scene.add(directionalLight);
    }

    setupEventListeners() {
        window.addEventListener('resize', this.handleResize);
    }

    handleResize() {
        if (this.camera && this.renderer) {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        }
    }

    animate() {
        requestAnimationFrame(this.animate);

        const now = Date.now();
        const deltaTime = (now - this.lastTime) / 1000;
        this.lastTime = now;

        // Update game state
        if (this.update) {
            this.update(deltaTime);
        }

        // Render scene
        if (this.scene && this.camera) {
            this.renderer.render(this.scene, this.camera);
        }
    }

    start() {
        this.animate();
    }

    cleanup() {
        // Remove event listeners
        window.removeEventListener('resize', this.handleResize);

        // Cleanup THREE.js resources
        this.scene?.traverse(object => {
            if (object.geometry) {
                object.geometry.dispose();
            }
            if (object.material) {
                if (Array.isArray(object.material)) {
                    object.material.forEach(material => material.dispose());
                } else {
                    object.material.dispose();
                }
            }
        });

        // Dispose of renderer
        if (this.renderer) {
            this.renderer.dispose();
            document.body.removeChild(this.renderer.domElement);
        }
    }

    // Utility methods for scene management
    add(...objects) {
        objects.forEach(object => this.scene.add(object));
    }

    remove(...objects) {
        objects.forEach(object => this.scene.remove(object));
    }
}

export default Engine; 
### ./core/Engine.js END ###

### ./core/NetworkManager.js BEGIN ###
import { EventEmitter } from 'events';
import { io } from 'socket.io-client';

export class NetworkManager extends EventEmitter {
  constructor() {
    super();
    this.socket = null;
    this.playerId = null;
    this.connected = false;
    this.players = new Map();
    this.lastUpdateTime = 0;
    this.updateInterval = 50; // 20 updates per second
  }

  connect(serverUrl = 'http://localhost:3000') {
    // Don't reconnect if already connected
    if (this.connected) return;

    // Create socket connection
    this.socket = io(serverUrl, {
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 10
    });

    // Set up event handlers
    this.socket.on('connect', () => {
      console.log('Connected to game server');
      this.connected = true;
      this.emit('connected');
    });

    this.socket.on('disconnect', () => {
      console.log('Disconnected from game server');
      this.connected = false;
      this.emit('disconnected');
    });

    this.socket.on('player_id', (id) => {
      this.playerId = id;
      console.log(`Assigned player ID: ${id}`);
      this.emit('player_id', id);
    });

    this.socket.on('player_joined', (player) => {
      if (player.id !== this.playerId) {
        this.players.set(player.id, player);
        console.log(`Player joined: ${player.id}`);
        this.emit('player_joined', player);
      }
    });

    this.socket.on('player_left', (id) => {
      this.players.delete(id);
      console.log(`Player left: ${id}`);
      this.emit('player_left', id);
    });

    this.socket.on('player_update', (update) => {
      if (update.id !== this.playerId) {
        const player = this.players.get(update.id);
        if (player) {
          // Update the player with new data
          Object.assign(player, update);
          player.lastUpdate = Date.now();
          this.emit('player_update', update);
        }
      }
    });

    this.socket.on('laser_shot', (data) => {
      if (data.playerId !== this.playerId) {
        this.emit('laser_shot', data);
      }
    });

    // Handle initial player list
    this.socket.on('players', (players) => {
      players.forEach(player => {
        if (player.id !== this.playerId) {
          this.players.set(player.id, player);
        }
      });
      this.emit('players', players);
    });

    // Handle error
    this.socket.on('error', (error) => {
      console.error('Socket error:', error);
      this.emit('error', error);
    });
  }

  disconnect() {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.playerId = null;
      this.connected = false;
      this.players.clear();
    }
  }

  sendPlayerUpdate(data) {
    if (!this.connected || !this.socket) return;

    const now = Date.now();
    // Throttle updates to save bandwidth
    if (now - this.lastUpdateTime < this.updateInterval) return;
    
    this.lastUpdateTime = now;
    
    this.socket.emit('player_update', {
      id: this.playerId,
      ...data
    });
  }

  sendLaserShot(data) {
    if (!this.connected || !this.socket) return;
    
    this.socket.emit('laser_shot', {
      playerId: this.playerId,
      ...data
    });
  }

  updatePlayerInfo(name, shipType) {
    if (!this.connected || !this.socket) return;
    
    this.socket.emit('player_info', {
      id: this.playerId,
      name: name,
      shipType: shipType
    });
  }

  // Get all other players (not including self)
  getOtherPlayers() {
    return Array.from(this.players.values());
  }

  isConnected() {
    return this.connected;
  }

  getPlayerId() {
    return this.playerId;
  }
} 
### ./core/NetworkManager.js END ###

### ./core/InfiniteMap.js BEGIN ###
import * as THREE from 'three';

/**
 * Manages an infinite map system using chunks
 */
export class InfiniteMap {
  constructor(game) {
    this.game = game;
    this.chunks = new Map(); // Map of loaded chunks
    this.chunkSize = 100; // Size of each chunk in world units
    this.loadDistance = 2; // Number of chunks to load in each direction
    this.cullingDistance = 3; // Number of chunks before culling
    
    // Track current chunk
    this.currentChunkX = 0;
    this.currentChunkZ = 0;
    
    // Asset categories for random placement
    this.assetCategories = {
      flora: [
        'SP_Plant07.glb',
        'SP_Plant08.glb',
        'SP_Tree01.glb',
        'SP_Tree02.glb',
        'SP_Tree03.glb',
        'SP_Tree04.glb',
      ],
      rocks: [
        'SP_Rock01.glb',
        'SP_Rock02.glb',
        'SP_Rock03.glb',
        'SP_Rock04.glb',
        'SP_Rock05.glb',
        'SP_Rock06.glb',
        'SP_Rock07.glb',
        'SP_Rock08.glb',
        'SP_Rock09.glb'
      ],
      objects: [
        'SP_Crystal01.glb',
        'SP_Ground02.glb',
        'SP_Ground03.glb',
        'SP_Ground04.glb',
        'SP_Ground05.glb',
        'SP_Mountain01.glb',
        'SP_Mountain02.glb',
        'SP_Mountain03.glb',
        'SP_Stone01.glb'
      ]
    };
  }

  /**
   * Get chunk key from world coordinates
   */
  getChunkKey(x, z) {
    const chunkX = Math.floor(x / this.chunkSize);
    const chunkZ = Math.floor(z / this.chunkSize);
    return `${chunkX},${chunkZ}`;
  }

  /**
   * Update chunks based on player position
   */
  update(playerPosition) {
    // Get current chunk from player position
    const newChunkX = Math.floor(playerPosition.x / this.chunkSize);
    const newChunkZ = Math.floor(playerPosition.z / this.chunkSize);

    // If chunk changed, update loaded chunks
    if (newChunkX !== this.currentChunkX || newChunkZ !== this.currentChunkZ) {
      this.currentChunkX = newChunkX;
      this.currentChunkZ = newChunkZ;
      this.updateLoadedChunks();
    }
  }

  /**
   * Update which chunks are loaded based on current position
   */
  updateLoadedChunks() {
    // Track which chunks should be kept
    const chunksToKeep = new Set();

    // Calculate chunks to load
    for (let x = -this.loadDistance; x <= this.loadDistance; x++) {
      for (let z = -this.loadDistance; z <= this.loadDistance; z++) {
        const chunkX = this.currentChunkX + x;
        const chunkZ = this.currentChunkZ + z;
        const key = `${chunkX},${chunkZ}`;
        chunksToKeep.add(key);

        // Load chunk if not already loaded
        if (!this.chunks.has(key)) {
          this.loadChunk(chunkX, chunkZ);
        }
      }
    }

    // Unload chunks that are too far away
    for (const [key, chunk] of this.chunks) {
      if (!chunksToKeep.has(key)) {
        const distance = Math.max(
          Math.abs(chunk.x - this.currentChunkX),
          Math.abs(chunk.z - this.currentChunkZ)
        );

        if (distance > this.cullingDistance) {
          this.unloadChunk(key);
        }
      }
    }
  }

  /**
   * Load a new chunk at the specified coordinates
   */
  loadChunk(chunkX, chunkZ) {
    const key = `${chunkX},${chunkZ}`;
    
    // Create chunk container
    const chunk = {
      x: chunkX,
      z: chunkZ,
      objects: [],
      group: new THREE.Group()
    };

    // Calculate world position of chunk corner
    const worldX = chunkX * this.chunkSize;
    const worldZ = chunkZ * this.chunkSize;

    // Add random objects to chunk
    this.populateChunk(chunk, worldX, worldZ);

    // Add chunk to scene
    this.game.scene.add(chunk.group);
    this.chunks.set(key, chunk);
  }

  /**
   * Populate a chunk with random objects
   */
  populateChunk(chunk, worldX, worldZ) {
    // Number of objects to place in each category
    const counts = {
      flora: this.getRandomInt(3, 6),
      rocks: this.getRandomInt(2, 4),
      objects: this.getRandomInt(1, 3)
    };

    // Place objects from each category
    for (const [category, assets] of Object.entries(this.assetCategories)) {
      for (let i = 0; i < counts[category]; i++) {
        // Get random asset from category
        const assetPath = assets[Math.floor(Math.random() * assets.length)];
        
        // Calculate random position within chunk
        const x = worldX + Math.random() * this.chunkSize;
        const z = worldZ + Math.random() * this.chunkSize;

        // Load and place object
        this.game.assetLoader.loadModel(`models/${category}/${assetPath}`)
          .then(model => {
            // Random rotation
            model.rotation.y = Math.random() * Math.PI * 2;

            // Random scale based on category
            let scale = 1;
            if (category === 'flora') {
              scale = 0.5 + Math.random() * 0.5;
            } else if (category === 'rocks') {
              scale = 0.3 + Math.random() * 0.4;
            } else {
              scale = 0.2 + Math.random() * 0.3;
            }
            model.scale.set(scale, scale, scale);

            // Position object
            model.position.set(x, 0, z);

            // Add to chunk group
            chunk.group.add(model);

            // Store object data for collision
            chunk.objects.push({
              model,
              position: model.position.clone(),
              radius: this.calculateCollisionRadius(model, scale),
              type: category
            });
          })
          .catch(error => console.error('Error loading model:', error));
      }
    }
  }

  /**
   * Calculate appropriate collision radius for an object
   */
  calculateCollisionRadius(model, scale) {
    // Calculate using bounding box for more accuracy
    const bbox = new THREE.Box3().setFromObject(model);
    const size = bbox.getSize(new THREE.Vector3());
    
    // Use the larger of width or depth (horizontal dimensions)
    const radius = Math.max(size.x, size.z) / 2;
    
    // Apply scale
    const scaledRadius = radius * scale;
    
    // Add small padding (10%) for better collision detection
    return scaledRadius * 1.1;
  }

  /**
   * Unload a chunk and remove it from the scene
   */
  unloadChunk(key) {
    const chunk = this.chunks.get(key);
    if (chunk) {
      // Remove from scene
      this.game.scene.remove(chunk.group);
      
      // Dispose of geometries and materials
      chunk.group.traverse(object => {
        if (object.geometry) {
          object.geometry.dispose();
        }
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach(material => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });

      // Remove from chunks map
      this.chunks.delete(key);
    }
  }

  /**
   * Get random integer between min and max (inclusive)
   */
  getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * Check for collisions with objects in nearby chunks
   */
  checkCollisions(position, radius) {
    const currentKey = this.getChunkKey(position.x, position.z);
    const nearbyChunks = this.getNearbyChunks(currentKey);
    
    // First, do a quick sphere-based check for efficiency
    for (const chunk of nearbyChunks) {
      for (const object of chunk.objects) {
        const distance = position.distanceTo(object.position);
        const quickCheckDistance = radius + object.radius;
        
        // Skip detailed check if clearly not colliding
        if (distance > quickCheckDistance * 1.2) continue;
        
        // For close objects, do a more accurate bounding box check
        const model = object.model;
        
        // Get bounding box in world space
        const bbox = new THREE.Box3().setFromObject(model);
        
        // Create a sphere representing the player
        const playerSphere = {
          center: position.clone(),
          radius: radius
        };
        
        // Check if sphere intersects with box - simple approximation
        const collision = this.checkSphereBoxIntersection(playerSphere, bbox);
        
        if (collision) {
          return {
            collided: true,
            object: {
              position: object.position.clone(),
              radius: object.radius,
              type: object.type
            },
            distance: distance
          };
        }
      }
    }
    
    return { collided: false };
  }

  /**
   * Check if a sphere intersects with a box
   */
  checkSphereBoxIntersection(sphere, box) {
    // Find the closest point on the box to the sphere
    const closestPoint = new THREE.Vector3().copy(sphere.center);
    
    // For each axis, clamp the sphere center to the box bounds
    closestPoint.x = Math.max(box.min.x, Math.min(box.max.x, closestPoint.x));
    closestPoint.y = Math.max(box.min.y, Math.min(box.max.y, closestPoint.y));
    closestPoint.z = Math.max(box.min.z, Math.min(box.max.z, closestPoint.z));
    
    // Calculate distance from closest point to sphere center
    const distance = closestPoint.distanceTo(sphere.center);
    
    // If this distance is less than the sphere radius, we have a collision
    return distance < sphere.radius;
  }

  /**
   * Get array of chunks near the specified chunk
   */
  getNearbyChunks(key) {
    const [x, z] = key.split(',').map(Number);
    const nearby = [];
    
    for (let dx = -1; dx <= 1; dx++) {
      for (let dz = -1; dz <= 1; dz++) {
        const nearbyKey = `${x + dx},${z + dz}`;
        const chunk = this.chunks.get(nearbyKey);
        if (chunk) {
          nearby.push(chunk);
        }
      }
    }
    
    return nearby;
  }
} 
### ./core/InfiniteMap.js END ###

### ./config/ShipConfig.js BEGIN ###
export const SHIP_TYPES = {
    SCOUT: 'SCOUT',
    INTERCEPTOR: 'INTERCEPTOR',
    HEAVY: 'HEAVY'
};

export const SHIP_STATUS = {
    FREE: 'FREE',
    PREMIUM: 'PREMIUM'
};

export const SHIP_CONFIGS = {
    [SHIP_TYPES.SCOUT]: {
        name: 'Scout',
        description: 'Fast and agile, but lightly armored',
        status: SHIP_STATUS.FREE,
        stats: {
            health: 80,
            speed: 0.2,
            size: 0.8,
            turnSpeed: 0.15,
            acceleration: 0.12
        },
        model: 'SCOUT',
        abilities: ['Quick Boost', 'Stealth Mode']
    },
    [SHIP_TYPES.INTERCEPTOR]: {
        name: 'Interceptor',
        description: 'Balanced combat vessel',
        status: SHIP_STATUS.FREE,
        stats: {
            health: 100,
            speed: 0.15,
            size: 1.0,
            turnSpeed: 0.1,
            acceleration: 0.1
        },
        model: 'INTERCEPTOR',
        abilities: ['Shield Burst', 'EMP Blast']
    },
    [SHIP_TYPES.HEAVY]: {
        name: 'Heavy Destroyer',
        description: 'Premium battle cruiser with superior firepower',
        status: SHIP_STATUS.PREMIUM,
        stats: {
            health: 150,
            speed: 0.12,
            size: 1.2,
            turnSpeed: 0.08,
            acceleration: 0.08
        },
        model: 'HEAVY',
        abilities: ['Heavy Shield', 'Missile Barrage', 'Area Denial']
    }
};

export class ShipSelector {
    static getAvailableShips(isPremium = false) {
        return Object.entries(SHIP_CONFIGS)
            .filter(([_, config]) => 
                config.status === SHIP_STATUS.FREE || 
                (isPremium && config.status === SHIP_STATUS.PREMIUM)
            )
            .map(([type, config]) => ({
                type,
                ...config
            }));
    }

    static getShipConfig(type) {
        return SHIP_CONFIGS[type];
    }

    static isShipAvailable(type, isPremium = false) {
        const config = SHIP_CONFIGS[type];
        return config && (
            config.status === SHIP_STATUS.FREE || 
            (isPremium && config.status === SHIP_STATUS.PREMIUM)
        );
    }
} 
### ./config/ShipConfig.js END ###

### ./config/Controls.js BEGIN ###
// Control configuration for the game
// This file centralizes all control-related settings and mappings

// Key mappings for different actions
export const KEY_MAPPINGS = {
    // Movement controls
    MOVEMENT: {
        FORWARD: ['KeyW', 'ArrowUp'],
        BACKWARD: ['KeyS', 'ArrowDown'],
        LEFT: ['KeyA', 'ArrowLeft'],
        RIGHT: ['KeyD', 'ArrowRight'],
        STRAFE_LEFT: ['KeyQ'],
        STRAFE_RIGHT: ['KeyE']
    },
    // Weapon controls
    WEAPONS: {
        FIRE: ['Space'],
        SELECT_LASER: ['Digit1'],
        SELECT_GRENADE: ['Digit2'],
        SELECT_BOUNCE: ['Digit3'],
        SWITCH_WEAPON: ['KeyX']
    },
    // UI controls
    UI: {
        TOGGLE_MAP: ['KeyM'],
        TOGGLE_CONTROLS: ['KeyC']
    }
};

// Control settings and configurations
export const CONTROL_SETTINGS = {
    // Movement settings
    MOVEMENT: {
        ROTATION_SPEED: 2.5,
        SHIP_SPEED: 30,
        ACCELERATION: 1.0,
        DECELERATION: 0.95,
        STRAFE_SPEED_MULTIPLIER: 0.8
    },
    // Weapon cooldowns (in milliseconds)
    WEAPON_COOLDOWNS: {
        LASER: 200,
        BOUNCE: 500,
        GRENADE: 1000
    },
    // Touch controls settings
    TOUCH: {
        JOYSTICK_MAX_DISTANCE: 40,
        JOYSTICK_DEAD_ZONE: 10,
        DOUBLE_TAP_DELAY: 300
    }
};

// Visual feedback settings for controls
export const CONTROL_FEEDBACK = {
    INDICATORS: {
        MOVEMENT: [
            { id: 'forward', key: 'W', label: '⬆️', tooltip: 'Forward' },
            { id: 'backward', key: 'S', label: '⬇️', tooltip: 'Backward' },
            { id: 'left', key: 'A', label: '⬅️', tooltip: 'Turn Left' },
            { id: 'right', key: 'D', label: '➡️', tooltip: 'Turn Right' },
            { id: 'strafeLeft', key: 'Q', label: '↩️', tooltip: 'Strafe Left' },
            { id: 'strafeRight', key: 'E', label: '↪️', tooltip: 'Strafe Right' }
        ],
        WEAPONS: [
            { id: 'selectLaser', key: '1', label: '🔫', tooltip: 'Laser' },
            { id: 'selectGrenade', key: '2', label: '💣', tooltip: 'Grenade' },
            { id: 'selectBounce', key: '3', label: '↗️↘️', tooltip: 'Bounce Laser' },
            { id: 'switchWeapon', key: 'X', label: '🔄', tooltip: 'Switch Weapon' }
        ],
        ACTIONS: [
            { id: 'fire', key: 'CLICK', label: '🔥', tooltip: 'Fire Weapon' }
        ]
    }
};

// Default control state
export const DEFAULT_CONTROL_STATE = {
    forward: false,
    backward: false,
    left: false,
    right: false,
    strafeLeft: false,
    strafeRight: false,
    fire: false,
    switchWeapon: false
};

// Helper functions for control handling
export const ControlUtils = {
    /**
     * Check if a key code matches any of the specified actions
     * @param {string} keyCode - The key code to check
     * @param {string} action - The action to check against
     * @param {string} category - The category of the action (MOVEMENT, WEAPONS, UI)
     * @returns {boolean} - Whether the key matches the action
     */
    isKeyMatch: (keyCode, action, category) => {
        return KEY_MAPPINGS[category]?.[action]?.includes(keyCode) || false;
    },

    /**
     * Get the action for a given key code
     * @param {string} keyCode - The key code to check
     * @returns {Object|null} - The matching action and category, or null if no match
     */
    getActionForKey: (keyCode) => {
        for (const [category, actions] of Object.entries(KEY_MAPPINGS)) {
            for (const [action, keys] of Object.entries(actions)) {
                if (keys.includes(keyCode)) {
                    return { category, action };
                }
            }
        }
        return null;
    },

    /**
     * Check if a key is a weapon selection key
     * @param {string} keyCode - The key code to check
     * @returns {boolean} - Whether the key is a weapon selection key
     */
    isWeaponSelectionKey: (keyCode) => {
        return KEY_MAPPINGS.WEAPONS.SELECT_LASER.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SELECT_GRENADE.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SELECT_BOUNCE.includes(keyCode) ||
               KEY_MAPPINGS.WEAPONS.SWITCH_WEAPON.includes(keyCode);
    }
}; 
### ./config/Controls.js END ###

### ./config/GameConfig.js BEGIN ###
export const GAME_CONFIG = {
    PLAYER: {
        INITIAL_HEALTH: 100,
        INITIAL_ENERGY: 100,
        ENERGY_RECHARGE_RATE: 20,
        MOVEMENT_SPEED: 0.1,
        ROTATION_SPEED: 0.05,
        COLLISION_RADIUS: 0.8
    },
    
    WEAPONS: {
        LASER: {
            COOLDOWN: 200,
            SPEED: 1.2,
            DAMAGE: 10,
            ENERGY_COST: 25,
            TRAIL_LENGTH: 8
        },
        BOUNCE: {
            COOLDOWN: 500,
            SPEED: 0.8,
            DAMAGE: 25,
            ENERGY_COST: 50,
            MAX_BOUNCES: 3,
            TRAIL_LENGTH: 12
        },
        GRENADE: {
            COOLDOWN: 1000,
            EXPLOSION_RADIUS: 4,
            MAX_DAMAGE: 50,
            ENERGY_COST: 100,
            TRAIL_LENGTH: 20
        }
    },
    
    SCENE: {
        BOUNDARY_SIZE: 25,
        GRID_SIZE: 100,
        GRID_DIVISIONS: 100,
        NUM_OBSTACLES: 15,
        MIN_OBSTACLE_DISTANCE: 10
    },
    
    CAMERA: {
        FOV: 75,
        NEAR: 0.1,
        FAR: 1000,
        POSITION: {
            Y: 18,
            Z: -16
        },
        SMOOTHING: 0.05
    },
    
    COLORS: {
        BACKGROUND: 0x000011,
        GRID: {
            MAIN: 0x444444,
            SECONDARY: 0x222222
        },
        LASER: 0x00ffff,
        BOUNCE: 0x00ff99,
        GRENADE: 0xff4500
    },
    
    EFFECTS: {
        PULSE_SPEED: 0.2,
        TRAIL_OPACITY: 0.5,
        GLOW_INTENSITY: 2
    }
};

// Weapon type constants
export const WEAPON_TYPES = {
    LASER: 'LASER',
    BOUNCE: 'BOUNCE',
    GRENADE: 'GRENADE'
}; 
### ./config/GameConfig.js END ###

### ./styles/main.css BEGIN ###
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --neon-text-color: #f40183;
  --neon-border-color: #08f;
  --bg-color: #000;
  --secondary-color: #0ff;
  --accent-color: #ff00ff;
  --success-color: #00ff88;
  --warning-color: #ffaa00;
  --danger-color: #ff3300;
}

body {
  font-family: 'Orbitron', sans-serif;
  background-color: var(--bg-color);
  color: #fff;
  overflow: hidden;
}

/* Loading Screen */
#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: var(--bg-color);
  z-index: 100;
}

.loading-content {
  text-align: center;
}

.loading-content h1 {
  font-size: 4rem;
  margin-bottom: 2rem;
  text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--neon-text-color),
    0 0 20px var(--neon-text-color), 0 0 25px var(--neon-text-color),
    0 0 30px var(--neon-text-color), 0 0 35px var(--neon-text-color);
}

.loader {
  border: 5px solid transparent;
  border-top: 5px solid var(--neon-text-color);
  border-radius: 50%;
  width: 50px;
  height: 50px;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem;
  box-shadow: 0 0 10px var(--neon-text-color);
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Start Screen Enhancements */
#start-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  background: radial-gradient(circle at center, rgba(15, 30, 60, 0.5) 0%, rgba(0, 0, 0, 0.95) 70%);
  overflow: hidden;
}

#start-screen::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: linear-gradient(125deg, rgba(0, 60, 255, 0.05), rgba(120, 0, 170, 0.05));
  z-index: -1;
}

.start-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  max-width: 600px;
  width: 90%;
  padding: 2rem;
  border-radius: 8px;
  background: rgba(5, 10, 20, 0.7);
  box-shadow: 0 0 40px rgba(0, 195, 255, 0.15);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(48, 197, 255, 0.2);
  transform: translateY(0);
  animation: float 6s ease-in-out infinite;
}

@keyframes float {
  0% { transform: translateY(0px); }
  50% { transform: translateY(-15px); }
  100% { transform: translateY(0px); }
}

.start-content h1 {
  font-size: 3.5rem;
  font-weight: 900;
  margin-bottom: 2rem;
  text-align: center;
  color: #fff;
  text-shadow: 
    0 0 10px #ff007b,
    0 0 20px #ff007b,
    0 0 30px #ff007b,
    0 0 40px #ff007b;
  letter-spacing: 0.1em;
  animation: pulsate 2s infinite;
}

@keyframes pulsate {
  0% { text-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 30px #ff007b, 0 0 40px #ff007b; }
  50% { text-shadow: 0 0 15px #ff007b, 0 0 25px #ff007b, 0 0 35px #ff007b, 0 0 50px #ff007b; }
  100% { text-shadow: 0 0 10px #ff007b, 0 0 20px #ff007b, 0 0 30px #ff007b, 0 0 40px #ff007b; }
}

/* Buttons */
.glow-button {
  background-color: transparent;
  color: var(--neon-border-color);
  border: 0.2rem solid var(--neon-border-color);
  border-radius: 0.5rem;
  padding: 1rem 2rem;
  font-size: 1.5rem;
  font-family: 'Orbitron', sans-serif;
  cursor: pointer;
  transition: all 0.3s;
  text-shadow: 0 0 5px var(--neon-border-color), 0 0 10px var(--neon-border-color);
  box-shadow: 0 0 10px var(--neon-border-color), inset 0 0 10px var(--neon-border-color);
}

.glow-button:hover {
  background-color: var(--neon-border-color);
  color: #000;
  box-shadow: 0 0 20px var(--neon-border-color), inset 0 0 20px #000;
}

/* Canvas */
canvas {
  display: block;
}

/* HUD Elements */
.hud {
  position: fixed;
  top: 20px;
  left: 20px;
  color: var(--secondary-color);
  font-size: 1rem;
  text-shadow: 0 0 5px var(--secondary-color);
  z-index: 100;
  pointer-events: none;
}

/* Controls info */
.controls-info {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid #00ffff;
  border-radius: 10px;
  padding: 20px;
  color: #fff;
  text-align: center;
  z-index: 1000;
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
  animation: fadeIn 0.5s ease-in-out;
}

.controls-info h3 {
  color: #00ffff;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 24px;
}

.controls-info p {
  margin: 8px 0;
  font-size: 16px;
  color: #eee;
}

.controls-info.fade-out {
  animation: fadeOut 0.5s ease-in-out forwards;
}

/* Ensure these keyframes are defined */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Fix hidden class */
.hidden {
  display: none !important;
}

/* Controls */
.control-indicators {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 15px;
  transition: opacity 0.5s ease, transform 0.3s ease;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.4);
  backdrop-filter: blur(5px);
}

.control-indicators.visible {
  opacity: 1;
  transform: translateY(0);
}

.control-indicators.fading {
  opacity: 0.2;
  transform: translateY(10px);
}

.control-indicators.hidden {
  opacity: 0;
  transform: translateY(30px);
  pointer-events: none;
}

.control-group {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
}

.movement-controls {
  display: grid;
  grid-template-areas:
    ".    forward    ."
    "left backward right"
    "strafeLeft fire strafeRight";
  grid-gap: 5px;
}

.weapon-controls {
  display: flex;
  justify-content: center;
  gap: 10px;
}

.key-indicator {
  width: 50px;
  height: 50px;
  background: rgba(20, 20, 30, 0.8);
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #aaf;
  font-family: 'Rajdhani', sans-serif;
  border: 1px solid rgba(0, 200, 255, 0.2);
  transition: all 0.2s ease;
  box-shadow: 0 0 5px rgba(0, 200, 255, 0.1);
  overflow: hidden;
}

.key-indicator.active {
  background: rgba(0, 150, 200, 0.4);
  color: #fff;
  border-color: rgba(0, 255, 255, 0.8);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
  transform: scale(1.05);
}

.key-indicator .key {
  font-size: 12px;
  background: rgba(0, 0, 0, 0.5);
  padding: 2px 5px;
  border-radius: 4px;
  margin-bottom: 3px;
  font-weight: bold;
}

.key-indicator .label {
  font-size: 18px;
  line-height: 1;
}

.weapon-key {
  background: rgba(30, 20, 40, 0.8);
  border-color: rgba(255, 100, 255, 0.2);
}

.weapon-key.active {
  background: rgba(150, 0, 200, 0.4);
  border-color: rgba(255, 100, 255, 0.8);
  box-shadow: 0 0 15px rgba(255, 100, 255, 0.5);
}

.controls-hint {
  text-align: center;
  font-size: 12px;
  color: rgba(255, 255, 255, 0.6);
  margin-top: 5px;
  font-family: 'Rajdhani', sans-serif;
}

/* Game UI */
.game-ui {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10;
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 220px;
  background: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  backdrop-filter: blur(5px);
  box-shadow: 0 0 15px rgba(0, 200, 255, 0.2);
  border: 1px solid rgba(0, 200, 255, 0.3);
  transition: all 0.3s ease;
}

.game-ui.hidden {
  display: none;
  opacity: 0;
}

.status-bars {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.bar-container {
  display: flex;
  align-items: center;
  gap: 10px;
}

.bar-container {
  flex-direction: row;
}

.bar-label {
  width: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: #fff;
  font-weight: bold;
  order: 1;
}

.bar-outer {
  flex: 1;
  height: 10px;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 5px;
  overflow: hidden;
  position: relative;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
  order: 2;
}

.bar-inner {
  height: 100%;
  transition: width 0.3s ease, background-color 0.3s ease;
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.health-bar {
  background: linear-gradient(90deg, #0f0, #5f0);
  box-shadow: 0 0 8px rgba(0, 255, 0, 0.5);
}

.health-bar.warning {
  background: linear-gradient(90deg, #ff0, #fa0);
  box-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
}

.health-bar.critical {
  background: linear-gradient(90deg, #f00, #a00);
  box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
  animation: pulse-critical 0.8s infinite;
}

.energy-bar {
  background: linear-gradient(90deg, #00f, #06f);
  box-shadow: 0 0 8px rgba(0, 0, 255, 0.5);
}

.energy-bar.warning {
  background: linear-gradient(90deg, #09f, #07a);
  box-shadow: 0 0 8px rgba(0, 100, 255, 0.5);
}

.energy-bar.critical {
  background: linear-gradient(90deg, #07f, #059);
  box-shadow: 0 0 8px rgba(0, 50, 255, 0.5);
}

.weapon-indicator {
  display: flex;
  align-items: center;
  margin-top: 5px;
  background: rgba(0, 0, 0, 0.4);
  border-radius: 5px;
  padding: 5px 10px;
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.weapon-label {
  font-size: 14px;
  color: #aaa;
  margin-right: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.weapon-name {
  flex: 1;
  text-align: right;
  font-size: 16px;
  font-weight: bold;
  color: #fff;
  letter-spacing: 1px;
  text-shadow: 0 0 5px currentColor;
}

.weapon-name.laser {
  color: #0ff;
}

.weapon-name.grenade {
  color: #f70;
}

.weapon-name.bounce {
  color: #0f6;
}

/* Health bar shine effect */
.bar-inner::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 50%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
  animation: shine 2s infinite;
}

@keyframes shine {
  0% { left: -100%; }
  100% { left: 200%; }
}

@media (max-width: 768px) {
  .game-ui {
    top: 10px;
    left: 10px;
    width: 180px;
    padding: 10px;
  }
  
  .bar-label, .weapon-label {
    font-size: 12px;
  }
  
  .weapon-name {
    font-size: 14px;
  }
}

.bar-percentage {
  margin-left: 5px;
  color: #fff;
  font-size: 12px;
  min-width: 40px;
  text-align: right;
  order: 3;
}

/* Position indicators in the grid */
#indicator-forward { grid-area: forward; }
#indicator-backward { grid-area: backward; }
#indicator-left { grid-area: left; }
#indicator-right { grid-area: right; }
#indicator-strafeLeft { grid-area: strafeLeft; }
#indicator-strafeRight { grid-area: strafeRight; }
#indicator-fire { grid-area: fire; }

/* Special styling for fire key */
#indicator-fire {
  width: 80px;
  grid-column: span 3;
}

/* Collision Flash Effect */
.collision-flash {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 0, 0, 0.2);
  z-index: 1000;
  pointer-events: none;
  animation: flash 0.15s ease-out;
}

@keyframes flash {
  0% { opacity: 0; }
  50% { opacity: 1; }
  100% { opacity: 0; }
}

/* Score Display */
.score-display {
  position: fixed;
  top: 20px;
  right: 20px;
  font-size: 1.5rem;
  color: var(--neon-text-color);
  text-shadow: 0 0 5px var(--neon-text-color);
  z-index: 100;
}

/* Mobile Touch Controls */
.touch-controls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  right: 20px;
  z-index: 90;
  display: none; /* Hidden by default, shown on touch devices */
  justify-content: space-between;
  align-items: center;
  pointer-events: none;
  height: 120px;
}

/* Media query for touch devices */
@media (pointer: coarse) {
  .touch-controls {
    display: flex;
  }
  
  .controls-info {
    display: none; /* Hide keyboard controls info on touch devices */
  }
}

/* Controls toggle button for touch devices */
.controls-toggle-button {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 101;
  background: rgba(0, 0, 0, 0.6);
  color: #00ffff;
  border: 1px solid rgba(0, 255, 255, 0.4);
  border-radius: 10px;
  padding: 10px 15px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 16px;
  cursor: pointer;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  transition: all 0.3s ease;
  display: none; /* Hidden by default, shown on touch devices */
}

.controls-toggle-button:hover,
.controls-toggle-button:active {
  background: rgba(0, 50, 70, 0.8);
  box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
}

/* Responsive designs for different devices */

/* Base styles (desktop) */
.control-indicators {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  gap: 15px;
  transition: opacity 0.5s ease, transform 0.3s ease;
  background: rgba(0, 0, 0, 0.6);
  border-radius: 10px;
  padding: 15px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.4);
  backdrop-filter: blur(5px);
}

.key-indicator {
  width: 50px;
  height: 50px;
}

.key-indicator .key {
  font-size: 12px;
}

.key-indicator .label {
  font-size: 18px;
}

/* Large tablet and desktop (landscape) */
@media (min-width: 1024px) {
  .control-indicators {
    bottom: 30px;
    left: 30px;
    padding: 20px;
  }
  
  .key-indicator {
    width: 60px;
    height: 60px;
  }
  
  .key-indicator .key {
    font-size: 14px;
  }
  
  .key-indicator .label {
    font-size: 22px;
  }
  
  .game-ui {
    top: 30px;
    left: 30px;
    width: 250px;
  }
}

/* iPad and smaller tablets */
@media (min-width: 768px) and (max-width: 1023px) {
  .control-indicators {
    bottom: 20px;
    left: 20px;
    padding: 15px;
  }
  
  .key-indicator {
    width: 55px;
    height: 55px;
  }
  
  .game-ui {
    width: 220px;
  }
}

/* Mobile phones (portrait) */
@media (max-width: 767px) {
  .control-indicators {
    bottom: 10px;
    left: 10px;
    padding: 10px;
    gap: 8px;
  }
  
  .key-indicator {
    width: 40px;
    height: 40px;
  }
  
  .key-indicator .key {
    font-size: 10px;
  }
  
  .key-indicator .label {
    font-size: 14px;
  }
  
  .game-ui {
    top: 10px;
    left: 10px;
    width: 180px;
    padding: 10px;
  }
  
  .bar-label, .weapon-label {
    font-size: 12px;
  }
  
  .weapon-name {
    font-size: 14px;
  }
  
  .controls-toggle-button {
    display: block;
    font-size: 14px;
    padding: 8px 12px;
  }
}

/* Very small screens and iPhones in portrait */
@media (max-width: 375px) {
  .control-indicators {
    bottom: 5px;
    left: 5px;
    padding: 8px;
    gap: 5px;
  }
  
  .key-indicator {
    width: 35px;
    height: 35px;
  }
  
  .key-indicator .key {
    font-size: 8px;
  }
  
  .key-indicator .label {
    font-size: 12px;
  }
  
  .game-ui {
    width: 150px;
  }
}

/* Touch device specific styles */
@media (pointer: coarse) {
  .controls-toggle-button {
    display: block;
  }
  
  /* Make touch targets larger */
  .key-indicator {
    min-width: 44px;
    min-height: 44px;
  }
}

/* iPhone-specific fixes - ensure proper viewport */
@media only screen and (max-device-width: 812px) and (-webkit-min-device-pixel-ratio: 2) {
  .touch-controls {
    bottom: env(safe-area-inset-bottom, 20px);
    padding-bottom: 10px;
  }
  
  .controls-toggle-button {
    bottom: env(safe-area-inset-bottom, 20px);
    right: env(safe-area-inset-right, 20px);
  }
}

/* Fix for notched phones */
@supports (padding: max(0px)) {
  .touch-controls {
    padding-left: max(20px, env(safe-area-inset-left));
    padding-right: max(20px, env(safe-area-inset-right));
    padding-bottom: max(20px, env(safe-area-inset-bottom));
  }
}

.joystick-container {
  width: 150px;
  height: 150px;
  margin-left: 10px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
}

.joystick {
  width: 100px;
  height: 100px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 50%;
  border: 2px solid rgba(0, 200, 255, 0.3);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.2);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.joystick-knob {
  width: 40px;
  height: 40px;
  background: rgba(0, 200, 255, 0.7);
  border-radius: 50%;
  box-shadow: 0 0 15px rgba(0, 200, 255, 0.7);
  position: absolute;
  transition: transform 0.1s ease;
}

.touch-button {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 24px;
  background: rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 10px rgba(0, 200, 255, 0.3);
  border: 2px solid rgba(0, 200, 255, 0.3);
  pointer-events: auto;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.fire-button {
  margin-right: 10px;
  background: rgba(50, 0, 0, 0.5);
  border-color: rgba(255, 100, 100, 0.4);
  box-shadow: 0 0 10px rgba(255, 100, 100, 0.3);
}

.weapon-button {
  margin-right: 90px;
  background: rgba(0, 30, 50, 0.5);
}

/* Mini-Map */
.mini-map-container {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 95;
  width: 180px;
  height: 180px;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 8px;
  padding: 5px;
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
  border: 1px solid rgba(0, 255, 255, 0.3);
  backdrop-filter: blur(3px);
  transition: all 0.3s ease;
  transform-origin: bottom right;
  overflow: hidden;
}

.mini-map-container.hidden {
  transform: scale(0);
  opacity: 0;
}

.mini-map {
  width: 100%;
  height: 100%;
  background: rgba(0, 20, 40, 0.4);
  border-radius: 5px;
  border: 1px solid rgba(0, 255, 255, 0.2);
  overflow: hidden;
}

.mini-map canvas {
  width: 100%;
  height: 100%;
}

/* Subtle M key hint */
.mini-map-hint {
  position: absolute;
  bottom: 7px;
  right: 7px;
  font-size: 10px;
  color: rgba(0, 255, 255, 0.5);
  font-family: 'Rajdhani', sans-serif;
  opacity: 0.7;
  text-shadow: 0 0 2px rgba(0, 255, 255, 0.5);
  pointer-events: none;
}

/* Responsive adjustments for mini-map */
@media (max-width: 768px) {
  .mini-map-container {
    width: 150px;
    height: 150px;
  }
}

@media (max-width: 480px) {
  .mini-map-container {
    bottom: 150px; /* Position above touch controls on mobile */
    width: 120px;
    height: 120px;
  }
}

/* Game container */
#game-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 1;
}

#game-container canvas {
  display: block;
  width: 100%;
  height: 100%;
}

/* Error screen */
#error-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.95);
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 1100;
  color: #ff0000;
}

/* Animations */
.fade-in {
  animation: fadeIn 0.5s ease-in forwards;
}

.fade-out {
  animation: fadeOut 0.5s ease-out forwards;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Controls display */
#controls {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  padding: 15px;
  border-radius: 10px;
  z-index: 700;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
  border: 1px solid rgba(0, 255, 255, 0.2);
  box-shadow: 0 0 15px rgba(0, 255, 255, 0.1);
}

#controls.visible {
  opacity: 1;
  visibility: visible;
}

.control-section {
  margin: 10px;
  display: flex;
  gap: 10px;
  align-items: center;
}

.control-indicator {
  display: flex;
  align-items: center;
  gap: 5px;
  padding: 8px 12px;
  border-radius: 5px;
  background: rgba(0, 20, 40, 0.6);
  border: 1px solid rgba(0, 255, 255, 0.1);
  transition: all 0.2s ease;
}

.control-indicator.active {
  background: rgba(0, 100, 150, 0.4);
  border-color: rgba(0, 255, 255, 0.5);
  box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
}

/* Touch controls */
.touch-controls {
  position: fixed;
  bottom: 20px;
  left: 20px;
  z-index: 600;
  display: none;
}

@media (hover: none) and (pointer: coarse) {
  .touch-controls {
    display: block;
  }
}

.joystick-container {
  width: 120px;
  height: 120px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  position: relative;
}

.joystick {
  width: 60px;
  height: 60px;
  background: rgba(0, 255, 255, 0.3);
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

.touch-button {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 50%;
  display: flex;
  justify-content: center;
  align-items: center;
  margin-top: 10px;
  color: #fff;
  font-size: 12px;
  text-align: center;
}

.ship-selection {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 50%;
    max-width: 600px;
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ffff;
    border-radius: 10px;
    padding: 12px;
    color: #fff;
    z-index: 1000;
    box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
}

.ship-selection.visible {
    opacity: 1;
    visibility: visible;
}

.ship-selection.hidden {
    opacity: 0;
    visibility: hidden;
}

.ship-selection-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    padding-bottom: 5px;
    border-bottom: 1px solid rgba(0, 255, 255, 0.3);
}

.ship-selection-header h2 {
    color: #00ffff;
    margin: 0;
    font-size: 18px;
}

.ships-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    margin-bottom: 10px;
}

.ship-option {
    background: rgba(0, 20, 40, 0.5);
    border: 1px solid #333;
    border-radius: 8px;
    padding: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 13px;
}

.ship-option h3 {
    color: #00ffff;
    margin: 0 0 2px 0;
    font-size: 15px;
}

.ship-option p {
    margin: 0 0 5px 0;
    font-size: 11px;
}

.stat {
    margin: 3px 0;
    display: flex;
    align-items: center;
}

.stat label {
    display: inline-block;
    width: 80px;
    color: #888;
    font-size: 11px;
}

.preview-section {
    text-align: center;
    margin-bottom: 10px;
}

.preview-section h3 {
    color: #00ffff;
    margin-bottom: 5px;
    font-size: 15px;
}

#ship-preview {
    width: 100%;
    height: 150px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #333;
}

.ship-details {
    padding: 8px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 6px;
    margin-bottom: 10px;
    border: 1px solid #333;
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-gap: 10px;
}

.ship-details-left {
    grid-column: 1;
}

.ship-details-right {
    grid-column: 2;
}

.ship-name {
    color: #00ffff;
    margin: 0 0 2px 0;
    font-size: 15px;
    grid-column: 1 / -1;
}

.ship-description {
    color: #aaa;
    margin-bottom: 5px;
    font-size: 11px;
    grid-column: 1 / -1;
}

.special-abilities {
    margin-top: 5px;
}

.special-abilities h4 {
    color: #00ffff;
    margin: 0 0 5px 0;
    font-size: 13px;
}

.ability {
    display: inline-block;
    margin: 2px;
    padding: 3px 6px;
    background: rgba(0, 255, 255, 0.1);
    border: 1px solid #00ffff;
    border-radius: 4px;
    color: #00ffff;
    font-size: 11px;
}

.launch-button {
    display: block;
    width: 150px;
    margin: 0 auto;
    padding: 8px 15px;
    background: #00ff00;
    border: none;
    border-radius: 5px;
    color: #000;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    align-self: center;
}

.stat-bar {
    display: inline-block;
    flex: 1;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
    margin: 0 5px;
}

.stat-bar > div {
    height: 100%;
    background: #00ffff;
    transition: width 0.3s ease;
}

.stat-value {
    width: 40px;
    text-align: right;
    color: #00ffff;
    font-size: 11px;
}

.visible {
    display: flex;
    flex-direction: column;
}

/* Player Name Input Styling */
.player-input {
  margin: 20px 0 30px;
  width: 100%;
  max-width: 350px;
  position: relative;
}

#player-name {
  width: 100%;
  padding: 15px 20px;
  border: 2px solid #30c5ff;
  background-color: rgba(0, 10, 30, 0.7);
  color: #fff;
  font-family: 'Orbitron', sans-serif;
  font-size: 16px;
  text-align: center;
  border-radius: 4px;
  box-shadow: 
    0 0 10px rgba(48, 197, 255, 0.5),
    0 0 20px rgba(48, 197, 255, 0.2);
  transition: all 0.3s ease;
  outline: none;
  letter-spacing: 1px;
  position: relative;
  backdrop-filter: blur(5px);
}

#player-name:focus {
  border-color: #ff3e88;
  box-shadow: 
    0 0 15px rgba(255, 62, 136, 0.6),
    0 0 30px rgba(255, 62, 136, 0.3);
  transform: scale(1.02);
}

#player-name::placeholder {
  color: rgba(255, 255, 255, 0.5);
}

.input-info {
  margin-top: 10px;
  font-size: 12px;
  color: #8af3ff;
  text-align: center;
  opacity: 0.8;
  letter-spacing: 0.5px;
  font-weight: 400;
}

/* Enhanced Start Button */
#start-button {
  margin-top: 20px;
  padding: 15px 40px;
  font-size: 18px;
  font-weight: 600;
  letter-spacing: 2px;
  color: #fff;
  background: linear-gradient(45deg, #0062ff, #00c3ff);
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 
    0 0 15px rgba(0, 195, 255, 0.7),
    0 0 30px rgba(0, 195, 255, 0.4);
  position: relative;
  overflow: hidden;
  font-family: 'Orbitron', sans-serif;
  text-transform: uppercase;
}

#start-button::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: linear-gradient(
    to bottom right,
    rgba(255, 255, 255, 0) 0%,
    rgba(255, 255, 255, 0.1) 50%,
    rgba(255, 255, 255, 0) 100%
  );
  transform: rotate(45deg);
  animation: shine 3s infinite;
}

#start-button:hover {
  transform: translateY(-3px) scale(1.05);
  box-shadow: 
    0 0 20px rgba(0, 195, 255, 0.8),
    0 0 40px rgba(0, 195, 255, 0.5);
  background: linear-gradient(45deg, #00c3ff, #0062ff);
}

#start-button:active {
  transform: translateY(1px) scale(0.98);
  box-shadow: 
    0 0 10px rgba(0, 195, 255, 0.6),
    0 0 20px rgba(0, 195, 255, 0.3);
}

@keyframes shine {
  0% { left: -100%; }
  20% { left: 100%; }
  100% { left: 100%; }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .start-content h1 {
    font-size: 2.5rem;
  }
  
  #player-name {
    font-size: 14px;
    padding: 12px 15px;
  }
  
  #start-button {
    padding: 12px 30px;
    font-size: 16px;
  }
}

@media (max-width: 480px) {
  .start-content h1 {
    font-size: 2rem;
  }
  
  .start-content {
    padding: 1.5rem;
  }
}

/* Multiplayer Information */
#multiplayer-info {
  position: absolute;
  top: 10px;
  right: 10px;
  background-color: rgba(0, 0, 0, 0.7);
  color: #00ffff;
  padding: 10px;
  border-radius: 5px;
  font-family: 'Orbitron', sans-serif;
  border: 1px solid #00ffff;
  z-index: 100;
}

.connection-indicator, .players-indicator {
  margin: 5px 0;
  display: flex;
  justify-content: space-between;
}

#connection-status {
  color: #ff3333;
  font-weight: bold;
}

#connection-status.connected {
  color: #33ff33;
}

#players-count {
  color: #ffff33;
  font-weight: bold;
}

/* Player Labels */
.player-label {
  color: #00ffff;
  font-family: 'Orbitron', sans-serif;
  padding: 2px 6px;
  border-radius: 4px;
  background-color: rgba(0, 0, 0, 0.7);
  font-size: 10px;
  white-space: nowrap;
  text-align: center;
  transform: translate(-50%, -50%);
  pointer-events: none;
  text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff;
} 
### ./styles/main.css END ###

### ./styles/controls.css BEGIN ###
#controls {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 20px;
    padding: 15px;
    background: rgba(0, 0, 0, 0.7);
    border-radius: 10px;
    z-index: 1000;
    transition: opacity 0.5s ease;
    pointer-events: none;
}

.control-section {
    display: flex;
    gap: 10px;
    padding: 0 15px;
    border-right: 1px solid rgba(255, 255, 255, 0.2);
}

.control-section:last-child {
    border-right: none;
}

.control-indicator {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 40px;
}

.control-indicator .key {
    background: rgba(255, 255, 255, 0.1);
    padding: 5px 8px;
    border-radius: 4px;
    font-size: 12px;
    color: #fff;
    margin-bottom: 4px;
}

.control-indicator .label {
    font-size: 16px;
    color: #fff;
}

.control-indicator .tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
}

.control-indicator:hover .tooltip {
    opacity: 1;
}

/* Mobile and tablet adjustments */
@media (max-width: 768px) {
    #controls {
        flex-direction: column;
        bottom: 10px;
        gap: 10px;
        padding: 10px;
    }
    
    .control-section {
        border-right: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        padding: 10px 0;
    }
    
    .control-section:last-child {
        border-bottom: none;
    }
    
    .control-indicator {
        min-width: 30px;
    }
    
    .control-indicator .key {
        font-size: 10px;
        padding: 3px 6px;
    }
    
    .control-indicator .label {
        font-size: 14px;
    }
} 
### ./styles/controls.css END ###

### ./assets/ModelLoader.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader';

// Manager to handle and cache all loaded models
export class ModelLoader {
  constructor() {
    // Cache for storing loaded models to avoid reloading
    this.modelCache = new Map();
    
    // Create loaders
    this.gltfLoader = new GLTFLoader();
    
    // Loading manager to track progress
    this.loadingManager = new THREE.LoadingManager();
    this.loadingManager.onProgress = (url, loaded, total) => {
      const progress = (loaded / total) * 100;
      console.log(`Loading: ${Math.round(progress)}% (${url})`);
    };
    
    // Set up loaders with manager
    this.gltfLoader.manager = this.loadingManager;
  }
  
  /**
   * Load a 3D model from path
   * @param {string} path - Path to the model file, relative to the assets directory
   * @returns {Promise} - Promise that resolves with the loaded model
   */
  loadModel(path) {
    // Add assets prefix for webpack build
    const assetPath = path.startsWith('assets/') ? path : `assets/${path}`;
    
    // Check if model is already in cache
    if (this.modelCache.has(assetPath)) {
      return Promise.resolve(this.modelCache.get(assetPath).clone());
    }
    
    // If not in cache, load it
    return new Promise((resolve, reject) => {
      this.gltfLoader.load(
        assetPath,
        (gltf) => {
          // Store original in cache
          this.modelCache.set(assetPath, gltf.scene.clone());
          
          // Process the model for better performance
          this.processModel(gltf.scene);
          
          resolve(gltf.scene);
        },
        (progress) => {
          // Optional progress callback
        },
        (error) => {
          console.error(`Error loading model from ${assetPath}:`, error);
          reject(error);
        }
      );
    });
  }
  
  /**
   * Process model to optimize it
   * @param {THREE.Group} model - The loaded model
   */
  processModel(model) {
    console.log('Processing model in ModelLoader, initial scale:', model.scale.x, model.scale.y, model.scale.z);
    
    // Traverse the model and optimize materials, geometries, etc.
    model.traverse((node) => {
      if (node.isMesh) {
        console.log(`ModelLoader found mesh: ${node.name}, Scale:`, node.scale);
        
        // Enable shadows
        node.castShadow = true;
        node.receiveShadow = true;
        
        // Keep materials but ensure they're properly configured
        if (node.material) {
          // Ensure material has appropriate render settings
          node.material.needsUpdate = true;
        }
      }
    });
    
    // Center the model if needed
    this.centerModel(model);
    
    console.log('Model after processing, final scale:', model.scale.x, model.scale.y, model.scale.z);
  }
  
  /**
   * Center the model at its geometric center
   * @param {THREE.Group} model - The model to center
   */
  centerModel(model) {
    // Create a bounding box for the model
    const boundingBox = new THREE.Box3().setFromObject(model);
    
    // Calculate the center of the bounding box
    const center = new THREE.Vector3();
    boundingBox.getCenter(center);
    
    // Move the model so its center is at the origin
    model.position.sub(center);
  }
  
  /**
   * Clear the model cache (useful when memory needs to be freed)
   */
  clearCache() {
    this.modelCache.clear();
  }
  
  /**
   * Get a list of all loaded model paths
   * @returns {Array} - Array of paths to loaded models
   */
  getLoadedModelPaths() {
    return Array.from(this.modelCache.keys());
  }
} 
### ./assets/ModelLoader.js END ###

### ./assets/SoundManager.js BEGIN ###
import * as THREE from 'three';

/**
 * SoundManager class for managing game audio
 */
export class SoundManager {
  constructor() {
    // Initialize audio listeners, buffers, and sources
    this.listener = new THREE.AudioListener();
    this.sounds = new Map();
    this.music = null;
    this.isMuted = false;
    
    // Default volumes
    this.effectsVolume = 0.5;
    this.musicVolume = 0.3;
    
    // Preload common sounds
    this.preloadSounds();
    
    // Setup audio control buttons
    this.setupAudioControls();
  }
  
  /**
   * Preload common game sounds
   */
  preloadSounds() {
    // Create a sound loader
    const audioLoader = new THREE.AudioLoader();
    
    // Define common sounds to preload with updated paths
    const soundsToLoad = [
      { name: 'laser', path: 'assets/sounds/laser.mp3' },
      { name: 'explosion', path: 'assets/sounds/explosion.mp3' },
      { name: 'hit', path: 'assets/sounds/hit.mp3' },
      { name: 'powerup', path: 'assets/sounds/powerup.mp3' },
      { name: 'engine', path: 'assets/sounds/engine.mp3', loop: true },
      { name: 'laser-bounce', path: 'assets/sounds/laser-bounce.mp3' },
      { name: 'weapon-switch', path: 'assets/sounds/weapon-switch.mp3' },
      { name: 'collision', path: 'assets/sounds/collision.mp3' },
      { name: 'weapon-charging', path: 'assets/sounds/weapon-charging.mp3' },
      { name: 'bounce', path: 'assets/sounds/bounce.mp3' },
      { name: 'weapon-armor-hit', path: 'assets/sounds/weapon-armor-hit.mp3' },
      { name: 'grenade-laser', path: 'assets/sounds/grenade-laser.mp3' }
    ];
    
    // Load each sound
    soundsToLoad.forEach(soundInfo => {
      try {
        const sound = new THREE.Audio(this.listener);
        
        audioLoader.load(
          soundInfo.path,
          buffer => {
            sound.setBuffer(buffer);
            sound.setVolume(this.effectsVolume);
            if (soundInfo.loop) {
              sound.setLoop(true);
            }
            this.sounds.set(soundInfo.name, sound);
            console.log(`Loaded sound: ${soundInfo.name}`);
          },
          xhr => {
            console.log(`${soundInfo.name}: ${(xhr.loaded / xhr.total * 100)}% loaded`);
          },
          error => {
            console.error(`Error loading sound ${soundInfo.name}:`, error);
          }
        );
      } catch (error) {
        console.error(`Failed to setup sound ${soundInfo.name}:`, error);
      }
    });
    
    // Load background music with updated path
    try {
      this.music = new THREE.Audio(this.listener);
      audioLoader.load(
        'assets/sounds/background_music.mp3',
        buffer => {
          this.music.setBuffer(buffer);
          this.music.setVolume(this.musicVolume);
          this.music.setLoop(true);
        },
        xhr => {
          console.log(`Background music: ${(xhr.loaded / xhr.total * 100)}% loaded`);
        },
        error => {
          console.error('Error loading background music:', error);
        }
      );
    } catch (error) {
      console.error('Failed to setup background music:', error);
    }
  }
  
  /**
   * Setup audio control buttons
   */
  setupAudioControls() {
    // Add event listeners for audio controls if they exist in the DOM
    const muteButton = document.getElementById('mute-button');
    if (muteButton) {
      muteButton.addEventListener('click', () => this.toggleMute());
    }
    
    const effectsVolumeSlider = document.getElementById('effects-volume');
    if (effectsVolumeSlider) {
      effectsVolumeSlider.value = this.effectsVolume * 100;
      effectsVolumeSlider.addEventListener('input', (e) => {
        this.setEffectsVolume(e.target.value / 100);
      });
    }
    
    const musicVolumeSlider = document.getElementById('music-volume');
    if (musicVolumeSlider) {
      musicVolumeSlider.value = this.musicVolume * 100;
      musicVolumeSlider.addEventListener('input', (e) => {
        this.setMusicVolume(e.target.value / 100);
      });
    }
  }
  
  /**
   * Play a sound by name
   * @param {string} name - Name of the sound to play
   * @param {THREE.Vector3} position - Optional position for 3D audio
   */
  playSound(name, position = null) {
    if (this.isMuted) return;
    
    const sound = this.sounds.get(name);
    if (!sound) {
      console.warn(`Sound '${name}' not found`);
      return;
    }
    
    let soundToPlay = sound;
    
    // If sound is already playing, create a new instance
    if (sound.isPlaying) {
      try {
        // Create a new audio instance
        if (position) {
          // For positional audio
          const soundClone = new THREE.PositionalAudio(this.listener);
          soundClone.setBuffer(sound.buffer);
          soundClone.setVolume(this.effectsVolume);
          soundClone.setRefDistance(10); // Distance at which the volume is at full
          soundToPlay = soundClone;
        } else {
          // For non-positional audio - create new instead of cloning
          const soundClone = new THREE.Audio(this.listener);
          soundClone.setBuffer(sound.buffer);
          soundClone.setVolume(this.effectsVolume);
          soundToPlay = soundClone;
        }
        
        // Clean up clone after playing
        soundToPlay.onEnded = () => {
          if (soundToPlay.source) {
            soundToPlay.disconnect();
            soundToPlay.source = null; // Prevent memory leaks
          }
        };
      } catch (error) {
        console.error("Error creating new sound instance:", error);
        // If cloning fails, don't play any sound rather than crashing
        return;
      }
    }
    
    // If position is provided, make it positional
    if (position && !sound.isPlaying) {
      // We're using the original sound, convert it to positional if needed
      if (!(soundToPlay instanceof THREE.PositionalAudio)) {
        try {
          // Create new positional audio
          const positionalSound = new THREE.PositionalAudio(this.listener);
          positionalSound.setBuffer(sound.buffer);
          positionalSound.setVolume(this.effectsVolume);
          positionalSound.setRefDistance(10);
          soundToPlay = positionalSound;
        } catch (error) {
          console.error("Error creating positional audio:", error);
          // Fall back to non-positional
        }
      }
    }
    
    // Apply position if provided
    if (position && soundToPlay instanceof THREE.PositionalAudio) {
      try {
        // Check if we need to add this to an object in the scene
        const dummyObject = new THREE.Object3D();
        dummyObject.position.copy(position);
        dummyObject.add(soundToPlay);
        
        // Cleanup function to remove the dummy object after playing
        soundToPlay.onEnded = () => {
          if (dummyObject.parent) dummyObject.parent.remove(dummyObject);
          if (soundToPlay.source) {
            soundToPlay.disconnect();
            soundToPlay.source = null;
          }
        };
        
        // Add to scene or listener (we assume listener is in scene)
        if (this.listener && this.listener.parent) {
          this.listener.parent.add(dummyObject);
        } else {
          console.warn('Audio listener has no parent, positional audio may not work correctly');
          // Just play non-positional as fallback
        }
      } catch (error) {
        console.error("Error setting up positional audio:", error);
        // Fall back to just playing the sound
      }
    }
    
    // Play the sound
    try {
      soundToPlay.play();
    } catch (error) {
      console.error("Error playing sound:", error);
    }
  }
  
  /**
   * Start playing background music
   */
  playMusic() {
    if (this.isMuted || !this.music || this.music.isPlaying) return;
    
    this.music.play();
  }
  
  /**
   * Stop background music
   */
  stopMusic() {
    if (!this.music || !this.music.isPlaying) return;
    
    this.music.stop();
  }
  
  /**
   * Toggle mute state for all audio
   */
  toggleMute() {
    this.isMuted = !this.isMuted;
    
    // Update mute button if it exists
    const muteButton = document.getElementById('mute-button');
    if (muteButton) {
      muteButton.textContent = this.isMuted ? '🔇' : '🔊';
    }
    
    if (this.isMuted) {
      // Pause all sounds
      this.sounds.forEach(sound => {
        if (sound.isPlaying) {
          sound.pause();
        }
      });
      
      // Pause music
      if (this.music && this.music.isPlaying) {
        this.music.pause();
      }
    } else {
      // Resume music
      if (this.music && !this.music.isPlaying) {
        this.music.play();
      }
    }
  }
  
  /**
   * Set volume for sound effects
   * @param {number} volume - Volume level (0-1)
   */
  setEffectsVolume(volume) {
    this.effectsVolume = Math.max(0, Math.min(1, volume));
    
    // Update all sound effects with new volume
    this.sounds.forEach(sound => {
      sound.setVolume(this.effectsVolume);
    });
  }
  
  /**
   * Set volume for background music
   * @param {number} volume - Volume level (0-1)
   */
  setMusicVolume(volume) {
    this.musicVolume = Math.max(0, Math.min(1, volume));
    
    if (this.music) {
      this.music.setVolume(this.musicVolume);
    }
  }
  
  /**
   * Get the audio listener for positioning
   * @returns {THREE.AudioListener} The audio listener
   */
  getListener() {
    return this.listener;
  }
} 
### ./assets/SoundManager.js END ###

### ./assets/AssetLoader.js BEGIN ###
import * as THREE from 'three';
import { GLTFLoader } from '@three/examples/loaders/GLTFLoader';

class AssetLoader {
    constructor() {
        this.loadingState = {
            started: false,
            completed: false,
            errors: [],
            timeouts: new Map(),
            retryCount: new Map(),
            maxRetries: 3,
            loadingPromises: new Map()
        };

        this.assets = {
            models: new Map(),
            sounds: new Map(),
            textures: new Map()
        };

        this.onProgress = null;
        this.onError = null;
    }

    setCallbacks(onProgress, onError) {
        this.onProgress = onProgress;
        this.onError = onError;
        return this;
    }

    async loadAll() {
        if (this.loadingState.started) {
            console.warn('Asset loading already in progress');
            return;
        }

        this.loadingState.started = true;
        this.loadingState.completed = false;
        this.loadingState.errors = [];

        try {
            const modelsToLoad = [
                'ships/ALTSPACE1.glb',
                'ships/ALTSPACE2.glb',
                'terrain/Terrain.glb',
                'terrain/Water.glb',
                'objects/SP_Stone01.glb',
                'objects/SP_Ground05.glb'
            ];

            const loader = new GLTFLoader();
            
            for (const model of modelsToLoad) {
                try {
                    const loaded = await this.loadWithRetry(() => 
                        this.loadModel(loader, model, `assets/models/${model}`)
                    );
                    if (loaded) {
                        console.log(`✅ Successfully loaded model: ${model}`);
                        
                        // Add aliases for ship models
                        if (model === 'ships/ALTSPACE1.glb') {
                            this.assets.models.set('FIGHTER', this.assets.models.get(model));
                            this.assets.models.set('SCOUT', this.assets.models.get(model));
                        } else if (model === 'ships/ALTSPACE2.glb') {
                            this.assets.models.set('INTERCEPTOR', this.assets.models.get(model));
                            this.assets.models.set('EXPERIMENTAL', this.assets.models.get(model));
                        }
                    }
                } catch (error) {
                    console.error(`⛔ Failed to load model ${model}:`, error);
                    this.handleError('model', error);
                }
            }

            this.loadingState.completed = true;
            return true;
        } catch (error) {
            this.handleError('critical', error);
            return false;
        }
    }

    async loadModel(loader, key, path) {
        return new Promise((resolve, reject) => {
            console.log(`🔍 Actually loading model: ${key} from: ${path}`);
            
            const timeoutId = setTimeout(() => {
                reject(new Error(`Model loading timeout: ${key}`));
            }, 15000);

            loader.load(
                path,
                (gltf) => {
                    clearTimeout(timeoutId);
                    console.log(`✅ Successfully loaded model: ${key}`);
                    
                    // Store the original model before any scaling
                    this.assets.models.set(key, gltf.scene);
                    this.onProgress?.(`Loaded model: ${key}`);
                    resolve();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100);
                    this.onProgress?.(`Loading ${key}: ${Math.round(percent)}%`);
                },
                (error) => {
                    clearTimeout(timeoutId);
                    console.error(`⛔ Error loading model ${key}:`, error.message);
                    reject(new Error(`Error loading model ${key}: ${error.message}`));
                }
            );
        });
    }

    async loadTextures() {
        const textureLoader = new THREE.TextureLoader();
        const texturePaths = {
            // Add texture paths when needed
        };

        const loadPromises = Object.entries(texturePaths).map(([key, path]) => {
            return this.loadWithRetry(() => this.loadTexture(textureLoader, key, path));
        });

        await Promise.all(loadPromises);
    }

    async loadTexture(loader, key, path) {
        return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
                reject(new Error(`Texture loading timeout: ${key}`));
            }, 10000);

            loader.load(
                path,
                (texture) => {
                    clearTimeout(timeoutId);
                    this.assets.textures.set(key, texture);
                    this.onProgress?.(`Loaded texture: ${key}`);
                    resolve();
                },
                (xhr) => {
                    const percent = (xhr.loaded / xhr.total * 100);
                    this.onProgress?.(`Loading ${key}: ${Math.round(percent)}%`);
                },
                (error) => {
                    clearTimeout(timeoutId);
                    reject(new Error(`Error loading texture ${key}: ${error.message}`));
                }
            );
        });
    }

    async loadWithRetry(loadFunction) {
        const key = loadFunction.name || 'unknown';
        let retryCount = 0;

        while (retryCount < this.loadingState.maxRetries) {
            try {
                return await loadFunction();
            } catch (error) {
                retryCount++;
                if (retryCount === this.loadingState.maxRetries) {
                    this.handleError(key, error);
                    throw error;
                }
                console.warn(`Retrying ${key} (attempt ${retryCount}/${this.loadingState.maxRetries})`);
                await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
            }
        }
    }

    handleError(assetType, error) {
        console.error(`Error loading ${assetType}:`, error);
        this.loadingState.errors.push({ type: assetType, error: error.message });
        this.onError?.(assetType, error.message);
    }

    getModel(key) {
        return this.assets.models.get(key);
    }

    getTexture(key) {
        return this.assets.textures.get(key);
    }

    isLoaded() {
        return this.loadingState.completed;
    }

    getErrors() {
        return this.loadingState.errors;
    }

    cleanup() {
        // Dispose of all loaded assets
        this.assets.models.forEach(model => {
            model.traverse(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) {
                        child.material.forEach(mat => mat.dispose());
                    } else {
                        child.material.dispose();
                    }
                }
            });
        });

        this.assets.textures.forEach(texture => texture.dispose());

        // Clear all maps
        this.assets.models.clear();
        this.assets.textures.clear();

        // Reset loading state
        this.loadingState = {
            started: false,
            completed: false,
            errors: [],
            timeouts: new Map(),
            retryCount: new Map(),
            maxRetries: 3,
            loadingPromises: new Map()
        };
    }

    // Force ship sizes to be consistent
    normalizeShipSizes() {
        console.log('🛠️ NORMALIZING SHIP SIZES');
        
        // Check what models we have
        const modelKeys = Array.from(this.assets.models.keys());
        console.log('Available models:', modelKeys);
        
        // Skip if no models are loaded
        if (this.assets.models.size === 0) {
            console.warn('⚠️ No models loaded yet, skipping normalization');
            return;
        }
        
        // Set all models to scale 1
        modelKeys.forEach(key => {
            try {
                const model = this.assets.models.get(key);
                if (model) {
                    console.log(`Setting standard scale 1.0 for ${key}`);
                    model.scale.set(1, 1, 1);
                }
            } catch (error) {
                console.error(`Error setting scale for model ${key}:`, error);
            }
        });
        
        console.log('🛠️ SHIP SIZE NORMALIZATION COMPLETE');
    }
    
    // Method to get a cloned ship model
    getShipModel(key) {
        try {
            console.log(`Getting ship model: ${key}`);
            
            // First try direct key lookup
            let model = this.assets.models.get(key);
            
            // If not found, try the file path
            if (!model) {
                model = this.assets.models.get(`ships/${key}.glb`);
            }
            
            // If still not found, try aliases
            if (!model) {
                console.log(`Trying to find model by alias: ${key}`);
                if (key === 'FIGHTER' || key === 'SCOUT') {
                    model = this.assets.models.get('ships/ALTSPACE1.glb');
                } else if (key === 'INTERCEPTOR' || key === 'EXPERIMENTAL') {
                    model = this.assets.models.get('ships/ALTSPACE2.glb');
                }
            }
            
            if (!model) {
                console.warn(`Ship model with key "${key}" not found!`);
                return null;
            }
            
            return this.cloneAndPrepareModel(model);
        } catch (error) {
            console.error(`Error cloning ship model ${key}:`, error);
            return null;
        }
    }

    // New method to handle model cloning and preparation
    cloneAndPrepareModel(model) {
        // DIAGNOSTIC: Log scale before cloning
        console.log(`DIAGNOSTIC: Original model scale before clone - [${model.scale.x}, ${model.scale.y}, ${model.scale.z}]`);
        
        // Clone the model
        const cloned = model.clone();
        
        // Apply consistent scaling as specified in Task 12
        cloned.scale.set(0.45, 0.45, 0.45);
        
        // Ensure materials are properly cloned
        cloned.traverse(node => {
            if (node.isMesh && node.material) {
                // Clone material to prevent sharing between instances
                node.material = node.material.clone();
                
                // Ensure material properties are set
                if (!node.material.color) node.material.color = new THREE.Color(0xffffff);
                if (!node.material.emissive) node.material.emissive = new THREE.Color(0x000000);
                
                // Enable shadows
                node.castShadow = true;
                node.receiveShadow = true;
            }
        });
        
        // DIAGNOSTIC: Log scale after cloning
        console.log(`DIAGNOSTIC: Cloned model scale - [${cloned.scale.x}, ${cloned.scale.y}, ${cloned.scale.z}]`);
        
        return cloned;
    }

    // Method to get a cloned ship model for opponents
    getOpponentShipModel(key) {
        try {
            console.log(`Getting opponent ship model: ${key}`);
            // Use the same model loading logic as getShipModel
            const model = this.getShipModel(key);
            
            if (!model) {
                console.warn(`No model found for opponent ship type: ${key}`);
                return null;
            }
            
            // Clone the model to ensure each opponent has their own instance
            const clonedModel = model.clone();
            
            // Apply any opponent-specific modifications here if needed
            // For example, different materials or effects
            
            return clonedModel;
        } catch (error) {
            console.error(`Error getting opponent ship model ${key}:`, error);
            return null;
        }
    }

    // Add the loadModels method used by ShipSelectionUI
    async loadModels() {
        console.log('Loading ship models for selection UI');
        
        if (this.assets.models.has('FIGHTER') && this.assets.models.has('INTERCEPTOR')) {
            console.log('Ship models already loaded, using cached versions');
            return true;
        }
        
        const shipModels = [
            'ships/ALTSPACE1.glb',
            'ships/ALTSPACE2.glb'
        ];
        
        const loader = new GLTFLoader();
        
        for (const model of shipModels) {
            try {
                const loaded = await this.loadWithRetry(() => 
                    this.loadModel(loader, model, `assets/models/${model}`)
                );
                if (loaded) {
                    console.log(`✅ Successfully loaded ship model: ${model} for selection UI`);
                    
                    // Add aliases for ship models
                    if (model === 'ships/ALTSPACE1.glb') {
                        this.assets.models.set('FIGHTER', this.assets.models.get(model));
                        this.assets.models.set('SCOUT', this.assets.models.get(model));
                    } else if (model === 'ships/ALTSPACE2.glb') {
                        this.assets.models.set('INTERCEPTOR', this.assets.models.get(model));
                        this.assets.models.set('EXPERIMENTAL', this.assets.models.get(model));
                    }
                }
            } catch (error) {
                console.error(`⛔ Failed to load ship model ${model}:`, error);
                this.handleError('model', error);
            }
        }
        
        return true;
    }
}

export default AssetLoader; 
### ./assets/AssetLoader.js END ###

### ./entities/Ship.js BEGIN ###
import * as THREE from 'three';
import { EventEmitter } from 'events';

export class Ship extends EventEmitter {
    constructor(scene, position, options = {}) {
        super();
        
        this.scene = scene;
        this.options = { 
            health: 100, 
            speed: 0.1,
            type: 'BASIC',
            teamId: null,
            teamColor: 0xffffff,
            maxHealth: 100,
            size: 1.0,
            shipModel: 'STANDARD',
            ...options 
        };
        
        this.health = this.options.health;
        this.maxHealth = this.options.maxHealth;
        this.isActive = true;
        this.teamId = this.options.teamId;
        this.mesh = null;
        
        // Initialize the ship if position is provided
        if (position) {
            this.createMesh(position);
            // Add to scene if mesh was created
            if (this.mesh) {
                this.scene.add(this.mesh);
            }
            // Initialize effects
            this.initializeEffects();
        }
    }

    createMesh(position) {
        // This is a base method that can be overridden by subclasses
        // In the base class, implement default behavior
        
        const geometry = this.createGeometry();
        const material = this.createMaterial();
        
        // Create mesh
        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.copy(position || new THREE.Vector3());
        this.mesh.position.y = this.options.size;
        
        // Add engine glow
        this.addEngineGlow();
        
        return this.mesh;
    }
    
    createGeometry() {
        // Ship models based on type
        const models = {
            STANDARD: () => new THREE.ConeGeometry(this.options.size, this.options.size * 2, 3),
            INTERCEPTOR: () => {
                const geometry = new THREE.ConeGeometry(this.options.size * 0.8, this.options.size * 2.5, 4);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            },
            HEAVY: () => new THREE.CylinderGeometry(
                this.options.size * 1.2,
                this.options.size * 1.4,
                this.options.size * 2,
                6
            ),
            SCOUT: () => {
                const geometry = new THREE.ConeGeometry(this.options.size * 0.6, this.options.size * 2.2, 5);
                geometry.rotateX(Math.PI / 2);
                return geometry;
            }
        };

        // Get geometry based on ship model or fallback to STANDARD
        const geometry = (models[this.options.shipModel] || models.STANDARD)();
        geometry.rotateX(Math.PI / 2);
        
        return geometry;
    }
    
    createMaterial() {
        // Create material with team color and effects
        return new THREE.MeshStandardMaterial({
            color: this.options.teamColor,
            emissive: this.options.teamColor,
            emissiveIntensity: 0.5,
            metalness: 0.7,
            roughness: 0.3
        });
    }

    addEngineGlow() {
        const engineLight = new THREE.PointLight(this.options.teamColor, 1, 2);
        engineLight.position.set(0, 0, -this.options.size);
        this.mesh.add(engineLight);
    }

    initializeEffects() {
        this.effects = {
            damageTween: null,
            enginePulse: { value: 0 }
        };
    }

    update(deltaTime) {
        if (!this.isActive) return;

        // Update engine pulse effect
        this.updateEngineEffect(deltaTime);
    }

    updateEngineEffect(deltaTime) {
        this.effects.enginePulse.value += deltaTime * 0.005;
        const pulseIntensity = 0.5 + 0.2 * Math.sin(this.effects.enginePulse.value);
        this.material.emissiveIntensity = pulseIntensity;
    }

    takeDamage(amount) {
        if (!this.isActive) return;

        this.health = Math.max(0, this.health - amount);
        this.flashOnDamage();

        if (this.health <= 0) {
            this.destroy();
        }

        // Emit damage event
        this.emit('damage', {
            amount,
            remainingHealth: this.health,
            maxHealth: this.maxHealth
        });
    }

    flashOnDamage() {
        const originalEmissive = this.material.emissive.getHex();
        this.material.emissive.setHex(0xffffff);

        setTimeout(() => {
            if (this.material) {
                this.material.emissive.setHex(originalEmissive);
            }
        }, 100);
    }

    destroy() {
        if (!this.isActive) return;

        this.isActive = false;
        this.createExplosionEffect();
        
        // Emit destroy event
        this.emit('destroy', {
            position: this.mesh.position.clone(),
            teamId: this.teamId
        });

        // Remove from scene after explosion
        setTimeout(() => {
            if (this.mesh && this.mesh.parent) {
                this.mesh.parent.remove(this.mesh);
            }
        }, 1000);
    }

    createExplosionEffect() {
        const particleCount = 20;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const velocities = [];
        const particles = [];

        for (let i = 0; i < particleCount; i++) {
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2,
                (Math.random() - 0.5) * 0.2
            );
            velocities.push(velocity);
            particles.push(new THREE.Vector3(0, 0, 0));
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: this.options.teamColor,
            size: 0.2,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(geometry, material);
        particleSystem.position.copy(this.mesh.position);
        this.scene.add(particleSystem);

        const startTime = Date.now();
        const duration = 1000;

        const animateExplosion = () => {
            const elapsed = Date.now() - startTime;
            if (elapsed < duration) {
                for (let i = 0; i < particleCount; i++) {
                    particles[i].add(velocities[i]);
                    positions[i * 3] = particles[i].x;
                    positions[i * 3 + 1] = particles[i].y;
                    positions[i * 3 + 2] = particles[i].z;
                }
                geometry.attributes.position.needsUpdate = true;
                material.opacity = 1 - (elapsed / duration);
                requestAnimationFrame(animateExplosion);
            } else {
                this.scene.remove(particleSystem);
            }
        };

        animateExplosion();
    }

    setTeam(teamId, teamColor) {
        this.teamId = teamId;
        this.options.teamColor = teamColor;
        if (this.material) {
            this.material.color.setHex(teamColor);
            this.material.emissive.setHex(teamColor);
        }
    }
} 
### ./entities/Ship.js END ###

### ./entities/weapons/RegularLaser.js BEGIN ###
import * as THREE from 'three';
import { Laser } from './Laser';

/**
 * RegularLaser weapon class
 */
export class RegularLaser extends Laser {
  constructor(weaponSystem) {
    super(weaponSystem.scene, null, null, {
      damage: 10, range: 50, speed: 50, color: 0x00ffff
    });
    this.weaponSystem = weaponSystem;
    this.cooldown = 0.2;
    this.currentCooldown = 0;
    this.energyCost = 5;
  }
  
  /**
   * Update cooldown timer and laser position
   * @param {number} deltaTime - Time since last frame in seconds
   */
  update(deltaTime) {
    // Call parent update to handle movement and range checking
    super.update(deltaTime);
    
    // Handle cooldown timer
    if (this.currentCooldown > 0) {
      this.currentCooldown -= deltaTime;
    }
  }
  
  /**
   * Check if weapon can fire
   * @param {object} player - Player object with energy properties
   * @returns {boolean} - True if weapon can fire
   */
  canFire(player) {
    return this.currentCooldown <= 0 && player.energy >= this.energyCost;
  }
  
  /**
   * Fire the weapon
   * @param {THREE.Vector3} position - Starting position of projectile
   * @param {THREE.Vector3} direction - Direction to fire
   * @param {object} player - Player object for energy management
   * @returns {boolean} - True if weapon fired successfully
   */
  fire(position, direction, options = {}) {
    // Position and orient the laser
    this.mesh.position.copy(position);
    this.direction = direction.normalize();
    this.initialPosition = position.clone();
    
    // Store initial properties
    this.teamId = options.teamId;
    
    // Set color based on team
    if (options.teamColor) {
      if (this.mesh.material) {
        this.mesh.material.color.set(options.teamColor);
      }
    }
    
    // Play sound if available
    if (this.weaponSystem.scene.soundManager) {
      this.weaponSystem.scene.soundManager.playSound('laser', position);
    }
    
    return this;
  }
  
  /**
   * Create a laser projectile
   * @param {THREE.Vector3} position - Starting position
   * @param {THREE.Vector3} direction - Direction to fire
   * @returns {object} - Projectile object
   */
  createProjectile(position, direction) {
    // Create laser geometry and material
    const geometry = new THREE.CylinderGeometry(
      this.size.width, 
      this.size.width, 
      this.size.length, 
      8
    );
    
    // Rotate geometry to point along z-axis
    geometry.rotateX(Math.PI / 2);
    
    // Create glowing material
    const material = new THREE.MeshBasicMaterial({
      color: this.color,
      transparent: true,
      opacity: 0.8
    });
    
    // Create mesh
    const mesh = new THREE.Mesh(geometry, material);
    
    // Set initial position
    mesh.position.copy(position);
    
    // Set rotation to match direction
    mesh.quaternion.setFromUnitVectors(
      new THREE.Vector3(0, 0, 1), 
      direction.clone().normalize()
    );
    
    // Add a point light to make it glow
    const light = new THREE.PointLight(this.color, 1, 2);
    mesh.add(light);
    
    // Create projectile object
    const projectile = {
      mesh: mesh,
      direction: direction.clone().normalize(),
      speed: this.speed,
      distance: 0,
      maxDistance: this.range,
      damage: this.damage,
      isActive: true,
      owner: 'player',
      type: 'laser',
      explosionSize: this.explosionSize,
      
      // Update method
      update: function(deltaTime) {
        if (!this.isActive) return false;
        
        // Move projectile
        const moveAmount = this.speed * deltaTime;
        this.mesh.position.addScaledVector(this.direction, moveAmount);
        this.distance += moveAmount;
        
        // Deactivate if max distance reached
        if (this.distance >= this.maxDistance) {
          this.isActive = false;
          return false;
        }
        
        return true;
      },
      
      // Handle collision
      handleCollision: function() {
        this.isActive = false;
      },
      
      // Get current position
      get position() {
        return this.mesh.position;
      }
    };
    
    return projectile;
  }
} 
### ./entities/weapons/RegularLaser.js END ###

### ./entities/weapons/WeaponSystem.js BEGIN ###
import * as THREE from 'three';
import { Laser } from './Laser';

export class WeaponSystem {
  constructor(scene) {
    this.scene = scene;
    this.projectiles = [];
    
    // Weapon types
    this.weaponTypes = {
      LASER: {
        name: 'Regular Laser',
        color: 0x00ffff,
        cooldown: 300,
        length: 3,
        thickness: 0.1,
        speed: 0.3,
        damage: 10
      },
      BOUNCE_LASER: {
        name: 'Bounce Laser',
        color: 0xff00ff,
        cooldown: 500,
        length: 2.5,
        thickness: 0.15,
        speed: 0.25,
        damage: 8,
        bounces: 3
      },
      QUANTUM_GRENADE: {
        name: 'Quantum Grenade',
        color: 0xffff00,
        cooldown: 1000,
        speed: 0.15,
        radius: 0.3,
        damage: 25,
        areaEffectRadius: 5,
        delay: 3000
      }
    };
    
    // Audio (will be implemented later)
    this.audioEnabled = false;
  }
  
  fireWeapon(weaponType, position, direction, options = {}) {
    const config = this.weaponTypes[weaponType] || this.weaponTypes['LASER'];
    let projectile = this.createLaser(position, direction, {
      ...config,
      ...options
    });
    
    if (projectile) {
      this.projectiles.push(projectile);
    }
    
    // Network synchronization if available
    if (this.scene.networkManager) {
      this.scene.networkManager.emit('laser_shot', {
        origin: position,
        direction: direction,
        type: weaponType
      });
    }
    
    return projectile;
  }
  
  createLaser(position, direction, config) {
    // Create laser projectile
    return new Laser(this.scene, position, direction, config);
  }
  
  update(deltaTime) {
    // Update all projectiles
    for (let i = this.projectiles.length - 1; i >= 0; i--) {
      const projectile = this.projectiles[i];
      
      // Update projectile
      projectile.update(deltaTime);
      
      // Remove inactive projectiles
      if (!projectile.isActive) {
        this.projectiles.splice(i, 1);
      }
    }
  }
  
  checkCollisions(targets, obstacles) {
    const hitResults = [];
    
    // Skip if no active projectiles
    if (this.projectiles.length === 0) return hitResults;
    
    // Ensure targets is an array
    const targetArray = Array.isArray(targets) ? targets : [];
    
    // Format obstacles to wall segments if needed
    const wallSegments = this.formatObstacles(obstacles);
    
    // Check each projectile for collisions
    for (const projectile of this.projectiles) {
      if (!projectile.isActive) continue;
      
      // Check wall collisions
      if (wallSegments && this.checkWallCollision(projectile, wallSegments)) {
        hitResults.push({
          projectile: projectile,
          target: 'wall',
          position: projectile.position.clone()
        });
        
        // Handle the hit
        projectile.handleCollision();
        continue;
      }
      
      // Check target collisions
      if (targetArray.length > 0) {
        for (const target of targetArray) {
          if (this.checkTargetCollision(projectile, target)) {
            hitResults.push({
              projectile: projectile,
              target: target,
              position: projectile.position.clone()
            });
            
            // Handle the hit
            projectile.handleCollision();
            break;
          }
        }
      }
    }
    
    return hitResults;
  }
  
  formatObstacles(obstacles) {
    // If obstacles is already an array of wall segments, return it
    if (Array.isArray(obstacles) && obstacles.length > 0 && 
        obstacles[0].start && obstacles[0].end) {
      return obstacles;
    }
    
    // Format obstacles into wall segments if they're in the GameRoom format
    if (Array.isArray(obstacles)) {
      const wallSegments = [];
      
      for (const obstacle of obstacles) {
        if (!obstacle || !obstacle.position) continue;
        
        if (obstacle.type === 'wall' && obstacle.size) {
          // Create line segments for walls
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          // Determine if it's a horizontal or vertical wall
          if (obstacle.size.x > obstacle.size.z) {
            // Horizontal wall
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z),
              end: new THREE.Vector3(x + halfWidth, 0, z)
            });
          } else {
            // Vertical wall
            wallSegments.push({
              start: new THREE.Vector3(x, 0, z - halfDepth),
              end: new THREE.Vector3(x, 0, z + halfDepth)
            });
          }
        } else if (obstacle.radius) {
          // For cylindrical obstacles, we'll approximate with line segments
          const segments = 8; // Number of line segments to approximate circle
          const center = obstacle.position;
          const radius = obstacle.radius;
          
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2;
            const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
            const x1 = center.x + Math.cos(angle1) * radius;
            const z1 = center.z + Math.sin(angle1) * radius;
            const x2 = center.x + Math.cos(angle2) * radius;
            const z2 = center.z + Math.sin(angle2) * radius;
            
            wallSegments.push({
              start: new THREE.Vector3(x1, 0, z1),
              end: new THREE.Vector3(x2, 0, z2)
            });
          }
        } else if (obstacle.size) {
          // Box obstacle - create four wall segments
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z - halfDepth),
            end: new THREE.Vector3(x + halfWidth, 0, z - halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x + halfWidth, 0, z - halfDepth),
            end: new THREE.Vector3(x + halfWidth, 0, z + halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x + halfWidth, 0, z + halfDepth),
            end: new THREE.Vector3(x - halfWidth, 0, z + halfDepth)
          });
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z + halfDepth),
            end: new THREE.Vector3(x - halfWidth, 0, z - halfDepth)
          });
        }
      }
      
      return wallSegments;
    }
    
    // If obstacles is not in a recognized format, return an empty array
    return [];
  }
  
  checkWallCollision(projectile, wallSegments) {
    // Simple collision check for laser projectiles
    const projectilePosition = new THREE.Vector2(
      projectile.position.x,
      projectile.position.z
    );
    
    const radius = projectile.options.thickness;
    
    // Check each wall segment
    for (const segment of wallSegments) {
      const wallStart = new THREE.Vector2(segment.start.x, segment.start.z);
      const wallEnd = new THREE.Vector2(segment.end.x, segment.end.z);
      
      // Calculate closest point on wall segment to projectile
      const wallVector = wallEnd.clone().sub(wallStart);
      const projectileToWallStart = projectilePosition.clone().sub(wallStart);
      
      // Project projectile onto wall line
      const wallLength = wallVector.length();
      const wallDirection = wallVector.clone().normalize();
      const projectionLength = projectileToWallStart.dot(wallDirection);
      
      // Find closest point on wall segment
      let closestPoint;
      if (projectionLength < 0) {
        closestPoint = wallStart;
      } else if (projectionLength > wallLength) {
        closestPoint = wallEnd;
      } else {
        closestPoint = wallStart.clone().add(wallDirection.multiplyScalar(projectionLength));
      }
      
      // Calculate distance from projectile to closest point
      const distance = projectilePosition.distanceTo(closestPoint);
      
      // Check if collision occurred
      if (distance < radius) {
        return true;
      }
    }
    
    return false;
  }
  
  checkTargetCollision(projectile, target) {
    // Simple distance-based collision check
    if (!target.mesh) return false;
    
    // Get target position (assume it has a mesh with position)
    const targetPosition = target.mesh.position;
    
    // Calculate distance
    const distance = projectile.position.distanceTo(targetPosition);
    
    // Simple radius check (can be enhanced later)
    const collisionThreshold = 0.5 + projectile.options.thickness;
    return distance < collisionThreshold;
  }
  
  clearAllProjectiles() {
    // Deactivate all projectiles
    for (const projectile of this.projectiles) {
      projectile.deactivate();
    }
    
    // Clear array
    this.projectiles = [];
  }
} 
### ./entities/weapons/WeaponSystem.js END ###

### ./entities/weapons/Laser.js BEGIN ###
import * as THREE from 'three';

export class Laser {
  constructor(scene, position, direction, options = {}) {
    this.scene = scene;
    this.options = { speed: 0.3, color: 0x00ffff, ...options };
    this.mesh = this.createMesh();
    if (position) this.mesh.position.copy(position);
    if (direction) this.direction = direction.normalize();
    this.scene.add(this.mesh);
    this.isActive = true;
  }

  createMesh() {
    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 8);
    geometry.rotateX(Math.PI / 2);
    const material = new THREE.MeshBasicMaterial({ color: this.options.color });
    return new THREE.Mesh(geometry, material);
  }
  
  update(deltaTime) {
    if (!this.isActive) return;
    
    // Move in direction
    if (this.direction) {
      this.mesh.position.add(
        this.direction.clone().multiplyScalar(this.options.speed * deltaTime)
      );
    }
    
    // Check if laser has exceeded its range
    if (this.options.range) {
      const distance = this.mesh.position.distanceTo(this.initialPosition);
      if (distance > this.options.range) {
        this.deactivate();
      }
    }
  }
  
  deactivate() {
    if (!this.isActive) return;
    
    this.isActive = false;
    if (this.mesh && this.scene) {
      this.scene.remove(this.mesh);
    }
    
    // Dispose of geometry and materials
    if (this.mesh) {
      if (this.mesh.geometry) this.mesh.geometry.dispose();
      if (this.mesh.material) {
        if (Array.isArray(this.mesh.material)) {
          this.mesh.material.forEach(material => material.dispose());
        } else {
          this.mesh.material.dispose();
        }
      }
    }
  }
} 
### ./entities/weapons/Laser.js END ###

### ./entities/enemies/EnemyManager.js BEGIN ###
import * as THREE from 'three';
import { Enemy } from './Enemy';

export class EnemyManager {
  constructor(scene, mazeSize = 10) {
    this.scene = scene;
    this.mazeSize = mazeSize;
    this.enemies = [];
    
    // Enemy types with their probabilities and configs
    this.enemyTypes = {
      BASIC: {
        probability: 0.6,
        color: 0xff0000,
        health: 30,
        speed: 0.005
      },
      HUNTER: {
        probability: 0.3,
        color: 0xff00ff,
        health: 20,
        speed: 0.008,
        detectionRadius: 15
      },
      PATROLLER: {
        probability: 0.1,
        color: 0xffaa00,
        health: 40,
        speed: 0.004
      }
    };
    
    // Spawn settings
    this.maxEnemies = 10;
    this.spawnInterval = 5000; // 5 seconds
    this.lastSpawnTime = 0;
    this.spawnDistanceFromPlayer = 10;
    this.difficulty = 1; // Scales over time
  }
  
  update(deltaTime, playerPosition, obstacles) {
    // Check if we should spawn new enemies
    this.checkSpawn(playerPosition);
    
    // Ensure obstacles are correctly formatted for enemies
    const wallSegments = this.formatObstaclesForCollision(obstacles);
    
    // Update all active enemies
    for (let i = this.enemies.length - 1; i >= 0; i--) {
      const enemy = this.enemies[i];
      
      // Skip inactive enemies - they'll be removed later
      if (!enemy.isActive) {
        this.enemies.splice(i, 1);
        continue;
      }
      
      // Update enemy behavior
      enemy.update(deltaTime, playerPosition, wallSegments);
    }
  }
  
  checkSpawn(playerPosition) {
    // Skip if player position isn't available
    if (!playerPosition) return;
    
    const currentTime = Date.now();
    
    // Check if it's time to spawn and we're under the limit
    if (currentTime - this.lastSpawnTime > this.spawnInterval && this.enemies.length < this.maxEnemies) {
      this.lastSpawnTime = currentTime;
      this.spawnEnemy(playerPosition);
    }
  }
  
  spawnEnemy(playerPosition) {
    // Determine spawn position (away from player)
    const spawnPosition = this.getSpawnPosition(playerPosition);
    if (!spawnPosition) return;
    
    // Determine enemy type based on probabilities
    const enemyType = this.selectEnemyType();
    
    // Get configuration for selected enemy type
    const typeConfig = this.enemyTypes[enemyType];
    
    // Scale difficulty based on current level
    const healthMultiplier = 1 + (this.difficulty - 1) * 0.2;
    const speedMultiplier = 1 + (this.difficulty - 1) * 0.1;
    
    // Create enemy with adjusted settings
    const enemy = new Enemy(this.scene, spawnPosition, {
      type: enemyType,
      color: typeConfig.color,
      health: typeConfig.health * healthMultiplier,
      speed: typeConfig.speed * speedMultiplier,
      detectionRadius: typeConfig.detectionRadius || 10
    });
    
    // Add to active enemies list
    this.enemies.push(enemy);
    
    return enemy;
  }
  
  getSpawnPosition(playerPosition) {
    // Try to find a valid spawn position
    for (let attempt = 0; attempt < 10; attempt++) {
      // Generate random angle around player
      const angle = Math.random() * Math.PI * 2;
      
      // Calculate position at random distance from player (between min and max)
      const minDistance = this.spawnDistanceFromPlayer;
      const maxDistance = this.spawnDistanceFromPlayer + 5;
      const distance = minDistance + Math.random() * (maxDistance - minDistance);
      
      // Calculate position
      const x = playerPosition.x + Math.cos(angle) * distance;
      const z = playerPosition.z + Math.sin(angle) * distance;
      
      // Check if position is within maze bounds
      if (Math.abs(x) < this.mazeSize * 0.8 && Math.abs(z) < this.mazeSize * 0.8) {
        return new THREE.Vector3(x, 0, z);
      }
    }
    
    // If all attempts failed, return null
    return null;
  }
  
  selectEnemyType() {
    // Random value between 0 and 1
    const rand = Math.random();
    
    // Calculate cumulative probability
    let cumulativeProbability = 0;
    
    for (const [type, config] of Object.entries(this.enemyTypes)) {
      cumulativeProbability += config.probability;
      
      if (rand <= cumulativeProbability) {
        return type;
      }
    }
    
    // Fallback to basic enemy
    return 'BASIC';
  }
  
  increaseMaxEnemies(amount = 1) {
    this.maxEnemies += amount;
  }
  
  increaseDifficulty(amount = 0.1) {
    this.difficulty += amount;
    
    // Also decrease spawn interval as difficulty increases
    this.spawnInterval = Math.max(1000, this.spawnInterval - 100);
  }
  
  checkCollisions(playerPosition, playerRadius = 0.5) {
    // Check for collisions between player and enemies
    if (!playerPosition) return false;
    
    for (const enemy of this.enemies) {
      if (!enemy.isActive) continue;
      
      // Simple distance-based collision check
      const distance = enemy.mesh.position.distanceTo(playerPosition);
      
      // If collision detected
      if (distance < playerRadius + enemy.options.size) {
        return enemy;
      }
    }
    
    return null;
  }
  
  clear() {
    // Remove all enemies
    for (const enemy of this.enemies) {
      enemy.destroy();
    }
    
    this.enemies = [];
  }
  
  // Convert obstacle data to wall segments format for collision detection
  formatObstaclesForCollision(obstacles) {
    if (!obstacles || !Array.isArray(obstacles)) return [];
    
    const wallSegments = [];
    
    for (const obstacle of obstacles) {
      if (obstacle.type === 'wall' && obstacle.position && obstacle.size) {
        // Create wall segments from obstacle bounds
        const halfWidth = obstacle.size.x / 2;
        const halfDepth = obstacle.size.z / 2;
        const x = obstacle.position.x;
        const z = obstacle.position.z;
        
        // Create four wall segments for each rectangular wall
        if (obstacle.size.x > obstacle.size.z) {
          // Horizontal wall (longer in x direction)
          wallSegments.push({
            start: new THREE.Vector3(x - halfWidth, 0, z),
            end: new THREE.Vector3(x + halfWidth, 0, z)
          });
        } else {
          // Vertical wall (longer in z direction)
          wallSegments.push({
            start: new THREE.Vector3(x, 0, z - halfDepth),
            end: new THREE.Vector3(x, 0, z + halfDepth)
          });
        }
      } else if (obstacle.type === 'obstacle' && obstacle.position) {
        // Create a simple boundary for other obstacles
        if (obstacle.radius) {
          // For cylindrical obstacles, create a circle approximation using 8 segments
          const radius = obstacle.radius;
          const center = obstacle.position;
          const segments = 8;
          
          for (let i = 0; i < segments; i++) {
            const angle1 = (i / segments) * Math.PI * 2;
            const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
            const x1 = center.x + Math.cos(angle1) * radius;
            const z1 = center.z + Math.sin(angle1) * radius;
            const x2 = center.x + Math.cos(angle2) * radius;
            const z2 = center.z + Math.sin(angle2) * radius;
            
            wallSegments.push({
              start: new THREE.Vector3(x1, 0, z1),
              end: new THREE.Vector3(x2, 0, z2)
            });
          }
        } else if (obstacle.size) {
          // For box obstacles, create four wall segments
          const halfWidth = obstacle.size.x / 2;
          const halfDepth = obstacle.size.z / 2;
          const x = obstacle.position.x;
          const z = obstacle.position.z;
          
          // Handle rotation if present
          let rotation = 0;
          if (obstacle.rotation) {
            rotation = obstacle.rotation.y;
          }
          
          if (rotation) {
            // Rotated rectangle - more complex calculation
            // For simplicity, we'll just create a simpler collision boundary
            const radius = Math.max(halfWidth, halfDepth);
            const segments = 8;
            
            for (let i = 0; i < segments; i++) {
              const angle1 = (i / segments) * Math.PI * 2;
              const angle2 = ((i + 1) / segments) * Math.PI * 2;
              
              const x1 = x + Math.cos(angle1) * radius;
              const z1 = z + Math.sin(angle1) * radius;
              const x2 = x + Math.cos(angle2) * radius;
              const z2 = z + Math.sin(angle2) * radius;
              
              wallSegments.push({
                start: new THREE.Vector3(x1, 0, z1),
                end: new THREE.Vector3(x2, 0, z2)
              });
            }
          } else {
            // Axis-aligned rectangle - simpler
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z - halfDepth),
              end: new THREE.Vector3(x + halfWidth, 0, z - halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x + halfWidth, 0, z - halfDepth),
              end: new THREE.Vector3(x + halfWidth, 0, z + halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x + halfWidth, 0, z + halfDepth),
              end: new THREE.Vector3(x - halfWidth, 0, z + halfDepth)
            });
            wallSegments.push({
              start: new THREE.Vector3(x - halfWidth, 0, z + halfDepth),
              end: new THREE.Vector3(x - halfWidth, 0, z - halfDepth)
            });
          }
        }
      }
    }
    
    return wallSegments;
  }
} 
### ./entities/enemies/EnemyManager.js END ###

### ./entities/enemies/Enemy.js BEGIN ###
import * as THREE from 'three';
import { Ship } from '../Ship';

export class Enemy extends Ship {
  constructor(scene, position, options = {}) {
    // Set default enemy options
    const enemyOptions = {
      type: 'BASIC',
      health: 30,
      speed: 0.005,
      size: 0.6,
      detectionRadius: 10,
      attackRange: 8,
      shipModel: 'STANDARD',
      ...options
    };
    
    super(scene, position, enemyOptions);
    
    // Enemy-specific properties
    this.targetPosition = null;
    this.lastDirectionChange = 0;
    this.directionChangeInterval = 2000 + Math.random() * 2000;
    this.currentTarget = null;
    this.lastAttackTime = 0;
    this.attackCooldown = 1000;
  }
  
  update(deltaTime, players, wallSegments) {
    if (!this.isActive) return;
    
    super.update(deltaTime);
    
    // Update behavior based on enemy type
    switch (this.options.type) {
      case 'HUNTER':
        this.updateHunter(deltaTime, players, wallSegments);
        break;
      case 'PATROLLER':
        this.updatePatroller(deltaTime, wallSegments);
        break;
      case 'BASIC':
      default:
        this.updateBasic(deltaTime, players, wallSegments);
        break;
    }
  }
  
  updateBasic(deltaTime, players, wallSegments) {
    const currentTime = Date.now();
    
    // Find nearest enemy player
    let nearestTarget = this.findNearestEnemyPlayer(players);
    
    if (nearestTarget && this.isInRange(nearestTarget.position, this.options.detectionRadius)) {
      // If enemy player is in range, engage
      this.currentTarget = nearestTarget;
      this.engageTarget(deltaTime, wallSegments);
    } else {
      // Random movement when no target
      if (currentTime - this.lastDirectionChange > this.directionChangeInterval) {
        this.lastDirectionChange = currentTime;
        const angle = Math.random() * Math.PI * 2;
        this.direction = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
        this.directionChangeInterval = 2000 + Math.random() * 2000;
      }
      
      if (this.direction) {
        this.moveWithCollision(this.direction, deltaTime, wallSegments);
      }
    }
  }
  
  updateHunter(deltaTime, players, wallSegments) {
    const nearestTarget = this.findNearestEnemyPlayer(players);
    
    if (nearestTarget && this.isInRange(nearestTarget.position, this.options.detectionRadius)) {
      this.currentTarget = nearestTarget;
      this.engageTarget(deltaTime, wallSegments);
    } else {
      this.updateBasic(deltaTime, players, wallSegments);
    }
  }
  
  updatePatroller(deltaTime, wallSegments) {
    if (!this.targetPosition || this.mesh.position.distanceTo(this.targetPosition) < 0.5) {
      this.targetPosition = new THREE.Vector3(
        this.mesh.position.x + (Math.random() * 10 - 5),
        this.mesh.position.y,
        this.mesh.position.z + (Math.random() * 10 - 5)
      );
    }
    
    const toTarget = new THREE.Vector3().subVectors(this.targetPosition, this.mesh.position).normalize();
    this.moveWithCollision(toTarget, deltaTime, wallSegments);
  }
  
  engageTarget(deltaTime, wallSegments) {
    if (!this.currentTarget || !this.currentTarget.isActive) {
      this.currentTarget = null;
      return;
    }

    const toTarget = new THREE.Vector3().subVectors(
      this.currentTarget.position,
      this.mesh.position
    );
    
    const distance = toTarget.length();
    
    if (distance < this.options.attackRange) {
      // Attack if in range and cooldown is ready
      const currentTime = Date.now();
      if (currentTime - this.lastAttackTime > this.attackCooldown) {
        this.attack();
        this.lastAttackTime = currentTime;
      }
      
      // Maintain distance
      if (distance < this.options.attackRange * 0.5) {
        this.moveWithCollision(toTarget.normalize().negate(), deltaTime, wallSegments);
      }
    } else {
      // Move towards target
      this.moveWithCollision(toTarget.normalize(), deltaTime, wallSegments);
    }
    
    // Face target
    const angle = Math.atan2(toTarget.x, toTarget.z);
    this.mesh.rotation.y = angle;
  }
  
  moveWithCollision(direction, deltaTime, wallSegments) {
    const movement = direction.clone().multiplyScalar(this.options.speed * deltaTime);
    const previousPosition = this.mesh.position.clone();
    
    this.mesh.position.add(movement);
    
    if (this.checkWallCollision(wallSegments)) {
      this.mesh.position.copy(previousPosition);
      this.direction = direction.clone().reflect(new THREE.Vector3(1, 0, 0));
    }
    
    // Face movement direction
    if (direction.length() > 0) {
      const angle = Math.atan2(direction.x, direction.z);
      this.mesh.rotation.y = angle;
    }
  }
  
  findNearestEnemyPlayer(players) {
    let nearestDistance = Infinity;
    let nearestPlayer = null;

    players.forEach(player => {
      if (player.isActive && player.teamId !== this.teamId) {
        const distance = this.mesh.position.distanceTo(player.mesh.position);
        if (distance < nearestDistance) {
          nearestDistance = distance;
          nearestPlayer = player;
        }
      }
    });

    return nearestPlayer;
  }
  
  isInRange(position, range) {
    return this.mesh.position.distanceTo(position) <= range;
  }
  
  attack() {
    // Emit attack event for weapon system to handle
    this.emit('attack', {
      position: this.mesh.position.clone(),
      direction: new THREE.Vector3().subVectors(
        this.currentTarget.mesh.position,
        this.mesh.position
      ).normalize(),
      teamId: this.teamId
    });
  }
  
  checkWallCollision(wallSegments) {
    const pos = this.mesh.position;
    for (const segment of wallSegments) {
      const closest = this.getClosestPoint(pos, segment.start, segment.end);
      if (pos.distanceTo(closest) < this.options.size) return true;
    }
    return false;
  }

  getClosestPoint(point, start, end) {
    const line = end.clone().sub(start);
    const t = Math.max(0, Math.min(1, point.clone().sub(start).dot(line) / line.lengthSq()));
    return start.clone().add(line.multiplyScalar(t));
  }
} 
### ./entities/enemies/Enemy.js END ###

### ./entities/player/Player.js BEGIN ###
import * as THREE from 'three';
import { ModelLoader } from '../../assets/ModelLoader';
import { KEY_MAPPINGS, CONTROL_SETTINGS, DEFAULT_CONTROL_STATE, ControlUtils } from '../../config/Controls';
import { Ship } from '../Ship';

export class Player extends Ship {
  constructor(scene, position, options = {}) {
    // Set default player options
    const playerOptions = {
      type: 'PLAYER',
      health: 100,
      maxHealth: 100,
      speed: 0.15,
      size: 1.0,
      shipModel: 'STANDARD',
      ...options
    };
    
    super(scene, position, playerOptions);
    
    // Player-specific properties
    this.moveDirection = new THREE.Vector3();
    this.velocity = new THREE.Vector3();
    this.rotation = new THREE.Euler();
    this.quaternion = new THREE.Quaternion();
    this.targetQuaternion = new THREE.Quaternion();
    
    // Movement state
    this.moveState = {
      forward: false,
      backward: false,
      left: false,
      right: false,
      boost: false
    };
    
    // Bind event handler methods to preserve 'this' context
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleKeyUp = this.handleKeyUp.bind(this);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    
    // Initialize controls
    this.setupControls();
  }

  setupControls() {
    // Keyboard controls
    document.addEventListener('keydown', this.handleKeyDown);
    document.addEventListener('keyup', this.handleKeyUp);
    
    // Mouse controls for aiming
    document.addEventListener('mousemove', this.handleMouseMove);
  }

  handleKeyDown(event) {
    switch(event.code) {
        case 'KeyW':
        this.moveState.forward = true;
          break;
        case 'KeyS':
        this.moveState.backward = true;
          break;
        case 'KeyA':
        this.moveState.left = true;
          break;
        case 'KeyD':
        this.moveState.right = true;
          break;
      case 'ShiftLeft':
        this.moveState.boost = true;
          break;
      }
  }
    
  handleKeyUp(event) {
    switch(event.code) {
        case 'KeyW':
        this.moveState.forward = false;
          break;
        case 'KeyS':
        this.moveState.backward = false;
          break;
        case 'KeyA':
        this.moveState.left = false;
          break;
        case 'KeyD':
        this.moveState.right = false;
        break;
      case 'ShiftLeft':
        this.moveState.boost = false;
          break;
      }
  }

  handleMouseMove(event) {
    // Update rotation based on mouse position
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // Calculate target rotation
    this.rotation.y = Math.atan2(mouseX, mouseY);
    this.targetQuaternion.setFromEuler(this.rotation);
  }
  
  update(deltaTime) {
    if (!this.isActive) return;
    
    super.update(deltaTime);
    
    // Update movement
    this.updateMovement(deltaTime);
    
    // Update rotation
    this.updateRotation(deltaTime);
    
    // Emit position update event
    this.emit('positionUpdate', {
      position: this.mesh.position.clone(),
      rotation: this.mesh.rotation.clone(),
      teamId: this.teamId
    });
  }

  updateMovement(deltaTime) {
    // Reset movement direction
    this.moveDirection.set(0, 0, 0);
    
    // Calculate movement direction based on input state
    if (this.moveState.forward) this.moveDirection.z -= 1;
    if (this.moveState.backward) this.moveDirection.z += 1;
    if (this.moveState.left) this.moveDirection.x -= 1;
    if (this.moveState.right) this.moveDirection.x += 1;
    
    // Normalize movement direction
    if (this.moveDirection.lengthSq() > 0) {
      this.moveDirection.normalize();
    }
    
    // Apply speed and boost
    const currentSpeed = this.moveState.boost ? this.options.speed * 1.5 : this.options.speed;
    
    // Update velocity with smooth acceleration
    const acceleration = 0.1;
    this.velocity.lerp(this.moveDirection.multiplyScalar(currentSpeed), acceleration);
    
    // Apply velocity
    this.mesh.position.add(this.velocity.clone().multiplyScalar(deltaTime));
    
    // Keep player within bounds (example bounds)
    const bounds = 50;
    this.mesh.position.x = Math.max(-bounds, Math.min(bounds, this.mesh.position.x));
    this.mesh.position.z = Math.max(-bounds, Math.min(bounds, this.mesh.position.z));
    
    // Broadcast position updates for multiplayer
    if (this.networkManager) {
      this.networkManager.emit('player_move', {
        position: this.mesh.position,
        rotation: this.mesh.rotation,
      });
    }
  }

  updateRotation(deltaTime) {
    // Smoothly interpolate current rotation to target rotation
    this.mesh.quaternion.slerp(this.targetQuaternion, 0.1);
  }

  getForwardDirection() {
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyQuaternion(this.mesh.quaternion);
    return forward;
  }

  getRightDirection() {
    const right = new THREE.Vector3(1, 0, 0);
    right.applyQuaternion(this.mesh.quaternion);
    return right;
  }

  // Override destroy to handle player-specific cleanup
  destroy() {
    if (!this.isActive) return;
    
    // Remove event listeners
    document.removeEventListener('keydown', this.handleKeyDown);
    document.removeEventListener('keyup', this.handleKeyUp);
    document.removeEventListener('mousemove', this.handleMouseMove);
    
    // Call parent destroy method
    super.destroy();
    
    // Emit player destroyed event
    this.emit('playerDestroyed', {
      position: this.mesh.position.clone(),
      teamId: this.teamId
    });
  }
} 
### ./entities/player/Player.js END ###

### DIRECTORY . FLATTENED CONTENT ###
