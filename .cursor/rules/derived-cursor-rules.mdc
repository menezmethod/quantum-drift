---
description: Cursor rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT OVERVIEW

This project, Quantum Drift, is a 3D space combat game.  The current focus is on implementing features outlined in `QUANTUM_DRIFT_CHECKLIST.md`, including a bounce laser, an infinite alien map, and refining the user interface.  Version 1.0 of the checklist was reviewed on 2025-03-10.  A bug related to the in-game "Change Ship" menu functionality was identified and resolved on 2025-03-10. The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A subsequent bug report on 2025-03-10 (9:07 PM) highlighted an issue with the in-game "Change Ship" menu not functioning correctly after pressing ESC. This issue was resolved by ensuring the in-game ESC menu's "Change Ship" functionality mirrors the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A further bug was identified where the game froze when switching options in the ship change menu. This issue was resolved by removing pause logic from the ship selection menu and keeping the game running continuously while menus are open.  A bug report detailing the freezing issue was filed on 2025-03-10 (9:07 PM). The final resolution involved removing pause logic and treating menus as overlays on a continuously running game loop.  Further issues with the "Change Ship" menu functionality were addressed on 2025-03-10.  These issues were resolved by ensuring proper re-initialization of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness.  Additional issues with the "Change Ship" menu functionality were identified and resolved on 2025-03-10.  The resolution involved ensuring proper re-initialization of the `ShipSelectionUI` instance and handling event listeners to prevent conflicts and ensure responsiveness.  A further error, "Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node," was resolved by adding a check to ensure the node exists and is a child of the container before attempting removal.  Subsequent issues with the "Change Ship" menu functionality, specifically the failure to apply the selected ship, were resolved by ensuring proper re-initialization and cleanup of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness. A check was added to ensure the node exists and is a child of its container before attempting removal in the `removeChild` operation.  A final issue where the ship model wasn't updating after selection was resolved by ensuring proper cleanup and re-initialization of the `ShipSelectionUI` instance and adding a check to ensure the node exists before removal.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay.  Proper re-initialization and cleanup of the `ShipSelectionUI` should be performed to avoid conflicts and ensure responsiveness.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay. The resolution of the "Change Ship" menu bug, including the addition of a check to prevent removing nodes that are not children, should be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The in-game ESC menu's "Change Ship" functionality should now mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` component should be reused for both main and in-game menus, maintaining consistent styling and functionality.  Development will now proceed with the implementation of an infinite map, starting with the strategic placement of existing assets to ensure game playability.  Collision detection will be carefully adjusted with the addition of new objects.


## CODE STYLE

Maintain consistent indentation (2 spaces).  Follow standard JavaScript naming conventions.  Comments should be clear and concise.


## FOLDER ORGANIZATION

The project follows a modular structure.  See the project structure for details.  This structure should be maintained.  A new folder structure for imported assets is recommended: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  A new folder structure for imported assets has been implemented: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  The project uses a modular folder structure.  The `/src/assets/models/` folder now contains subfolders for flora, rocks, and terrain.


## TECH STACK

- JavaScript (ES6+)
- Three.js (for 3D rendering)
- Webpack (for module bundling)
- GLTFLoader (for loading GLTF/GLB models)
- FBXLoader (for loading FBX models)


## PROJECT-SPECIFIC STANDARDS

- All sound effects should be in the `src/assets/sounds` folder.
-  New features should be implemented incrementally and thoroughly tested.
-  Use a consistent approach to collision detection and handling.
- The in-game ESC menu should be consistent with the main menu.  The "Change Ship" functionality in both menus now uses the same `ShipSelectionUI` instance and includes fade-in/fade-out transitions for improved user experience. Event listeners for menu buttons are now added only once during menu creation to prevent stacking.  The in-game ESC menu's "Change Ship" functionality should mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` should be properly re-initialized to avoid conflicts with event listeners and ensure responsiveness.  The `ShipSelectionUI` should be properly initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  The `ShipSelectionUI` should be properly re-initialized to prevent event listener conflicts and ensure that the selected ship is applied correctly.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The `ShipSelectionUI` should be properly re-initialized to prevent issues where the selected ship is not applied.  A check should be added to ensure the node exists and is a child of its container before attempting removal.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The game should remain running while menus are open; menus should function as overlays.  The game should not pause while menus are open; menus should function as overlays on a continuously running game.  The `ShipSelectionUI` should be properly re-initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The in-game ESC menu should function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling, and the game should remain running during menu interactions.  The implementation of the infinite map will involve the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.


## WORKFLOW & RELEASE RULES

- Utilize a version control system (Git) for all code changes.
- Commit messages should be clear and descriptive.
- Feature branches should be used for new features.
-  Bug fixes should be addressed promptly.  The resolution of the "Change Ship" menu bug serves as an example of prompt bug fixing and iterative development.  The fix included adding console logs for debugging purposes. The removal of pause logic during ship selection demonstrates a better approach for a multiplayer-style game.


## REFERENCE EXAMPLES

- Existing sound effect implementation in `src/index.js` can serve as a reference.
- The `BaseShip` class's `takeDamage` method provides an example of damage handling.
- The updated `showInGameMenu` and `showShipChangeScreen` methods in `src/index.js` (as of 2025-03-10) demonstrate best practices for menu handling and UI consistency, including the use of fade-in/fade-out transitions and a single `ShipSelectionUI` instance.  The revised methods (post 2025-03-10) demonstrate a continuous game loop with UI overlays.  The updated `showShipChangeScreen` method (post 2025-03-10) demonstrates proper re-initialization of the `ShipSelectionUI` to prevent event listener conflicts.  The `AssetManager.js` file provides an example of how to manage the loading of 3D models.  The updated `showShipChangeScreen` and `applyShipSelection` methods (post 2025-03-10) demonstrate proper handling of the `removeChild` method, including checks to ensure the node exists and is a child of its parent before removal.  The `AssetManager.js` file provides an example of how to manage the loading of 3D models, and the updated `applyShipSelection` method demonstrates proper cleanup of the existing ship model before applying a new one.


## PROJECT DOCUMENTATION & CONTEXT SYSTEM

-  `QUANTUM_DRIFT_CHECKLIST.md` tracks development progress. Updates to the checklist should be reflected in this file. Version 1.0 of this document was reviewed on 2025-03-10.  The resolution of the "Change Ship" menu bug should be documented in a subsequent checklist update.  The bug report from 2025-03-10 (9:07 PM) should also be documented.  The resolution of the game freeze issue during ship selection should be documented, highlighting the removal of pause logic.  The resolution of subsequent issues related to event listener conflicts and UI responsiveness should also be documented.  The resolution of the "removeChild" error should be documented, highlighting the addition of a check to ensure the node exists and is a child of its container before removal.  The resolution of the issue where the ship model wasn't updating after ship selection should be documented.  The resolution of the final issue with ship model updates should be documented, highlighting the addition of model cleanup and re-initialization.  The resolution of the "Change Ship" menu bug, including the removal of pause logic and the implementation of UI overlays, should be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The checklist should be updated to reflect the completion of the "Change Ship" bug fixes.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the resolution of the "Change Ship" menu bug.  The `QUANTUM_DRIFT_CHECKLIST.md` file should be updated to reflect the resolution of the in-game ship selection menu issues.  The implementation of the infinite map will be documented in `QUANTUM_DRIFT_CHECKLIST.md`, including details on asset placement and collision handling.


## DEBUGGING

- Utilize the browser's developer tools for debugging.
- Add console logs for tracking variables and function calls.  The addition of console logs in the updated "Change Ship" code (2025-03-10) is an example of effective debugging techniques.  The updated code includes improved logging for tracking the visibility and initialization of the ship selection UI.  Strategic logging has been added to the `animate()` and `resumeGame()` methods to track animation frame IDs, game state, and UI visibility to help diagnose the freezing issue. This logging includes a frame counter to log game state approximately every second.  The final debugging involved removing unnecessary pause logic and simplifying the game loop.  Strategic logging was crucial in identifying and resolving issues related to the re-initialization of the `ShipSelectionUI` and event listener management.  Additional logging was added to track the ship model update process.  Strategic logging was used to identify and resolve issues related to ship model updates and collision detection.  The addition of strategic logging to the `animate()` and `showShipChangeScreen` methods proved crucial in identifying and resolving the freezing issue.  The use of console logs for debugging purposes is recommended.  Strategic logging proved crucial in identifying issues with the ship model update process.  Additional debugging will focus on implementing the infinite map and ensuring smooth collision detection with randomly placed objects.


## FINAL DOs AND DON'Ts

- **DO** write clear, concise, and well-documented code.
- **DO** test thoroughly before merging into main branch.
- **DO** use version control effectively.
- **DON'T** commit broken code.
- **DON'T** introduce unnecessary complexity.
- **DON'T** neglect error handling.
- **DON'T** deviate from the established folder structure unless there is a justified reason.
- **DO** utilize fade-in/fade-out transitions for improved UI experience, as demonstrated in the updated "Change Ship" menu functionality (2025-03-10).
- **DO** reuse UI components where appropriate to maintain consistency (e.g., using the same `ShipSelectionUI` instance for both main and in-game menus).
- **DO** add console logs strategically for debugging purposes, as demonstrated in the fix for the "Change Ship" menu bug.
- **DO** prevent duplicate event listeners by managing them efficiently, as demonstrated in the updated menu handling code.  Ensure proper re-initialization of UI components to avoid event listener conflicts.
- **DON'T** introduce pause logic in the ship selection menu, as it is unnecessary for a multiplayer game.  Menus should function as overlays on a continuously running game loop.
- **DO** ensure proper cleanup and re-initialization of UI components, particularly when reusing instances, to avoid conflicts and maintain responsiveness.  Ensure proper checks are in place before removing child nodes to prevent runtime errors.  Always check if a node exists and is a child of its parent before attempting to remove it using `removeChild`.  Ensure proper cleanup of the ship model before applying a new one to prevent visual and functional issues.  Always check if a node exists and is a child of its parent before attempting removal using `removeChild`.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  Always check for null values before accessing properties of objects.
- **DO** use GLTF/GLB for 3D models.  FBX can also be used, but requires additional scaling.  The use of GLTF/GLB models is preferred for compatibility and efficiency. FBX models can also be used but may require additional scaling adjustments.  When importing assets from external sources, always ensure they are converted into GLTF/GLB format to maintain consistency and compatibility with the project's Three.js rendering engine.  Before removing a node using `removeChild`, always ensure that the node exists and is a child of the parent node to prevent runtime errors.  Always check that a node exists and is a child of its parent before using `removeChild`.  The use of GLTF/GLB models is strongly preferred for better performance and compatibility with Three.js.  FBX models can be used but may require additional scaling and may introduce potential compatibility issues.  The use of a dedicated asset manager (e.g., `AssetManager.js`) is recommended to handle loading and management of 3D models, textures, and other assets efficiently.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.