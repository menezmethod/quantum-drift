---
description: Cursor rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT OVERVIEW

This project, Quantum Drift, is a 3D space combat game.  The current focus is on implementing features outlined in `QUANTUM_DRIFT_CHECKLIST.md`, including a bounce laser, an infinite alien map, and refining the user interface.  Version 1.0 of the checklist was reviewed on 2025-03-10.  A bug related to the in-game "Change Ship" menu functionality was identified and resolved on 2025-03-10. The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A subsequent bug report on 2025-03-10 (9:07 PM) highlighted an issue with the in-game "Change Ship" menu not functioning correctly after pressing ESC. This issue was resolved by ensuring the in-game ESC menu's "Change Ship" functionality mirrors the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A further bug was identified where the game froze when switching options in the ship change menu. This issue was resolved by removing pause logic from the ship selection menu and keeping the game running continuously while menus are open.  A bug report detailing the freezing issue was filed on 2025-03-10 (9:07 PM). The final resolution involved removing pause logic and treating menus as overlays on a continuously running game loop.  Further issues with the "Change Ship" menu functionality were addressed on 2025-03-10.  These issues were resolved by ensuring proper re-initialization of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness.  Additional issues with the "Change Ship" menu functionality were identified and resolved on 2025-03-10.  The resolution involved ensuring proper re-initialization of the `ShipSelectionUI` instance and handling event listeners to prevent conflicts and ensure responsiveness.  A further error, "Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node," was resolved by adding a check to ensure the node exists and is a child of the container before attempting removal.  Subsequent issues with the "Change Ship" menu functionality, specifically the failure to apply the selected ship, were resolved by ensuring proper re-initialization and cleanup of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness. A check was added to ensure the node exists and is a child of its container before attempting removal in the `removeChild` operation.  A final issue where the ship model wasn't updating after selection was resolved by ensuring proper cleanup and re-initialization of the `ShipSelectionUI` instance and adding a check to ensure the node exists before removal.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay.  Proper re-initialization and cleanup of the `ShipSelectionUI` should be performed to avoid conflicts and ensure responsiveness.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay. The resolution of the "Change Ship" menu bug, including the addition of a check to prevent removing nodes that are not children, should be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The in-game ESC menu's "Change Ship" functionality should now mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` component should be reused for both main and in-game menus, maintaining consistent styling and functionality.  Development will now proceed with the implementation of an infinite map, starting with the strategic placement of existing assets to ensure game playability.  Collision detection will be carefully adjusted with the addition of new objects. The infinite map implementation, completed on 2025-03-10, involved the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The implementation details are documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The infinite map implementation has been completed and integrated into the game.  The implementation includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers.  The MiniMap has also been updated to support the infinite map system.  Several previously omitted features have been re-integrated and updated for compatibility with the new infinite map system. The infinite map implementation, completed on 2025-03-10, involved strategic asset placement for game playability and adjusted collision detection. Details are in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The implementation of the infinite map involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The implementation of the infinite map, completed on 2025-03-10, involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The reintegration of previously omitted features, including `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`, ensures full functionality.  The implementation of the infinite map involved strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation now includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers. The minimap has been updated to support the infinite map.  The infinite map implementation will prioritize efficient asset placement and collision detection algorithms.  Strategic placement of existing assets will ensure game playability while careful adjustment of collision detection will maintain this playability.  The minimap will be updated to reflect the infinite map.  The infinite map implementation uses a chunk-based system for procedural generation, object culling for performance, and updated collision detection. The minimap has been updated to support the infinite map system.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system. The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor.  The implementation includes scaling and positioning adjustments to integrate it seamlessly into the game world. The floor now casts and receives shadows for improved visual realism.  The floor's material properties have been enhanced.  A subtle glow effect has been added to the terrain for visual appeal.  A circular highlight has been added around the player's position for enhanced visual feedback.  A fallback mechanism has been implemented in case Terrain.glb fails to load.  The infinite map implementation prioritizes efficient asset placement and collision detection algorithms.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor.  Implementation details are documented in `QUANTUM_DRIFT_CHECKLIST.md`.
The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The game floor now utilizes the `/src/assets/models/terrain/Terrain.glb` model.  The implementation includes scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures. A texture from `/src/assets/models/textures/tex.png` has been added to the terrain. The texture is repeated 5 times in both directions, and a color blend is applied for visual enhancement.  The mouse pointer was temporarily off due to changes in the terrain implementation. This was resolved by implementing a dedicated invisible plane for raycasting, ensuring consistent mouse interaction regardless of the visual floor implementation.  The infinite map implementation now includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers.  The minimap has been updated to support the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures. A texture from `/src/assets/models/textures/tex.png` has been added to the terrain. The texture is repeated 5 times in both directions, and a color blend is applied for visual enhancement.  The mouse pointer issue was resolved by implementing a dedicated invisible plane for raycasting, ensuring consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map involved strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain, enhancing its visual appeal.  The implementation involved adjusting the texture's wrapping and repeating parameters for optimal visual results.  The strategic placement of additional `SP_Ground02-05.glb` models has enhanced the game's landscape.  The implementation included careful consideration of object placement to ensure game playability and visual appeal.  The implementation of the infinite map, starting with strategic placement of existing assets and adjusted collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system. The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The implementation includes scaling and positioning adjustments to integrate it seamlessly into the game world. The floor now casts and receives shadows for improved visual realism.  The floor's material properties have been enhanced.  A subtle glow effect has been added to the terrain for visual appeal.  A circular highlight has been added around the player's position for enhanced visual feedback.  A fallback mechanism has been implemented in case Terrain.glb fails to load.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The implementation of the infinite map, including the strategic placement of assets and the adjustment of collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  A new `InfiniteMap.js` file has been added to the project, implementing a chunk-based system for procedural generation, object culling, and updated collision detection.  The `MiniMap.js` file has been updated to integrate with the infinite map system. The game floor now utilizes the `/src/assets/models/terrain/Terrain.glb` model, with scaling, positioning, shadowing, material enhancements, and glow effect. A fallback mechanism handles loading failures. A texture from `/src/assets/models/textures/tex.png` is applied, repeated 5 times, with color blending for visual enhancement.  An invisible plane is implemented for raycasting, ensuring consistent mouse interaction.  The implementation of the infinite map involved strategic placement of existing assets, adjusted collision detection, and a new texture, `/src/assets/models/textures/Colors3.png`, applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor, with the `/src/assets/models/textures/Colors3.png` texture applied.  The implementation of the infinite map involved strategic asset placement and adjusted collision detection.  The QUANTUM_DRIFT_CHECKLIST.md file has been updated to reflect the completion of the infinite map implementation (2025-03-10).  The QUANTUM_DRIFT_CHECKLIST.md file has been updated to reflect the reintegration of the following methods: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the completion of the infinite map implementation, including details on asset placement, collision detection, and chunk management.  The implementation of the infinite map, including object placement and collision detection adjustments, will be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map and the use of the Terrain.glb model as the game floor are documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including the use of `/src/assets/models/terrain/Terrain.glb` as the game floor, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including strategic asset placement and adjusted collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects. The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to include details on the implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation. The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the removal of the `SP_Ground01.glb` model and the addition of more mountains and ground features.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the implementation of the improved collision system, which uses compound shapes for more accurate collision detection. The game is now multiplayer only.
The game is now multiplayer only.  The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only.


## CODE STYLE

Maintain consistent indentation (2 spaces).  Follow standard JavaScript naming conventions.  Comments should be clear and concise.

## FOLDER ORGANIZATION

The project follows a modular structure.  See the project structure for details.  This structure should be maintained.  A new folder structure for imported assets is recommended: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  A new folder structure for imported assets has been implemented: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  The project uses a modular folder structure.  The `/src/assets/models/` folder now contains subfolders for flora, rocks, and terrain.  The file `/src/assets/models/objects/SP_Ground01.glb` has been removed from the project.  A new `src/core/NetworkManager.js` file has been added to handle networking logic for multiplayer support.

## TECH STACK

- JavaScript (ES6+)
- Three.js (for 3D rendering)
- Webpack (for module bundling)
- GLTFLoader (for loading GLTF/GLB models)
- FBXLoader (for loading FBX models)
- Socket.io-client (for WebSocket communication)
- Socket.io (for server-side WebSocket handling)
- concurrently (for running dev server and game server simultaneously)
- uuid (for generating unique player IDs)
- OrbitControls (for camera controls)
- @three/examples/jsm/controls/OrbitControls.js
- @three/examples/jsm/loaders/GLTFLoader.js
- @three/examples/jsm/renderers/CSS2DRenderer.js


## PROJECT-SPECIFIC STANDARDS

- All sound effects should be in the `src/assets/sounds` folder.
-  New features should be implemented incrementally and thoroughly tested.
-  Use a consistent approach to collision detection and handling.  The collision detection system has been updated to use oriented bounding boxes for more accurate collision detection. A two-stage collision detection system has been implemented, first performing a quick sphere-based check for efficiency and then performing a more accurate bounding box check for close objects. The checkSphereBoxIntersection method has been added for precise collision detection between spheres and boxes.
- The in-game ESC menu should be consistent with the main menu.  The "Change Ship" functionality in both menus now uses the same `ShipSelectionUI` instance and includes fade-in/fade-out transitions for improved user experience. Event listeners for menu buttons are now added only once during menu creation to prevent stacking.  The in-game ESC menu's "Change Ship" functionality should mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` should be properly re-initialized to avoid conflicts with event listeners and ensure responsiveness.  The `ShipSelectionUI` should be properly initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  The `ShipSelectionUI` should be properly re-initialized to prevent event listener conflicts and ensure that the selected ship is applied correctly.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The `ShipSelectionUI` should be properly re-initialized to prevent issues where the selected ship is not applied.  A check should be added to ensure the node exists and is a child of its container before attempting removal.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The game should remain running while menus are open; menus should function as overlays.  The game should not pause while menus are open; menus should function as overlays on a continuously running game.  The `ShipSelectionUI` should be properly re-initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The in-game ESC menu should function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling, and the game should remain running during menu interactions.  The implementation of the infinite map will involve the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation prioritizes efficient asset placement and collision detection.  The game should not pause when menus are open; menus should function as overlays.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container. The following methods were re-integrated from the original codebase: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, ensure strategic placement of assets to maintain game playability and adjust collision detection accordingly.  The infinite map implementation uses a chunk-based system for procedural generation and object culling.  The minimap has been updated to support the infinite map.  The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model for improved visual realism and immersion.  The infinite map implementation now uses a chunk-based system, object culling, and updated collision detection.  The minimap has been updated to support this system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The `/src/assets/models/terrain/Terrain.glb` model should be used as the game floor. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  For raycasting, use a dedicated invisible plane to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Always ensure that the targeting indicator is properly positioned and visible above the terrain.  Use a dedicated invisible plane for raycasting to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Ensure that the raycasting plane is positioned sufficiently high above the terrain to avoid interference with the terrain geometry. Add strategic console logs to track mouse positions, raycast results, and targeting indicator properties for debugging purposes.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality.  The implementation of the infinite map should prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality. A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  The implementation involved strategic placement of additional ground models (`SP_Ground02-05.glb`) to enhance the game's landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  For raycasting, a dedicated invisible plane should be used to ensure consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, including scaling, positioning, shadowing, material enhancements, and glow effect. A fallback mechanism is in place for loading failures.  A texture from `/src/assets/models/textures/tex.png` is applied, repeated 5 times, with color blending for visual enhancement. An invisible plane is implemented for raycasting, ensuring consistent mouse interaction.  A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved collision system, which uses compound shapes for more accurate collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. For multiplayer, considerations for TCP/UDP architecture are needed. Simplest architecture for beginners will be researched.  Multiplayer support will be implemented using a client-server architecture with WebSockets. A dedicated `NetworkManager` class will handle all networking-related tasks.  This approach minimizes disruption to the existing codebase. The game is now multiplayer only.
The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only. The game is now multiplayer only.


## WORKFLOW & RELEASE RULES

- Utilize a version control system (Git) for all code changes.
- Commit messages should be clear and descriptive.
- Feature branches should be used for new features.
-  Bug fixes should be addressed promptly.  The resolution of the "Change Ship" menu bug serves as an example of prompt bug fixing and iterative development.  The fix included adding console logs for debugging purposes. The removal of pause logic during ship selection demonstrates a better approach for a multiplayer-style game.  For multiplayer game development,  consider using a client-server architecture with appropriate networking protocols (TCP/UDP) to handle communication between players.  For multiplayer, a client-server architecture using WebSockets will be implemented.  The focus will be on a simple, beginner-friendly approach to minimize disruption to the existing code.  A dedicated `NetworkManager` class will handle all networking logic. To test the multiplayer functionality, run `npm run dev:all` to start both the game client and server. Multiple browser instances are required to test interactions between players. The game is now multiplayer only.


## REFERENCE EXAMPLES

- Existing sound effect implementation in `src/index.js` can serve as a reference.
- The `BaseShip` class's `takeDamage` method provides an example of damage handling.
- The updated `showInGameMenu` and `showShipChangeScreen` methods in `src/index.js` (as of 2025-03-10) demonstrate best practices for menu handling and UI consistency, including the use of fade-in/fade-out transitions and a single `ShipSelectionUI` instance.  The revised methods (post 2025-03-10) demonstrate a continuous game loop with UI overlays.  The updated `showShipChangeScreen` method (post 2025-03-10) demonstrates proper re-initialization of the `ShipSelectionUI` to prevent event listener conflicts.  The `AssetManager.js` file provides an example of how to manage the loading of 3D models.  The updated `showShipChangeScreen` and `applyShipSelection` methods (post 2025-03-10) demonstrate proper handling of the `removeChild` method, including checks to ensure the node exists and is a child of its parent before removal.  The `AssetManager.js` file provides an example of how to manage the loading of 3D models, and the updated `applyShipSelection` method demonstrates proper cleanup of the existing ship model before applying a new one. The `InfiniteMap.js` file (added 2025-03-10) provides a reference implementation for procedural map generation and chunk management.  The updated `MiniMap.js` file (added 2025-03-10) demonstrates how to integrate the minimap with the infinite map system.  The `InfiniteMap.js` and updated `Game.js` files demonstrate best practices for implementing an infinite map system, including chunk management, object culling, and collision detection.  The `InfiniteMap.js` file provides a reference implementation for a chunk-based infinite map system.  The updated `MiniMap.js` file demonstrates how to render objects from the infinite map onto the minimap.  The updated `Game.js` file demonstrates how to integrate the infinite map system into the game loop and handle collisions.  The `InfiniteMap.js` file now serves as a reference implementation for a chunk-based infinite map system, including asset loading, placement, and collision detection. The updated `MiniMap.js` file demonstrates how to integrate the minimap with the infinite map system, including rendering objects from chunks. The updated `Game.js` file demonstrates how to integrate the infinite map system, including collision detection, and manage player interaction with objects across chunks.  The `InfiniteMap.js` file, added on 2025-03-10, provides a reference implementation for a chunk-based infinite map system, including asset loading, placement, and collision detection.  The `InfiniteMap.js` file provides a reference implementation for a chunk-based infinite map system, including asset loading, placement, and collision detection.  The updated `MiniMap.js` file demonstrates how to integrate the minimap with the infinite map system, including rendering objects from chunks.  The updated `Game.js` file demonstrates how to integrate the infinite map system, including collision detection, and manage player interaction with objects across chunks.  The `InfiniteMap.js` file provides a reference implementation for a chunk-based infinite map system, including asset loading, placement, and collision detection. The `calculateGroundOffset` method provides a reference for calculating accurate ground placement for objects with varied geometries and pivot points.  The `NetworkManager.js` file (added 2025-03-10) provides a reference implementation for handling WebSocket connections and managing multiplayer game state. The `NetworkManager.js` file provides a reference implementation for handling WebSocket connections and managing multiplayer game state, including connection management, player updates, and laser shot synchronization.


## PROJECT DOCUMENTATION & CONTEXT SYSTEM

-  `QUANTUM_DRIFT_CHECKLIST.md` tracks development progress. Updates to the checklist should be reflected in this file. Version 1.0 of this document was reviewed on 2025-03-10.  The resolution of the "Change Ship" menu bug should be documented in a subsequent checklist update.  The bug report from 2025-03-10 (9:07 PM) should also be documented.  The resolution of the game freeze issue during ship selection should be documented, highlighting the removal of pause logic.  The resolution of subsequent issues related to event listener conflicts and UI responsiveness should also be documented.  The resolution of the "removeChild" error should be documented, highlighting the addition of a check to ensure the node exists and is a child of its container before removal.  The resolution of the issue where the ship model wasn't updating after ship selection should be documented.  The resolution of the final issue with ship model updates should be documented, highlighting the addition of model cleanup and re-initialization.  The resolution of the "Change Ship" menu bug, including the removal of pause logic and the implementation of UI overlays, should be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The checklist should be updated to reflect the completion of the "Change Ship" bug fixes.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the resolution of the "Change Ship" menu bug.  The `QUANTUM_DRIFT_CHECKLIST.md` file should be updated to reflect the resolution of the in-game ship selection menu issues.  The implementation of the infinite map will be documented in `QUANTUM_DRIFT_CHECKLIST.md`, including details on asset placement and collision handling. The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the completion of the infinite map implementation (2025-03-10).  The `QUANTUM_DRIFT_CHECKLIST.md` file should be updated to reflect the reintegration of previously omitted features.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the reintegration of the following methods: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the completion of the infinite map implementation, including details on asset placement, collision detection, and chunk management.  The implementation of the infinite map, including object placement and collision detection adjustments, will be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map and the use of the Terrain.glb model as the game floor are documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including the use of `/src/assets/models/terrain/Terrain.glb` as the game floor, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including strategic asset placement and adjusted collision detection, is documented in `QUANTUM_DRIFT