---
description: Cursor rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT OVERVIEW

## CODE STYLE

Maintain consistent indentation (2 spaces).  Follow standard JavaScript naming conventions.  Comments should be clear and concise.

## FOLDER ORGANIZATION

The project follows a modular structure.  See the project structure for details.  This structure should be maintained.  A new folder structure for imported assets is recommended: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  A new folder structure for imported assets has been implemented: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  The project uses a modular folder structure.  The `/src/assets/models/` folder now contains subfolders for flora, rocks, and terrain.  The file `/src/assets/models/objects/SP_Ground01.glb` has been removed from the project.  A new `src/core/NetworkManager.js` file has been added to handle networking logic for multiplayer support.  The `/assets` directory now contains subdirectories for `models`, `sounds`, and `textures`.  The `/src/assets/models/ships` directory now contains `ALTSPACE1.glb` and `ALTSPACE2.glb`.  The project structure has been reorganized to improve maintainability and facilitate LLM collaboration, as detailed in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`. The new structure centralizes core game logic, entities, UI components, assets, and configurations into dedicated folders. The project structure now follows the recommendations in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`, centralizing core game logic, entities, UI, assets, and configurations into dedicated folders.  All core game mechanics (ship management, weapon systems) are now centralized into reusable modules under the `core/` directory. All asset loading is now delegated to `AssetLoader.js`.  The project structure has been updated to reflect the centralization of asset loading, as detailed in `docs/2025-03-11-52-centralizing-asset-loading-in-codebase.md`. The game is now multiplayer only.  All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. A codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. A new `WeaponSystem.js` file has been added to the `src/entities/weapons` directory.

## TECH STACK

- JavaScript (ES6+)
- Three.js (for 3D rendering)
- Webpack (for module bundling)
- GLTFLoader (for loading GLTF/GLB models)
- FBXLoader (for loading FBX models)
- Socket.io-client (for WebSocket communication)
- Socket.io (for server-side WebSocket handling)
- concurrently (for running dev server and game server simultaneously)
- uuid (for generating unique player IDs)
- OrbitControls (for camera controls)
- @three/examples/jsm/controls/OrbitControls.js
- @three/examples/jsm/loaders/GLTFLoader.js
- @three/examples/jsm/renderers/CSS2DRenderer.js
- AssetLoader (Custom asset loading manager)
- EventEmitter (for event handling)
- NetworkManager (for multiplayer networking)
- WeaponSystem (Custom weapon management system)


## PROJECT-SPECIFIC STANDARDS

- All sound effects should be in the `src/assets/sounds` folder.
-  New features should be implemented incrementally and thoroughly tested.
-  Use a consistent approach to collision detection and handling.  The collision detection system has been updated to use oriented bounding boxes for more accurate collision detection. A two-stage collision detection system has been implemented, first performing a quick sphere-based check for efficiency and then performing a more accurate bounding box check for close objects. The checkSphereBoxIntersection method has been added for precise collision detection between spheres and boxes.  The bouncing laser system has been significantly improved, including the addition of a `checkBoxIntersection` method for more accurate collision detection with boxes, and support for compound collision shapes.  The improved bouncing laser system is detailed in `2025-03-12_21-09-fixing-unresolved-variable-issue.md`.  The `updateBouncingLasers` method has been updated to include the necessary variable declarations (`bounced`, `tempRay`, `tempVector`, `closestDist`) and to handle different collision shapes (boxes and spheres) more accurately.  A new `rayBoxIntersection` method has been added to handle ray-box intersection more effectively. The collision detection now uses a two-stage approach: a quick sphere-based check followed by a more accurate bounding box check if necessary.  The `rayBoxIntersection` method handles rotated boxes and returns both the intersection point and normal vector.  Error handling has been improved to handle cases where `obstacle.boundingBox` is not a THREE.Box3 object.  The `updateBouncingLasers` method has been significantly improved to handle different collision shapes (boxes and spheres) more accurately, and includes proper variable declarations. A new `rayBoxIntersection` method has been added for accurate ray-box intersection handling. The collision detection now uses a two-stage approach: a quick sphere-based check followed by a more accurate bounding box check if necessary. The `rayBoxIntersection` method handles rotated boxes and returns both the intersection point and normal vector. Error handling has been improved to handle cases where `obstacle.boundingBox` is not a THREE.Box3 object. The bouncing laser system now uses a two-stage collision detection system: a quick sphere-based check followed by a more precise box check if available.  The `rayBoxIntersection` method accurately handles ray-box intersections, considering box rotation.  Error handling is improved to manage cases where `obstacle.boundingBox` is not a THREE.Box3 object.
- The in-game ESC menu should be consistent with the main menu.  The "Change Ship" functionality in both menus now uses the same `ShipSelectionUI` instance and includes fade-in/fade-out transitions for improved user experience. Event listeners for menu buttons are now added only once during menu creation to prevent stacking.  The in-game ESC menu's "Change Ship" functionality should mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` should be properly re-initialized to avoid conflicts with event listeners and ensure responsiveness.  The `ShipSelectionUI` should be properly initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  The `ShipSelectionUI` should be properly re-initialized to prevent event listener conflicts and ensure that the selected ship is applied correctly.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The `ShipSelectionUI` should be properly re-initialized to prevent issues where the selected ship is not applied.  A check should be added to ensure the node exists and is a child of its container before attempting removal.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The game should remain running while menus are open; menus should function as overlays.  The game should not pause while menus are open; menus should function as overlays on a continuously running game.  The `ShipSelectionUI` should be properly re-initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The in-game ESC menu should function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling, and the game should remain running during menu interactions.  The implementation of the infinite map will involve the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation prioritizes efficient asset placement and collision detection.  The game should not pause when menus are open; menus should function as overlays.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container. The following methods were re-integrated from the original codebase: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, ensure strategic placement of assets to maintain game playability and adjust collision detection accordingly.  The infinite map implementation uses a chunk-based system for procedural generation and object culling.  The minimap has been updated to support the infinite map.  The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model for improved visual realism and immersion.  The infinite map implementation now uses a chunk-based system, object culling, and updated collision detection.  The minimap has been updated to support this system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The `/src/assets/models/terrain/Terrain.glb` model should be used as the game floor. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  For raycasting, use a dedicated invisible plane to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Always ensure that the targeting indicator is properly positioned and visible above the terrain.  Use a dedicated invisible plane for raycasting to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Ensure that the raycasting plane is positioned sufficiently high above the terrain to avoid interference with the terrain geometry. Add strategic console logs to track mouse positions, raycast results, and targeting indicator properties for debugging purposes.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality.  The implementation of the infinite map should prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality. A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  The implementation involved strategic placement of additional ground models (`SP_Ground02-05.glb`) to enhance the game's landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  For raycasting, a dedicated invisible plane should be used to ensure consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, including scaling, positioning, shadowing, material enhancements, and glow effect. A fallback mechanism is in place for loading failures.  A texture from `/src/assets/models/textures/tex.png` is applied, repeated 5 times, with color blending for visual enhancement. An invisible plane is implemented for raycasting, ensuring consistent mouse interaction.  A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved collision system, which uses compound shapes for more accurate collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. For multiplayer, considerations for TCP/UDP architecture are needed. Simplest architecture for beginners will be researched.  Multiplayer support will be implemented using a client-server architecture with WebSockets. A dedicated `NetworkManager` class will handle all networking-related tasks.  This approach minimizes disruption to the existing codebase.  The game now uses a client-server architecture with WebSockets for multiplayer functionality, managed by a dedicated `NetworkManager` class.  This is detailed in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`.  Ensure the `shipType` sent from the server matches the keys in `AssetLoader` (e.g., 'FIGHTER', 'INTERCEPTOR', 'SCOUT', 'EXPERIMENTAL'). Add console logs to track if `player_update` events are received and if the positions are updating as expected in `updateOtherPlayers()`. Ensure your `NetworkManager` is receiving `laser_shot` events and that `fireLaser()` or `fireBouncingLaser()` are correctly adding these to the scene. Add console logs to confirm these events are triggered and check if the laser objects are visible with proper materials. Modify your 3D models in a tool like Blender to have separate materials for parts like the body and accents. Then, in `getShipModel()` in `assetloader.js`, set only specific materials to the team color while keeping others (e.g., windows) with original colors. Check the `MiniMap` class implementation to ensure it's being updated in the game loop with current positions. Verify the mini-map's camera is set up to view from above and that its canvas is visible on screen. Debug by adding logs to see if positions are being passed correctly. To improve visuals, give ships random, nuanced colors by modifying models to support partial coloring.  This means modifying 3D models to have separate materials for different parts (e.g., body, accents) and then, in `getShipModel()`, setting only specific materials to team colors while leaving others with their original colors.  All core game mechanics (ship management, weapon systems) are now centralized into reusable modules under the `core/` directory.  All asset loading is now delegated to `AssetLoader.js`.  The project structure is now organized according to the recommendations in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`.  Proper error handling with try-catch blocks and consistent error logging has been implemented throughout the codebase.  All features (weapon switching, enemy AI, minimap) are now fully functional and thoroughly tested. The game is now multiplayer only. Use `AssetLoader.js` as the sole asset loader. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only.
All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only. Bounce laser damage updated to 50. Health auto-healing implemented at half the rate of energy regeneration. Enemy health display always visible. Enemy visibility issues fixed. Performance optimizations implemented. Code cleanup completed. Controls should auto-hide after a timeout.  A SpecStory codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`.  A codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`.
The game is now multiplayer only.  All asset loading is now handled by AssetLoader.js, removing duplicate loading functions from index.js.  A new `2025-03-12_20-18-moving-asset-logic-to-assetloader.md` file details refactoring strategies (direct transfer, composition, inheritance, event-based communication, facade, service locator, dependency injection) for moving asset logic from `Game.js` to `AssetLoader.js`.  The composition pattern was chosen to avoid dependency loops