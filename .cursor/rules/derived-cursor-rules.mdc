---
description: Cursor rules derived by SpecStory from the project AI interaction history
globs: *
---

## PROJECT OVERVIEW

This project, Quantum Drift, is a 3D space combat game.  The current focus is on implementing features outlined in `QUANTUM_DRIFT_CHECKLIST.md`, including a bounce laser, an infinite alien map, and refining the user interface.  Version 1.0 of the checklist was reviewed on 2025-03-10.  A bug related to the in-game "Change Ship" menu functionality was identified and resolved on 2025-03-10. The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A subsequent bug report on 2025-03-10 (9:07 PM) highlighted an issue with the in-game "Change Ship" menu not functioning correctly after pressing ESC. This issue was resolved by ensuring the in-game ESC menu's "Change Ship" functionality mirrors the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A further bug was identified where the game froze when switching options in the ship change menu. This issue was resolved by removing pause logic from the ship selection menu and keeping the game running continuously while menus are open.  A bug report detailing the freezing issue was filed on 2025-03-10 (9:07 PM). The final resolution involved removing pause logic and treating menus as overlays on a continuously running game loop.  Further issues with the "Change Ship" menu functionality were addressed on 2025-03-10.  These issues were resolved by ensuring proper re-initialization of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness.  Additional issues with the "Change Ship" menu functionality were identified and resolved on 2025-03-10.  The resolution involved ensuring proper re-initialization of the `ShipSelectionUI` instance and handling event listeners to prevent conflicts and ensure responsiveness.  A further error, "Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node," was resolved by adding a check to ensure the node exists and is a child of the container before attempting removal.  Subsequent issues with the "Change Ship" menu functionality, specifically the failure to apply the selected ship, were resolved by ensuring proper re-initialization and cleanup of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness. A check was added to ensure the node exists and is a child of its parent container before attempting removal in the `removeChild` operation.  A final issue where the ship model wasn't updating after selection was resolved by ensuring proper cleanup and re-initialization of the `ShipSelectionUI` instance and adding a check to ensure the node exists before removal.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay.  Proper re-initialization and cleanup of the `ShipSelectionUI` should be performed to avoid conflicts and ensure responsiveness.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay. The resolution of the "Change Ship" menu bug, including the addition of a check to prevent removing nodes that are not children, should be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The in-game ESC menu's "Change Ship" functionality should now mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` component should be reused for both main and in-game menus, maintaining consistent styling and functionality.  Development will now proceed with the implementation of an infinite map, starting with the strategic placement of existing assets to ensure game playability.  Collision detection will be carefully adjusted with the addition of new objects. The infinite map implementation, completed on 2025-03-10, involved the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The implementation details are documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The infinite map implementation has been completed and integrated into the game.  The implementation includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers.  The MiniMap has also been updated to support the infinite map system.  Several previously omitted features have been re-integrated and updated for compatibility with the new infinite map system. The infinite map implementation, completed on 2025-03-10, involved strategic asset placement for game playability and adjusted collision detection. Details are in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The implementation of the infinite map involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The implementation of the infinite map, completed on 2025-03-10, involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The reintegration of previously omitted features, including `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`, ensures full functionality.  The implementation of the infinite map involved strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation now includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers. The minimap has been updated to support the infinite map.  The infinite map implementation will prioritize efficient asset placement and collision detection algorithms.  Strategic placement of existing assets will ensure game playability while careful adjustment of collision detection will maintain this playability.  The minimap will be updated to reflect the infinite map.  The infinite map implementation uses a chunk-based system for procedural generation, object culling for performance, and updated collision detection. The minimap has been updated to support the infinite map system.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system. The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor.  The implementation includes scaling and positioning adjustments to integrate it seamlessly into the game world. The floor now casts and receives shadows for improved visual realism.  The floor's material properties have been enhanced.  A subtle glow effect has been added to the terrain for visual appeal.  A circular highlight has been added around the player's position for enhanced visual feedback.  A fallback mechanism has been implemented in case Terrain.glb fails to load.  The infinite map implementation prioritizes efficient asset placement and collision detection algorithms.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor.  Implementation details are documented in `QUANTUM_DRIFT_CHECKLIST.md`. The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The game floor now utilizes the `/src/assets/models/terrain/Terrain.glb` model.  The implementation includes scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A texture from `/src/assets/models/textures/tex.png` has been added to the terrain. The texture is repeated 5 times in both directions, and a color blend is applied for visual enhancement.  The mouse pointer was temporarily off due to changes in the terrain implementation. This was resolved by implementing a dedicated invisible plane for raycasting, ensuring consistent mouse interaction regardless of the visual floor implementation.  The infinite map implementation now includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers.  The minimap has been updated to support the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures. A texture from `/src/assets/models/textures/tex.png` has been added to the terrain. The texture is repeated 5 times in both directions, and a color blend is applied for visual enhancement.  The mouse pointer issue was resolved by implementing a dedicated invisible plane for raycasting, ensuring consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map involved strategic placement of existing assets, adjusted collision detection, and a new texture, `/src/assets/models/textures/Colors3.png`, applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor, with the `/src/assets/models/textures/Colors3.png` texture applied.  The implementation of the infinite map involved strategic asset placement and adjusted collision detection.  The QUANTUM_DRIFT_CHECKLIST.md file has been updated to reflect the completion of the infinite map implementation (2025-03-10).  The QUANTUM_DRIFT_CHECKLIST.md file has been updated to reflect the reintegration of the following methods: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the completion of the infinite map implementation, including details on asset placement, collision detection, and chunk management.  The implementation of the infinite map, including object placement and collision detection adjustments, will be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map and the use of the Terrain.glb model as the game floor are documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including the use of `/src/assets/models/terrain/Terrain.glb` as the game floor, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map, including strategic asset placement and adjusted collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects. The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to include details on the implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation. The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the removal of the `SP_Ground01.glb` model and the addition of more mountains and ground features.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the implementation of the improved collision system, which uses compound shapes for more accurate collision detection. The game is now multiplayer only. A new `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md` file has been added detailing codebase improvements and bug fixes. A new `docs/2025-03-11_11-52-untitled.md` file has been added detailing asset loading centralization.  A new `docs/2025-03-11_11-52-centralizing-asset-loading-in-codebase.md` file has been added detailing asset loading centralization. The game is now multiplayer only. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`.  The game is now multiplayer only.
The game is now multiplayer only.
All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`.
All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only.


## CODE STYLE

Maintain consistent indentation (2 spaces).  Follow standard JavaScript naming conventions.  Comments should be clear and concise.

## FOLDER ORGANIZATION

The project follows a modular structure.  See the project structure for details.  This structure should be maintained.  A new folder structure for imported assets is recommended: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  A new folder structure for imported assets has been implemented: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  The project uses a modular folder structure.  The `/src/assets/models/` folder now contains subfolders for flora, rocks, and terrain.  The file `/src/assets/models/objects/SP_Ground01.glb` has been removed from the project.  A new `src/core/NetworkManager.js` file has been added to handle networking logic for multiplayer support.  The `/assets` directory now contains subdirectories for `models`, `sounds`, and `textures`.  The `/src/assets/models/ships` directory now contains `ALTSPACE1.glb` and `ALTSPACE2.glb`.  The project structure has been reorganized to improve maintainability and facilitate LLM collaboration, as detailed in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`. The new structure centralizes core game logic, entities, UI components, assets, and configurations into dedicated folders. The project structure now follows the recommendations in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`, centralizing core game logic, entities, UI, assets, and configurations into dedicated folders.  All core game mechanics (ship management, weapon systems) are now centralized into reusable modules under the `core/` directory. All asset loading is now delegated to `AssetLoader.js`.  The project structure has been updated to reflect the centralization of asset loading, as detailed in `docs/2025-03-11_11-52-centralizing-asset-loading-in-codebase.md`.  The game is now multiplayer only.  All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`.


## TECH STACK

- JavaScript (ES6+)
- Three.js (for 3D rendering)
- Webpack (for module bundling)
- GLTFLoader (for loading GLTF/GLB models)
- FBXLoader (for loading FBX models)
- Socket.io-client (for WebSocket communication)
- Socket.io (for server-side WebSocket handling)
- concurrently (for running dev server and game server simultaneously)
- uuid (for generating unique player IDs)
- OrbitControls (for camera controls)
- @three/examples/jsm/controls/OrbitControls.js
- @three/examples/jsm/loaders/GLTFLoader.js
- @three/examples/jsm/renderers/CSS2DRenderer.js
- AssetLoader (Custom asset loading manager)
- EventEmitter (for event handling)
- NetworkManager (for multiplayer networking)

## PROJECT-SPECIFIC STANDARDS

- All sound effects should be in the `src/assets/sounds` folder.
-  New features should be implemented incrementally and thoroughly tested.
-  Use a consistent approach to collision detection and handling.  The collision detection system has been updated to use oriented bounding boxes for more accurate collision detection. A two-stage collision detection system has been implemented, first performing a quick sphere-based check for efficiency and then performing a more accurate bounding box check for close objects. The checkSphereBoxIntersection method has been added for precise collision detection between spheres and boxes.
- The in-game ESC menu should be consistent with the main menu.  The "Change Ship" functionality in both menus now uses the same `ShipSelectionUI` instance and includes fade-in/fade-out transitions for improved user experience. Event listeners for menu buttons are now added only once during menu creation to prevent stacking.  The in-game ESC menu's "Change Ship" functionality should mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` should be properly re-initialized to avoid conflicts with event listeners and ensure responsiveness.  The `ShipSelectionUI` should be properly initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  The `ShipSelectionUI` should be properly re-initialized to prevent event listener conflicts and ensure that the selected ship is applied correctly.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The `ShipSelectionUI` should be properly re-initialized to prevent issues where the selected ship is not applied.  A check should be added to ensure the node exists and is a child of its container before attempting removal.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The game should remain running while menus are open; menus should function as overlays.  The game should not pause while menus are open; menus should function as overlays on a continuously running game.  The `ShipSelectionUI` should be properly re-initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The in-game ESC menu should function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling, and the game should remain running during menu interactions.  The implementation of the infinite map will involve the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation prioritizes efficient asset placement and collision detection.  The game should not pause when menus are open; menus should function as overlays.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container. The following methods were re-integrated from the original codebase: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, ensure strategic placement of assets to maintain game playability and adjust collision detection accordingly.  The infinite map implementation uses a chunk-based system for procedural generation and object culling.  The minimap has been updated to support the infinite map.  The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model for improved visual realism and immersion.  The infinite map implementation now uses a chunk-based system, object culling, and updated collision detection.  The minimap has been updated to support this system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The `/src/assets/models/terrain/Terrain.glb` model should be used as the game floor. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  For raycasting, use a dedicated invisible plane to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Always ensure that the targeting indicator is properly positioned and visible above the terrain.  Use a dedicated invisible plane for raycasting to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Ensure that the raycasting plane is positioned sufficiently high above the terrain to avoid interference with the terrain geometry. Add strategic console logs to track mouse positions, raycast results, and targeting indicator properties for debugging purposes.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality.  The implementation of the infinite map should prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality. A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  The implementation involved strategic placement of additional ground models (`SP_Ground02-05.glb`) to enhance the game's landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  For raycasting, a dedicated invisible plane should be used to ensure consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, including scaling, positioning, shadowing, material enhancements, and glow effect. A fallback mechanism is in place for loading failures.  A texture from `/src/assets/models/textures/tex.png` is applied, repeated 5 times, with color blending for visual enhancement. An invisible plane is implemented for raycasting, ensuring consistent mouse interaction.  A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved collision system, which uses compound shapes for more accurate collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. For multiplayer, considerations for TCP/UDP architecture are needed. Simplest architecture for beginners will be researched.  Multiplayer support will be implemented using a client-server architecture with WebSockets. A dedicated `NetworkManager` class will handle all networking-related tasks.  This approach minimizes disruption to the existing codebase.  The game now uses a client-server architecture with WebSockets for multiplayer functionality, managed by a dedicated `NetworkManager` class.  This is detailed in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`.  Ensure the `shipType` sent from the server matches the keys in `AssetLoader` (e.g., 'FIGHTER', 'INTERCEPTOR', 'SCOUT', 'EXPERIMENTAL'). Add console logs to track if `player_update` events are received and if the positions are updating as expected in `updateOtherPlayers()`. Ensure your `NetworkManager` is receiving `laser_shot` events and that `fireLaser()` or `fireBouncingLaser()` are correctly adding these to the scene. Add console logs to confirm these events are triggered and check if the laser objects are visible with proper materials. Modify your 3D models in a tool like Blender to have separate materials for parts like the body and accents. Then, in `getShipModel()` in `assetloader.js`, set only specific materials to the team color while keeping others (e.g., windows) with original colors. Check the `MiniMap` class implementation to ensure it's being updated in the game loop with current positions. Verify the mini-map's camera is set up to view from above and that its canvas is visible on screen. Debug by adding logs to see if positions are being passed correctly. To improve visuals, give ships random, nuanced colors by modifying models to support partial coloring.  This means modifying 3D models to have separate materials for different parts (e.g., body, accents) and then, in `getShipModel()`, setting only specific materials to team colors while leaving others with their original colors.  All core game mechanics (ship management, weapon systems) are now centralized into reusable modules under the `core/` directory.  All asset loading is now delegated to `AssetLoader.js`.  The project structure is now organized according to the recommendations in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`.  Proper error handling with try-catch blocks and consistent error logging has been implemented throughout the codebase.  All features (weapon switching, enemy AI, minimap) are now fully functional and thoroughly tested. The game is now multiplayer only. Use `AssetLoader.js` as the sole asset loader. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only.


## WORKFLOW & RELEASE RULES

- Utilize a version control system (Git) for all code changes.
- Commit messages should be clear and descriptive.
- Feature branches should be used for new features.
-  Bug fixes should be addressed promptly.  The resolution of the "Change Ship" menu bug serves as an example of prompt bug fixing and iterative development.  The fix included adding console logs for debugging purposes. The removal of pause logic during ship selection demonstrates a better approach for a multiplayer-style game.  For multiplayer game development,  consider using a client-server architecture with appropriate networking protocols (TCP/UDP) to handle communication between players.  For multiplayer, a client-server architecture using WebSockets will be implemented.  The focus will be on a simple, beginner-friendly approach to minimize disruption to the existing code.  A dedicated `NetworkManager` class will handle all networking logic. To test the multiplayer functionality, run `npm run dev:all` to start both the game client and server. Multiple browser instances are required to test interactions between players. The game is now multiplayer only.
-  Add comprehensive testing procedures for multiplayer functionality, including unit tests for individual components and integration tests for the entire system.  Testing should cover scenarios such as player connection/disconnection, laser shot synchronization, and asset loading across multiple clients.  The workflow now includes comprehensive testing procedures for multiplayer features, including unit tests and integration tests, as outlined in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`. The game is now multiplayer only. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`.


## REFERENCE EXAMPLES

- Existing sound effect implementation in `src/index.js` can serve as a reference.
- The `Ship` class's `takeDamage` method provides an example of damage handling.
- The updated `showInGameMenu` and `showShipChangeScreen` methods in `src/index.js` (as of 2025-03-10) demonstrate best practices for menu handling and UI consistency, including the use of fade-in/fade-out transitions and a single `ShipSelectionUI` instance.  The revised methods (post 2025-03-10) demonstrate a continuous game loop with UI overlays.  The updated `showShipChangeScreen` method (post 2025-03-10) demonstrates proper re-initialization of the `ShipSelectionUI` to prevent event listener conflicts.  The `AssetManager.js` file provides an example of how to manage the loading of 3D models.  The updated `showShipChangeScreen` and `applyShipSelection` methods (post 2025-03-10) demonstrate proper handling of the `removeChild` method, including checks to ensure the node exists and is a child of its parent before removal.  The `AssetManager.js` file provides an example of how to manage the loading of 3D models, and the updated `applyShipSelection` method demonstrates proper cleanup of the existing ship model before applying a new one. The `InfiniteMap.js` file provides a reference implementation for procedural map generation and chunk management.  The updated `MiniMap.js` file demonstrates how to integrate the minimap with the infinite map system.


## PROJECT DOCUMENTATION & CONTEXT SYSTEM

- `QUANTUM_DRIFT_CHECKLIST.md` tracks project progress and bug fixes. Version 1.0 reviewed 2025-03-10.
- `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md` details codebase improvements and bug fixes.
- `docs/2025-03-11_11-52-centralizing-asset-loading-in-codebase.md` details asset loading centralization.


## DEBUGGING

- Add comprehensive console logs for debugging asset loading and multiplayer interactions.
- All functions and methods should be thoroughly tested to ensure proper integration and functionality.
- Add strategic console logs to track mouse positions, raycast results, and targeting indicator properties for debugging purposes.
- Ensure your `NetworkManager` is receiving `laser_shot` events and that `fireLaser()` or `fireBouncingLaser()` are correctly adding these to the scene. Add console logs to confirm these events are triggered and check if the laser objects are visible with proper materials.
- Add console logs to track if `player_update` events are received and if the positions are updating as expected in `updateOtherPlayers()`.
- Ensure your `MiniMap` class implementation is being updated in the game loop with current positions. Verify the mini-map's camera is set up to view from above and that its canvas is visible on screen. Debug by adding logs to see if positions are being passed correctly.


## FINAL DOs AND DON'Ts

- Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.
- Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.
- Before removing a node, ensure it is a valid child node of its parent container.
- For raycasting, use a dedicated invisible plane to ensure consistent mouse interaction regardless of the visual floor implementation.
- The game should not pause when menus are open; menus should function as overlays.
- All UI interactions should maintain responsiveness and avoid event listener conflicts.
- Ensure the `shipType` sent from the server matches the keys in `AssetLoader` (e.g., 'FIGHTER', 'INTERCEPTOR', 'SCOUT', 'EXPERIMENTAL').
- Use `AssetLoader.js` as the sole asset loader.
- Always ensure that the targeting indicator is properly positioned and visible above the terrain.
- Ensure the raycasting plane is positioned sufficiently high above the terrain to avoid interference with the terrain geometry.
- For multiplayer, considerations for TCP/UDP architecture are needed. Simplest architecture for beginners will be researched.  Multiplayer support will be implemented using a client-server architecture with WebSockets. A dedicated `NetworkManager` class will handle all networking-related tasks.  This approach minimizes disruption to the existing codebase. The game is now multiplayer only.
- Use `AssetLoader.js` as the sole asset loader. All asset loading is now handled by `AssetLoader.js`, removing