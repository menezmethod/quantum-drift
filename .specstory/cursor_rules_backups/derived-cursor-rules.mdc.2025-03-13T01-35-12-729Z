
## PROJECT OVERVIEW

This project, Quantum Drift, is a 3D space combat game.  The current focus is on implementing features outlined in `QUANTUM_DRIFT_CHECKLIST.md`, including a bounce laser, an infinite alien map, and refining the user interface.  Version 1.0 of the checklist was reviewed on 2025-03-10.  A bug related to the in-game "Change Ship" menu functionality was identified and resolved on 2025-03-10. The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A subsequent bug report on 2025-03-10 (9:07 PM) highlighted an issue with the in-game "Change Ship" menu not functioning correctly after pressing ESC. This issue was resolved by ensuring the in-game ESC menu's "Change Ship" functionality mirrors the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The resolution involved reusing the same `ShipSelectionUI` instance for both main and in-game menus and incorporating fade-in/fade-out transitions.  A further bug was identified where the game froze when switching options in the ship change menu. This issue was resolved by removing pause logic from the ship selection menu and keeping the game running continuously while menus are open.  A bug report detailing the freezing issue was filed on 2025-03-10 (9:07 PM). The final resolution involved removing pause logic and treating menus as overlays on a continuously running game loop.  Further issues with the "Change Ship" menu functionality were addressed on 2025-03-10.  These issues were resolved by ensuring proper re-initialization of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness.  Additional issues with the "Change Ship" menu functionality were identified and resolved on 2025-03-10.  The resolution involved ensuring proper re-initialization of the `ShipSelectionUI` instance and handling event listeners to prevent conflicts and ensure responsiveness.  A further error, "Failed to execute 'removeChild' on 'Node': The node to be removed is not a child of this node," was resolved by adding a check to ensure the node exists and is a child of the container before attempting removal.  Subsequent issues with the "Change Ship" menu functionality, specifically the failure to apply the selected ship, were resolved by ensuring proper re-initialization and cleanup of the `ShipSelectionUI` instance and handling of event listeners to prevent conflicts and ensure responsiveness. A check was added to ensure the node exists and is a child of its parent container before attempting removal in the `removeChild` operation.  A final issue where the ship model wasn't updating after selection was resolved by ensuring proper cleanup and re-initialization of the `ShipSelectionUI` instance and adding a check to ensure the node exists before removal.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay.  Proper re-initialization and cleanup of the `ShipSelectionUI` should be performed to avoid conflicts and ensure responsiveness.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The in-game ESC menu should now function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling.  The game should not pause when the ship selection menu is open, instead functioning as an overlay. The resolution of the "Change Ship" menu bug, including the addition of a check to prevent removing nodes that are not children, should be documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The in-game ESC menu's "Change Ship" functionality should now mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling and reusing existing UI components.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` component should be reused for both main and in-game menus, maintaining consistent styling and functionality.  Development will now proceed with the implementation of an infinite map, starting with the strategic placement of existing assets to ensure game playability.  Collision detection will be carefully adjusted with the addition of new objects. The infinite map implementation, completed on 2025-03-10, involved the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The implementation details are documented in `QUANTUM_DRIFT_CHECKLIST.md`.  The infinite map implementation has been completed and integrated into the game.  The implementation includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers.  The MiniMap has also been updated to support the infinite map system.  Several previously omitted features have been re-integrated and updated for compatibility with the new infinite map system. The infinite map implementation, completed on 2025-03-10, involved strategic asset placement for game playability and adjusted collision detection. Details are in `QUANTUM_DRIFT_CHECKLIST.md`.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The implementation of the infinite map involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The implementation of the infinite map, completed on 2025-03-10, involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The reintegration of previously omitted features, including `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`, ensures full functionality.  The implementation of the infinite map involved strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation now includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers. The minimap has been updated to support the infinite map.  The infinite map implementation will prioritize efficient asset placement and collision detection algorithms.  Strategic placement of existing assets will ensure game playability while careful adjustment of collision detection will maintain this playability.  The minimap will be updated to reflect the infinite map.  The infinite map implementation uses a chunk-based system for procedural generation, object culling for performance, and updated collision detection. The minimap has been updated to support the infinite map system.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system. The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor.  The implementation includes scaling and positioning adjustments to integrate it seamlessly into the game world. The floor now casts and receives shadows for improved visual realism.  The floor's material properties have been enhanced.  A subtle glow effect has been added to the terrain for visual appeal.  A circular highlight has been added around the player's position for enhanced visual feedback.  A fallback mechanism has been implemented in case Terrain.glb fails to load.  The infinite map implementation prioritizes efficient asset placement and collision detection algorithms.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor.  Implementation details are documented in `QUANTUM_DRIFT_CHECKLIST.md`. The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map involved strategic asset placement and careful adjustment of collision detection to maintain game playability.  The game floor now utilizes the `/src/assets/models/terrain/Terrain.glb` model.  The implementation includes scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A texture from `/src/assets/models/textures/tex.png` has been added to the terrain. The texture is repeated 5 times in both directions, and a color blend is applied for visual enhancement.  The mouse pointer was temporarily off due to changes in the terrain implementation. This was resolved by implementing a dedicated invisible plane for raycasting, ensuring consistent mouse interaction regardless of the visual floor implementation.  The infinite map implementation now includes a chunk-based system for procedural generation, object culling for performance, and updated collision detection for both player and lasers.  The minimap has been updated to support the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures. A texture from `/src/assets/models/textures/tex.png` has been added to the terrain. The texture is repeated 5 times in both directions, and a color blend is applied for visual enhancement.  The mouse pointer issue was resolved by implementing a dedicated invisible plane for raycasting, ensuring consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map involved strategic asset placement, adjusted collision detection, and a new texture, `/src/assets/models/textures/Colors3.png`, applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The `/src/assets/models/terrain/Terrain.glb` model is now used as the game floor, with the `/src/assets/models/textures/Colors3.png` texture applied.  The implementation of the infinite map involved strategic asset placement and adjusted collision detection.  The QUANTUM_DRIFT_CHECKLIST.md file has been updated to reflect the completion of the infinite map implementation (2025-03-10).  The QUANTUM_DRIFT_CHECKLIST.md file has been updated to reflect the reintegration of the following methods: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  The `QUANTUM_DRIFT_CHECKLIST.md` file has been updated to reflect the completion of the infinite map implementation, including details on asset placement, collision detection, and chunk management.  A new `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md` file has been added detailing codebase improvements and bug fixes. A new `docs/2025-03-11_11-52-centralizing-asset-loading-in-codebase.md` file has been added detailing asset loading centralization.  The implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved collision system, which uses compound shapes for more accurate collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the infinite map, including strategic asset placement and adjusted collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. A codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`. A new `2025-03-11_15-57-codebase-review-before-modifications.md` file has been added documenting the codebase review conducted before making modifications. The game is now multiplayer only. A codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made.  This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`.
A SpecStory codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`.
All asset-related logic has been moved from `Game.js` to `AssetLoader.js`, as documented in `2025-03-12_20-18-untitled.md`.  The `createFloor` method has been moved to `AssetLoader.js`.
A new `2025-03-12_20-18-untitled.md` file has been added documenting the movement of asset-related logic from `Game.js` to `AssetLoader.js`.
A new `2025-03-12_20-18-moving-asset-logic-to-assetloader.md` file has been added documenting the process of moving asset-related logic from `Game.js` to `AssetLoader.js`, outlining various approaches and considerations for avoiding dependency loops.
The game is now multiplayer only.
The game is now multiplayer only.  All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`.
The game is now multiplayer only.  Added documentation for resolving an unresolved variable issue in `updateBouncingLasers` method as detailed in `2025-03-12_21-09-fixing-unresolved-variable-issue.md`.
The resolution of the unresolved variables in `updateBouncingLasers` is documented in `2025-03-12_21-09-fixing-unresolved-variable-issue.md`. Bounce laser damage updated to 50. Health auto-healing implemented at half the rate of energy regeneration. Enemy health display always visible. Enemy visibility issues fixed. Performance optimizations implemented. Code cleanup completed. Controls should auto-hide after a timeout.  A Promise returned from `loadAssets()` in `Game.js` was being ignored, potentially causing race conditions. This was resolved by awaiting the Promise returned by `loadAssets()` within the `init()` method, ensuring assets are fully loaded before proceeding.  This is documented in `2025-03-12_21-28-untitled.md`.
A Promise returned from `init()` in `Game.js` was being ignored, potentially causing race conditions. This was resolved by storing the promise returned by `init()` in `this.initPromise`, allowing other parts of the code to await its resolution before proceeding. This is documented in `2025-03-12_21-28-ignoring-promises-in-loadassets-method.md`.


## CODE STYLE

Maintain consistent indentation (2 spaces).  Follow standard JavaScript naming conventions.  Comments should be clear and concise.

## FOLDER ORGANIZATION

The project follows a modular structure.  See the project structure for details.  This structure should be maintained.  A new folder structure for imported assets is recommended: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  A new folder structure for imported assets has been implemented: `/src/assets/models/`, with subfolders for flora, rocks, and terrain.  The project uses a modular folder structure.  The `/src/assets/models/` folder now contains subfolders for flora, rocks, and terrain.  The file `/src/assets/models/objects/SP_Ground01.glb` has been removed from the project.  A new `src/core/NetworkManager.js` file has been added to handle networking logic for multiplayer support.  The `/assets` directory now contains subdirectories for `models`, `sounds`, and `textures`.  The `/src/assets/models/ships` directory now contains `ALTSPACE1.glb` and `ALTSPACE2.glb`.  The project structure has been reorganized to improve maintainability and facilitate LLM collaboration, as detailed in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`. The new structure centralizes core game logic, entities, UI components, assets, and configurations into dedicated folders. The project structure now follows the recommendations in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`, centralizing core game logic, entities, UI, assets, and configurations into dedicated folders.  All core game mechanics (ship management, weapon systems) are now centralized into reusable modules under the `core/` directory. All asset loading is now delegated to `AssetLoader.js`.  The project structure has been updated to reflect the centralization of asset loading, as detailed in `docs/2025-03-11-52-centralizing-asset-loading-in-codebase.md`. The game is now multiplayer only.  All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. A codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. A new `WeaponSystem.js` file has been added to the `src/entities/weapons` directory.

## TECH STACK

- JavaScript (ES6+)
- Three.js (for 3D rendering)
- Webpack (for module bundling)
- GLTFLoader (for loading GLTF/GLB models)
- FBXLoader (for loading FBX models)
- Socket.io-client (for WebSocket communication)
- Socket.io (for server-side WebSocket handling)
- concurrently (for running dev server and game server simultaneously)
- uuid (for generating unique player IDs)
- OrbitControls (for camera controls)
- @three/examples/jsm/controls/OrbitControls.js
- @three/examples/jsm/loaders/GLTFLoader.js
- @three/examples/jsm/renderers/CSS2DRenderer.js
- AssetLoader (Custom asset loading manager)
- EventEmitter (for event handling)
- NetworkManager (for multiplayer networking)
- WeaponSystem (Custom weapon management system)


## PROJECT-SPECIFIC STANDARDS

- All sound effects should be in the `src/assets/sounds` folder.
-  New features should be implemented incrementally and thoroughly tested.
-  Use a consistent approach to collision detection and handling.  The collision detection system has been updated to use oriented bounding boxes for more accurate collision detection. A two-stage collision detection system has been implemented, first performing a quick sphere-based check for efficiency and then performing a more accurate bounding box check for close objects. The checkSphereBoxIntersection method has been added for precise collision detection between spheres and boxes.  The bouncing laser system has been significantly improved, including the addition of a `checkBoxIntersection` method for more accurate collision detection with boxes, and support for compound collision shapes.  The improved bouncing laser system is detailed in `2025-03-12_21-09-fixing-unresolved-variable-issue.md`.  The `updateBouncingLasers` method has been updated to include the necessary variable declarations (`bounced`, `tempRay`, `tempVector`, `closestDist`) and to handle different collision shapes (boxes and spheres) more accurately.  A new `rayBoxIntersection` method has been added to handle ray-box intersection more effectively. The collision detection now uses a two-stage approach: a quick sphere-based check followed by a more accurate bounding box check if necessary.  The `rayBoxIntersection` method handles rotated boxes and returns both the intersection point and normal vector.  Error handling has been improved to handle cases where `obstacle.boundingBox` is not a THREE.Box3 object.  The `updateBouncingLasers` method has been significantly improved to handle different collision shapes (boxes and spheres) more accurately, and includes proper variable declarations. A new `rayBoxIntersection` method has been added for accurate ray-box intersection handling. The collision detection now uses a two-stage approach: a quick sphere-based check followed by a more accurate bounding box check if necessary. The `rayBoxIntersection` method handles rotated boxes and returns both the intersection point and normal vector. Error handling has been improved to handle cases where `obstacle.boundingBox` is not a THREE.Box3 object. The bouncing laser system now uses a two-stage collision detection system: a quick sphere-based check followed by a more precise box check if available.  The `rayBoxIntersection` method accurately handles ray-box intersections, considering box rotation.  Error handling is improved to manage cases where `obstacle.boundingBox` is not a THREE.Box3 object.
- The in-game ESC menu should be consistent with the main menu.  The "Change Ship" functionality in both menus now uses the same `ShipSelectionUI` instance and includes fade-in/fade-out transitions for improved user experience. Event listeners for menu buttons are now added only once during menu creation to prevent stacking.  The in-game ESC menu's "Change Ship" functionality should mirror the main menu's functionality, including options for changing ship and name, while maintaining consistent styling.  The game should not pause when the ship selection menu is open; the menu should function as an overlay on the continuously running game.  The `ShipSelectionUI` should be properly re-initialized to avoid conflicts with event listeners and ensure responsiveness.  The `ShipSelectionUI` should be properly initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  The `ShipSelectionUI` should be properly re-initialized to prevent event listener conflicts and ensure that the selected ship is applied correctly.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The `ShipSelectionUI` should be properly re-initialized to prevent issues where the selected ship is not applied.  A check should be added to ensure the node exists and is a child of its container before attempting removal.  Before removing a node using `removeChild`, ensure it exists and is a child of its parent container.  The game should remain running while menus are open; menus should function as overlays.  The game should not pause while menus are open; menus should function as overlays on a continuously running game.  The `ShipSelectionUI` should be properly re-initialized and cleaned up to prevent errors related to removing nodes that are not children of the container.  A check should be added to ensure the node exists and is a child of its container before attempting removal using `removeChild`.  The in-game ESC menu should function identically to the main menu's "Change Ship" functionality, reusing the existing `ShipSelectionUI` component and maintaining consistent styling, and the game should remain running during menu interactions.  The implementation of the infinite map will involve the strategic placement of existing assets to ensure game playability, with collision detection adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation prioritizes efficient asset placement and collision detection.  The game should not pause when menus are open; menus should function as overlays.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container.  The implementation of the infinite map involved strategic asset placement to ensure game playability and collision detection was adjusted accordingly.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should prioritize efficient asset placement and collision detection algorithms.  All UI interactions should maintain responsiveness and avoid event listener conflicts.  Before removing a node, ensure it is a valid child node of its parent container. The following methods were re-integrated from the original codebase: `startGame`, `showShipSelection`, `startGameplay`, `applyShipSelection`, `exitToMainMenu`, `resetGameState`, `handleDirectionalFiring`, `fireCurrentWeapon`, `createMuzzleFlash`, `updateCamera`, `updateThrusterEffects`, `flashCollisionWarning`, `updateEnergy`, `updateGrenades`, `updateBouncingLasers`, `createBounceEffect`, `updateGrenadeTargetingIndicator`, `handleGrenadeTargeting`, `launchGrenade`, `updateTargetingIndicator`, `toggleMiniMap`, `cleanup`.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, ensure strategic placement of assets to maintain game playability and adjust collision detection accordingly.  The infinite map implementation uses a chunk-based system for procedural generation and object culling.  The minimap has been updated to support the infinite map.  The game floor is now implemented using the `/src/assets/models/terrain/Terrain.glb` model.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model for improved visual realism and immersion.  The infinite map implementation now uses a chunk-based system, object culling, and updated collision detection.  The minimap has been updated to support this system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, with scaling, positioning, shadowing, material enhancements, and a glow effect added. A fallback mechanism is in place for loading failures.  The infinite map implementation should utilize a chunk-based system for efficient procedural generation and object management.  For the infinite map implementation, prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  Code duplication between `Game.js` and `index.js` should be addressed by refactoring to improve code maintainability and reduce redundancy.  The `/src/assets/models/terrain/Terrain.glb` model should be used as the game floor. The implementation should include scaling and positioning adjustments for seamless integration into the game world, shadow casting and receiving for improved visual realism, enhanced material properties, a subtle glow effect for visual appeal, and a fallback mechanism in case Terrain.glb fails to load.  For raycasting, use a dedicated invisible plane to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Always ensure that the targeting indicator is properly positioned and visible above the terrain.  Use a dedicated invisible plane for raycasting to ensure consistent mouse interaction regardless of the visual floor implementation.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  Ensure that the raycasting plane is positioned sufficiently high above the terrain to avoid interference with the terrain geometry. Add strategic console logs to track mouse positions, raycast results, and targeting indicator properties for debugging purposes.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality.  The implementation of the infinite map should prioritize efficient asset placement and collision detection algorithms.  The game floor should utilize the `/src/assets/models/terrain/Terrain.glb` model.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  Always ensure proper handling of event listeners and UI components to maintain responsiveness and avoid conflicts.  Thorough testing is crucial after each update to ensure functionality and prevent unexpected behavior.  The implementation of the infinite map requires careful consideration of asset placement and efficient collision detection algorithms to maintain game performance.  All functions and methods should be thoroughly tested to ensure proper integration and functionality. A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  The implementation involved strategic placement of additional ground models (`SP_Ground02-05.glb`) to enhance the game's landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of a texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  For raycasting, a dedicated invisible plane should be used to ensure consistent mouse interaction regardless of the visual floor implementation.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`.  A new `InfiniteMap.js` file has been added to manage the infinite map, including chunk loading, object placement, and collision detection. The `MiniMap.js` file has been updated to integrate with the infinite map system.  The game floor now uses `/src/assets/models/terrain/Terrain.glb`, including scaling, positioning, shadowing, material enhancements, and glow effect. A fallback mechanism is in place for loading failures.  A texture from `/src/assets/models/textures/tex.png` is applied, repeated 5 times, with color blending for visual enhancement. An invisible plane is implemented for raycasting, ensuring consistent mouse interaction.  A new texture, `/src/assets/models/textures/Colors3.png`, has been applied to the terrain.  Additional `SP_Ground02-05.glb` models enhance the landscape.  The implementation of the infinite map, including the use of the Terrain.glb model as the game floor and the addition of the Colors3.png texture, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved obstacle system, including the use of compound collision shapes and the addition of a more diverse set of objects, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved landscape design, including the creation of pathways, crystal gardens, and a centerpiece formation, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. The implementation of the improved collision system, which uses compound shapes for more accurate collision detection, is documented in `QUANTUM_DRIFT_CHECKLIST.md`. For multiplayer, considerations for TCP/UDP architecture are needed. Simplest architecture for beginners will be researched.  Multiplayer support will be implemented using a client-server architecture with WebSockets. A dedicated `NetworkManager` class will handle all networking-related tasks.  This approach minimizes disruption to the existing codebase.  The game now uses a client-server architecture with WebSockets for multiplayer functionality, managed by a dedicated `NetworkManager` class.  This is detailed in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`.  Ensure the `shipType` sent from the server matches the keys in `AssetLoader` (e.g., 'FIGHTER', 'INTERCEPTOR', 'SCOUT', 'EXPERIMENTAL'). Add console logs to track if `player_update` events are received and if the positions are updating as expected in `updateOtherPlayers()`. Ensure your `NetworkManager` is receiving `laser_shot` events and that `fireLaser()` or `fireBouncingLaser()` are correctly adding these to the scene. Add console logs to confirm these events are triggered and check if the laser objects are visible with proper materials. Modify your 3D models in a tool like Blender to have separate materials for parts like the body and accents. Then, in `getShipModel()` in `assetloader.js`, set only specific materials to the team color while keeping others (e.g., windows) with original colors. Check the `MiniMap` class implementation to ensure it's being updated in the game loop with current positions. Verify the mini-map's camera is set up to view from above and that its canvas is visible on screen. Debug by adding logs to see if positions are being passed correctly. To improve visuals, give ships random, nuanced colors by modifying models to support partial coloring.  This means modifying 3D models to have separate materials for different parts (e.g., body, accents) and then, in `getShipModel()`, setting only specific materials to team colors while leaving others with their original colors.  All core game mechanics (ship management, weapon systems) are now centralized into reusable modules under the `core/` directory.  All asset loading is now delegated to `AssetLoader.js`.  The project structure is now organized according to the recommendations in `docs/2025-03-11_11-36-quantum-drift-codebase-improvement-checklist.md`.  Proper error handling with try-catch blocks and consistent error logging has been implemented throughout the codebase.  All features (weapon switching, enemy AI, minimap) are now fully functional and thoroughly tested. The game is now multiplayer only. Use `AssetLoader.js` as the sole asset loader. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only. All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only.
All asset loading is now handled by `AssetLoader.js`, removing duplicate loading functions from `index.js`. The game is now multiplayer only. Bounce laser damage updated to 50. Health auto-healing implemented at half the rate of energy regeneration. Enemy health display always visible. Enemy visibility issues fixed. Performance optimizations implemented. Code cleanup completed. Controls should auto-hide after a timeout.  A SpecStory codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`.  A codebase review was conducted on 2025-03-11 at 3:57 PM before any modifications were made. This review is documented in `2025-03-11_15-57-codebase-review-before-modifications.md`.
The game is now multiplayer only.  All asset loading is now handled by AssetLoader.js, removing duplicate loading functions from index.js.  A new `2025-03-12_20-18-moving-asset-logic-to-assetloader.md` file details refactoring strategies (direct transfer, composition, inheritance, event-based communication, facade, service locator, dependency injection) for moving asset logic from `Game.js` to `AssetLoader.js`.  The composition pattern was chosen to avoid dependency loops.


## WORKFLOW & RELEASE RULES

New features should be implemented incrementally and thoroughly tested before merging into the main branch.  All code should adhere to the specified code style guidelines.  Release cycles will be determined based on the completion of key features and thorough testing.  The game is now multiplayer only.

## REFERENCE EXAMPLES

- Refer to `QUANTUM_DRIFT_CHECKLIST